import require$$1$4 from "os";
import require$$0$a from "path";
import require$$1$5 from "util";
import stream$2 from "stream";
import require$$0$6 from "fs";
import require$$5 from "crypto";
import require$$6 from "tty";
/* empty css                           */
import "url";
import require$$0$9 from "assert";
import "child_process";
import require$$0$7 from "buffer";
import require$$2$2 from "string_decoder";
import require$$7 from "process";
import {
  g as getAugmentedNamespace,
  c as commonjsGlobal,
  d as getDefaultExportFromCjs,
  e as createAstro,
  f as createComponent,
  r as renderTemplate,
  m as maybeRenderHead,
  s as spreadAttributes,
  h as addAttribute,
  u as unescapeHTML,
  i as renderComponent,
  F as Fragment,
  j as renderHead,
  k as renderSlot,
} from "../astro_yvkYO_vT.mjs";
import { useSSRContext, defineComponent, mergeProps, ref } from "vue";
import {
  ssrRenderAttrs,
  ssrRenderSlot,
  ssrInterpolate,
  ssrRenderStyle,
} from "vue/server-renderer";
/* empty css                            */
import zlib$3 from "zlib";
import require$$0$8 from "events";
import { formateTitle, formateDate, titleNews } from "./title_CQvU0ofJ.mjs";
/* empty css                          */
/* empty css                            */
import { Content } from "./code01_DuLDFnqO.mjs";
import { Content as Content$1 } from "./code02_LUyuckIC.mjs";
import { Content as Content$2 } from "./code03_DpknsN9o.mjs";
import { Content as Content$3 } from "./code04_EEVd7ETI.mjs";
import { Content as Content$4 } from "./code05_wlI1PdDo.mjs";

function _mergeNamespaces(n, m) {
  for (var i = 0; i < m.length; i++) {
    const e = m[i];
    if (typeof e !== "string" && !Array.isArray(e)) {
      for (const k in e) {
        if (k !== "default" && !(k in n)) {
          const d = Object.getOwnPropertyDescriptor(e, k);
          if (d) {
            Object.defineProperty(
              n,
              k,
              d.get
                ? d
                : {
                    enumerable: true,
                    get: () => e[k],
                  },
            );
          }
        }
      }
    }
  }
  return Object.freeze(
    Object.defineProperty(n, Symbol.toStringTag, { value: "Module" }),
  );
}

const _export_sfc = (sfc, props) => {
  const target = sfc.__vccOpts || sfc;
  for (const [key, val] of props) {
    target[key] = val;
  }
  return target;
};

const _sfc_main$4 = /* @__PURE__ */ defineComponent({
  __name: "Header",
  props: {
    title: {
      type: String,
      required: true,
    },
  },
  setup(__props, { expose: __expose }) {
    __expose();
    const __returned__ = {};
    Object.defineProperty(__returned__, "__isScriptSetup", {
      enumerable: false,
      value: true,
    });
    return __returned__;
  },
});
function _sfc_ssrRender$4(
  _ctx,
  _push,
  _parent,
  _attrs,
  $props,
  $setup,
  $data,
  $options,
) {
  _push(
    `<div${ssrRenderAttrs(
      mergeProps({ class: "flex items-center gap-3" }, _attrs),
    )} data-v-094adf9a>`,
  );
  ssrRenderSlot(_ctx.$slots, "default", {}, null, _push, _parent);
  _push(
    `<h1 class="font-header text-2xl" data-v-094adf9a>${ssrInterpolate(
      $props.title,
    )}</h1></div>`,
  );
}
const _sfc_setup$4 = _sfc_main$4.setup;
_sfc_main$4.setup = (props, ctx) => {
  const ssrContext = useSSRContext();
  (ssrContext.modules || (ssrContext.modules = /* @__PURE__ */ new Set())).add(
    "src/components/Header/Header.vue",
  );
  return _sfc_setup$4 ? _sfc_setup$4(props, ctx) : void 0;
};
const HeaderVue = /* @__PURE__ */ _export_sfc(_sfc_main$4, [
  ["ssrRender", _sfc_ssrRender$4],
  ["__scopeId", "data-v-094adf9a"],
]);

const SPRITESHEET_NAMESPACE = `astroicon`;

const defaultOpts$2 = {
  xml: false,
  decodeEntities: true,
};
const xmlModeDefault = {
  _useHtmlParser2: true,
  xmlMode: true,
};
/**
 * Flatten the options for Cheerio.
 *
 * This will set `_useHtmlParser2` to true if `xml` is set to true.
 *
 * @param options - The options to flatten.
 * @returns The flattened options.
 */
function flatten(options) {
  return (options === null || options === void 0 ? void 0 : options.xml)
    ? typeof options.xml === "boolean"
      ? xmlModeDefault
      : { ...xmlModeDefault, ...options.xml }
    : options !== null && options !== void 0
      ? options
      : undefined;
}

var lib$5 = {};

/** Types of elements found in htmlparser2's DOM */
var ElementType$1;
(function (ElementType) {
  /** Type for the root element of a document */
  ElementType["Root"] = "root";
  /** Type for Text */
  ElementType["Text"] = "text";
  /** Type for <? ... ?> */
  ElementType["Directive"] = "directive";
  /** Type for <!-- ... --> */
  ElementType["Comment"] = "comment";
  /** Type for <script> tags */
  ElementType["Script"] = "script";
  /** Type for <style> tags */
  ElementType["Style"] = "style";
  /** Type for Any tag */
  ElementType["Tag"] = "tag";
  /** Type for <![CDATA[ ... ]]> */
  ElementType["CDATA"] = "cdata";
  /** Type for <!doctype ...> */
  ElementType["Doctype"] = "doctype";
})(ElementType$1 || (ElementType$1 = {}));
/**
 * Tests whether an element is a tag or not.
 *
 * @param elem Element to test
 */
function isTag$3(elem) {
  return (
    elem.type === ElementType$1.Tag ||
    elem.type === ElementType$1.Script ||
    elem.type === ElementType$1.Style
  );
}
// Exports for backwards compatibility
/** Type for the root element of a document */
const Root = ElementType$1.Root;
/** Type for Text */
const Text$2 = ElementType$1.Text;
/** Type for <? ... ?> */
const Directive = ElementType$1.Directive;
/** Type for <!-- ... --> */
const Comment$c = ElementType$1.Comment;
/** Type for <script> tags */
const Script = ElementType$1.Script;
/** Type for <style> tags */
const Style = ElementType$1.Style;
/** Type for Any tag */
const Tag = ElementType$1.Tag;
/** Type for <![CDATA[ ... ]]> */
const CDATA$2 = ElementType$1.CDATA;
/** Type for <!doctype ...> */
const Doctype = ElementType$1.Doctype;

const esm$1 = /*#__PURE__*/ Object.freeze(
  /*#__PURE__*/ Object.defineProperty(
    {
      __proto__: null,
      CDATA: CDATA$2,
      Comment: Comment$c,
      Directive,
      Doctype,
      get ElementType() {
        return ElementType$1;
      },
      Root,
      Script,
      Style,
      Tag,
      Text: Text$2,
      isTag: isTag$3,
    },
    Symbol.toStringTag,
    { value: "Module" },
  ),
);

const require$$0$5 = /*@__PURE__*/ getAugmentedNamespace(esm$1);

var node$3 = {};

var __extends =
  (commonjsGlobal && commonjsGlobal.__extends) ||
  (function () {
    var extendStatics = function (d, b) {
      extendStatics =
        Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array &&
          function (d, b) {
            d.__proto__ = b;
          }) ||
        function (d, b) {
          for (var p in b)
            if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
        };
      return extendStatics(d, b);
    };
    return function (d, b) {
      if (typeof b !== "function" && b !== null)
        throw new TypeError(
          "Class extends value " + String(b) + " is not a constructor or null",
        );
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype =
        b === null
          ? Object.create(b)
          : ((__.prototype = b.prototype), new __());
    };
  })();
var __assign$1 =
  (commonjsGlobal && commonjsGlobal.__assign) ||
  function () {
    __assign$1 =
      Object.assign ||
      function (t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
      };
    return __assign$1.apply(this, arguments);
  };
Object.defineProperty(node$3, "__esModule", { value: true });
node$3.cloneNode =
  node$3.hasChildren =
  node$3.isDocument =
  node$3.isDirective =
  node$3.isComment =
  node$3.isText =
  node$3.isCDATA =
  node$3.isTag =
  node$3.Element =
  node$3.Document =
  node$3.CDATA =
  node$3.NodeWithChildren =
  node$3.ProcessingInstruction =
  node$3.Comment =
  node$3.Text =
  node$3.DataNode =
  node$3.Node =
    void 0;
var domelementtype_1$1 = require$$0$5;
/**
 * This object will be used as the prototype for Nodes when creating a
 * DOM-Level-1-compliant structure.
 */
var Node$2 = /** @class */ (function () {
  function Node() {
    /** Parent of the node */
    this.parent = null;
    /** Previous sibling */
    this.prev = null;
    /** Next sibling */
    this.next = null;
    /** The start index of the node. Requires `withStartIndices` on the handler to be `true. */
    this.startIndex = null;
    /** The end index of the node. Requires `withEndIndices` on the handler to be `true. */
    this.endIndex = null;
  }
  Object.defineProperty(Node.prototype, "parentNode", {
    // Read-write aliases for properties
    /**
     * Same as {@link parent}.
     * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
     */
    get: function () {
      return this.parent;
    },
    set: function (parent) {
      this.parent = parent;
    },
    enumerable: false,
    configurable: true,
  });
  Object.defineProperty(Node.prototype, "previousSibling", {
    /**
     * Same as {@link prev}.
     * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
     */
    get: function () {
      return this.prev;
    },
    set: function (prev) {
      this.prev = prev;
    },
    enumerable: false,
    configurable: true,
  });
  Object.defineProperty(Node.prototype, "nextSibling", {
    /**
     * Same as {@link next}.
     * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
     */
    get: function () {
      return this.next;
    },
    set: function (next) {
      this.next = next;
    },
    enumerable: false,
    configurable: true,
  });
  /**
   * Clone this node, and optionally its children.
   *
   * @param recursive Clone child nodes as well.
   * @returns A clone of the node.
   */
  Node.prototype.cloneNode = function (recursive) {
    if (recursive === void 0) {
      recursive = false;
    }
    return cloneNode$1(this, recursive);
  };
  return Node;
})();
node$3.Node = Node$2;
/**
 * A node that contains some data.
 */
var DataNode$1 = /** @class */ (function (_super) {
  __extends(DataNode, _super);
  /**
   * @param data The content of the data node
   */
  function DataNode(data) {
    var _this = _super.call(this) || this;
    _this.data = data;
    return _this;
  }
  Object.defineProperty(DataNode.prototype, "nodeValue", {
    /**
     * Same as {@link data}.
     * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
     */
    get: function () {
      return this.data;
    },
    set: function (data) {
      this.data = data;
    },
    enumerable: false,
    configurable: true,
  });
  return DataNode;
})(Node$2);
node$3.DataNode = DataNode$1;
/**
 * Text within the document.
 */
var Text$1 = /** @class */ (function (_super) {
  __extends(Text, _super);
  function Text() {
    var _this = (_super !== null && _super.apply(this, arguments)) || this;
    _this.type = domelementtype_1$1.ElementType.Text;
    return _this;
  }
  Object.defineProperty(Text.prototype, "nodeType", {
    get: function () {
      return 3;
    },
    enumerable: false,
    configurable: true,
  });
  return Text;
})(DataNode$1);
node$3.Text = Text$1;
/**
 * Comments within the document.
 */
var Comment$b = /** @class */ (function (_super) {
  __extends(Comment, _super);
  function Comment() {
    var _this = (_super !== null && _super.apply(this, arguments)) || this;
    _this.type = domelementtype_1$1.ElementType.Comment;
    return _this;
  }
  Object.defineProperty(Comment.prototype, "nodeType", {
    get: function () {
      return 8;
    },
    enumerable: false,
    configurable: true,
  });
  return Comment;
})(DataNode$1);
node$3.Comment = Comment$b;
/**
 * Processing instructions, including doc types.
 */
var ProcessingInstruction$1 = /** @class */ (function (_super) {
  __extends(ProcessingInstruction, _super);
  function ProcessingInstruction(name, data) {
    var _this = _super.call(this, data) || this;
    _this.name = name;
    _this.type = domelementtype_1$1.ElementType.Directive;
    return _this;
  }
  Object.defineProperty(ProcessingInstruction.prototype, "nodeType", {
    get: function () {
      return 1;
    },
    enumerable: false,
    configurable: true,
  });
  return ProcessingInstruction;
})(DataNode$1);
node$3.ProcessingInstruction = ProcessingInstruction$1;
/**
 * A `Node` that can have children.
 */
var NodeWithChildren$1 = /** @class */ (function (_super) {
  __extends(NodeWithChildren, _super);
  /**
   * @param children Children of the node. Only certain node types can have children.
   */
  function NodeWithChildren(children) {
    var _this = _super.call(this) || this;
    _this.children = children;
    return _this;
  }
  Object.defineProperty(NodeWithChildren.prototype, "firstChild", {
    // Aliases
    /** First child of the node. */
    get: function () {
      var _a;
      return (_a = this.children[0]) !== null && _a !== void 0 ? _a : null;
    },
    enumerable: false,
    configurable: true,
  });
  Object.defineProperty(NodeWithChildren.prototype, "lastChild", {
    /** Last child of the node. */
    get: function () {
      return this.children.length > 0
        ? this.children[this.children.length - 1]
        : null;
    },
    enumerable: false,
    configurable: true,
  });
  Object.defineProperty(NodeWithChildren.prototype, "childNodes", {
    /**
     * Same as {@link children}.
     * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
     */
    get: function () {
      return this.children;
    },
    set: function (children) {
      this.children = children;
    },
    enumerable: false,
    configurable: true,
  });
  return NodeWithChildren;
})(Node$2);
node$3.NodeWithChildren = NodeWithChildren$1;
var CDATA$1 = /** @class */ (function (_super) {
  __extends(CDATA, _super);
  function CDATA() {
    var _this = (_super !== null && _super.apply(this, arguments)) || this;
    _this.type = domelementtype_1$1.ElementType.CDATA;
    return _this;
  }
  Object.defineProperty(CDATA.prototype, "nodeType", {
    get: function () {
      return 4;
    },
    enumerable: false,
    configurable: true,
  });
  return CDATA;
})(NodeWithChildren$1);
node$3.CDATA = CDATA$1;
/**
 * The root node of the document.
 */
var Document$1 = /** @class */ (function (_super) {
  __extends(Document, _super);
  function Document() {
    var _this = (_super !== null && _super.apply(this, arguments)) || this;
    _this.type = domelementtype_1$1.ElementType.Root;
    return _this;
  }
  Object.defineProperty(Document.prototype, "nodeType", {
    get: function () {
      return 9;
    },
    enumerable: false,
    configurable: true,
  });
  return Document;
})(NodeWithChildren$1);
node$3.Document = Document$1;
/**
 * An element within the DOM.
 */
var Element$1 = /** @class */ (function (_super) {
  __extends(Element, _super);
  /**
   * @param name Name of the tag, eg. `div`, `span`.
   * @param attribs Object mapping attribute names to attribute values.
   * @param children Children of the node.
   */
  function Element(name, attribs, children, type) {
    if (children === void 0) {
      children = [];
    }
    if (type === void 0) {
      type =
        name === "script"
          ? domelementtype_1$1.ElementType.Script
          : name === "style"
            ? domelementtype_1$1.ElementType.Style
            : domelementtype_1$1.ElementType.Tag;
    }
    var _this = _super.call(this, children) || this;
    _this.name = name;
    _this.attribs = attribs;
    _this.type = type;
    return _this;
  }
  Object.defineProperty(Element.prototype, "nodeType", {
    get: function () {
      return 1;
    },
    enumerable: false,
    configurable: true,
  });
  Object.defineProperty(Element.prototype, "tagName", {
    // DOM Level 1 aliases
    /**
     * Same as {@link name}.
     * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
     */
    get: function () {
      return this.name;
    },
    set: function (name) {
      this.name = name;
    },
    enumerable: false,
    configurable: true,
  });
  Object.defineProperty(Element.prototype, "attributes", {
    get: function () {
      var _this = this;
      return Object.keys(this.attribs).map(function (name) {
        var _a, _b;
        return {
          name: name,
          value: _this.attribs[name],
          namespace:
            (_a = _this["x-attribsNamespace"]) === null || _a === void 0
              ? void 0
              : _a[name],
          prefix:
            (_b = _this["x-attribsPrefix"]) === null || _b === void 0
              ? void 0
              : _b[name],
        };
      });
    },
    enumerable: false,
    configurable: true,
  });
  return Element;
})(NodeWithChildren$1);
node$3.Element = Element$1;
/**
 * @param node Node to check.
 * @returns `true` if the node is a `Element`, `false` otherwise.
 */
function isTag$2(node) {
  return (0, domelementtype_1$1.isTag)(node);
}
node$3.isTag = isTag$2;
/**
 * @param node Node to check.
 * @returns `true` if the node has the type `CDATA`, `false` otherwise.
 */
function isCDATA$1(node) {
  return node.type === domelementtype_1$1.ElementType.CDATA;
}
node$3.isCDATA = isCDATA$1;
/**
 * @param node Node to check.
 * @returns `true` if the node has the type `Text`, `false` otherwise.
 */
function isText$1(node) {
  return node.type === domelementtype_1$1.ElementType.Text;
}
node$3.isText = isText$1;
/**
 * @param node Node to check.
 * @returns `true` if the node has the type `Comment`, `false` otherwise.
 */
function isComment$1(node) {
  return node.type === domelementtype_1$1.ElementType.Comment;
}
node$3.isComment = isComment$1;
/**
 * @param node Node to check.
 * @returns `true` if the node has the type `ProcessingInstruction`, `false` otherwise.
 */
function isDirective$1(node) {
  return node.type === domelementtype_1$1.ElementType.Directive;
}
node$3.isDirective = isDirective$1;
/**
 * @param node Node to check.
 * @returns `true` if the node has the type `ProcessingInstruction`, `false` otherwise.
 */
function isDocument$1(node) {
  return node.type === domelementtype_1$1.ElementType.Root;
}
node$3.isDocument = isDocument$1;
/**
 * @param node Node to check.
 * @returns `true` if the node has children, `false` otherwise.
 */
function hasChildren$1(node) {
  return Object.prototype.hasOwnProperty.call(node, "children");
}
node$3.hasChildren = hasChildren$1;
/**
 * Clone a node, and optionally its children.
 *
 * @param recursive Clone child nodes as well.
 * @returns A clone of the node.
 */
function cloneNode$1(node, recursive) {
  if (recursive === void 0) {
    recursive = false;
  }
  var result;
  if (isText$1(node)) {
    result = new Text$1(node.data);
  } else if (isComment$1(node)) {
    result = new Comment$b(node.data);
  } else if (isTag$2(node)) {
    var children = recursive ? cloneChildren$1(node.children) : [];
    var clone_1 = new Element$1(
      node.name,
      __assign$1({}, node.attribs),
      children,
    );
    children.forEach(function (child) {
      return (child.parent = clone_1);
    });
    if (node.namespace != null) {
      clone_1.namespace = node.namespace;
    }
    if (node["x-attribsNamespace"]) {
      clone_1["x-attribsNamespace"] = __assign$1(
        {},
        node["x-attribsNamespace"],
      );
    }
    if (node["x-attribsPrefix"]) {
      clone_1["x-attribsPrefix"] = __assign$1({}, node["x-attribsPrefix"]);
    }
    result = clone_1;
  } else if (isCDATA$1(node)) {
    var children = recursive ? cloneChildren$1(node.children) : [];
    var clone_2 = new CDATA$1(children);
    children.forEach(function (child) {
      return (child.parent = clone_2);
    });
    result = clone_2;
  } else if (isDocument$1(node)) {
    var children = recursive ? cloneChildren$1(node.children) : [];
    var clone_3 = new Document$1(children);
    children.forEach(function (child) {
      return (child.parent = clone_3);
    });
    if (node["x-mode"]) {
      clone_3["x-mode"] = node["x-mode"];
    }
    result = clone_3;
  } else if (isDirective$1(node)) {
    var instruction = new ProcessingInstruction$1(node.name, node.data);
    if (node["x-name"] != null) {
      instruction["x-name"] = node["x-name"];
      instruction["x-publicId"] = node["x-publicId"];
      instruction["x-systemId"] = node["x-systemId"];
    }
    result = instruction;
  } else {
    throw new Error("Not implemented yet: ".concat(node.type));
  }
  result.startIndex = node.startIndex;
  result.endIndex = node.endIndex;
  if (node.sourceCodeLocation != null) {
    result.sourceCodeLocation = node.sourceCodeLocation;
  }
  return result;
}
node$3.cloneNode = cloneNode$1;
function cloneChildren$1(childs) {
  var children = childs.map(function (child) {
    return cloneNode$1(child, true);
  });
  for (var i = 1; i < children.length; i++) {
    children[i].prev = children[i - 1];
    children[i - 1].next = children[i];
  }
  return children;
}

(function (exports) {
  var __createBinding =
    (commonjsGlobal && commonjsGlobal.__createBinding) ||
    (Object.create
      ? function (o, m, k, k2) {
          if (k2 === undefined) k2 = k;
          var desc = Object.getOwnPropertyDescriptor(m, k);
          if (
            !desc ||
            ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)
          ) {
            desc = {
              enumerable: true,
              get: function () {
                return m[k];
              },
            };
          }
          Object.defineProperty(o, k2, desc);
        }
      : function (o, m, k, k2) {
          if (k2 === undefined) k2 = k;
          o[k2] = m[k];
        });
  var __exportStar =
    (commonjsGlobal && commonjsGlobal.__exportStar) ||
    function (m, exports) {
      for (var p in m)
        if (
          p !== "default" &&
          !Object.prototype.hasOwnProperty.call(exports, p)
        )
          __createBinding(exports, m, p);
    };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.DomHandler = void 0;
  var domelementtype_1 = require$$0$5;
  var node_js_1 = node$3;
  __exportStar(node$3, exports);
  // Default options
  var defaultOpts = {
    withStartIndices: false,
    withEndIndices: false,
    xmlMode: false,
  };
  var DomHandler = /** @class */ (function () {
    /**
     * @param callback Called once parsing has completed.
     * @param options Settings for the handler.
     * @param elementCB Callback whenever a tag is closed.
     */
    function DomHandler(callback, options, elementCB) {
      /** The elements of the DOM */
      this.dom = [];
      /** The root element for the DOM */
      this.root = new node_js_1.Document(this.dom);
      /** Indicated whether parsing has been completed. */
      this.done = false;
      /** Stack of open tags. */
      this.tagStack = [this.root];
      /** A data node that is still being written to. */
      this.lastNode = null;
      /** Reference to the parser instance. Used for location information. */
      this.parser = null;
      // Make it possible to skip arguments, for backwards-compatibility
      if (typeof options === "function") {
        elementCB = options;
        options = defaultOpts;
      }
      if (typeof callback === "object") {
        options = callback;
        callback = undefined;
      }
      this.callback =
        callback !== null && callback !== void 0 ? callback : null;
      this.options =
        options !== null && options !== void 0 ? options : defaultOpts;
      this.elementCB =
        elementCB !== null && elementCB !== void 0 ? elementCB : null;
    }
    DomHandler.prototype.onparserinit = function (parser) {
      this.parser = parser;
    };
    // Resets the handler back to starting state
    DomHandler.prototype.onreset = function () {
      this.dom = [];
      this.root = new node_js_1.Document(this.dom);
      this.done = false;
      this.tagStack = [this.root];
      this.lastNode = null;
      this.parser = null;
    };
    // Signals the handler that parsing is done
    DomHandler.prototype.onend = function () {
      if (this.done) return;
      this.done = true;
      this.parser = null;
      this.handleCallback(null);
    };
    DomHandler.prototype.onerror = function (error) {
      this.handleCallback(error);
    };
    DomHandler.prototype.onclosetag = function () {
      this.lastNode = null;
      var elem = this.tagStack.pop();
      if (this.options.withEndIndices) {
        elem.endIndex = this.parser.endIndex;
      }
      if (this.elementCB) this.elementCB(elem);
    };
    DomHandler.prototype.onopentag = function (name, attribs) {
      var type = this.options.xmlMode
        ? domelementtype_1.ElementType.Tag
        : undefined;
      var element = new node_js_1.Element(name, attribs, undefined, type);
      this.addNode(element);
      this.tagStack.push(element);
    };
    DomHandler.prototype.ontext = function (data) {
      var lastNode = this.lastNode;
      if (lastNode && lastNode.type === domelementtype_1.ElementType.Text) {
        lastNode.data += data;
        if (this.options.withEndIndices) {
          lastNode.endIndex = this.parser.endIndex;
        }
      } else {
        var node = new node_js_1.Text(data);
        this.addNode(node);
        this.lastNode = node;
      }
    };
    DomHandler.prototype.oncomment = function (data) {
      if (
        this.lastNode &&
        this.lastNode.type === domelementtype_1.ElementType.Comment
      ) {
        this.lastNode.data += data;
        return;
      }
      var node = new node_js_1.Comment(data);
      this.addNode(node);
      this.lastNode = node;
    };
    DomHandler.prototype.oncommentend = function () {
      this.lastNode = null;
    };
    DomHandler.prototype.oncdatastart = function () {
      var text = new node_js_1.Text("");
      var node = new node_js_1.CDATA([text]);
      this.addNode(node);
      text.parent = node;
      this.lastNode = text;
    };
    DomHandler.prototype.oncdataend = function () {
      this.lastNode = null;
    };
    DomHandler.prototype.onprocessinginstruction = function (name, data) {
      var node = new node_js_1.ProcessingInstruction(name, data);
      this.addNode(node);
    };
    DomHandler.prototype.handleCallback = function (error) {
      if (typeof this.callback === "function") {
        this.callback(error, this.dom);
      } else if (error) {
        throw error;
      }
    };
    DomHandler.prototype.addNode = function (node) {
      var parent = this.tagStack[this.tagStack.length - 1];
      var previousSibling = parent.children[parent.children.length - 1];
      if (this.options.withStartIndices) {
        node.startIndex = this.parser.startIndex;
      }
      if (this.options.withEndIndices) {
        node.endIndex = this.parser.endIndex;
      }
      parent.children.push(node);
      if (previousSibling) {
        node.prev = previousSibling;
        previousSibling.next = node;
      }
      node.parent = parent;
      this.lastNode = null;
    };
    return DomHandler;
  })();
  exports.DomHandler = DomHandler;
  exports.default = DomHandler;
})(lib$5);

var lib$4 = {};

// Generated using scripts/write-decode-map.ts
const htmlDecodeTree = new Uint16Array(
  // prettier-ignore
  "\u1d41<\xd5\u0131\u028a\u049d\u057b\u05d0\u0675\u06de\u07a2\u07d6\u080f\u0a4a\u0a91\u0da1\u0e6d\u0f09\u0f26\u10ca\u1228\u12e1\u1415\u149d\u14c3\u14df\u1525\0\0\0\0\0\0\u156b\u16cd\u198d\u1c12\u1ddd\u1f7e\u2060\u21b0\u228d\u23c0\u23fb\u2442\u2824\u2912\u2d08\u2e48\u2fce\u3016\u32ba\u3639\u37ac\u38fe\u3a28\u3a71\u3ae0\u3b2e\u0800EMabcfglmnoprstu\\bfms\x7f\x84\x8b\x90\x95\x98\xa6\xb3\xb9\xc8\xcflig\u803b\xc6\u40c6P\u803b&\u4026cute\u803b\xc1\u40c1reve;\u4102\u0100iyx}rc\u803b\xc2\u40c2;\u4410r;\uc000\ud835\udd04rave\u803b\xc0\u40c0pha;\u4391acr;\u4100d;\u6a53\u0100gp\x9d\xa1on;\u4104f;\uc000\ud835\udd38plyFunction;\u6061ing\u803b\xc5\u40c5\u0100cs\xbe\xc3r;\uc000\ud835\udc9cign;\u6254ilde\u803b\xc3\u40c3ml\u803b\xc4\u40c4\u0400aceforsu\xe5\xfb\xfe\u0117\u011c\u0122\u0127\u012a\u0100cr\xea\xf2kslash;\u6216\u0176\xf6\xf8;\u6ae7ed;\u6306y;\u4411\u0180crt\u0105\u010b\u0114ause;\u6235noullis;\u612ca;\u4392r;\uc000\ud835\udd05pf;\uc000\ud835\udd39eve;\u42d8c\xf2\u0113mpeq;\u624e\u0700HOacdefhilorsu\u014d\u0151\u0156\u0180\u019e\u01a2\u01b5\u01b7\u01ba\u01dc\u0215\u0273\u0278\u027ecy;\u4427PY\u803b\xa9\u40a9\u0180cpy\u015d\u0162\u017aute;\u4106\u0100;i\u0167\u0168\u62d2talDifferentialD;\u6145leys;\u612d\u0200aeio\u0189\u018e\u0194\u0198ron;\u410cdil\u803b\xc7\u40c7rc;\u4108nint;\u6230ot;\u410a\u0100dn\u01a7\u01adilla;\u40b8terDot;\u40b7\xf2\u017fi;\u43a7rcle\u0200DMPT\u01c7\u01cb\u01d1\u01d6ot;\u6299inus;\u6296lus;\u6295imes;\u6297o\u0100cs\u01e2\u01f8kwiseContourIntegral;\u6232eCurly\u0100DQ\u0203\u020foubleQuote;\u601duote;\u6019\u0200lnpu\u021e\u0228\u0247\u0255on\u0100;e\u0225\u0226\u6237;\u6a74\u0180git\u022f\u0236\u023aruent;\u6261nt;\u622fourIntegral;\u622e\u0100fr\u024c\u024e;\u6102oduct;\u6210nterClockwiseContourIntegral;\u6233oss;\u6a2fcr;\uc000\ud835\udc9ep\u0100;C\u0284\u0285\u62d3ap;\u624d\u0580DJSZacefios\u02a0\u02ac\u02b0\u02b4\u02b8\u02cb\u02d7\u02e1\u02e6\u0333\u048d\u0100;o\u0179\u02a5trahd;\u6911cy;\u4402cy;\u4405cy;\u440f\u0180grs\u02bf\u02c4\u02c7ger;\u6021r;\u61a1hv;\u6ae4\u0100ay\u02d0\u02d5ron;\u410e;\u4414l\u0100;t\u02dd\u02de\u6207a;\u4394r;\uc000\ud835\udd07\u0100af\u02eb\u0327\u0100cm\u02f0\u0322ritical\u0200ADGT\u0300\u0306\u0316\u031ccute;\u40b4o\u0174\u030b\u030d;\u42d9bleAcute;\u42ddrave;\u4060ilde;\u42dcond;\u62c4ferentialD;\u6146\u0470\u033d\0\0\0\u0342\u0354\0\u0405f;\uc000\ud835\udd3b\u0180;DE\u0348\u0349\u034d\u40a8ot;\u60dcqual;\u6250ble\u0300CDLRUV\u0363\u0372\u0382\u03cf\u03e2\u03f8ontourIntegra\xec\u0239o\u0274\u0379\0\0\u037b\xbb\u0349nArrow;\u61d3\u0100eo\u0387\u03a4ft\u0180ART\u0390\u0396\u03a1rrow;\u61d0ightArrow;\u61d4e\xe5\u02cang\u0100LR\u03ab\u03c4eft\u0100AR\u03b3\u03b9rrow;\u67f8ightArrow;\u67faightArrow;\u67f9ight\u0100AT\u03d8\u03derrow;\u61d2ee;\u62a8p\u0241\u03e9\0\0\u03efrrow;\u61d1ownArrow;\u61d5erticalBar;\u6225n\u0300ABLRTa\u0412\u042a\u0430\u045e\u047f\u037crrow\u0180;BU\u041d\u041e\u0422\u6193ar;\u6913pArrow;\u61f5reve;\u4311eft\u02d2\u043a\0\u0446\0\u0450ightVector;\u6950eeVector;\u695eector\u0100;B\u0459\u045a\u61bdar;\u6956ight\u01d4\u0467\0\u0471eeVector;\u695fector\u0100;B\u047a\u047b\u61c1ar;\u6957ee\u0100;A\u0486\u0487\u62a4rrow;\u61a7\u0100ct\u0492\u0497r;\uc000\ud835\udc9frok;\u4110\u0800NTacdfglmopqstux\u04bd\u04c0\u04c4\u04cb\u04de\u04e2\u04e7\u04ee\u04f5\u0521\u052f\u0536\u0552\u055d\u0560\u0565G;\u414aH\u803b\xd0\u40d0cute\u803b\xc9\u40c9\u0180aiy\u04d2\u04d7\u04dcron;\u411arc\u803b\xca\u40ca;\u442dot;\u4116r;\uc000\ud835\udd08rave\u803b\xc8\u40c8ement;\u6208\u0100ap\u04fa\u04fecr;\u4112ty\u0253\u0506\0\0\u0512mallSquare;\u65fberySmallSquare;\u65ab\u0100gp\u0526\u052aon;\u4118f;\uc000\ud835\udd3csilon;\u4395u\u0100ai\u053c\u0549l\u0100;T\u0542\u0543\u6a75ilde;\u6242librium;\u61cc\u0100ci\u0557\u055ar;\u6130m;\u6a73a;\u4397ml\u803b\xcb\u40cb\u0100ip\u056a\u056fsts;\u6203onentialE;\u6147\u0280cfios\u0585\u0588\u058d\u05b2\u05ccy;\u4424r;\uc000\ud835\udd09lled\u0253\u0597\0\0\u05a3mallSquare;\u65fcerySmallSquare;\u65aa\u0370\u05ba\0\u05bf\0\0\u05c4f;\uc000\ud835\udd3dAll;\u6200riertrf;\u6131c\xf2\u05cb\u0600JTabcdfgorst\u05e8\u05ec\u05ef\u05fa\u0600\u0612\u0616\u061b\u061d\u0623\u066c\u0672cy;\u4403\u803b>\u403emma\u0100;d\u05f7\u05f8\u4393;\u43dcreve;\u411e\u0180eiy\u0607\u060c\u0610dil;\u4122rc;\u411c;\u4413ot;\u4120r;\uc000\ud835\udd0a;\u62d9pf;\uc000\ud835\udd3eeater\u0300EFGLST\u0635\u0644\u064e\u0656\u065b\u0666qual\u0100;L\u063e\u063f\u6265ess;\u62dbullEqual;\u6267reater;\u6aa2ess;\u6277lantEqual;\u6a7eilde;\u6273cr;\uc000\ud835\udca2;\u626b\u0400Aacfiosu\u0685\u068b\u0696\u069b\u069e\u06aa\u06be\u06caRDcy;\u442a\u0100ct\u0690\u0694ek;\u42c7;\u405eirc;\u4124r;\u610clbertSpace;\u610b\u01f0\u06af\0\u06b2f;\u610dizontalLine;\u6500\u0100ct\u06c3\u06c5\xf2\u06a9rok;\u4126mp\u0144\u06d0\u06d8ownHum\xf0\u012fqual;\u624f\u0700EJOacdfgmnostu\u06fa\u06fe\u0703\u0707\u070e\u071a\u071e\u0721\u0728\u0744\u0778\u078b\u078f\u0795cy;\u4415lig;\u4132cy;\u4401cute\u803b\xcd\u40cd\u0100iy\u0713\u0718rc\u803b\xce\u40ce;\u4418ot;\u4130r;\u6111rave\u803b\xcc\u40cc\u0180;ap\u0720\u072f\u073f\u0100cg\u0734\u0737r;\u412ainaryI;\u6148lie\xf3\u03dd\u01f4\u0749\0\u0762\u0100;e\u074d\u074e\u622c\u0100gr\u0753\u0758ral;\u622bsection;\u62c2isible\u0100CT\u076c\u0772omma;\u6063imes;\u6062\u0180gpt\u077f\u0783\u0788on;\u412ef;\uc000\ud835\udd40a;\u4399cr;\u6110ilde;\u4128\u01eb\u079a\0\u079ecy;\u4406l\u803b\xcf\u40cf\u0280cfosu\u07ac\u07b7\u07bc\u07c2\u07d0\u0100iy\u07b1\u07b5rc;\u4134;\u4419r;\uc000\ud835\udd0dpf;\uc000\ud835\udd41\u01e3\u07c7\0\u07ccr;\uc000\ud835\udca5rcy;\u4408kcy;\u4404\u0380HJacfos\u07e4\u07e8\u07ec\u07f1\u07fd\u0802\u0808cy;\u4425cy;\u440cppa;\u439a\u0100ey\u07f6\u07fbdil;\u4136;\u441ar;\uc000\ud835\udd0epf;\uc000\ud835\udd42cr;\uc000\ud835\udca6\u0580JTaceflmost\u0825\u0829\u082c\u0850\u0863\u09b3\u09b8\u09c7\u09cd\u0a37\u0a47cy;\u4409\u803b<\u403c\u0280cmnpr\u0837\u083c\u0841\u0844\u084dute;\u4139bda;\u439bg;\u67ealacetrf;\u6112r;\u619e\u0180aey\u0857\u085c\u0861ron;\u413ddil;\u413b;\u441b\u0100fs\u0868\u0970t\u0500ACDFRTUVar\u087e\u08a9\u08b1\u08e0\u08e6\u08fc\u092f\u095b\u0390\u096a\u0100nr\u0883\u088fgleBracket;\u67e8row\u0180;BR\u0899\u089a\u089e\u6190ar;\u61e4ightArrow;\u61c6eiling;\u6308o\u01f5\u08b7\0\u08c3bleBracket;\u67e6n\u01d4\u08c8\0\u08d2eeVector;\u6961ector\u0100;B\u08db\u08dc\u61c3ar;\u6959loor;\u630aight\u0100AV\u08ef\u08f5rrow;\u6194ector;\u694e\u0100er\u0901\u0917e\u0180;AV\u0909\u090a\u0910\u62a3rrow;\u61a4ector;\u695aiangle\u0180;BE\u0924\u0925\u0929\u62b2ar;\u69cfqual;\u62b4p\u0180DTV\u0937\u0942\u094cownVector;\u6951eeVector;\u6960ector\u0100;B\u0956\u0957\u61bfar;\u6958ector\u0100;B\u0965\u0966\u61bcar;\u6952ight\xe1\u039cs\u0300EFGLST\u097e\u098b\u0995\u099d\u09a2\u09adqualGreater;\u62daullEqual;\u6266reater;\u6276ess;\u6aa1lantEqual;\u6a7dilde;\u6272r;\uc000\ud835\udd0f\u0100;e\u09bd\u09be\u62d8ftarrow;\u61daidot;\u413f\u0180npw\u09d4\u0a16\u0a1bg\u0200LRlr\u09de\u09f7\u0a02\u0a10eft\u0100AR\u09e6\u09ecrrow;\u67f5ightArrow;\u67f7ightArrow;\u67f6eft\u0100ar\u03b3\u0a0aight\xe1\u03bfight\xe1\u03caf;\uc000\ud835\udd43er\u0100LR\u0a22\u0a2ceftArrow;\u6199ightArrow;\u6198\u0180cht\u0a3e\u0a40\u0a42\xf2\u084c;\u61b0rok;\u4141;\u626a\u0400acefiosu\u0a5a\u0a5d\u0a60\u0a77\u0a7c\u0a85\u0a8b\u0a8ep;\u6905y;\u441c\u0100dl\u0a65\u0a6fiumSpace;\u605flintrf;\u6133r;\uc000\ud835\udd10nusPlus;\u6213pf;\uc000\ud835\udd44c\xf2\u0a76;\u439c\u0480Jacefostu\u0aa3\u0aa7\u0aad\u0ac0\u0b14\u0b19\u0d91\u0d97\u0d9ecy;\u440acute;\u4143\u0180aey\u0ab4\u0ab9\u0aberon;\u4147dil;\u4145;\u441d\u0180gsw\u0ac7\u0af0\u0b0eative\u0180MTV\u0ad3\u0adf\u0ae8ediumSpace;\u600bhi\u0100cn\u0ae6\u0ad8\xeb\u0ad9eryThi\xee\u0ad9ted\u0100GL\u0af8\u0b06reaterGreate\xf2\u0673essLes\xf3\u0a48Line;\u400ar;\uc000\ud835\udd11\u0200Bnpt\u0b22\u0b28\u0b37\u0b3areak;\u6060BreakingSpace;\u40a0f;\u6115\u0680;CDEGHLNPRSTV\u0b55\u0b56\u0b6a\u0b7c\u0ba1\u0beb\u0c04\u0c5e\u0c84\u0ca6\u0cd8\u0d61\u0d85\u6aec\u0100ou\u0b5b\u0b64ngruent;\u6262pCap;\u626doubleVerticalBar;\u6226\u0180lqx\u0b83\u0b8a\u0b9bement;\u6209ual\u0100;T\u0b92\u0b93\u6260ilde;\uc000\u2242\u0338ists;\u6204reater\u0380;EFGLST\u0bb6\u0bb7\u0bbd\u0bc9\u0bd3\u0bd8\u0be5\u626fqual;\u6271ullEqual;\uc000\u2267\u0338reater;\uc000\u226b\u0338ess;\u6279lantEqual;\uc000\u2a7e\u0338ilde;\u6275ump\u0144\u0bf2\u0bfdownHump;\uc000\u224e\u0338qual;\uc000\u224f\u0338e\u0100fs\u0c0a\u0c27tTriangle\u0180;BE\u0c1a\u0c1b\u0c21\u62eaar;\uc000\u29cf\u0338qual;\u62ecs\u0300;EGLST\u0c35\u0c36\u0c3c\u0c44\u0c4b\u0c58\u626equal;\u6270reater;\u6278ess;\uc000\u226a\u0338lantEqual;\uc000\u2a7d\u0338ilde;\u6274ested\u0100GL\u0c68\u0c79reaterGreater;\uc000\u2aa2\u0338essLess;\uc000\u2aa1\u0338recedes\u0180;ES\u0c92\u0c93\u0c9b\u6280qual;\uc000\u2aaf\u0338lantEqual;\u62e0\u0100ei\u0cab\u0cb9verseElement;\u620cghtTriangle\u0180;BE\u0ccb\u0ccc\u0cd2\u62ebar;\uc000\u29d0\u0338qual;\u62ed\u0100qu\u0cdd\u0d0cuareSu\u0100bp\u0ce8\u0cf9set\u0100;E\u0cf0\u0cf3\uc000\u228f\u0338qual;\u62e2erset\u0100;E\u0d03\u0d06\uc000\u2290\u0338qual;\u62e3\u0180bcp\u0d13\u0d24\u0d4eset\u0100;E\u0d1b\u0d1e\uc000\u2282\u20d2qual;\u6288ceeds\u0200;EST\u0d32\u0d33\u0d3b\u0d46\u6281qual;\uc000\u2ab0\u0338lantEqual;\u62e1ilde;\uc000\u227f\u0338erset\u0100;E\u0d58\u0d5b\uc000\u2283\u20d2qual;\u6289ilde\u0200;EFT\u0d6e\u0d6f\u0d75\u0d7f\u6241qual;\u6244ullEqual;\u6247ilde;\u6249erticalBar;\u6224cr;\uc000\ud835\udca9ilde\u803b\xd1\u40d1;\u439d\u0700Eacdfgmoprstuv\u0dbd\u0dc2\u0dc9\u0dd5\u0ddb\u0de0\u0de7\u0dfc\u0e02\u0e20\u0e22\u0e32\u0e3f\u0e44lig;\u4152cute\u803b\xd3\u40d3\u0100iy\u0dce\u0dd3rc\u803b\xd4\u40d4;\u441eblac;\u4150r;\uc000\ud835\udd12rave\u803b\xd2\u40d2\u0180aei\u0dee\u0df2\u0df6cr;\u414cga;\u43a9cron;\u439fpf;\uc000\ud835\udd46enCurly\u0100DQ\u0e0e\u0e1aoubleQuote;\u601cuote;\u6018;\u6a54\u0100cl\u0e27\u0e2cr;\uc000\ud835\udcaaash\u803b\xd8\u40d8i\u016c\u0e37\u0e3cde\u803b\xd5\u40d5es;\u6a37ml\u803b\xd6\u40d6er\u0100BP\u0e4b\u0e60\u0100ar\u0e50\u0e53r;\u603eac\u0100ek\u0e5a\u0e5c;\u63deet;\u63b4arenthesis;\u63dc\u0480acfhilors\u0e7f\u0e87\u0e8a\u0e8f\u0e92\u0e94\u0e9d\u0eb0\u0efcrtialD;\u6202y;\u441fr;\uc000\ud835\udd13i;\u43a6;\u43a0usMinus;\u40b1\u0100ip\u0ea2\u0eadncareplan\xe5\u069df;\u6119\u0200;eio\u0eb9\u0eba\u0ee0\u0ee4\u6abbcedes\u0200;EST\u0ec8\u0ec9\u0ecf\u0eda\u627aqual;\u6aaflantEqual;\u627cilde;\u627eme;\u6033\u0100dp\u0ee9\u0eeeuct;\u620fortion\u0100;a\u0225\u0ef9l;\u621d\u0100ci\u0f01\u0f06r;\uc000\ud835\udcab;\u43a8\u0200Ufos\u0f11\u0f16\u0f1b\u0f1fOT\u803b\"\u4022r;\uc000\ud835\udd14pf;\u611acr;\uc000\ud835\udcac\u0600BEacefhiorsu\u0f3e\u0f43\u0f47\u0f60\u0f73\u0fa7\u0faa\u0fad\u1096\u10a9\u10b4\u10bearr;\u6910G\u803b\xae\u40ae\u0180cnr\u0f4e\u0f53\u0f56ute;\u4154g;\u67ebr\u0100;t\u0f5c\u0f5d\u61a0l;\u6916\u0180aey\u0f67\u0f6c\u0f71ron;\u4158dil;\u4156;\u4420\u0100;v\u0f78\u0f79\u611cerse\u0100EU\u0f82\u0f99\u0100lq\u0f87\u0f8eement;\u620builibrium;\u61cbpEquilibrium;\u696fr\xbb\u0f79o;\u43a1ght\u0400ACDFTUVa\u0fc1\u0feb\u0ff3\u1022\u1028\u105b\u1087\u03d8\u0100nr\u0fc6\u0fd2gleBracket;\u67e9row\u0180;BL\u0fdc\u0fdd\u0fe1\u6192ar;\u61e5eftArrow;\u61c4eiling;\u6309o\u01f5\u0ff9\0\u1005bleBracket;\u67e7n\u01d4\u100a\0\u1014eeVector;\u695dector\u0100;B\u101d\u101e\u61c2ar;\u6955loor;\u630b\u0100er\u102d\u1043e\u0180;AV\u1035\u1036\u103c\u62a2rrow;\u61a6ector;\u695biangle\u0180;BE\u1050\u1051\u1055\u62b3ar;\u69d0qual;\u62b5p\u0180DTV\u1063\u106e\u1078ownVector;\u694feeVector;\u695cector\u0100;B\u1082\u1083\u61bear;\u6954ector\u0100;B\u1091\u1092\u61c0ar;\u6953\u0100pu\u109b\u109ef;\u611dndImplies;\u6970ightarrow;\u61db\u0100ch\u10b9\u10bcr;\u611b;\u61b1leDelayed;\u69f4\u0680HOacfhimoqstu\u10e4\u10f1\u10f7\u10fd\u1119\u111e\u1151\u1156\u1161\u1167\u11b5\u11bb\u11bf\u0100Cc\u10e9\u10eeHcy;\u4429y;\u4428FTcy;\u442ccute;\u415a\u0280;aeiy\u1108\u1109\u110e\u1113\u1117\u6abcron;\u4160dil;\u415erc;\u415c;\u4421r;\uc000\ud835\udd16ort\u0200DLRU\u112a\u1134\u113e\u1149ownArrow\xbb\u041eeftArrow\xbb\u089aightArrow\xbb\u0fddpArrow;\u6191gma;\u43a3allCircle;\u6218pf;\uc000\ud835\udd4a\u0272\u116d\0\0\u1170t;\u621aare\u0200;ISU\u117b\u117c\u1189\u11af\u65a1ntersection;\u6293u\u0100bp\u118f\u119eset\u0100;E\u1197\u1198\u628fqual;\u6291erset\u0100;E\u11a8\u11a9\u6290qual;\u6292nion;\u6294cr;\uc000\ud835\udcaear;\u62c6\u0200bcmp\u11c8\u11db\u1209\u120b\u0100;s\u11cd\u11ce\u62d0et\u0100;E\u11cd\u11d5qual;\u6286\u0100ch\u11e0\u1205eeds\u0200;EST\u11ed\u11ee\u11f4\u11ff\u627bqual;\u6ab0lantEqual;\u627dilde;\u627fTh\xe1\u0f8c;\u6211\u0180;es\u1212\u1213\u1223\u62d1rset\u0100;E\u121c\u121d\u6283qual;\u6287et\xbb\u1213\u0580HRSacfhiors\u123e\u1244\u1249\u1255\u125e\u1271\u1276\u129f\u12c2\u12c8\u12d1ORN\u803b\xde\u40deADE;\u6122\u0100Hc\u124e\u1252cy;\u440by;\u4426\u0100bu\u125a\u125c;\u4009;\u43a4\u0180aey\u1265\u126a\u126fron;\u4164dil;\u4162;\u4422r;\uc000\ud835\udd17\u0100ei\u127b\u1289\u01f2\u1280\0\u1287efore;\u6234a;\u4398\u0100cn\u128e\u1298kSpace;\uc000\u205f\u200aSpace;\u6009lde\u0200;EFT\u12ab\u12ac\u12b2\u12bc\u623cqual;\u6243ullEqual;\u6245ilde;\u6248pf;\uc000\ud835\udd4bipleDot;\u60db\u0100ct\u12d6\u12dbr;\uc000\ud835\udcafrok;\u4166\u0ae1\u12f7\u130e\u131a\u1326\0\u132c\u1331\0\0\0\0\0\u1338\u133d\u1377\u1385\0\u13ff\u1404\u140a\u1410\u0100cr\u12fb\u1301ute\u803b\xda\u40dar\u0100;o\u1307\u1308\u619fcir;\u6949r\u01e3\u1313\0\u1316y;\u440eve;\u416c\u0100iy\u131e\u1323rc\u803b\xdb\u40db;\u4423blac;\u4170r;\uc000\ud835\udd18rave\u803b\xd9\u40d9acr;\u416a\u0100di\u1341\u1369er\u0100BP\u1348\u135d\u0100ar\u134d\u1350r;\u405fac\u0100ek\u1357\u1359;\u63dfet;\u63b5arenthesis;\u63ddon\u0100;P\u1370\u1371\u62c3lus;\u628e\u0100gp\u137b\u137fon;\u4172f;\uc000\ud835\udd4c\u0400ADETadps\u1395\u13ae\u13b8\u13c4\u03e8\u13d2\u13d7\u13f3rrow\u0180;BD\u1150\u13a0\u13a4ar;\u6912ownArrow;\u61c5ownArrow;\u6195quilibrium;\u696eee\u0100;A\u13cb\u13cc\u62a5rrow;\u61a5own\xe1\u03f3er\u0100LR\u13de\u13e8eftArrow;\u6196ightArrow;\u6197i\u0100;l\u13f9\u13fa\u43d2on;\u43a5ing;\u416ecr;\uc000\ud835\udcb0ilde;\u4168ml\u803b\xdc\u40dc\u0480Dbcdefosv\u1427\u142c\u1430\u1433\u143e\u1485\u148a\u1490\u1496ash;\u62abar;\u6aeby;\u4412ash\u0100;l\u143b\u143c\u62a9;\u6ae6\u0100er\u1443\u1445;\u62c1\u0180bty\u144c\u1450\u147aar;\u6016\u0100;i\u144f\u1455cal\u0200BLST\u1461\u1465\u146a\u1474ar;\u6223ine;\u407ceparator;\u6758ilde;\u6240ThinSpace;\u600ar;\uc000\ud835\udd19pf;\uc000\ud835\udd4dcr;\uc000\ud835\udcb1dash;\u62aa\u0280cefos\u14a7\u14ac\u14b1\u14b6\u14bcirc;\u4174dge;\u62c0r;\uc000\ud835\udd1apf;\uc000\ud835\udd4ecr;\uc000\ud835\udcb2\u0200fios\u14cb\u14d0\u14d2\u14d8r;\uc000\ud835\udd1b;\u439epf;\uc000\ud835\udd4fcr;\uc000\ud835\udcb3\u0480AIUacfosu\u14f1\u14f5\u14f9\u14fd\u1504\u150f\u1514\u151a\u1520cy;\u442fcy;\u4407cy;\u442ecute\u803b\xdd\u40dd\u0100iy\u1509\u150drc;\u4176;\u442br;\uc000\ud835\udd1cpf;\uc000\ud835\udd50cr;\uc000\ud835\udcb4ml;\u4178\u0400Hacdefos\u1535\u1539\u153f\u154b\u154f\u155d\u1560\u1564cy;\u4416cute;\u4179\u0100ay\u1544\u1549ron;\u417d;\u4417ot;\u417b\u01f2\u1554\0\u155boWidt\xe8\u0ad9a;\u4396r;\u6128pf;\u6124cr;\uc000\ud835\udcb5\u0be1\u1583\u158a\u1590\0\u15b0\u15b6\u15bf\0\0\0\0\u15c6\u15db\u15eb\u165f\u166d\0\u1695\u169b\u16b2\u16b9\0\u16becute\u803b\xe1\u40e1reve;\u4103\u0300;Ediuy\u159c\u159d\u15a1\u15a3\u15a8\u15ad\u623e;\uc000\u223e\u0333;\u623frc\u803b\xe2\u40e2te\u80bb\xb4\u0306;\u4430lig\u803b\xe6\u40e6\u0100;r\xb2\u15ba;\uc000\ud835\udd1erave\u803b\xe0\u40e0\u0100ep\u15ca\u15d6\u0100fp\u15cf\u15d4sym;\u6135\xe8\u15d3ha;\u43b1\u0100ap\u15dfc\u0100cl\u15e4\u15e7r;\u4101g;\u6a3f\u0264\u15f0\0\0\u160a\u0280;adsv\u15fa\u15fb\u15ff\u1601\u1607\u6227nd;\u6a55;\u6a5clope;\u6a58;\u6a5a\u0380;elmrsz\u1618\u1619\u161b\u161e\u163f\u164f\u1659\u6220;\u69a4e\xbb\u1619sd\u0100;a\u1625\u1626\u6221\u0461\u1630\u1632\u1634\u1636\u1638\u163a\u163c\u163e;\u69a8;\u69a9;\u69aa;\u69ab;\u69ac;\u69ad;\u69ae;\u69aft\u0100;v\u1645\u1646\u621fb\u0100;d\u164c\u164d\u62be;\u699d\u0100pt\u1654\u1657h;\u6222\xbb\xb9arr;\u637c\u0100gp\u1663\u1667on;\u4105f;\uc000\ud835\udd52\u0380;Eaeiop\u12c1\u167b\u167d\u1682\u1684\u1687\u168a;\u6a70cir;\u6a6f;\u624ad;\u624bs;\u4027rox\u0100;e\u12c1\u1692\xf1\u1683ing\u803b\xe5\u40e5\u0180cty\u16a1\u16a6\u16a8r;\uc000\ud835\udcb6;\u402amp\u0100;e\u12c1\u16af\xf1\u0288ilde\u803b\xe3\u40e3ml\u803b\xe4\u40e4\u0100ci\u16c2\u16c8onin\xf4\u0272nt;\u6a11\u0800Nabcdefiklnoprsu\u16ed\u16f1\u1730\u173c\u1743\u1748\u1778\u177d\u17e0\u17e6\u1839\u1850\u170d\u193d\u1948\u1970ot;\u6aed\u0100cr\u16f6\u171ek\u0200ceps\u1700\u1705\u170d\u1713ong;\u624cpsilon;\u43f6rime;\u6035im\u0100;e\u171a\u171b\u623dq;\u62cd\u0176\u1722\u1726ee;\u62bded\u0100;g\u172c\u172d\u6305e\xbb\u172drk\u0100;t\u135c\u1737brk;\u63b6\u0100oy\u1701\u1741;\u4431quo;\u601e\u0280cmprt\u1753\u175b\u1761\u1764\u1768aus\u0100;e\u010a\u0109ptyv;\u69b0s\xe9\u170cno\xf5\u0113\u0180ahw\u176f\u1771\u1773;\u43b2;\u6136een;\u626cr;\uc000\ud835\udd1fg\u0380costuvw\u178d\u179d\u17b3\u17c1\u17d5\u17db\u17de\u0180aiu\u1794\u1796\u179a\xf0\u0760rc;\u65efp\xbb\u1371\u0180dpt\u17a4\u17a8\u17adot;\u6a00lus;\u6a01imes;\u6a02\u0271\u17b9\0\0\u17becup;\u6a06ar;\u6605riangle\u0100du\u17cd\u17d2own;\u65bdp;\u65b3plus;\u6a04e\xe5\u1444\xe5\u14adarow;\u690d\u0180ako\u17ed\u1826\u1835\u0100cn\u17f2\u1823k\u0180lst\u17fa\u05ab\u1802ozenge;\u69ebriangle\u0200;dlr\u1812\u1813\u1818\u181d\u65b4own;\u65beeft;\u65c2ight;\u65b8k;\u6423\u01b1\u182b\0\u1833\u01b2\u182f\0\u1831;\u6592;\u65914;\u6593ck;\u6588\u0100eo\u183e\u184d\u0100;q\u1843\u1846\uc000=\u20e5uiv;\uc000\u2261\u20e5t;\u6310\u0200ptwx\u1859\u185e\u1867\u186cf;\uc000\ud835\udd53\u0100;t\u13cb\u1863om\xbb\u13cctie;\u62c8\u0600DHUVbdhmptuv\u1885\u1896\u18aa\u18bb\u18d7\u18db\u18ec\u18ff\u1905\u190a\u1910\u1921\u0200LRlr\u188e\u1890\u1892\u1894;\u6557;\u6554;\u6556;\u6553\u0280;DUdu\u18a1\u18a2\u18a4\u18a6\u18a8\u6550;\u6566;\u6569;\u6564;\u6567\u0200LRlr\u18b3\u18b5\u18b7\u18b9;\u655d;\u655a;\u655c;\u6559\u0380;HLRhlr\u18ca\u18cb\u18cd\u18cf\u18d1\u18d3\u18d5\u6551;\u656c;\u6563;\u6560;\u656b;\u6562;\u655fox;\u69c9\u0200LRlr\u18e4\u18e6\u18e8\u18ea;\u6555;\u6552;\u6510;\u650c\u0280;DUdu\u06bd\u18f7\u18f9\u18fb\u18fd;\u6565;\u6568;\u652c;\u6534inus;\u629flus;\u629eimes;\u62a0\u0200LRlr\u1919\u191b\u191d\u191f;\u655b;\u6558;\u6518;\u6514\u0380;HLRhlr\u1930\u1931\u1933\u1935\u1937\u1939\u193b\u6502;\u656a;\u6561;\u655e;\u653c;\u6524;\u651c\u0100ev\u0123\u1942bar\u803b\xa6\u40a6\u0200ceio\u1951\u1956\u195a\u1960r;\uc000\ud835\udcb7mi;\u604fm\u0100;e\u171a\u171cl\u0180;bh\u1968\u1969\u196b\u405c;\u69c5sub;\u67c8\u016c\u1974\u197el\u0100;e\u1979\u197a\u6022t\xbb\u197ap\u0180;Ee\u012f\u1985\u1987;\u6aae\u0100;q\u06dc\u06db\u0ce1\u19a7\0\u19e8\u1a11\u1a15\u1a32\0\u1a37\u1a50\0\0\u1ab4\0\0\u1ac1\0\0\u1b21\u1b2e\u1b4d\u1b52\0\u1bfd\0\u1c0c\u0180cpr\u19ad\u19b2\u19ddute;\u4107\u0300;abcds\u19bf\u19c0\u19c4\u19ca\u19d5\u19d9\u6229nd;\u6a44rcup;\u6a49\u0100au\u19cf\u19d2p;\u6a4bp;\u6a47ot;\u6a40;\uc000\u2229\ufe00\u0100eo\u19e2\u19e5t;\u6041\xee\u0693\u0200aeiu\u19f0\u19fb\u1a01\u1a05\u01f0\u19f5\0\u19f8s;\u6a4don;\u410ddil\u803b\xe7\u40e7rc;\u4109ps\u0100;s\u1a0c\u1a0d\u6a4cm;\u6a50ot;\u410b\u0180dmn\u1a1b\u1a20\u1a26il\u80bb\xb8\u01adptyv;\u69b2t\u8100\xa2;e\u1a2d\u1a2e\u40a2r\xe4\u01b2r;\uc000\ud835\udd20\u0180cei\u1a3d\u1a40\u1a4dy;\u4447ck\u0100;m\u1a47\u1a48\u6713ark\xbb\u1a48;\u43c7r\u0380;Ecefms\u1a5f\u1a60\u1a62\u1a6b\u1aa4\u1aaa\u1aae\u65cb;\u69c3\u0180;el\u1a69\u1a6a\u1a6d\u42c6q;\u6257e\u0261\u1a74\0\0\u1a88rrow\u0100lr\u1a7c\u1a81eft;\u61baight;\u61bb\u0280RSacd\u1a92\u1a94\u1a96\u1a9a\u1a9f\xbb\u0f47;\u64c8st;\u629birc;\u629aash;\u629dnint;\u6a10id;\u6aefcir;\u69c2ubs\u0100;u\u1abb\u1abc\u6663it\xbb\u1abc\u02ec\u1ac7\u1ad4\u1afa\0\u1b0aon\u0100;e\u1acd\u1ace\u403a\u0100;q\xc7\xc6\u026d\u1ad9\0\0\u1ae2a\u0100;t\u1ade\u1adf\u402c;\u4040\u0180;fl\u1ae8\u1ae9\u1aeb\u6201\xee\u1160e\u0100mx\u1af1\u1af6ent\xbb\u1ae9e\xf3\u024d\u01e7\u1afe\0\u1b07\u0100;d\u12bb\u1b02ot;\u6a6dn\xf4\u0246\u0180fry\u1b10\u1b14\u1b17;\uc000\ud835\udd54o\xe4\u0254\u8100\xa9;s\u0155\u1b1dr;\u6117\u0100ao\u1b25\u1b29rr;\u61b5ss;\u6717\u0100cu\u1b32\u1b37r;\uc000\ud835\udcb8\u0100bp\u1b3c\u1b44\u0100;e\u1b41\u1b42\u6acf;\u6ad1\u0100;e\u1b49\u1b4a\u6ad0;\u6ad2dot;\u62ef\u0380delprvw\u1b60\u1b6c\u1b77\u1b82\u1bac\u1bd4\u1bf9arr\u0100lr\u1b68\u1b6a;\u6938;\u6935\u0270\u1b72\0\0\u1b75r;\u62dec;\u62dfarr\u0100;p\u1b7f\u1b80\u61b6;\u693d\u0300;bcdos\u1b8f\u1b90\u1b96\u1ba1\u1ba5\u1ba8\u622arcap;\u6a48\u0100au\u1b9b\u1b9ep;\u6a46p;\u6a4aot;\u628dr;\u6a45;\uc000\u222a\ufe00\u0200alrv\u1bb5\u1bbf\u1bde\u1be3rr\u0100;m\u1bbc\u1bbd\u61b7;\u693cy\u0180evw\u1bc7\u1bd4\u1bd8q\u0270\u1bce\0\0\u1bd2re\xe3\u1b73u\xe3\u1b75ee;\u62ceedge;\u62cfen\u803b\xa4\u40a4earrow\u0100lr\u1bee\u1bf3eft\xbb\u1b80ight\xbb\u1bbde\xe4\u1bdd\u0100ci\u1c01\u1c07onin\xf4\u01f7nt;\u6231lcty;\u632d\u0980AHabcdefhijlorstuwz\u1c38\u1c3b\u1c3f\u1c5d\u1c69\u1c75\u1c8a\u1c9e\u1cac\u1cb7\u1cfb\u1cff\u1d0d\u1d7b\u1d91\u1dab\u1dbb\u1dc6\u1dcdr\xf2\u0381ar;\u6965\u0200glrs\u1c48\u1c4d\u1c52\u1c54ger;\u6020eth;\u6138\xf2\u1133h\u0100;v\u1c5a\u1c5b\u6010\xbb\u090a\u016b\u1c61\u1c67arow;\u690fa\xe3\u0315\u0100ay\u1c6e\u1c73ron;\u410f;\u4434\u0180;ao\u0332\u1c7c\u1c84\u0100gr\u02bf\u1c81r;\u61catseq;\u6a77\u0180glm\u1c91\u1c94\u1c98\u803b\xb0\u40b0ta;\u43b4ptyv;\u69b1\u0100ir\u1ca3\u1ca8sht;\u697f;\uc000\ud835\udd21ar\u0100lr\u1cb3\u1cb5\xbb\u08dc\xbb\u101e\u0280aegsv\u1cc2\u0378\u1cd6\u1cdc\u1ce0m\u0180;os\u0326\u1cca\u1cd4nd\u0100;s\u0326\u1cd1uit;\u6666amma;\u43ddin;\u62f2\u0180;io\u1ce7\u1ce8\u1cf8\u40f7de\u8100\xf7;o\u1ce7\u1cf0ntimes;\u62c7n\xf8\u1cf7cy;\u4452c\u026f\u1d06\0\0\u1d0arn;\u631eop;\u630d\u0280lptuw\u1d18\u1d1d\u1d22\u1d49\u1d55lar;\u4024f;\uc000\ud835\udd55\u0280;emps\u030b\u1d2d\u1d37\u1d3d\u1d42q\u0100;d\u0352\u1d33ot;\u6251inus;\u6238lus;\u6214quare;\u62a1blebarwedg\xe5\xfan\u0180adh\u112e\u1d5d\u1d67ownarrow\xf3\u1c83arpoon\u0100lr\u1d72\u1d76ef\xf4\u1cb4igh\xf4\u1cb6\u0162\u1d7f\u1d85karo\xf7\u0f42\u026f\u1d8a\0\0\u1d8ern;\u631fop;\u630c\u0180cot\u1d98\u1da3\u1da6\u0100ry\u1d9d\u1da1;\uc000\ud835\udcb9;\u4455l;\u69f6rok;\u4111\u0100dr\u1db0\u1db4ot;\u62f1i\u0100;f\u1dba\u1816\u65bf\u0100ah\u1dc0\u1dc3r\xf2\u0429a\xf2\u0fa6angle;\u69a6\u0100ci\u1dd2\u1dd5y;\u445fgrarr;\u67ff\u0900Dacdefglmnopqrstux\u1e01\u1e09\u1e19\u1e38\u0578\u1e3c\u1e49\u1e61\u1e7e\u1ea5\u1eaf\u1ebd\u1ee1\u1f2a\u1f37\u1f44\u1f4e\u1f5a\u0100Do\u1e06\u1d34o\xf4\u1c89\u0100cs\u1e0e\u1e14ute\u803b\xe9\u40e9ter;\u6a6e\u0200aioy\u1e22\u1e27\u1e31\u1e36ron;\u411br\u0100;c\u1e2d\u1e2e\u6256\u803b\xea\u40ealon;\u6255;\u444dot;\u4117\u0100Dr\u1e41\u1e45ot;\u6252;\uc000\ud835\udd22\u0180;rs\u1e50\u1e51\u1e57\u6a9aave\u803b\xe8\u40e8\u0100;d\u1e5c\u1e5d\u6a96ot;\u6a98\u0200;ils\u1e6a\u1e6b\u1e72\u1e74\u6a99nters;\u63e7;\u6113\u0100;d\u1e79\u1e7a\u6a95ot;\u6a97\u0180aps\u1e85\u1e89\u1e97cr;\u4113ty\u0180;sv\u1e92\u1e93\u1e95\u6205et\xbb\u1e93p\u01001;\u1e9d\u1ea4\u0133\u1ea1\u1ea3;\u6004;\u6005\u6003\u0100gs\u1eaa\u1eac;\u414bp;\u6002\u0100gp\u1eb4\u1eb8on;\u4119f;\uc000\ud835\udd56\u0180als\u1ec4\u1ece\u1ed2r\u0100;s\u1eca\u1ecb\u62d5l;\u69e3us;\u6a71i\u0180;lv\u1eda\u1edb\u1edf\u43b5on\xbb\u1edb;\u43f5\u0200csuv\u1eea\u1ef3\u1f0b\u1f23\u0100io\u1eef\u1e31rc\xbb\u1e2e\u0269\u1ef9\0\0\u1efb\xed\u0548ant\u0100gl\u1f02\u1f06tr\xbb\u1e5dess\xbb\u1e7a\u0180aei\u1f12\u1f16\u1f1als;\u403dst;\u625fv\u0100;D\u0235\u1f20D;\u6a78parsl;\u69e5\u0100Da\u1f2f\u1f33ot;\u6253rr;\u6971\u0180cdi\u1f3e\u1f41\u1ef8r;\u612fo\xf4\u0352\u0100ah\u1f49\u1f4b;\u43b7\u803b\xf0\u40f0\u0100mr\u1f53\u1f57l\u803b\xeb\u40ebo;\u60ac\u0180cip\u1f61\u1f64\u1f67l;\u4021s\xf4\u056e\u0100eo\u1f6c\u1f74ctatio\xee\u0559nential\xe5\u0579\u09e1\u1f92\0\u1f9e\0\u1fa1\u1fa7\0\0\u1fc6\u1fcc\0\u1fd3\0\u1fe6\u1fea\u2000\0\u2008\u205allingdotse\xf1\u1e44y;\u4444male;\u6640\u0180ilr\u1fad\u1fb3\u1fc1lig;\u8000\ufb03\u0269\u1fb9\0\0\u1fbdg;\u8000\ufb00ig;\u8000\ufb04;\uc000\ud835\udd23lig;\u8000\ufb01lig;\uc000fj\u0180alt\u1fd9\u1fdc\u1fe1t;\u666dig;\u8000\ufb02ns;\u65b1of;\u4192\u01f0\u1fee\0\u1ff3f;\uc000\ud835\udd57\u0100ak\u05bf\u1ff7\u0100;v\u1ffc\u1ffd\u62d4;\u6ad9artint;\u6a0d\u0100ao\u200c\u2055\u0100cs\u2011\u2052\u03b1\u201a\u2030\u2038\u2045\u2048\0\u2050\u03b2\u2022\u2025\u2027\u202a\u202c\0\u202e\u803b\xbd\u40bd;\u6153\u803b\xbc\u40bc;\u6155;\u6159;\u615b\u01b3\u2034\0\u2036;\u6154;\u6156\u02b4\u203e\u2041\0\0\u2043\u803b\xbe\u40be;\u6157;\u615c5;\u6158\u01b6\u204c\0\u204e;\u615a;\u615d8;\u615el;\u6044wn;\u6322cr;\uc000\ud835\udcbb\u0880Eabcdefgijlnorstv\u2082\u2089\u209f\u20a5\u20b0\u20b4\u20f0\u20f5\u20fa\u20ff\u2103\u2112\u2138\u0317\u213e\u2152\u219e\u0100;l\u064d\u2087;\u6a8c\u0180cmp\u2090\u2095\u209dute;\u41f5ma\u0100;d\u209c\u1cda\u43b3;\u6a86reve;\u411f\u0100iy\u20aa\u20aerc;\u411d;\u4433ot;\u4121\u0200;lqs\u063e\u0642\u20bd\u20c9\u0180;qs\u063e\u064c\u20c4lan\xf4\u0665\u0200;cdl\u0665\u20d2\u20d5\u20e5c;\u6aa9ot\u0100;o\u20dc\u20dd\u6a80\u0100;l\u20e2\u20e3\u6a82;\u6a84\u0100;e\u20ea\u20ed\uc000\u22db\ufe00s;\u6a94r;\uc000\ud835\udd24\u0100;g\u0673\u061bmel;\u6137cy;\u4453\u0200;Eaj\u065a\u210c\u210e\u2110;\u6a92;\u6aa5;\u6aa4\u0200Eaes\u211b\u211d\u2129\u2134;\u6269p\u0100;p\u2123\u2124\u6a8arox\xbb\u2124\u0100;q\u212e\u212f\u6a88\u0100;q\u212e\u211bim;\u62e7pf;\uc000\ud835\udd58\u0100ci\u2143\u2146r;\u610am\u0180;el\u066b\u214e\u2150;\u6a8e;\u6a90\u8300>;cdlqr\u05ee\u2160\u216a\u216e\u2173\u2179\u0100ci\u2165\u2167;\u6aa7r;\u6a7aot;\u62d7Par;\u6995uest;\u6a7c\u0280adels\u2184\u216a\u2190\u0656\u219b\u01f0\u2189\0\u218epro\xf8\u209er;\u6978q\u0100lq\u063f\u2196les\xf3\u2088i\xed\u066b\u0100en\u21a3\u21adrtneqq;\uc000\u2269\ufe00\xc5\u21aa\u0500Aabcefkosy\u21c4\u21c7\u21f1\u21f5\u21fa\u2218\u221d\u222f\u2268\u227dr\xf2\u03a0\u0200ilmr\u21d0\u21d4\u21d7\u21dbrs\xf0\u1484f\xbb\u2024il\xf4\u06a9\u0100dr\u21e0\u21e4cy;\u444a\u0180;cw\u08f4\u21eb\u21efir;\u6948;\u61adar;\u610firc;\u4125\u0180alr\u2201\u220e\u2213rts\u0100;u\u2209\u220a\u6665it\xbb\u220alip;\u6026con;\u62b9r;\uc000\ud835\udd25s\u0100ew\u2223\u2229arow;\u6925arow;\u6926\u0280amopr\u223a\u223e\u2243\u225e\u2263rr;\u61fftht;\u623bk\u0100lr\u2249\u2253eftarrow;\u61a9ightarrow;\u61aaf;\uc000\ud835\udd59bar;\u6015\u0180clt\u226f\u2274\u2278r;\uc000\ud835\udcbdas\xe8\u21f4rok;\u4127\u0100bp\u2282\u2287ull;\u6043hen\xbb\u1c5b\u0ae1\u22a3\0\u22aa\0\u22b8\u22c5\u22ce\0\u22d5\u22f3\0\0\u22f8\u2322\u2367\u2362\u237f\0\u2386\u23aa\u23b4cute\u803b\xed\u40ed\u0180;iy\u0771\u22b0\u22b5rc\u803b\xee\u40ee;\u4438\u0100cx\u22bc\u22bfy;\u4435cl\u803b\xa1\u40a1\u0100fr\u039f\u22c9;\uc000\ud835\udd26rave\u803b\xec\u40ec\u0200;ino\u073e\u22dd\u22e9\u22ee\u0100in\u22e2\u22e6nt;\u6a0ct;\u622dfin;\u69dcta;\u6129lig;\u4133\u0180aop\u22fe\u231a\u231d\u0180cgt\u2305\u2308\u2317r;\u412b\u0180elp\u071f\u230f\u2313in\xe5\u078ear\xf4\u0720h;\u4131f;\u62b7ed;\u41b5\u0280;cfot\u04f4\u232c\u2331\u233d\u2341are;\u6105in\u0100;t\u2338\u2339\u621eie;\u69dddo\xf4\u2319\u0280;celp\u0757\u234c\u2350\u235b\u2361al;\u62ba\u0100gr\u2355\u2359er\xf3\u1563\xe3\u234darhk;\u6a17rod;\u6a3c\u0200cgpt\u236f\u2372\u2376\u237by;\u4451on;\u412ff;\uc000\ud835\udd5aa;\u43b9uest\u803b\xbf\u40bf\u0100ci\u238a\u238fr;\uc000\ud835\udcben\u0280;Edsv\u04f4\u239b\u239d\u23a1\u04f3;\u62f9ot;\u62f5\u0100;v\u23a6\u23a7\u62f4;\u62f3\u0100;i\u0777\u23aelde;\u4129\u01eb\u23b8\0\u23bccy;\u4456l\u803b\xef\u40ef\u0300cfmosu\u23cc\u23d7\u23dc\u23e1\u23e7\u23f5\u0100iy\u23d1\u23d5rc;\u4135;\u4439r;\uc000\ud835\udd27ath;\u4237pf;\uc000\ud835\udd5b\u01e3\u23ec\0\u23f1r;\uc000\ud835\udcbfrcy;\u4458kcy;\u4454\u0400acfghjos\u240b\u2416\u2422\u2427\u242d\u2431\u2435\u243bppa\u0100;v\u2413\u2414\u43ba;\u43f0\u0100ey\u241b\u2420dil;\u4137;\u443ar;\uc000\ud835\udd28reen;\u4138cy;\u4445cy;\u445cpf;\uc000\ud835\udd5ccr;\uc000\ud835\udcc0\u0b80ABEHabcdefghjlmnoprstuv\u2470\u2481\u2486\u248d\u2491\u250e\u253d\u255a\u2580\u264e\u265e\u2665\u2679\u267d\u269a\u26b2\u26d8\u275d\u2768\u278b\u27c0\u2801\u2812\u0180art\u2477\u247a\u247cr\xf2\u09c6\xf2\u0395ail;\u691barr;\u690e\u0100;g\u0994\u248b;\u6a8bar;\u6962\u0963\u24a5\0\u24aa\0\u24b1\0\0\0\0\0\u24b5\u24ba\0\u24c6\u24c8\u24cd\0\u24f9ute;\u413amptyv;\u69b4ra\xee\u084cbda;\u43bbg\u0180;dl\u088e\u24c1\u24c3;\u6991\xe5\u088e;\u6a85uo\u803b\xab\u40abr\u0400;bfhlpst\u0899\u24de\u24e6\u24e9\u24eb\u24ee\u24f1\u24f5\u0100;f\u089d\u24e3s;\u691fs;\u691d\xeb\u2252p;\u61abl;\u6939im;\u6973l;\u61a2\u0180;ae\u24ff\u2500\u2504\u6aabil;\u6919\u0100;s\u2509\u250a\u6aad;\uc000\u2aad\ufe00\u0180abr\u2515\u2519\u251drr;\u690crk;\u6772\u0100ak\u2522\u252cc\u0100ek\u2528\u252a;\u407b;\u405b\u0100es\u2531\u2533;\u698bl\u0100du\u2539\u253b;\u698f;\u698d\u0200aeuy\u2546\u254b\u2556\u2558ron;\u413e\u0100di\u2550\u2554il;\u413c\xec\u08b0\xe2\u2529;\u443b\u0200cqrs\u2563\u2566\u256d\u257da;\u6936uo\u0100;r\u0e19\u1746\u0100du\u2572\u2577har;\u6967shar;\u694bh;\u61b2\u0280;fgqs\u258b\u258c\u0989\u25f3\u25ff\u6264t\u0280ahlrt\u2598\u25a4\u25b7\u25c2\u25e8rrow\u0100;t\u0899\u25a1a\xe9\u24f6arpoon\u0100du\u25af\u25b4own\xbb\u045ap\xbb\u0966eftarrows;\u61c7ight\u0180ahs\u25cd\u25d6\u25derrow\u0100;s\u08f4\u08a7arpoon\xf3\u0f98quigarro\xf7\u21f0hreetimes;\u62cb\u0180;qs\u258b\u0993\u25falan\xf4\u09ac\u0280;cdgs\u09ac\u260a\u260d\u261d\u2628c;\u6aa8ot\u0100;o\u2614\u2615\u6a7f\u0100;r\u261a\u261b\u6a81;\u6a83\u0100;e\u2622\u2625\uc000\u22da\ufe00s;\u6a93\u0280adegs\u2633\u2639\u263d\u2649\u264bppro\xf8\u24c6ot;\u62d6q\u0100gq\u2643\u2645\xf4\u0989gt\xf2\u248c\xf4\u099bi\xed\u09b2\u0180ilr\u2655\u08e1\u265asht;\u697c;\uc000\ud835\udd29\u0100;E\u099c\u2663;\u6a91\u0161\u2669\u2676r\u0100du\u25b2\u266e\u0100;l\u0965\u2673;\u696alk;\u6584cy;\u4459\u0280;acht\u0a48\u2688\u268b\u2691\u2696r\xf2\u25c1orne\xf2\u1d08ard;\u696bri;\u65fa\u0100io\u269f\u26a4dot;\u4140ust\u0100;a\u26ac\u26ad\u63b0che\xbb\u26ad\u0200Eaes\u26bb\u26bd\u26c9\u26d4;\u6268p\u0100;p\u26c3\u26c4\u6a89rox\xbb\u26c4\u0100;q\u26ce\u26cf\u6a87\u0100;q\u26ce\u26bbim;\u62e6\u0400abnoptwz\u26e9\u26f4\u26f7\u271a\u272f\u2741\u2747\u2750\u0100nr\u26ee\u26f1g;\u67ecr;\u61fdr\xeb\u08c1g\u0180lmr\u26ff\u270d\u2714eft\u0100ar\u09e6\u2707ight\xe1\u09f2apsto;\u67fcight\xe1\u09fdparrow\u0100lr\u2725\u2729ef\xf4\u24edight;\u61ac\u0180afl\u2736\u2739\u273dr;\u6985;\uc000\ud835\udd5dus;\u6a2dimes;\u6a34\u0161\u274b\u274fst;\u6217\xe1\u134e\u0180;ef\u2757\u2758\u1800\u65cange\xbb\u2758ar\u0100;l\u2764\u2765\u4028t;\u6993\u0280achmt\u2773\u2776\u277c\u2785\u2787r\xf2\u08a8orne\xf2\u1d8car\u0100;d\u0f98\u2783;\u696d;\u600eri;\u62bf\u0300achiqt\u2798\u279d\u0a40\u27a2\u27ae\u27bbquo;\u6039r;\uc000\ud835\udcc1m\u0180;eg\u09b2\u27aa\u27ac;\u6a8d;\u6a8f\u0100bu\u252a\u27b3o\u0100;r\u0e1f\u27b9;\u601arok;\u4142\u8400<;cdhilqr\u082b\u27d2\u2639\u27dc\u27e0\u27e5\u27ea\u27f0\u0100ci\u27d7\u27d9;\u6aa6r;\u6a79re\xe5\u25f2mes;\u62c9arr;\u6976uest;\u6a7b\u0100Pi\u27f5\u27f9ar;\u6996\u0180;ef\u2800\u092d\u181b\u65c3r\u0100du\u2807\u280dshar;\u694ahar;\u6966\u0100en\u2817\u2821rtneqq;\uc000\u2268\ufe00\xc5\u281e\u0700Dacdefhilnopsu\u2840\u2845\u2882\u288e\u2893\u28a0\u28a5\u28a8\u28da\u28e2\u28e4\u0a83\u28f3\u2902Dot;\u623a\u0200clpr\u284e\u2852\u2863\u287dr\u803b\xaf\u40af\u0100et\u2857\u2859;\u6642\u0100;e\u285e\u285f\u6720se\xbb\u285f\u0100;s\u103b\u2868to\u0200;dlu\u103b\u2873\u2877\u287bow\xee\u048cef\xf4\u090f\xf0\u13d1ker;\u65ae\u0100oy\u2887\u288cmma;\u6a29;\u443cash;\u6014asuredangle\xbb\u1626r;\uc000\ud835\udd2ao;\u6127\u0180cdn\u28af\u28b4\u28c9ro\u803b\xb5\u40b5\u0200;acd\u1464\u28bd\u28c0\u28c4s\xf4\u16a7ir;\u6af0ot\u80bb\xb7\u01b5us\u0180;bd\u28d2\u1903\u28d3\u6212\u0100;u\u1d3c\u28d8;\u6a2a\u0163\u28de\u28e1p;\u6adb\xf2\u2212\xf0\u0a81\u0100dp\u28e9\u28eeels;\u62a7f;\uc000\ud835\udd5e\u0100ct\u28f8\u28fdr;\uc000\ud835\udcc2pos\xbb\u159d\u0180;lm\u2909\u290a\u290d\u43bctimap;\u62b8\u0c00GLRVabcdefghijlmoprstuvw\u2942\u2953\u297e\u2989\u2998\u29da\u29e9\u2a15\u2a1a\u2a58\u2a5d\u2a83\u2a95\u2aa4\u2aa8\u2b04\u2b07\u2b44\u2b7f\u2bae\u2c34\u2c67\u2c7c\u2ce9\u0100gt\u2947\u294b;\uc000\u22d9\u0338\u0100;v\u2950\u0bcf\uc000\u226b\u20d2\u0180elt\u295a\u2972\u2976ft\u0100ar\u2961\u2967rrow;\u61cdightarrow;\u61ce;\uc000\u22d8\u0338\u0100;v\u297b\u0c47\uc000\u226a\u20d2ightarrow;\u61cf\u0100Dd\u298e\u2993ash;\u62afash;\u62ae\u0280bcnpt\u29a3\u29a7\u29ac\u29b1\u29ccla\xbb\u02deute;\u4144g;\uc000\u2220\u20d2\u0280;Eiop\u0d84\u29bc\u29c0\u29c5\u29c8;\uc000\u2a70\u0338d;\uc000\u224b\u0338s;\u4149ro\xf8\u0d84ur\u0100;a\u29d3\u29d4\u666el\u0100;s\u29d3\u0b38\u01f3\u29df\0\u29e3p\u80bb\xa0\u0b37mp\u0100;e\u0bf9\u0c00\u0280aeouy\u29f4\u29fe\u2a03\u2a10\u2a13\u01f0\u29f9\0\u29fb;\u6a43on;\u4148dil;\u4146ng\u0100;d\u0d7e\u2a0aot;\uc000\u2a6d\u0338p;\u6a42;\u443dash;\u6013\u0380;Aadqsx\u0b92\u2a29\u2a2d\u2a3b\u2a41\u2a45\u2a50rr;\u61d7r\u0100hr\u2a33\u2a36k;\u6924\u0100;o\u13f2\u13f0ot;\uc000\u2250\u0338ui\xf6\u0b63\u0100ei\u2a4a\u2a4ear;\u6928\xed\u0b98ist\u0100;s\u0ba0\u0b9fr;\uc000\ud835\udd2b\u0200Eest\u0bc5\u2a66\u2a79\u2a7c\u0180;qs\u0bbc\u2a6d\u0be1\u0180;qs\u0bbc\u0bc5\u2a74lan\xf4\u0be2i\xed\u0bea\u0100;r\u0bb6\u2a81\xbb\u0bb7\u0180Aap\u2a8a\u2a8d\u2a91r\xf2\u2971rr;\u61aear;\u6af2\u0180;sv\u0f8d\u2a9c\u0f8c\u0100;d\u2aa1\u2aa2\u62fc;\u62facy;\u445a\u0380AEadest\u2ab7\u2aba\u2abe\u2ac2\u2ac5\u2af6\u2af9r\xf2\u2966;\uc000\u2266\u0338rr;\u619ar;\u6025\u0200;fqs\u0c3b\u2ace\u2ae3\u2aeft\u0100ar\u2ad4\u2ad9rro\xf7\u2ac1ightarro\xf7\u2a90\u0180;qs\u0c3b\u2aba\u2aealan\xf4\u0c55\u0100;s\u0c55\u2af4\xbb\u0c36i\xed\u0c5d\u0100;r\u0c35\u2afei\u0100;e\u0c1a\u0c25i\xe4\u0d90\u0100pt\u2b0c\u2b11f;\uc000\ud835\udd5f\u8180\xac;in\u2b19\u2b1a\u2b36\u40acn\u0200;Edv\u0b89\u2b24\u2b28\u2b2e;\uc000\u22f9\u0338ot;\uc000\u22f5\u0338\u01e1\u0b89\u2b33\u2b35;\u62f7;\u62f6i\u0100;v\u0cb8\u2b3c\u01e1\u0cb8\u2b41\u2b43;\u62fe;\u62fd\u0180aor\u2b4b\u2b63\u2b69r\u0200;ast\u0b7b\u2b55\u2b5a\u2b5flle\xec\u0b7bl;\uc000\u2afd\u20e5;\uc000\u2202\u0338lint;\u6a14\u0180;ce\u0c92\u2b70\u2b73u\xe5\u0ca5\u0100;c\u0c98\u2b78\u0100;e\u0c92\u2b7d\xf1\u0c98\u0200Aait\u2b88\u2b8b\u2b9d\u2ba7r\xf2\u2988rr\u0180;cw\u2b94\u2b95\u2b99\u619b;\uc000\u2933\u0338;\uc000\u219d\u0338ghtarrow\xbb\u2b95ri\u0100;e\u0ccb\u0cd6\u0380chimpqu\u2bbd\u2bcd\u2bd9\u2b04\u0b78\u2be4\u2bef\u0200;cer\u0d32\u2bc6\u0d37\u2bc9u\xe5\u0d45;\uc000\ud835\udcc3ort\u026d\u2b05\0\0\u2bd6ar\xe1\u2b56m\u0100;e\u0d6e\u2bdf\u0100;q\u0d74\u0d73su\u0100bp\u2beb\u2bed\xe5\u0cf8\xe5\u0d0b\u0180bcp\u2bf6\u2c11\u2c19\u0200;Ees\u2bff\u2c00\u0d22\u2c04\u6284;\uc000\u2ac5\u0338et\u0100;e\u0d1b\u2c0bq\u0100;q\u0d23\u2c00c\u0100;e\u0d32\u2c17\xf1\u0d38\u0200;Ees\u2c22\u2c23\u0d5f\u2c27\u6285;\uc000\u2ac6\u0338et\u0100;e\u0d58\u2c2eq\u0100;q\u0d60\u2c23\u0200gilr\u2c3d\u2c3f\u2c45\u2c47\xec\u0bd7lde\u803b\xf1\u40f1\xe7\u0c43iangle\u0100lr\u2c52\u2c5ceft\u0100;e\u0c1a\u2c5a\xf1\u0c26ight\u0100;e\u0ccb\u2c65\xf1\u0cd7\u0100;m\u2c6c\u2c6d\u43bd\u0180;es\u2c74\u2c75\u2c79\u4023ro;\u6116p;\u6007\u0480DHadgilrs\u2c8f\u2c94\u2c99\u2c9e\u2ca3\u2cb0\u2cb6\u2cd3\u2ce3ash;\u62adarr;\u6904p;\uc000\u224d\u20d2ash;\u62ac\u0100et\u2ca8\u2cac;\uc000\u2265\u20d2;\uc000>\u20d2nfin;\u69de\u0180Aet\u2cbd\u2cc1\u2cc5rr;\u6902;\uc000\u2264\u20d2\u0100;r\u2cca\u2ccd\uc000<\u20d2ie;\uc000\u22b4\u20d2\u0100At\u2cd8\u2cdcrr;\u6903rie;\uc000\u22b5\u20d2im;\uc000\u223c\u20d2\u0180Aan\u2cf0\u2cf4\u2d02rr;\u61d6r\u0100hr\u2cfa\u2cfdk;\u6923\u0100;o\u13e7\u13e5ear;\u6927\u1253\u1a95\0\0\0\0\0\0\0\0\0\0\0\0\0\u2d2d\0\u2d38\u2d48\u2d60\u2d65\u2d72\u2d84\u1b07\0\0\u2d8d\u2dab\0\u2dc8\u2dce\0\u2ddc\u2e19\u2e2b\u2e3e\u2e43\u0100cs\u2d31\u1a97ute\u803b\xf3\u40f3\u0100iy\u2d3c\u2d45r\u0100;c\u1a9e\u2d42\u803b\xf4\u40f4;\u443e\u0280abios\u1aa0\u2d52\u2d57\u01c8\u2d5alac;\u4151v;\u6a38old;\u69bclig;\u4153\u0100cr\u2d69\u2d6dir;\u69bf;\uc000\ud835\udd2c\u036f\u2d79\0\0\u2d7c\0\u2d82n;\u42dbave\u803b\xf2\u40f2;\u69c1\u0100bm\u2d88\u0df4ar;\u69b5\u0200acit\u2d95\u2d98\u2da5\u2da8r\xf2\u1a80\u0100ir\u2d9d\u2da0r;\u69beoss;\u69bbn\xe5\u0e52;\u69c0\u0180aei\u2db1\u2db5\u2db9cr;\u414dga;\u43c9\u0180cdn\u2dc0\u2dc5\u01cdron;\u43bf;\u69b6pf;\uc000\ud835\udd60\u0180ael\u2dd4\u2dd7\u01d2r;\u69b7rp;\u69b9\u0380;adiosv\u2dea\u2deb\u2dee\u2e08\u2e0d\u2e10\u2e16\u6228r\xf2\u1a86\u0200;efm\u2df7\u2df8\u2e02\u2e05\u6a5dr\u0100;o\u2dfe\u2dff\u6134f\xbb\u2dff\u803b\xaa\u40aa\u803b\xba\u40bagof;\u62b6r;\u6a56lope;\u6a57;\u6a5b\u0180clo\u2e1f\u2e21\u2e27\xf2\u2e01ash\u803b\xf8\u40f8l;\u6298i\u016c\u2e2f\u2e34de\u803b\xf5\u40f5es\u0100;a\u01db\u2e3as;\u6a36ml\u803b\xf6\u40f6bar;\u633d\u0ae1\u2e5e\0\u2e7d\0\u2e80\u2e9d\0\u2ea2\u2eb9\0\0\u2ecb\u0e9c\0\u2f13\0\0\u2f2b\u2fbc\0\u2fc8r\u0200;ast\u0403\u2e67\u2e72\u0e85\u8100\xb6;l\u2e6d\u2e6e\u40b6le\xec\u0403\u0269\u2e78\0\0\u2e7bm;\u6af3;\u6afdy;\u443fr\u0280cimpt\u2e8b\u2e8f\u2e93\u1865\u2e97nt;\u4025od;\u402eil;\u6030enk;\u6031r;\uc000\ud835\udd2d\u0180imo\u2ea8\u2eb0\u2eb4\u0100;v\u2ead\u2eae\u43c6;\u43d5ma\xf4\u0a76ne;\u660e\u0180;tv\u2ebf\u2ec0\u2ec8\u43c0chfork\xbb\u1ffd;\u43d6\u0100au\u2ecf\u2edfn\u0100ck\u2ed5\u2eddk\u0100;h\u21f4\u2edb;\u610e\xf6\u21f4s\u0480;abcdemst\u2ef3\u2ef4\u1908\u2ef9\u2efd\u2f04\u2f06\u2f0a\u2f0e\u402bcir;\u6a23ir;\u6a22\u0100ou\u1d40\u2f02;\u6a25;\u6a72n\u80bb\xb1\u0e9dim;\u6a26wo;\u6a27\u0180ipu\u2f19\u2f20\u2f25ntint;\u6a15f;\uc000\ud835\udd61nd\u803b\xa3\u40a3\u0500;Eaceinosu\u0ec8\u2f3f\u2f41\u2f44\u2f47\u2f81\u2f89\u2f92\u2f7e\u2fb6;\u6ab3p;\u6ab7u\xe5\u0ed9\u0100;c\u0ece\u2f4c\u0300;acens\u0ec8\u2f59\u2f5f\u2f66\u2f68\u2f7eppro\xf8\u2f43urlye\xf1\u0ed9\xf1\u0ece\u0180aes\u2f6f\u2f76\u2f7approx;\u6ab9qq;\u6ab5im;\u62e8i\xed\u0edfme\u0100;s\u2f88\u0eae\u6032\u0180Eas\u2f78\u2f90\u2f7a\xf0\u2f75\u0180dfp\u0eec\u2f99\u2faf\u0180als\u2fa0\u2fa5\u2faalar;\u632eine;\u6312urf;\u6313\u0100;t\u0efb\u2fb4\xef\u0efbrel;\u62b0\u0100ci\u2fc0\u2fc5r;\uc000\ud835\udcc5;\u43c8ncsp;\u6008\u0300fiopsu\u2fda\u22e2\u2fdf\u2fe5\u2feb\u2ff1r;\uc000\ud835\udd2epf;\uc000\ud835\udd62rime;\u6057cr;\uc000\ud835\udcc6\u0180aeo\u2ff8\u3009\u3013t\u0100ei\u2ffe\u3005rnion\xf3\u06b0nt;\u6a16st\u0100;e\u3010\u3011\u403f\xf1\u1f19\xf4\u0f14\u0a80ABHabcdefhilmnoprstux\u3040\u3051\u3055\u3059\u30e0\u310e\u312b\u3147\u3162\u3172\u318e\u3206\u3215\u3224\u3229\u3258\u326e\u3272\u3290\u32b0\u32b7\u0180art\u3047\u304a\u304cr\xf2\u10b3\xf2\u03ddail;\u691car\xf2\u1c65ar;\u6964\u0380cdenqrt\u3068\u3075\u3078\u307f\u308f\u3094\u30cc\u0100eu\u306d\u3071;\uc000\u223d\u0331te;\u4155i\xe3\u116emptyv;\u69b3g\u0200;del\u0fd1\u3089\u308b\u308d;\u6992;\u69a5\xe5\u0fd1uo\u803b\xbb\u40bbr\u0580;abcfhlpstw\u0fdc\u30ac\u30af\u30b7\u30b9\u30bc\u30be\u30c0\u30c3\u30c7\u30cap;\u6975\u0100;f\u0fe0\u30b4s;\u6920;\u6933s;\u691e\xeb\u225d\xf0\u272el;\u6945im;\u6974l;\u61a3;\u619d\u0100ai\u30d1\u30d5il;\u691ao\u0100;n\u30db\u30dc\u6236al\xf3\u0f1e\u0180abr\u30e7\u30ea\u30eer\xf2\u17e5rk;\u6773\u0100ak\u30f3\u30fdc\u0100ek\u30f9\u30fb;\u407d;\u405d\u0100es\u3102\u3104;\u698cl\u0100du\u310a\u310c;\u698e;\u6990\u0200aeuy\u3117\u311c\u3127\u3129ron;\u4159\u0100di\u3121\u3125il;\u4157\xec\u0ff2\xe2\u30fa;\u4440\u0200clqs\u3134\u3137\u313d\u3144a;\u6937dhar;\u6969uo\u0100;r\u020e\u020dh;\u61b3\u0180acg\u314e\u315f\u0f44l\u0200;ips\u0f78\u3158\u315b\u109cn\xe5\u10bbar\xf4\u0fa9t;\u65ad\u0180ilr\u3169\u1023\u316esht;\u697d;\uc000\ud835\udd2f\u0100ao\u3177\u3186r\u0100du\u317d\u317f\xbb\u047b\u0100;l\u1091\u3184;\u696c\u0100;v\u318b\u318c\u43c1;\u43f1\u0180gns\u3195\u31f9\u31fcht\u0300ahlrst\u31a4\u31b0\u31c2\u31d8\u31e4\u31eerrow\u0100;t\u0fdc\u31ada\xe9\u30c8arpoon\u0100du\u31bb\u31bfow\xee\u317ep\xbb\u1092eft\u0100ah\u31ca\u31d0rrow\xf3\u0feaarpoon\xf3\u0551ightarrows;\u61c9quigarro\xf7\u30cbhreetimes;\u62ccg;\u42daingdotse\xf1\u1f32\u0180ahm\u320d\u3210\u3213r\xf2\u0feaa\xf2\u0551;\u600foust\u0100;a\u321e\u321f\u63b1che\xbb\u321fmid;\u6aee\u0200abpt\u3232\u323d\u3240\u3252\u0100nr\u3237\u323ag;\u67edr;\u61fer\xeb\u1003\u0180afl\u3247\u324a\u324er;\u6986;\uc000\ud835\udd63us;\u6a2eimes;\u6a35\u0100ap\u325d\u3267r\u0100;g\u3263\u3264\u4029t;\u6994olint;\u6a12ar\xf2\u31e3\u0200achq\u327b\u3280\u10bc\u3285quo;\u603ar;\uc000\ud835\udcc7\u0100bu\u30fb\u328ao\u0100;r\u0214\u0213\u0180hir\u3297\u329b\u32a0re\xe5\u31f8mes;\u62cai\u0200;efl\u32aa\u1059\u1821\u32ab\u65b9tri;\u69celuhar;\u6968;\u611e\u0d61\u32d5\u32db\u32df\u332c\u3338\u3371\0\u337a\u33a4\0\0\u33ec\u33f0\0\u3428\u3448\u345a\u34ad\u34b1\u34ca\u34f1\0\u3616\0\0\u3633cute;\u415bqu\xef\u27ba\u0500;Eaceinpsy\u11ed\u32f3\u32f5\u32ff\u3302\u330b\u330f\u331f\u3326\u3329;\u6ab4\u01f0\u32fa\0\u32fc;\u6ab8on;\u4161u\xe5\u11fe\u0100;d\u11f3\u3307il;\u415frc;\u415d\u0180Eas\u3316\u3318\u331b;\u6ab6p;\u6abaim;\u62e9olint;\u6a13i\xed\u1204;\u4441ot\u0180;be\u3334\u1d47\u3335\u62c5;\u6a66\u0380Aacmstx\u3346\u334a\u3357\u335b\u335e\u3363\u336drr;\u61d8r\u0100hr\u3350\u3352\xeb\u2228\u0100;o\u0a36\u0a34t\u803b\xa7\u40a7i;\u403bwar;\u6929m\u0100in\u3369\xf0nu\xf3\xf1t;\u6736r\u0100;o\u3376\u2055\uc000\ud835\udd30\u0200acoy\u3382\u3386\u3391\u33a0rp;\u666f\u0100hy\u338b\u338fcy;\u4449;\u4448rt\u026d\u3399\0\0\u339ci\xe4\u1464ara\xec\u2e6f\u803b\xad\u40ad\u0100gm\u33a8\u33b4ma\u0180;fv\u33b1\u33b2\u33b2\u43c3;\u43c2\u0400;deglnpr\u12ab\u33c5\u33c9\u33ce\u33d6\u33de\u33e1\u33e6ot;\u6a6a\u0100;q\u12b1\u12b0\u0100;E\u33d3\u33d4\u6a9e;\u6aa0\u0100;E\u33db\u33dc\u6a9d;\u6a9fe;\u6246lus;\u6a24arr;\u6972ar\xf2\u113d\u0200aeit\u33f8\u3408\u340f\u3417\u0100ls\u33fd\u3404lsetm\xe9\u336ahp;\u6a33parsl;\u69e4\u0100dl\u1463\u3414e;\u6323\u0100;e\u341c\u341d\u6aaa\u0100;s\u3422\u3423\u6aac;\uc000\u2aac\ufe00\u0180flp\u342e\u3433\u3442tcy;\u444c\u0100;b\u3438\u3439\u402f\u0100;a\u343e\u343f\u69c4r;\u633ff;\uc000\ud835\udd64a\u0100dr\u344d\u0402es\u0100;u\u3454\u3455\u6660it\xbb\u3455\u0180csu\u3460\u3479\u349f\u0100au\u3465\u346fp\u0100;s\u1188\u346b;\uc000\u2293\ufe00p\u0100;s\u11b4\u3475;\uc000\u2294\ufe00u\u0100bp\u347f\u348f\u0180;es\u1197\u119c\u3486et\u0100;e\u1197\u348d\xf1\u119d\u0180;es\u11a8\u11ad\u3496et\u0100;e\u11a8\u349d\xf1\u11ae\u0180;af\u117b\u34a6\u05b0r\u0165\u34ab\u05b1\xbb\u117car\xf2\u1148\u0200cemt\u34b9\u34be\u34c2\u34c5r;\uc000\ud835\udcc8tm\xee\xf1i\xec\u3415ar\xe6\u11be\u0100ar\u34ce\u34d5r\u0100;f\u34d4\u17bf\u6606\u0100an\u34da\u34edight\u0100ep\u34e3\u34eapsilo\xee\u1ee0h\xe9\u2eafs\xbb\u2852\u0280bcmnp\u34fb\u355e\u1209\u358b\u358e\u0480;Edemnprs\u350e\u350f\u3511\u3515\u351e\u3523\u352c\u3531\u3536\u6282;\u6ac5ot;\u6abd\u0100;d\u11da\u351aot;\u6ac3ult;\u6ac1\u0100Ee\u3528\u352a;\u6acb;\u628alus;\u6abfarr;\u6979\u0180eiu\u353d\u3552\u3555t\u0180;en\u350e\u3545\u354bq\u0100;q\u11da\u350feq\u0100;q\u352b\u3528m;\u6ac7\u0100bp\u355a\u355c;\u6ad5;\u6ad3c\u0300;acens\u11ed\u356c\u3572\u3579\u357b\u3326ppro\xf8\u32faurlye\xf1\u11fe\xf1\u11f3\u0180aes\u3582\u3588\u331bppro\xf8\u331aq\xf1\u3317g;\u666a\u0680123;Edehlmnps\u35a9\u35ac\u35af\u121c\u35b2\u35b4\u35c0\u35c9\u35d5\u35da\u35df\u35e8\u35ed\u803b\xb9\u40b9\u803b\xb2\u40b2\u803b\xb3\u40b3;\u6ac6\u0100os\u35b9\u35bct;\u6abeub;\u6ad8\u0100;d\u1222\u35c5ot;\u6ac4s\u0100ou\u35cf\u35d2l;\u67c9b;\u6ad7arr;\u697bult;\u6ac2\u0100Ee\u35e4\u35e6;\u6acc;\u628blus;\u6ac0\u0180eiu\u35f4\u3609\u360ct\u0180;en\u121c\u35fc\u3602q\u0100;q\u1222\u35b2eq\u0100;q\u35e7\u35e4m;\u6ac8\u0100bp\u3611\u3613;\u6ad4;\u6ad6\u0180Aan\u361c\u3620\u362drr;\u61d9r\u0100hr\u3626\u3628\xeb\u222e\u0100;o\u0a2b\u0a29war;\u692alig\u803b\xdf\u40df\u0be1\u3651\u365d\u3660\u12ce\u3673\u3679\0\u367e\u36c2\0\0\0\0\0\u36db\u3703\0\u3709\u376c\0\0\0\u3787\u0272\u3656\0\0\u365bget;\u6316;\u43c4r\xeb\u0e5f\u0180aey\u3666\u366b\u3670ron;\u4165dil;\u4163;\u4442lrec;\u6315r;\uc000\ud835\udd31\u0200eiko\u3686\u369d\u36b5\u36bc\u01f2\u368b\0\u3691e\u01004f\u1284\u1281a\u0180;sv\u3698\u3699\u369b\u43b8ym;\u43d1\u0100cn\u36a2\u36b2k\u0100as\u36a8\u36aeppro\xf8\u12c1im\xbb\u12acs\xf0\u129e\u0100as\u36ba\u36ae\xf0\u12c1rn\u803b\xfe\u40fe\u01ec\u031f\u36c6\u22e7es\u8180\xd7;bd\u36cf\u36d0\u36d8\u40d7\u0100;a\u190f\u36d5r;\u6a31;\u6a30\u0180eps\u36e1\u36e3\u3700\xe1\u2a4d\u0200;bcf\u0486\u36ec\u36f0\u36f4ot;\u6336ir;\u6af1\u0100;o\u36f9\u36fc\uc000\ud835\udd65rk;\u6ada\xe1\u3362rime;\u6034\u0180aip\u370f\u3712\u3764d\xe5\u1248\u0380adempst\u3721\u374d\u3740\u3751\u3757\u375c\u375fngle\u0280;dlqr\u3730\u3731\u3736\u3740\u3742\u65b5own\xbb\u1dbbeft\u0100;e\u2800\u373e\xf1\u092e;\u625cight\u0100;e\u32aa\u374b\xf1\u105aot;\u65ecinus;\u6a3alus;\u6a39b;\u69cdime;\u6a3bezium;\u63e2\u0180cht\u3772\u377d\u3781\u0100ry\u3777\u377b;\uc000\ud835\udcc9;\u4446cy;\u445brok;\u4167\u0100io\u378b\u378ex\xf4\u1777head\u0100lr\u3797\u37a0eftarro\xf7\u084fightarrow\xbb\u0f5d\u0900AHabcdfghlmoprstuw\u37d0\u37d3\u37d7\u37e4\u37f0\u37fc\u380e\u381c\u3823\u3834\u3851\u385d\u386b\u38a9\u38cc\u38d2\u38ea\u38f6r\xf2\u03edar;\u6963\u0100cr\u37dc\u37e2ute\u803b\xfa\u40fa\xf2\u1150r\u01e3\u37ea\0\u37edy;\u445eve;\u416d\u0100iy\u37f5\u37farc\u803b\xfb\u40fb;\u4443\u0180abh\u3803\u3806\u380br\xf2\u13adlac;\u4171a\xf2\u13c3\u0100ir\u3813\u3818sht;\u697e;\uc000\ud835\udd32rave\u803b\xf9\u40f9\u0161\u3827\u3831r\u0100lr\u382c\u382e\xbb\u0957\xbb\u1083lk;\u6580\u0100ct\u3839\u384d\u026f\u383f\0\0\u384arn\u0100;e\u3845\u3846\u631cr\xbb\u3846op;\u630fri;\u65f8\u0100al\u3856\u385acr;\u416b\u80bb\xa8\u0349\u0100gp\u3862\u3866on;\u4173f;\uc000\ud835\udd66\u0300adhlsu\u114b\u3878\u387d\u1372\u3891\u38a0own\xe1\u13b3arpoon\u0100lr\u3888\u388cef\xf4\u382digh\xf4\u382fi\u0180;hl\u3899\u389a\u389c\u43c5\xbb\u13faon\xbb\u389aparrows;\u61c8\u0180cit\u38b0\u38c4\u38c8\u026f\u38b6\0\0\u38c1rn\u0100;e\u38bc\u38bd\u631dr\xbb\u38bdop;\u630eng;\u416fri;\u65f9cr;\uc000\ud835\udcca\u0180dir\u38d9\u38dd\u38e2ot;\u62f0lde;\u4169i\u0100;f\u3730\u38e8\xbb\u1813\u0100am\u38ef\u38f2r\xf2\u38a8l\u803b\xfc\u40fcangle;\u69a7\u0780ABDacdeflnoprsz\u391c\u391f\u3929\u392d\u39b5\u39b8\u39bd\u39df\u39e4\u39e8\u39f3\u39f9\u39fd\u3a01\u3a20r\xf2\u03f7ar\u0100;v\u3926\u3927\u6ae8;\u6ae9as\xe8\u03e1\u0100nr\u3932\u3937grt;\u699c\u0380eknprst\u34e3\u3946\u394b\u3952\u395d\u3964\u3996app\xe1\u2415othin\xe7\u1e96\u0180hir\u34eb\u2ec8\u3959op\xf4\u2fb5\u0100;h\u13b7\u3962\xef\u318d\u0100iu\u3969\u396dgm\xe1\u33b3\u0100bp\u3972\u3984setneq\u0100;q\u397d\u3980\uc000\u228a\ufe00;\uc000\u2acb\ufe00setneq\u0100;q\u398f\u3992\uc000\u228b\ufe00;\uc000\u2acc\ufe00\u0100hr\u399b\u399fet\xe1\u369ciangle\u0100lr\u39aa\u39afeft\xbb\u0925ight\xbb\u1051y;\u4432ash\xbb\u1036\u0180elr\u39c4\u39d2\u39d7\u0180;be\u2dea\u39cb\u39cfar;\u62bbq;\u625alip;\u62ee\u0100bt\u39dc\u1468a\xf2\u1469r;\uc000\ud835\udd33tr\xe9\u39aesu\u0100bp\u39ef\u39f1\xbb\u0d1c\xbb\u0d59pf;\uc000\ud835\udd67ro\xf0\u0efbtr\xe9\u39b4\u0100cu\u3a06\u3a0br;\uc000\ud835\udccb\u0100bp\u3a10\u3a18n\u0100Ee\u3980\u3a16\xbb\u397en\u0100Ee\u3992\u3a1e\xbb\u3990igzag;\u699a\u0380cefoprs\u3a36\u3a3b\u3a56\u3a5b\u3a54\u3a61\u3a6airc;\u4175\u0100di\u3a40\u3a51\u0100bg\u3a45\u3a49ar;\u6a5fe\u0100;q\u15fa\u3a4f;\u6259erp;\u6118r;\uc000\ud835\udd34pf;\uc000\ud835\udd68\u0100;e\u1479\u3a66at\xe8\u1479cr;\uc000\ud835\udccc\u0ae3\u178e\u3a87\0\u3a8b\0\u3a90\u3a9b\0\0\u3a9d\u3aa8\u3aab\u3aaf\0\0\u3ac3\u3ace\0\u3ad8\u17dc\u17dftr\xe9\u17d1r;\uc000\ud835\udd35\u0100Aa\u3a94\u3a97r\xf2\u03c3r\xf2\u09f6;\u43be\u0100Aa\u3aa1\u3aa4r\xf2\u03b8r\xf2\u09eba\xf0\u2713is;\u62fb\u0180dpt\u17a4\u3ab5\u3abe\u0100fl\u3aba\u17a9;\uc000\ud835\udd69im\xe5\u17b2\u0100Aa\u3ac7\u3acar\xf2\u03cer\xf2\u0a01\u0100cq\u3ad2\u17b8r;\uc000\ud835\udccd\u0100pt\u17d6\u3adcr\xe9\u17d4\u0400acefiosu\u3af0\u3afd\u3b08\u3b0c\u3b11\u3b15\u3b1b\u3b21c\u0100uy\u3af6\u3afbte\u803b\xfd\u40fd;\u444f\u0100iy\u3b02\u3b06rc;\u4177;\u444bn\u803b\xa5\u40a5r;\uc000\ud835\udd36cy;\u4457pf;\uc000\ud835\udd6acr;\uc000\ud835\udcce\u0100cm\u3b26\u3b29y;\u444el\u803b\xff\u40ff\u0500acdefhiosw\u3b42\u3b48\u3b54\u3b58\u3b64\u3b69\u3b6d\u3b74\u3b7a\u3b80cute;\u417a\u0100ay\u3b4d\u3b52ron;\u417e;\u4437ot;\u417c\u0100et\u3b5d\u3b61tr\xe6\u155fa;\u43b6r;\uc000\ud835\udd37cy;\u4436grarr;\u61ddpf;\uc000\ud835\udd6bcr;\uc000\ud835\udccf\u0100jn\u3b85\u3b87;\u600dj;\u600c"
    .split("")
    .map((c) => c.charCodeAt(0)),
);

// Generated using scripts/write-decode-map.ts
const xmlDecodeTree = new Uint16Array(
  // prettier-ignore
  "\u0200aglq\t\x15\x18\x1b\u026d\x0f\0\0\x12p;\u4026os;\u4027t;\u403et;\u403cuot;\u4022"
    .split("")
    .map((c) => c.charCodeAt(0)),
);

// Adapted from https://github.com/mathiasbynens/he/blob/36afe179392226cf1b6ccdb16ebbb7a5a844d93a/src/he.js#L106-L134
var _a;
const decodeMap = new Map([
  [0, 65533],
  // C1 Unicode control character reference replacements
  [128, 8364],
  [130, 8218],
  [131, 402],
  [132, 8222],
  [133, 8230],
  [134, 8224],
  [135, 8225],
  [136, 710],
  [137, 8240],
  [138, 352],
  [139, 8249],
  [140, 338],
  [142, 381],
  [145, 8216],
  [146, 8217],
  [147, 8220],
  [148, 8221],
  [149, 8226],
  [150, 8211],
  [151, 8212],
  [152, 732],
  [153, 8482],
  [154, 353],
  [155, 8250],
  [156, 339],
  [158, 382],
  [159, 376],
]);
/**
 * Polyfill for `String.fromCodePoint`. It is used to create a string from a Unicode code point.
 */
const fromCodePoint =
  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition, node/no-unsupported-features/es-builtins
  (_a = String.fromCodePoint) !== null && _a !== void 0
    ? _a
    : function (codePoint) {
        let output = "";
        if (codePoint > 0xffff) {
          codePoint -= 0x10000;
          output += String.fromCharCode(((codePoint >>> 10) & 0x3ff) | 0xd800);
          codePoint = 0xdc00 | (codePoint & 0x3ff);
        }
        output += String.fromCharCode(codePoint);
        return output;
      };
/**
 * Replace the given code point with a replacement character if it is a
 * surrogate or is outside the valid range. Otherwise return the code
 * point unchanged.
 */
function replaceCodePoint(codePoint) {
  var _a;
  if ((codePoint >= 0xd800 && codePoint <= 0xdfff) || codePoint > 0x10ffff) {
    return 0xfffd;
  }
  return (_a = decodeMap.get(codePoint)) !== null && _a !== void 0
    ? _a
    : codePoint;
}

var CharCodes$1;
(function (CharCodes) {
  CharCodes[(CharCodes["NUM"] = 35)] = "NUM";
  CharCodes[(CharCodes["SEMI"] = 59)] = "SEMI";
  CharCodes[(CharCodes["EQUALS"] = 61)] = "EQUALS";
  CharCodes[(CharCodes["ZERO"] = 48)] = "ZERO";
  CharCodes[(CharCodes["NINE"] = 57)] = "NINE";
  CharCodes[(CharCodes["LOWER_A"] = 97)] = "LOWER_A";
  CharCodes[(CharCodes["LOWER_F"] = 102)] = "LOWER_F";
  CharCodes[(CharCodes["LOWER_X"] = 120)] = "LOWER_X";
  CharCodes[(CharCodes["LOWER_Z"] = 122)] = "LOWER_Z";
  CharCodes[(CharCodes["UPPER_A"] = 65)] = "UPPER_A";
  CharCodes[(CharCodes["UPPER_F"] = 70)] = "UPPER_F";
  CharCodes[(CharCodes["UPPER_Z"] = 90)] = "UPPER_Z";
})(CharCodes$1 || (CharCodes$1 = {}));
/** Bit that needs to be set to convert an upper case ASCII character to lower case */
const TO_LOWER_BIT = 0b100000;
var BinTrieFlags;
(function (BinTrieFlags) {
  BinTrieFlags[(BinTrieFlags["VALUE_LENGTH"] = 49152)] = "VALUE_LENGTH";
  BinTrieFlags[(BinTrieFlags["BRANCH_LENGTH"] = 16256)] = "BRANCH_LENGTH";
  BinTrieFlags[(BinTrieFlags["JUMP_TABLE"] = 127)] = "JUMP_TABLE";
})(BinTrieFlags || (BinTrieFlags = {}));
function isNumber$1(code) {
  return code >= CharCodes$1.ZERO && code <= CharCodes$1.NINE;
}
function isHexadecimalCharacter(code) {
  return (
    (code >= CharCodes$1.UPPER_A && code <= CharCodes$1.UPPER_F) ||
    (code >= CharCodes$1.LOWER_A && code <= CharCodes$1.LOWER_F)
  );
}
function isAsciiAlphaNumeric$1(code) {
  return (
    (code >= CharCodes$1.UPPER_A && code <= CharCodes$1.UPPER_Z) ||
    (code >= CharCodes$1.LOWER_A && code <= CharCodes$1.LOWER_Z) ||
    isNumber$1(code)
  );
}
/**
 * Checks if the given character is a valid end character for an entity in an attribute.
 *
 * Attribute values that aren't terminated properly aren't parsed, and shouldn't lead to a parser error.
 * See the example in https://html.spec.whatwg.org/multipage/parsing.html#named-character-reference-state
 */
function isEntityInAttributeInvalidEnd$1(code) {
  return code === CharCodes$1.EQUALS || isAsciiAlphaNumeric$1(code);
}
var EntityDecoderState;
(function (EntityDecoderState) {
  EntityDecoderState[(EntityDecoderState["EntityStart"] = 0)] = "EntityStart";
  EntityDecoderState[(EntityDecoderState["NumericStart"] = 1)] = "NumericStart";
  EntityDecoderState[(EntityDecoderState["NumericDecimal"] = 2)] =
    "NumericDecimal";
  EntityDecoderState[(EntityDecoderState["NumericHex"] = 3)] = "NumericHex";
  EntityDecoderState[(EntityDecoderState["NamedEntity"] = 4)] = "NamedEntity";
})(EntityDecoderState || (EntityDecoderState = {}));
var DecodingMode;
(function (DecodingMode) {
  /** Entities in text nodes that can end with any character. */
  DecodingMode[(DecodingMode["Legacy"] = 0)] = "Legacy";
  /** Only allow entities terminated with a semicolon. */
  DecodingMode[(DecodingMode["Strict"] = 1)] = "Strict";
  /** Entities in attributes have limitations on ending characters. */
  DecodingMode[(DecodingMode["Attribute"] = 2)] = "Attribute";
})(DecodingMode || (DecodingMode = {}));
/**
 * Token decoder with support of writing partial entities.
 */
class EntityDecoder {
  constructor(
    /** The tree used to decode entities. */
    decodeTree,
    /**
     * The function that is called when a codepoint is decoded.
     *
     * For multi-byte named entities, this will be called multiple times,
     * with the second codepoint, and the same `consumed` value.
     *
     * @param codepoint The decoded codepoint.
     * @param consumed The number of bytes consumed by the decoder.
     */
    emitCodePoint,
    /** An object that is used to produce errors. */
    errors,
  ) {
    this.decodeTree = decodeTree;
    this.emitCodePoint = emitCodePoint;
    this.errors = errors;
    /** The current state of the decoder. */
    this.state = EntityDecoderState.EntityStart;
    /** Characters that were consumed while parsing an entity. */
    this.consumed = 1;
    /**
     * The result of the entity.
     *
     * Either the result index of a numeric entity, or the codepoint of a
     * numeric entity.
     */
    this.result = 0;
    /** The current index in the decode tree. */
    this.treeIndex = 0;
    /** The number of characters that were consumed in excess. */
    this.excess = 1;
    /** The mode in which the decoder is operating. */
    this.decodeMode = DecodingMode.Strict;
  }
  /** Resets the instance to make it reusable. */
  startEntity(decodeMode) {
    this.decodeMode = decodeMode;
    this.state = EntityDecoderState.EntityStart;
    this.result = 0;
    this.treeIndex = 0;
    this.excess = 1;
    this.consumed = 1;
  }
  /**
   * Write an entity to the decoder. This can be called multiple times with partial entities.
   * If the entity is incomplete, the decoder will return -1.
   *
   * Mirrors the implementation of `getDecoder`, but with the ability to stop decoding if the
   * entity is incomplete, and resume when the next string is written.
   *
   * @param string The string containing the entity (or a continuation of the entity).
   * @param offset The offset at which the entity begins. Should be 0 if this is not the first call.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  write(str, offset) {
    switch (this.state) {
      case EntityDecoderState.EntityStart: {
        if (str.charCodeAt(offset) === CharCodes$1.NUM) {
          this.state = EntityDecoderState.NumericStart;
          this.consumed += 1;
          return this.stateNumericStart(str, offset + 1);
        }
        this.state = EntityDecoderState.NamedEntity;
        return this.stateNamedEntity(str, offset);
      }
      case EntityDecoderState.NumericStart: {
        return this.stateNumericStart(str, offset);
      }
      case EntityDecoderState.NumericDecimal: {
        return this.stateNumericDecimal(str, offset);
      }
      case EntityDecoderState.NumericHex: {
        return this.stateNumericHex(str, offset);
      }
      case EntityDecoderState.NamedEntity: {
        return this.stateNamedEntity(str, offset);
      }
    }
  }
  /**
   * Switches between the numeric decimal and hexadecimal states.
   *
   * Equivalent to the `Numeric character reference state` in the HTML spec.
   *
   * @param str The string containing the entity (or a continuation of the entity).
   * @param offset The current offset.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  stateNumericStart(str, offset) {
    if (offset >= str.length) {
      return -1;
    }
    if ((str.charCodeAt(offset) | TO_LOWER_BIT) === CharCodes$1.LOWER_X) {
      this.state = EntityDecoderState.NumericHex;
      this.consumed += 1;
      return this.stateNumericHex(str, offset + 1);
    }
    this.state = EntityDecoderState.NumericDecimal;
    return this.stateNumericDecimal(str, offset);
  }
  addToNumericResult(str, start, end, base) {
    if (start !== end) {
      const digitCount = end - start;
      this.result =
        this.result * Math.pow(base, digitCount) +
        parseInt(str.substr(start, digitCount), base);
      this.consumed += digitCount;
    }
  }
  /**
   * Parses a hexadecimal numeric entity.
   *
   * Equivalent to the `Hexademical character reference state` in the HTML spec.
   *
   * @param str The string containing the entity (or a continuation of the entity).
   * @param offset The current offset.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  stateNumericHex(str, offset) {
    const startIdx = offset;
    while (offset < str.length) {
      const char = str.charCodeAt(offset);
      if (isNumber$1(char) || isHexadecimalCharacter(char)) {
        offset += 1;
      } else {
        this.addToNumericResult(str, startIdx, offset, 16);
        return this.emitNumericEntity(char, 3);
      }
    }
    this.addToNumericResult(str, startIdx, offset, 16);
    return -1;
  }
  /**
   * Parses a decimal numeric entity.
   *
   * Equivalent to the `Decimal character reference state` in the HTML spec.
   *
   * @param str The string containing the entity (or a continuation of the entity).
   * @param offset The current offset.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  stateNumericDecimal(str, offset) {
    const startIdx = offset;
    while (offset < str.length) {
      const char = str.charCodeAt(offset);
      if (isNumber$1(char)) {
        offset += 1;
      } else {
        this.addToNumericResult(str, startIdx, offset, 10);
        return this.emitNumericEntity(char, 2);
      }
    }
    this.addToNumericResult(str, startIdx, offset, 10);
    return -1;
  }
  /**
   * Validate and emit a numeric entity.
   *
   * Implements the logic from the `Hexademical character reference start
   * state` and `Numeric character reference end state` in the HTML spec.
   *
   * @param lastCp The last code point of the entity. Used to see if the
   *               entity was terminated with a semicolon.
   * @param expectedLength The minimum number of characters that should be
   *                       consumed. Used to validate that at least one digit
   *                       was consumed.
   * @returns The number of characters that were consumed.
   */
  emitNumericEntity(lastCp, expectedLength) {
    var _a;
    // Ensure we consumed at least one digit.
    if (this.consumed <= expectedLength) {
      (_a = this.errors) === null || _a === void 0
        ? void 0
        : _a.absenceOfDigitsInNumericCharacterReference(this.consumed);
      return 0;
    }
    // Figure out if this is a legit end of the entity
    if (lastCp === CharCodes$1.SEMI) {
      this.consumed += 1;
    } else if (this.decodeMode === DecodingMode.Strict) {
      return 0;
    }
    this.emitCodePoint(replaceCodePoint(this.result), this.consumed);
    if (this.errors) {
      if (lastCp !== CharCodes$1.SEMI) {
        this.errors.missingSemicolonAfterCharacterReference();
      }
      this.errors.validateNumericCharacterReference(this.result);
    }
    return this.consumed;
  }
  /**
   * Parses a named entity.
   *
   * Equivalent to the `Named character reference state` in the HTML spec.
   *
   * @param str The string containing the entity (or a continuation of the entity).
   * @param offset The current offset.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  stateNamedEntity(str, offset) {
    const { decodeTree } = this;
    let current = decodeTree[this.treeIndex];
    // The mask is the number of bytes of the value, including the current byte.
    let valueLength = (current & BinTrieFlags.VALUE_LENGTH) >> 14;
    for (; offset < str.length; offset++, this.excess++) {
      const char = str.charCodeAt(offset);
      this.treeIndex = determineBranch(
        decodeTree,
        current,
        this.treeIndex + Math.max(1, valueLength),
        char,
      );
      if (this.treeIndex < 0) {
        return this.result === 0 ||
          // If we are parsing an attribute
          (this.decodeMode === DecodingMode.Attribute &&
            // We shouldn't have consumed any characters after the entity,
            (valueLength === 0 ||
              // And there should be no invalid characters.
              isEntityInAttributeInvalidEnd$1(char)))
          ? 0
          : this.emitNotTerminatedNamedEntity();
      }
      current = decodeTree[this.treeIndex];
      valueLength = (current & BinTrieFlags.VALUE_LENGTH) >> 14;
      // If the branch is a value, store it and continue
      if (valueLength !== 0) {
        // If the entity is terminated by a semicolon, we are done.
        if (char === CharCodes$1.SEMI) {
          return this.emitNamedEntityData(
            this.treeIndex,
            valueLength,
            this.consumed + this.excess,
          );
        }
        // If we encounter a non-terminated (legacy) entity while parsing strictly, then ignore it.
        if (this.decodeMode !== DecodingMode.Strict) {
          this.result = this.treeIndex;
          this.consumed += this.excess;
          this.excess = 0;
        }
      }
    }
    return -1;
  }
  /**
   * Emit a named entity that was not terminated with a semicolon.
   *
   * @returns The number of characters consumed.
   */
  emitNotTerminatedNamedEntity() {
    var _a;
    const { result, decodeTree } = this;
    const valueLength = (decodeTree[result] & BinTrieFlags.VALUE_LENGTH) >> 14;
    this.emitNamedEntityData(result, valueLength, this.consumed);
    (_a = this.errors) === null || _a === void 0
      ? void 0
      : _a.missingSemicolonAfterCharacterReference();
    return this.consumed;
  }
  /**
   * Emit a named entity.
   *
   * @param result The index of the entity in the decode tree.
   * @param valueLength The number of bytes in the entity.
   * @param consumed The number of characters consumed.
   *
   * @returns The number of characters consumed.
   */
  emitNamedEntityData(result, valueLength, consumed) {
    const { decodeTree } = this;
    this.emitCodePoint(
      valueLength === 1
        ? decodeTree[result] & ~BinTrieFlags.VALUE_LENGTH
        : decodeTree[result + 1],
      consumed,
    );
    if (valueLength === 3) {
      // For multi-byte values, we need to emit the second byte.
      this.emitCodePoint(decodeTree[result + 2], consumed);
    }
    return consumed;
  }
  /**
   * Signal to the parser that the end of the input was reached.
   *
   * Remaining data will be emitted and relevant errors will be produced.
   *
   * @returns The number of characters consumed.
   */
  end() {
    var _a;
    switch (this.state) {
      case EntityDecoderState.NamedEntity: {
        // Emit a named entity if we have one.
        return this.result !== 0 &&
          (this.decodeMode !== DecodingMode.Attribute ||
            this.result === this.treeIndex)
          ? this.emitNotTerminatedNamedEntity()
          : 0;
      }
      // Otherwise, emit a numeric entity if we have one.
      case EntityDecoderState.NumericDecimal: {
        return this.emitNumericEntity(0, 2);
      }
      case EntityDecoderState.NumericHex: {
        return this.emitNumericEntity(0, 3);
      }
      case EntityDecoderState.NumericStart: {
        (_a = this.errors) === null || _a === void 0
          ? void 0
          : _a.absenceOfDigitsInNumericCharacterReference(this.consumed);
        return 0;
      }
      case EntityDecoderState.EntityStart: {
        // Return 0 if we have no entity.
        return 0;
      }
    }
  }
}
/**
 * Creates a function that decodes entities in a string.
 *
 * @param decodeTree The decode tree.
 * @returns A function that decodes entities in a string.
 */
function getDecoder(decodeTree) {
  let ret = "";
  const decoder = new EntityDecoder(
    decodeTree,
    (str) => (ret += fromCodePoint(str)),
  );
  return function decodeWithTrie(str, decodeMode) {
    let lastIndex = 0;
    let offset = 0;
    while ((offset = str.indexOf("&", offset)) >= 0) {
      ret += str.slice(lastIndex, offset);
      decoder.startEntity(decodeMode);
      const len = decoder.write(
        str,
        // Skip the "&"
        offset + 1,
      );
      if (len < 0) {
        lastIndex = offset + decoder.end();
        break;
      }
      lastIndex = offset + len;
      // If `len` is 0, skip the current `&` and continue.
      offset = len === 0 ? lastIndex + 1 : lastIndex;
    }
    const result = ret + str.slice(lastIndex);
    // Make sure we don't keep a reference to the final string.
    ret = "";
    return result;
  };
}
/**
 * Determines the branch of the current node that is taken given the current
 * character. This function is used to traverse the trie.
 *
 * @param decodeTree The trie.
 * @param current The current node.
 * @param nodeIdx The index right after the current node and its value.
 * @param char The current character.
 * @returns The index of the next node, or -1 if no branch is taken.
 */
function determineBranch(decodeTree, current, nodeIdx, char) {
  const branchCount = (current & BinTrieFlags.BRANCH_LENGTH) >> 7;
  const jumpOffset = current & BinTrieFlags.JUMP_TABLE;
  // Case 1: Single branch encoded in jump offset
  if (branchCount === 0) {
    return jumpOffset !== 0 && char === jumpOffset ? nodeIdx : -1;
  }
  // Case 2: Multiple branches encoded in jump table
  if (jumpOffset) {
    const value = char - jumpOffset;
    return value < 0 || value >= branchCount
      ? -1
      : decodeTree[nodeIdx + value] - 1;
  }
  // Case 3: Multiple branches encoded in dictionary
  // Binary search for the character.
  let lo = nodeIdx;
  let hi = lo + branchCount - 1;
  while (lo <= hi) {
    const mid = (lo + hi) >>> 1;
    const midVal = decodeTree[mid];
    if (midVal < char) {
      lo = mid + 1;
    } else if (midVal > char) {
      hi = mid - 1;
    } else {
      return decodeTree[mid + branchCount];
    }
  }
  return -1;
}
const htmlDecoder = getDecoder(htmlDecodeTree);
const xmlDecoder = getDecoder(xmlDecodeTree);
/**
 * Decodes an HTML string.
 *
 * @param str The string to decode.
 * @param mode The decoding mode.
 * @returns The decoded string.
 */
function decodeHTML(str, mode = DecodingMode.Legacy) {
  return htmlDecoder(str, mode);
}
/**
 * Decodes an HTML string in an attribute.
 *
 * @param str The string to decode.
 * @returns The decoded string.
 */
function decodeHTMLAttribute(str) {
  return htmlDecoder(str, DecodingMode.Attribute);
}
/**
 * Decodes an HTML string, requiring all entities to be terminated by a semicolon.
 *
 * @param str The string to decode.
 * @returns The decoded string.
 */
function decodeHTMLStrict(str) {
  return htmlDecoder(str, DecodingMode.Strict);
}
/**
 * Decodes an XML string, requiring all entities to be terminated by a semicolon.
 *
 * @param str The string to decode.
 * @returns The decoded string.
 */
function decodeXML(str) {
  return xmlDecoder(str, DecodingMode.Strict);
}

// Generated using scripts/write-encode-map.ts
function restoreDiff(arr) {
  for (let i = 1; i < arr.length; i++) {
    arr[i][0] += arr[i - 1][0] + 1;
  }
  return arr;
}
// prettier-ignore
const htmlTrie = new Map(/* #__PURE__ */ restoreDiff([[9, "&Tab;"], [0, "&NewLine;"], [22, "&excl;"], [0, "&quot;"], [0, "&num;"], [0, "&dollar;"], [0, "&percnt;"], [0, "&amp;"], [0, "&apos;"], [0, "&lpar;"], [0, "&rpar;"], [0, "&ast;"], [0, "&plus;"], [0, "&comma;"], [1, "&period;"], [0, "&sol;"], [10, "&colon;"], [0, "&semi;"], [0, { v: "&lt;", n: 8402, o: "&nvlt;" }], [0, { v: "&equals;", n: 8421, o: "&bne;" }], [0, { v: "&gt;", n: 8402, o: "&nvgt;" }], [0, "&quest;"], [0, "&commat;"], [26, "&lbrack;"], [0, "&bsol;"], [0, "&rbrack;"], [0, "&Hat;"], [0, "&lowbar;"], [0, "&DiacriticalGrave;"], [5, { n: 106, o: "&fjlig;" }], [20, "&lbrace;"], [0, "&verbar;"], [0, "&rbrace;"], [34, "&nbsp;"], [0, "&iexcl;"], [0, "&cent;"], [0, "&pound;"], [0, "&curren;"], [0, "&yen;"], [0, "&brvbar;"], [0, "&sect;"], [0, "&die;"], [0, "&copy;"], [0, "&ordf;"], [0, "&laquo;"], [0, "&not;"], [0, "&shy;"], [0, "&circledR;"], [0, "&macr;"], [0, "&deg;"], [0, "&PlusMinus;"], [0, "&sup2;"], [0, "&sup3;"], [0, "&acute;"], [0, "&micro;"], [0, "&para;"], [0, "&centerdot;"], [0, "&cedil;"], [0, "&sup1;"], [0, "&ordm;"], [0, "&raquo;"], [0, "&frac14;"], [0, "&frac12;"], [0, "&frac34;"], [0, "&iquest;"], [0, "&Agrave;"], [0, "&Aacute;"], [0, "&Acirc;"], [0, "&Atilde;"], [0, "&Auml;"], [0, "&angst;"], [0, "&AElig;"], [0, "&Ccedil;"], [0, "&Egrave;"], [0, "&Eacute;"], [0, "&Ecirc;"], [0, "&Euml;"], [0, "&Igrave;"], [0, "&Iacute;"], [0, "&Icirc;"], [0, "&Iuml;"], [0, "&ETH;"], [0, "&Ntilde;"], [0, "&Ograve;"], [0, "&Oacute;"], [0, "&Ocirc;"], [0, "&Otilde;"], [0, "&Ouml;"], [0, "&times;"], [0, "&Oslash;"], [0, "&Ugrave;"], [0, "&Uacute;"], [0, "&Ucirc;"], [0, "&Uuml;"], [0, "&Yacute;"], [0, "&THORN;"], [0, "&szlig;"], [0, "&agrave;"], [0, "&aacute;"], [0, "&acirc;"], [0, "&atilde;"], [0, "&auml;"], [0, "&aring;"], [0, "&aelig;"], [0, "&ccedil;"], [0, "&egrave;"], [0, "&eacute;"], [0, "&ecirc;"], [0, "&euml;"], [0, "&igrave;"], [0, "&iacute;"], [0, "&icirc;"], [0, "&iuml;"], [0, "&eth;"], [0, "&ntilde;"], [0, "&ograve;"], [0, "&oacute;"], [0, "&ocirc;"], [0, "&otilde;"], [0, "&ouml;"], [0, "&div;"], [0, "&oslash;"], [0, "&ugrave;"], [0, "&uacute;"], [0, "&ucirc;"], [0, "&uuml;"], [0, "&yacute;"], [0, "&thorn;"], [0, "&yuml;"], [0, "&Amacr;"], [0, "&amacr;"], [0, "&Abreve;"], [0, "&abreve;"], [0, "&Aogon;"], [0, "&aogon;"], [0, "&Cacute;"], [0, "&cacute;"], [0, "&Ccirc;"], [0, "&ccirc;"], [0, "&Cdot;"], [0, "&cdot;"], [0, "&Ccaron;"], [0, "&ccaron;"], [0, "&Dcaron;"], [0, "&dcaron;"], [0, "&Dstrok;"], [0, "&dstrok;"], [0, "&Emacr;"], [0, "&emacr;"], [2, "&Edot;"], [0, "&edot;"], [0, "&Eogon;"], [0, "&eogon;"], [0, "&Ecaron;"], [0, "&ecaron;"], [0, "&Gcirc;"], [0, "&gcirc;"], [0, "&Gbreve;"], [0, "&gbreve;"], [0, "&Gdot;"], [0, "&gdot;"], [0, "&Gcedil;"], [1, "&Hcirc;"], [0, "&hcirc;"], [0, "&Hstrok;"], [0, "&hstrok;"], [0, "&Itilde;"], [0, "&itilde;"], [0, "&Imacr;"], [0, "&imacr;"], [2, "&Iogon;"], [0, "&iogon;"], [0, "&Idot;"], [0, "&imath;"], [0, "&IJlig;"], [0, "&ijlig;"], [0, "&Jcirc;"], [0, "&jcirc;"], [0, "&Kcedil;"], [0, "&kcedil;"], [0, "&kgreen;"], [0, "&Lacute;"], [0, "&lacute;"], [0, "&Lcedil;"], [0, "&lcedil;"], [0, "&Lcaron;"], [0, "&lcaron;"], [0, "&Lmidot;"], [0, "&lmidot;"], [0, "&Lstrok;"], [0, "&lstrok;"], [0, "&Nacute;"], [0, "&nacute;"], [0, "&Ncedil;"], [0, "&ncedil;"], [0, "&Ncaron;"], [0, "&ncaron;"], [0, "&napos;"], [0, "&ENG;"], [0, "&eng;"], [0, "&Omacr;"], [0, "&omacr;"], [2, "&Odblac;"], [0, "&odblac;"], [0, "&OElig;"], [0, "&oelig;"], [0, "&Racute;"], [0, "&racute;"], [0, "&Rcedil;"], [0, "&rcedil;"], [0, "&Rcaron;"], [0, "&rcaron;"], [0, "&Sacute;"], [0, "&sacute;"], [0, "&Scirc;"], [0, "&scirc;"], [0, "&Scedil;"], [0, "&scedil;"], [0, "&Scaron;"], [0, "&scaron;"], [0, "&Tcedil;"], [0, "&tcedil;"], [0, "&Tcaron;"], [0, "&tcaron;"], [0, "&Tstrok;"], [0, "&tstrok;"], [0, "&Utilde;"], [0, "&utilde;"], [0, "&Umacr;"], [0, "&umacr;"], [0, "&Ubreve;"], [0, "&ubreve;"], [0, "&Uring;"], [0, "&uring;"], [0, "&Udblac;"], [0, "&udblac;"], [0, "&Uogon;"], [0, "&uogon;"], [0, "&Wcirc;"], [0, "&wcirc;"], [0, "&Ycirc;"], [0, "&ycirc;"], [0, "&Yuml;"], [0, "&Zacute;"], [0, "&zacute;"], [0, "&Zdot;"], [0, "&zdot;"], [0, "&Zcaron;"], [0, "&zcaron;"], [19, "&fnof;"], [34, "&imped;"], [63, "&gacute;"], [65, "&jmath;"], [142, "&circ;"], [0, "&caron;"], [16, "&breve;"], [0, "&DiacriticalDot;"], [0, "&ring;"], [0, "&ogon;"], [0, "&DiacriticalTilde;"], [0, "&dblac;"], [51, "&DownBreve;"], [127, "&Alpha;"], [0, "&Beta;"], [0, "&Gamma;"], [0, "&Delta;"], [0, "&Epsilon;"], [0, "&Zeta;"], [0, "&Eta;"], [0, "&Theta;"], [0, "&Iota;"], [0, "&Kappa;"], [0, "&Lambda;"], [0, "&Mu;"], [0, "&Nu;"], [0, "&Xi;"], [0, "&Omicron;"], [0, "&Pi;"], [0, "&Rho;"], [1, "&Sigma;"], [0, "&Tau;"], [0, "&Upsilon;"], [0, "&Phi;"], [0, "&Chi;"], [0, "&Psi;"], [0, "&ohm;"], [7, "&alpha;"], [0, "&beta;"], [0, "&gamma;"], [0, "&delta;"], [0, "&epsi;"], [0, "&zeta;"], [0, "&eta;"], [0, "&theta;"], [0, "&iota;"], [0, "&kappa;"], [0, "&lambda;"], [0, "&mu;"], [0, "&nu;"], [0, "&xi;"], [0, "&omicron;"], [0, "&pi;"], [0, "&rho;"], [0, "&sigmaf;"], [0, "&sigma;"], [0, "&tau;"], [0, "&upsi;"], [0, "&phi;"], [0, "&chi;"], [0, "&psi;"], [0, "&omega;"], [7, "&thetasym;"], [0, "&Upsi;"], [2, "&phiv;"], [0, "&piv;"], [5, "&Gammad;"], [0, "&digamma;"], [18, "&kappav;"], [0, "&rhov;"], [3, "&epsiv;"], [0, "&backepsilon;"], [10, "&IOcy;"], [0, "&DJcy;"], [0, "&GJcy;"], [0, "&Jukcy;"], [0, "&DScy;"], [0, "&Iukcy;"], [0, "&YIcy;"], [0, "&Jsercy;"], [0, "&LJcy;"], [0, "&NJcy;"], [0, "&TSHcy;"], [0, "&KJcy;"], [1, "&Ubrcy;"], [0, "&DZcy;"], [0, "&Acy;"], [0, "&Bcy;"], [0, "&Vcy;"], [0, "&Gcy;"], [0, "&Dcy;"], [0, "&IEcy;"], [0, "&ZHcy;"], [0, "&Zcy;"], [0, "&Icy;"], [0, "&Jcy;"], [0, "&Kcy;"], [0, "&Lcy;"], [0, "&Mcy;"], [0, "&Ncy;"], [0, "&Ocy;"], [0, "&Pcy;"], [0, "&Rcy;"], [0, "&Scy;"], [0, "&Tcy;"], [0, "&Ucy;"], [0, "&Fcy;"], [0, "&KHcy;"], [0, "&TScy;"], [0, "&CHcy;"], [0, "&SHcy;"], [0, "&SHCHcy;"], [0, "&HARDcy;"], [0, "&Ycy;"], [0, "&SOFTcy;"], [0, "&Ecy;"], [0, "&YUcy;"], [0, "&YAcy;"], [0, "&acy;"], [0, "&bcy;"], [0, "&vcy;"], [0, "&gcy;"], [0, "&dcy;"], [0, "&iecy;"], [0, "&zhcy;"], [0, "&zcy;"], [0, "&icy;"], [0, "&jcy;"], [0, "&kcy;"], [0, "&lcy;"], [0, "&mcy;"], [0, "&ncy;"], [0, "&ocy;"], [0, "&pcy;"], [0, "&rcy;"], [0, "&scy;"], [0, "&tcy;"], [0, "&ucy;"], [0, "&fcy;"], [0, "&khcy;"], [0, "&tscy;"], [0, "&chcy;"], [0, "&shcy;"], [0, "&shchcy;"], [0, "&hardcy;"], [0, "&ycy;"], [0, "&softcy;"], [0, "&ecy;"], [0, "&yucy;"], [0, "&yacy;"], [1, "&iocy;"], [0, "&djcy;"], [0, "&gjcy;"], [0, "&jukcy;"], [0, "&dscy;"], [0, "&iukcy;"], [0, "&yicy;"], [0, "&jsercy;"], [0, "&ljcy;"], [0, "&njcy;"], [0, "&tshcy;"], [0, "&kjcy;"], [1, "&ubrcy;"], [0, "&dzcy;"], [7074, "&ensp;"], [0, "&emsp;"], [0, "&emsp13;"], [0, "&emsp14;"], [1, "&numsp;"], [0, "&puncsp;"], [0, "&ThinSpace;"], [0, "&hairsp;"], [0, "&NegativeMediumSpace;"], [0, "&zwnj;"], [0, "&zwj;"], [0, "&lrm;"], [0, "&rlm;"], [0, "&dash;"], [2, "&ndash;"], [0, "&mdash;"], [0, "&horbar;"], [0, "&Verbar;"], [1, "&lsquo;"], [0, "&CloseCurlyQuote;"], [0, "&lsquor;"], [1, "&ldquo;"], [0, "&CloseCurlyDoubleQuote;"], [0, "&bdquo;"], [1, "&dagger;"], [0, "&Dagger;"], [0, "&bull;"], [2, "&nldr;"], [0, "&hellip;"], [9, "&permil;"], [0, "&pertenk;"], [0, "&prime;"], [0, "&Prime;"], [0, "&tprime;"], [0, "&backprime;"], [3, "&lsaquo;"], [0, "&rsaquo;"], [3, "&oline;"], [2, "&caret;"], [1, "&hybull;"], [0, "&frasl;"], [10, "&bsemi;"], [7, "&qprime;"], [7, { v: "&MediumSpace;", n: 8202, o: "&ThickSpace;" }], [0, "&NoBreak;"], [0, "&af;"], [0, "&InvisibleTimes;"], [0, "&ic;"], [72, "&euro;"], [46, "&tdot;"], [0, "&DotDot;"], [37, "&complexes;"], [2, "&incare;"], [4, "&gscr;"], [0, "&hamilt;"], [0, "&Hfr;"], [0, "&Hopf;"], [0, "&planckh;"], [0, "&hbar;"], [0, "&imagline;"], [0, "&Ifr;"], [0, "&lagran;"], [0, "&ell;"], [1, "&naturals;"], [0, "&numero;"], [0, "&copysr;"], [0, "&weierp;"], [0, "&Popf;"], [0, "&Qopf;"], [0, "&realine;"], [0, "&real;"], [0, "&reals;"], [0, "&rx;"], [3, "&trade;"], [1, "&integers;"], [2, "&mho;"], [0, "&zeetrf;"], [0, "&iiota;"], [2, "&bernou;"], [0, "&Cayleys;"], [1, "&escr;"], [0, "&Escr;"], [0, "&Fouriertrf;"], [1, "&Mellintrf;"], [0, "&order;"], [0, "&alefsym;"], [0, "&beth;"], [0, "&gimel;"], [0, "&daleth;"], [12, "&CapitalDifferentialD;"], [0, "&dd;"], [0, "&ee;"], [0, "&ii;"], [10, "&frac13;"], [0, "&frac23;"], [0, "&frac15;"], [0, "&frac25;"], [0, "&frac35;"], [0, "&frac45;"], [0, "&frac16;"], [0, "&frac56;"], [0, "&frac18;"], [0, "&frac38;"], [0, "&frac58;"], [0, "&frac78;"], [49, "&larr;"], [0, "&ShortUpArrow;"], [0, "&rarr;"], [0, "&darr;"], [0, "&harr;"], [0, "&updownarrow;"], [0, "&nwarr;"], [0, "&nearr;"], [0, "&LowerRightArrow;"], [0, "&LowerLeftArrow;"], [0, "&nlarr;"], [0, "&nrarr;"], [1, { v: "&rarrw;", n: 824, o: "&nrarrw;" }], [0, "&Larr;"], [0, "&Uarr;"], [0, "&Rarr;"], [0, "&Darr;"], [0, "&larrtl;"], [0, "&rarrtl;"], [0, "&LeftTeeArrow;"], [0, "&mapstoup;"], [0, "&map;"], [0, "&DownTeeArrow;"], [1, "&hookleftarrow;"], [0, "&hookrightarrow;"], [0, "&larrlp;"], [0, "&looparrowright;"], [0, "&harrw;"], [0, "&nharr;"], [1, "&lsh;"], [0, "&rsh;"], [0, "&ldsh;"], [0, "&rdsh;"], [1, "&crarr;"], [0, "&cularr;"], [0, "&curarr;"], [2, "&circlearrowleft;"], [0, "&circlearrowright;"], [0, "&leftharpoonup;"], [0, "&DownLeftVector;"], [0, "&RightUpVector;"], [0, "&LeftUpVector;"], [0, "&rharu;"], [0, "&DownRightVector;"], [0, "&dharr;"], [0, "&dharl;"], [0, "&RightArrowLeftArrow;"], [0, "&udarr;"], [0, "&LeftArrowRightArrow;"], [0, "&leftleftarrows;"], [0, "&upuparrows;"], [0, "&rightrightarrows;"], [0, "&ddarr;"], [0, "&leftrightharpoons;"], [0, "&Equilibrium;"], [0, "&nlArr;"], [0, "&nhArr;"], [0, "&nrArr;"], [0, "&DoubleLeftArrow;"], [0, "&DoubleUpArrow;"], [0, "&DoubleRightArrow;"], [0, "&dArr;"], [0, "&DoubleLeftRightArrow;"], [0, "&DoubleUpDownArrow;"], [0, "&nwArr;"], [0, "&neArr;"], [0, "&seArr;"], [0, "&swArr;"], [0, "&lAarr;"], [0, "&rAarr;"], [1, "&zigrarr;"], [6, "&larrb;"], [0, "&rarrb;"], [15, "&DownArrowUpArrow;"], [7, "&loarr;"], [0, "&roarr;"], [0, "&hoarr;"], [0, "&forall;"], [0, "&comp;"], [0, { v: "&part;", n: 824, o: "&npart;" }], [0, "&exist;"], [0, "&nexist;"], [0, "&empty;"], [1, "&Del;"], [0, "&Element;"], [0, "&NotElement;"], [1, "&ni;"], [0, "&notni;"], [2, "&prod;"], [0, "&coprod;"], [0, "&sum;"], [0, "&minus;"], [0, "&MinusPlus;"], [0, "&dotplus;"], [1, "&Backslash;"], [0, "&lowast;"], [0, "&compfn;"], [1, "&radic;"], [2, "&prop;"], [0, "&infin;"], [0, "&angrt;"], [0, { v: "&ang;", n: 8402, o: "&nang;" }], [0, "&angmsd;"], [0, "&angsph;"], [0, "&mid;"], [0, "&nmid;"], [0, "&DoubleVerticalBar;"], [0, "&NotDoubleVerticalBar;"], [0, "&and;"], [0, "&or;"], [0, { v: "&cap;", n: 65024, o: "&caps;" }], [0, { v: "&cup;", n: 65024, o: "&cups;" }], [0, "&int;"], [0, "&Int;"], [0, "&iiint;"], [0, "&conint;"], [0, "&Conint;"], [0, "&Cconint;"], [0, "&cwint;"], [0, "&ClockwiseContourIntegral;"], [0, "&awconint;"], [0, "&there4;"], [0, "&becaus;"], [0, "&ratio;"], [0, "&Colon;"], [0, "&dotminus;"], [1, "&mDDot;"], [0, "&homtht;"], [0, { v: "&sim;", n: 8402, o: "&nvsim;" }], [0, { v: "&backsim;", n: 817, o: "&race;" }], [0, { v: "&ac;", n: 819, o: "&acE;" }], [0, "&acd;"], [0, "&VerticalTilde;"], [0, "&NotTilde;"], [0, { v: "&eqsim;", n: 824, o: "&nesim;" }], [0, "&sime;"], [0, "&NotTildeEqual;"], [0, "&cong;"], [0, "&simne;"], [0, "&ncong;"], [0, "&ap;"], [0, "&nap;"], [0, "&ape;"], [0, { v: "&apid;", n: 824, o: "&napid;" }], [0, "&backcong;"], [0, { v: "&asympeq;", n: 8402, o: "&nvap;" }], [0, { v: "&bump;", n: 824, o: "&nbump;" }], [0, { v: "&bumpe;", n: 824, o: "&nbumpe;" }], [0, { v: "&doteq;", n: 824, o: "&nedot;" }], [0, "&doteqdot;"], [0, "&efDot;"], [0, "&erDot;"], [0, "&Assign;"], [0, "&ecolon;"], [0, "&ecir;"], [0, "&circeq;"], [1, "&wedgeq;"], [0, "&veeeq;"], [1, "&triangleq;"], [2, "&equest;"], [0, "&ne;"], [0, { v: "&Congruent;", n: 8421, o: "&bnequiv;" }], [0, "&nequiv;"], [1, { v: "&le;", n: 8402, o: "&nvle;" }], [0, { v: "&ge;", n: 8402, o: "&nvge;" }], [0, { v: "&lE;", n: 824, o: "&nlE;" }], [0, { v: "&gE;", n: 824, o: "&ngE;" }], [0, { v: "&lnE;", n: 65024, o: "&lvertneqq;" }], [0, { v: "&gnE;", n: 65024, o: "&gvertneqq;" }], [0, { v: "&ll;", n: new Map(/* #__PURE__ */ restoreDiff([[824, "&nLtv;"], [7577, "&nLt;"]])) }], [0, { v: "&gg;", n: new Map(/* #__PURE__ */ restoreDiff([[824, "&nGtv;"], [7577, "&nGt;"]])) }], [0, "&between;"], [0, "&NotCupCap;"], [0, "&nless;"], [0, "&ngt;"], [0, "&nle;"], [0, "&nge;"], [0, "&lesssim;"], [0, "&GreaterTilde;"], [0, "&nlsim;"], [0, "&ngsim;"], [0, "&LessGreater;"], [0, "&gl;"], [0, "&NotLessGreater;"], [0, "&NotGreaterLess;"], [0, "&pr;"], [0, "&sc;"], [0, "&prcue;"], [0, "&sccue;"], [0, "&PrecedesTilde;"], [0, { v: "&scsim;", n: 824, o: "&NotSucceedsTilde;" }], [0, "&NotPrecedes;"], [0, "&NotSucceeds;"], [0, { v: "&sub;", n: 8402, o: "&NotSubset;" }], [0, { v: "&sup;", n: 8402, o: "&NotSuperset;" }], [0, "&nsub;"], [0, "&nsup;"], [0, "&sube;"], [0, "&supe;"], [0, "&NotSubsetEqual;"], [0, "&NotSupersetEqual;"], [0, { v: "&subne;", n: 65024, o: "&varsubsetneq;" }], [0, { v: "&supne;", n: 65024, o: "&varsupsetneq;" }], [1, "&cupdot;"], [0, "&UnionPlus;"], [0, { v: "&sqsub;", n: 824, o: "&NotSquareSubset;" }], [0, { v: "&sqsup;", n: 824, o: "&NotSquareSuperset;" }], [0, "&sqsube;"], [0, "&sqsupe;"], [0, { v: "&sqcap;", n: 65024, o: "&sqcaps;" }], [0, { v: "&sqcup;", n: 65024, o: "&sqcups;" }], [0, "&CirclePlus;"], [0, "&CircleMinus;"], [0, "&CircleTimes;"], [0, "&osol;"], [0, "&CircleDot;"], [0, "&circledcirc;"], [0, "&circledast;"], [1, "&circleddash;"], [0, "&boxplus;"], [0, "&boxminus;"], [0, "&boxtimes;"], [0, "&dotsquare;"], [0, "&RightTee;"], [0, "&dashv;"], [0, "&DownTee;"], [0, "&bot;"], [1, "&models;"], [0, "&DoubleRightTee;"], [0, "&Vdash;"], [0, "&Vvdash;"], [0, "&VDash;"], [0, "&nvdash;"], [0, "&nvDash;"], [0, "&nVdash;"], [0, "&nVDash;"], [0, "&prurel;"], [1, "&LeftTriangle;"], [0, "&RightTriangle;"], [0, { v: "&LeftTriangleEqual;", n: 8402, o: "&nvltrie;" }], [0, { v: "&RightTriangleEqual;", n: 8402, o: "&nvrtrie;" }], [0, "&origof;"], [0, "&imof;"], [0, "&multimap;"], [0, "&hercon;"], [0, "&intcal;"], [0, "&veebar;"], [1, "&barvee;"], [0, "&angrtvb;"], [0, "&lrtri;"], [0, "&bigwedge;"], [0, "&bigvee;"], [0, "&bigcap;"], [0, "&bigcup;"], [0, "&diam;"], [0, "&sdot;"], [0, "&sstarf;"], [0, "&divideontimes;"], [0, "&bowtie;"], [0, "&ltimes;"], [0, "&rtimes;"], [0, "&leftthreetimes;"], [0, "&rightthreetimes;"], [0, "&backsimeq;"], [0, "&curlyvee;"], [0, "&curlywedge;"], [0, "&Sub;"], [0, "&Sup;"], [0, "&Cap;"], [0, "&Cup;"], [0, "&fork;"], [0, "&epar;"], [0, "&lessdot;"], [0, "&gtdot;"], [0, { v: "&Ll;", n: 824, o: "&nLl;" }], [0, { v: "&Gg;", n: 824, o: "&nGg;" }], [0, { v: "&leg;", n: 65024, o: "&lesg;" }], [0, { v: "&gel;", n: 65024, o: "&gesl;" }], [2, "&cuepr;"], [0, "&cuesc;"], [0, "&NotPrecedesSlantEqual;"], [0, "&NotSucceedsSlantEqual;"], [0, "&NotSquareSubsetEqual;"], [0, "&NotSquareSupersetEqual;"], [2, "&lnsim;"], [0, "&gnsim;"], [0, "&precnsim;"], [0, "&scnsim;"], [0, "&nltri;"], [0, "&NotRightTriangle;"], [0, "&nltrie;"], [0, "&NotRightTriangleEqual;"], [0, "&vellip;"], [0, "&ctdot;"], [0, "&utdot;"], [0, "&dtdot;"], [0, "&disin;"], [0, "&isinsv;"], [0, "&isins;"], [0, { v: "&isindot;", n: 824, o: "&notindot;" }], [0, "&notinvc;"], [0, "&notinvb;"], [1, { v: "&isinE;", n: 824, o: "&notinE;" }], [0, "&nisd;"], [0, "&xnis;"], [0, "&nis;"], [0, "&notnivc;"], [0, "&notnivb;"], [6, "&barwed;"], [0, "&Barwed;"], [1, "&lceil;"], [0, "&rceil;"], [0, "&LeftFloor;"], [0, "&rfloor;"], [0, "&drcrop;"], [0, "&dlcrop;"], [0, "&urcrop;"], [0, "&ulcrop;"], [0, "&bnot;"], [1, "&profline;"], [0, "&profsurf;"], [1, "&telrec;"], [0, "&target;"], [5, "&ulcorn;"], [0, "&urcorn;"], [0, "&dlcorn;"], [0, "&drcorn;"], [2, "&frown;"], [0, "&smile;"], [9, "&cylcty;"], [0, "&profalar;"], [7, "&topbot;"], [6, "&ovbar;"], [1, "&solbar;"], [60, "&angzarr;"], [51, "&lmoustache;"], [0, "&rmoustache;"], [2, "&OverBracket;"], [0, "&bbrk;"], [0, "&bbrktbrk;"], [37, "&OverParenthesis;"], [0, "&UnderParenthesis;"], [0, "&OverBrace;"], [0, "&UnderBrace;"], [2, "&trpezium;"], [4, "&elinters;"], [59, "&blank;"], [164, "&circledS;"], [55, "&boxh;"], [1, "&boxv;"], [9, "&boxdr;"], [3, "&boxdl;"], [3, "&boxur;"], [3, "&boxul;"], [3, "&boxvr;"], [7, "&boxvl;"], [7, "&boxhd;"], [7, "&boxhu;"], [7, "&boxvh;"], [19, "&boxH;"], [0, "&boxV;"], [0, "&boxdR;"], [0, "&boxDr;"], [0, "&boxDR;"], [0, "&boxdL;"], [0, "&boxDl;"], [0, "&boxDL;"], [0, "&boxuR;"], [0, "&boxUr;"], [0, "&boxUR;"], [0, "&boxuL;"], [0, "&boxUl;"], [0, "&boxUL;"], [0, "&boxvR;"], [0, "&boxVr;"], [0, "&boxVR;"], [0, "&boxvL;"], [0, "&boxVl;"], [0, "&boxVL;"], [0, "&boxHd;"], [0, "&boxhD;"], [0, "&boxHD;"], [0, "&boxHu;"], [0, "&boxhU;"], [0, "&boxHU;"], [0, "&boxvH;"], [0, "&boxVh;"], [0, "&boxVH;"], [19, "&uhblk;"], [3, "&lhblk;"], [3, "&block;"], [8, "&blk14;"], [0, "&blk12;"], [0, "&blk34;"], [13, "&square;"], [8, "&blacksquare;"], [0, "&EmptyVerySmallSquare;"], [1, "&rect;"], [0, "&marker;"], [2, "&fltns;"], [1, "&bigtriangleup;"], [0, "&blacktriangle;"], [0, "&triangle;"], [2, "&blacktriangleright;"], [0, "&rtri;"], [3, "&bigtriangledown;"], [0, "&blacktriangledown;"], [0, "&dtri;"], [2, "&blacktriangleleft;"], [0, "&ltri;"], [6, "&loz;"], [0, "&cir;"], [32, "&tridot;"], [2, "&bigcirc;"], [8, "&ultri;"], [0, "&urtri;"], [0, "&lltri;"], [0, "&EmptySmallSquare;"], [0, "&FilledSmallSquare;"], [8, "&bigstar;"], [0, "&star;"], [7, "&phone;"], [49, "&female;"], [1, "&male;"], [29, "&spades;"], [2, "&clubs;"], [1, "&hearts;"], [0, "&diamondsuit;"], [3, "&sung;"], [2, "&flat;"], [0, "&natural;"], [0, "&sharp;"], [163, "&check;"], [3, "&cross;"], [8, "&malt;"], [21, "&sext;"], [33, "&VerticalSeparator;"], [25, "&lbbrk;"], [0, "&rbbrk;"], [84, "&bsolhsub;"], [0, "&suphsol;"], [28, "&LeftDoubleBracket;"], [0, "&RightDoubleBracket;"], [0, "&lang;"], [0, "&rang;"], [0, "&Lang;"], [0, "&Rang;"], [0, "&loang;"], [0, "&roang;"], [7, "&longleftarrow;"], [0, "&longrightarrow;"], [0, "&longleftrightarrow;"], [0, "&DoubleLongLeftArrow;"], [0, "&DoubleLongRightArrow;"], [0, "&DoubleLongLeftRightArrow;"], [1, "&longmapsto;"], [2, "&dzigrarr;"], [258, "&nvlArr;"], [0, "&nvrArr;"], [0, "&nvHarr;"], [0, "&Map;"], [6, "&lbarr;"], [0, "&bkarow;"], [0, "&lBarr;"], [0, "&dbkarow;"], [0, "&drbkarow;"], [0, "&DDotrahd;"], [0, "&UpArrowBar;"], [0, "&DownArrowBar;"], [2, "&Rarrtl;"], [2, "&latail;"], [0, "&ratail;"], [0, "&lAtail;"], [0, "&rAtail;"], [0, "&larrfs;"], [0, "&rarrfs;"], [0, "&larrbfs;"], [0, "&rarrbfs;"], [2, "&nwarhk;"], [0, "&nearhk;"], [0, "&hksearow;"], [0, "&hkswarow;"], [0, "&nwnear;"], [0, "&nesear;"], [0, "&seswar;"], [0, "&swnwar;"], [8, { v: "&rarrc;", n: 824, o: "&nrarrc;" }], [1, "&cudarrr;"], [0, "&ldca;"], [0, "&rdca;"], [0, "&cudarrl;"], [0, "&larrpl;"], [2, "&curarrm;"], [0, "&cularrp;"], [7, "&rarrpl;"], [2, "&harrcir;"], [0, "&Uarrocir;"], [0, "&lurdshar;"], [0, "&ldrushar;"], [2, "&LeftRightVector;"], [0, "&RightUpDownVector;"], [0, "&DownLeftRightVector;"], [0, "&LeftUpDownVector;"], [0, "&LeftVectorBar;"], [0, "&RightVectorBar;"], [0, "&RightUpVectorBar;"], [0, "&RightDownVectorBar;"], [0, "&DownLeftVectorBar;"], [0, "&DownRightVectorBar;"], [0, "&LeftUpVectorBar;"], [0, "&LeftDownVectorBar;"], [0, "&LeftTeeVector;"], [0, "&RightTeeVector;"], [0, "&RightUpTeeVector;"], [0, "&RightDownTeeVector;"], [0, "&DownLeftTeeVector;"], [0, "&DownRightTeeVector;"], [0, "&LeftUpTeeVector;"], [0, "&LeftDownTeeVector;"], [0, "&lHar;"], [0, "&uHar;"], [0, "&rHar;"], [0, "&dHar;"], [0, "&luruhar;"], [0, "&ldrdhar;"], [0, "&ruluhar;"], [0, "&rdldhar;"], [0, "&lharul;"], [0, "&llhard;"], [0, "&rharul;"], [0, "&lrhard;"], [0, "&udhar;"], [0, "&duhar;"], [0, "&RoundImplies;"], [0, "&erarr;"], [0, "&simrarr;"], [0, "&larrsim;"], [0, "&rarrsim;"], [0, "&rarrap;"], [0, "&ltlarr;"], [1, "&gtrarr;"], [0, "&subrarr;"], [1, "&suplarr;"], [0, "&lfisht;"], [0, "&rfisht;"], [0, "&ufisht;"], [0, "&dfisht;"], [5, "&lopar;"], [0, "&ropar;"], [4, "&lbrke;"], [0, "&rbrke;"], [0, "&lbrkslu;"], [0, "&rbrksld;"], [0, "&lbrksld;"], [0, "&rbrkslu;"], [0, "&langd;"], [0, "&rangd;"], [0, "&lparlt;"], [0, "&rpargt;"], [0, "&gtlPar;"], [0, "&ltrPar;"], [3, "&vzigzag;"], [1, "&vangrt;"], [0, "&angrtvbd;"], [6, "&ange;"], [0, "&range;"], [0, "&dwangle;"], [0, "&uwangle;"], [0, "&angmsdaa;"], [0, "&angmsdab;"], [0, "&angmsdac;"], [0, "&angmsdad;"], [0, "&angmsdae;"], [0, "&angmsdaf;"], [0, "&angmsdag;"], [0, "&angmsdah;"], [0, "&bemptyv;"], [0, "&demptyv;"], [0, "&cemptyv;"], [0, "&raemptyv;"], [0, "&laemptyv;"], [0, "&ohbar;"], [0, "&omid;"], [0, "&opar;"], [1, "&operp;"], [1, "&olcross;"], [0, "&odsold;"], [1, "&olcir;"], [0, "&ofcir;"], [0, "&olt;"], [0, "&ogt;"], [0, "&cirscir;"], [0, "&cirE;"], [0, "&solb;"], [0, "&bsolb;"], [3, "&boxbox;"], [3, "&trisb;"], [0, "&rtriltri;"], [0, { v: "&LeftTriangleBar;", n: 824, o: "&NotLeftTriangleBar;" }], [0, { v: "&RightTriangleBar;", n: 824, o: "&NotRightTriangleBar;" }], [11, "&iinfin;"], [0, "&infintie;"], [0, "&nvinfin;"], [4, "&eparsl;"], [0, "&smeparsl;"], [0, "&eqvparsl;"], [5, "&blacklozenge;"], [8, "&RuleDelayed;"], [1, "&dsol;"], [9, "&bigodot;"], [0, "&bigoplus;"], [0, "&bigotimes;"], [1, "&biguplus;"], [1, "&bigsqcup;"], [5, "&iiiint;"], [0, "&fpartint;"], [2, "&cirfnint;"], [0, "&awint;"], [0, "&rppolint;"], [0, "&scpolint;"], [0, "&npolint;"], [0, "&pointint;"], [0, "&quatint;"], [0, "&intlarhk;"], [10, "&pluscir;"], [0, "&plusacir;"], [0, "&simplus;"], [0, "&plusdu;"], [0, "&plussim;"], [0, "&plustwo;"], [1, "&mcomma;"], [0, "&minusdu;"], [2, "&loplus;"], [0, "&roplus;"], [0, "&Cross;"], [0, "&timesd;"], [0, "&timesbar;"], [1, "&smashp;"], [0, "&lotimes;"], [0, "&rotimes;"], [0, "&otimesas;"], [0, "&Otimes;"], [0, "&odiv;"], [0, "&triplus;"], [0, "&triminus;"], [0, "&tritime;"], [0, "&intprod;"], [2, "&amalg;"], [0, "&capdot;"], [1, "&ncup;"], [0, "&ncap;"], [0, "&capand;"], [0, "&cupor;"], [0, "&cupcap;"], [0, "&capcup;"], [0, "&cupbrcap;"], [0, "&capbrcup;"], [0, "&cupcup;"], [0, "&capcap;"], [0, "&ccups;"], [0, "&ccaps;"], [2, "&ccupssm;"], [2, "&And;"], [0, "&Or;"], [0, "&andand;"], [0, "&oror;"], [0, "&orslope;"], [0, "&andslope;"], [1, "&andv;"], [0, "&orv;"], [0, "&andd;"], [0, "&ord;"], [1, "&wedbar;"], [6, "&sdote;"], [3, "&simdot;"], [2, { v: "&congdot;", n: 824, o: "&ncongdot;" }], [0, "&easter;"], [0, "&apacir;"], [0, { v: "&apE;", n: 824, o: "&napE;" }], [0, "&eplus;"], [0, "&pluse;"], [0, "&Esim;"], [0, "&Colone;"], [0, "&Equal;"], [1, "&ddotseq;"], [0, "&equivDD;"], [0, "&ltcir;"], [0, "&gtcir;"], [0, "&ltquest;"], [0, "&gtquest;"], [0, { v: "&leqslant;", n: 824, o: "&nleqslant;" }], [0, { v: "&geqslant;", n: 824, o: "&ngeqslant;" }], [0, "&lesdot;"], [0, "&gesdot;"], [0, "&lesdoto;"], [0, "&gesdoto;"], [0, "&lesdotor;"], [0, "&gesdotol;"], [0, "&lap;"], [0, "&gap;"], [0, "&lne;"], [0, "&gne;"], [0, "&lnap;"], [0, "&gnap;"], [0, "&lEg;"], [0, "&gEl;"], [0, "&lsime;"], [0, "&gsime;"], [0, "&lsimg;"], [0, "&gsiml;"], [0, "&lgE;"], [0, "&glE;"], [0, "&lesges;"], [0, "&gesles;"], [0, "&els;"], [0, "&egs;"], [0, "&elsdot;"], [0, "&egsdot;"], [0, "&el;"], [0, "&eg;"], [2, "&siml;"], [0, "&simg;"], [0, "&simlE;"], [0, "&simgE;"], [0, { v: "&LessLess;", n: 824, o: "&NotNestedLessLess;" }], [0, { v: "&GreaterGreater;", n: 824, o: "&NotNestedGreaterGreater;" }], [1, "&glj;"], [0, "&gla;"], [0, "&ltcc;"], [0, "&gtcc;"], [0, "&lescc;"], [0, "&gescc;"], [0, "&smt;"], [0, "&lat;"], [0, { v: "&smte;", n: 65024, o: "&smtes;" }], [0, { v: "&late;", n: 65024, o: "&lates;" }], [0, "&bumpE;"], [0, { v: "&PrecedesEqual;", n: 824, o: "&NotPrecedesEqual;" }], [0, { v: "&sce;", n: 824, o: "&NotSucceedsEqual;" }], [2, "&prE;"], [0, "&scE;"], [0, "&precneqq;"], [0, "&scnE;"], [0, "&prap;"], [0, "&scap;"], [0, "&precnapprox;"], [0, "&scnap;"], [0, "&Pr;"], [0, "&Sc;"], [0, "&subdot;"], [0, "&supdot;"], [0, "&subplus;"], [0, "&supplus;"], [0, "&submult;"], [0, "&supmult;"], [0, "&subedot;"], [0, "&supedot;"], [0, { v: "&subE;", n: 824, o: "&nsubE;" }], [0, { v: "&supE;", n: 824, o: "&nsupE;" }], [0, "&subsim;"], [0, "&supsim;"], [2, { v: "&subnE;", n: 65024, o: "&varsubsetneqq;" }], [0, { v: "&supnE;", n: 65024, o: "&varsupsetneqq;" }], [2, "&csub;"], [0, "&csup;"], [0, "&csube;"], [0, "&csupe;"], [0, "&subsup;"], [0, "&supsub;"], [0, "&subsub;"], [0, "&supsup;"], [0, "&suphsub;"], [0, "&supdsub;"], [0, "&forkv;"], [0, "&topfork;"], [0, "&mlcp;"], [8, "&Dashv;"], [1, "&Vdashl;"], [0, "&Barv;"], [0, "&vBar;"], [0, "&vBarv;"], [1, "&Vbar;"], [0, "&Not;"], [0, "&bNot;"], [0, "&rnmid;"], [0, "&cirmid;"], [0, "&midcir;"], [0, "&topcir;"], [0, "&nhpar;"], [0, "&parsim;"], [9, { v: "&parsl;", n: 8421, o: "&nparsl;" }], [44343, { n: new Map(/* #__PURE__ */ restoreDiff([[56476, "&Ascr;"], [1, "&Cscr;"], [0, "&Dscr;"], [2, "&Gscr;"], [2, "&Jscr;"], [0, "&Kscr;"], [2, "&Nscr;"], [0, "&Oscr;"], [0, "&Pscr;"], [0, "&Qscr;"], [1, "&Sscr;"], [0, "&Tscr;"], [0, "&Uscr;"], [0, "&Vscr;"], [0, "&Wscr;"], [0, "&Xscr;"], [0, "&Yscr;"], [0, "&Zscr;"], [0, "&ascr;"], [0, "&bscr;"], [0, "&cscr;"], [0, "&dscr;"], [1, "&fscr;"], [1, "&hscr;"], [0, "&iscr;"], [0, "&jscr;"], [0, "&kscr;"], [0, "&lscr;"], [0, "&mscr;"], [0, "&nscr;"], [1, "&pscr;"], [0, "&qscr;"], [0, "&rscr;"], [0, "&sscr;"], [0, "&tscr;"], [0, "&uscr;"], [0, "&vscr;"], [0, "&wscr;"], [0, "&xscr;"], [0, "&yscr;"], [0, "&zscr;"], [52, "&Afr;"], [0, "&Bfr;"], [1, "&Dfr;"], [0, "&Efr;"], [0, "&Ffr;"], [0, "&Gfr;"], [2, "&Jfr;"], [0, "&Kfr;"], [0, "&Lfr;"], [0, "&Mfr;"], [0, "&Nfr;"], [0, "&Ofr;"], [0, "&Pfr;"], [0, "&Qfr;"], [1, "&Sfr;"], [0, "&Tfr;"], [0, "&Ufr;"], [0, "&Vfr;"], [0, "&Wfr;"], [0, "&Xfr;"], [0, "&Yfr;"], [1, "&afr;"], [0, "&bfr;"], [0, "&cfr;"], [0, "&dfr;"], [0, "&efr;"], [0, "&ffr;"], [0, "&gfr;"], [0, "&hfr;"], [0, "&ifr;"], [0, "&jfr;"], [0, "&kfr;"], [0, "&lfr;"], [0, "&mfr;"], [0, "&nfr;"], [0, "&ofr;"], [0, "&pfr;"], [0, "&qfr;"], [0, "&rfr;"], [0, "&sfr;"], [0, "&tfr;"], [0, "&ufr;"], [0, "&vfr;"], [0, "&wfr;"], [0, "&xfr;"], [0, "&yfr;"], [0, "&zfr;"], [0, "&Aopf;"], [0, "&Bopf;"], [1, "&Dopf;"], [0, "&Eopf;"], [0, "&Fopf;"], [0, "&Gopf;"], [1, "&Iopf;"], [0, "&Jopf;"], [0, "&Kopf;"], [0, "&Lopf;"], [0, "&Mopf;"], [1, "&Oopf;"], [3, "&Sopf;"], [0, "&Topf;"], [0, "&Uopf;"], [0, "&Vopf;"], [0, "&Wopf;"], [0, "&Xopf;"], [0, "&Yopf;"], [1, "&aopf;"], [0, "&bopf;"], [0, "&copf;"], [0, "&dopf;"], [0, "&eopf;"], [0, "&fopf;"], [0, "&gopf;"], [0, "&hopf;"], [0, "&iopf;"], [0, "&jopf;"], [0, "&kopf;"], [0, "&lopf;"], [0, "&mopf;"], [0, "&nopf;"], [0, "&oopf;"], [0, "&popf;"], [0, "&qopf;"], [0, "&ropf;"], [0, "&sopf;"], [0, "&topf;"], [0, "&uopf;"], [0, "&vopf;"], [0, "&wopf;"], [0, "&xopf;"], [0, "&yopf;"], [0, "&zopf;"]])) }], [8906, "&fflig;"], [0, "&filig;"], [0, "&fllig;"], [0, "&ffilig;"], [0, "&ffllig;"]]));

const xmlReplacer = /["&'<>$\x80-\uFFFF]/g;
const xmlCodeMap = new Map([
  [34, "&quot;"],
  [38, "&amp;"],
  [39, "&apos;"],
  [60, "&lt;"],
  [62, "&gt;"],
]);
// For compatibility with node < 4, we wrap `codePointAt`
const getCodePoint =
  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
  String.prototype.codePointAt != null
    ? (str, index) => str.codePointAt(index)
    : // http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
      (c, index) =>
        (c.charCodeAt(index) & 0xfc00) === 0xd800
          ? (c.charCodeAt(index) - 0xd800) * 0x400 +
            c.charCodeAt(index + 1) -
            0xdc00 +
            0x10000
          : c.charCodeAt(index);
/**
 * Encodes all non-ASCII characters, as well as characters not valid in XML
 * documents using XML entities.
 *
 * If a character has no equivalent entity, a
 * numeric hexadecimal reference (eg. `&#xfc;`) will be used.
 */
function encodeXML(str) {
  let ret = "";
  let lastIdx = 0;
  let match;
  while ((match = xmlReplacer.exec(str)) !== null) {
    const i = match.index;
    const char = str.charCodeAt(i);
    const next = xmlCodeMap.get(char);
    if (next !== undefined) {
      ret += str.substring(lastIdx, i) + next;
      lastIdx = i + 1;
    } else {
      ret += `${str.substring(lastIdx, i)}&#x${getCodePoint(str, i).toString(
        16,
      )};`;
      // Increase by 1 if we have a surrogate pair
      lastIdx = xmlReplacer.lastIndex += Number((char & 0xfc00) === 0xd800);
    }
  }
  return ret + str.substr(lastIdx);
}
/**
 * Encodes all non-ASCII characters, as well as characters not valid in XML
 * documents using numeric hexadecimal reference (eg. `&#xfc;`).
 *
 * Have a look at `escapeUTF8` if you want a more concise output at the expense
 * of reduced transportability.
 *
 * @param data String to escape.
 */
const escape = encodeXML;
/**
 * Creates a function that escapes all characters matched by the given regular
 * expression using the given map of characters to escape to their entities.
 *
 * @param regex Regular expression to match characters to escape.
 * @param map Map of characters to escape to their entities.
 *
 * @returns Function that escapes all characters matched by the given regular
 * expression using the given map of characters to escape to their entities.
 */
function getEscaper(regex, map) {
  return function escape(data) {
    let match;
    let lastIdx = 0;
    let result = "";
    while ((match = regex.exec(data))) {
      if (lastIdx !== match.index) {
        result += data.substring(lastIdx, match.index);
      }
      // We know that this character will be in the map.
      result += map.get(match[0].charCodeAt(0));
      // Every match will be of length 1
      lastIdx = match.index + 1;
    }
    return result + data.substring(lastIdx);
  };
}
/**
 * Encodes all characters not valid in XML documents using XML entities.
 *
 * Note that the output will be character-set dependent.
 *
 * @param data String to escape.
 */
const escapeUTF8 = getEscaper(/[&<>'"]/g, xmlCodeMap);
/**
 * Encodes all characters that have to be escaped in HTML attributes,
 * following {@link https://html.spec.whatwg.org/multipage/parsing.html#escapingString}.
 *
 * @param data String to escape.
 */
const escapeAttribute = getEscaper(
  /["&\u00A0]/g,
  new Map([
    [34, "&quot;"],
    [38, "&amp;"],
    [160, "&nbsp;"],
  ]),
);
/**
 * Encodes all characters that have to be escaped in HTML text,
 * following {@link https://html.spec.whatwg.org/multipage/parsing.html#escapingString}.
 *
 * @param data String to escape.
 */
const escapeText = getEscaper(
  /[&<>\u00A0]/g,
  new Map([
    [38, "&amp;"],
    [60, "&lt;"],
    [62, "&gt;"],
    [160, "&nbsp;"],
  ]),
);

const htmlReplacer = /[\t\n!-,./:-@[-`\f{-}$\x80-\uFFFF]/g;
/**
 * Encodes all characters in the input using HTML entities. This includes
 * characters that are valid ASCII characters in HTML documents, such as `#`.
 *
 * To get a more compact output, consider using the `encodeNonAsciiHTML`
 * function, which will only encode characters that are not valid in HTML
 * documents, as well as non-ASCII characters.
 *
 * If a character has no equivalent entity, a numeric hexadecimal reference
 * (eg. `&#xfc;`) will be used.
 */
function encodeHTML(data) {
  return encodeHTMLTrieRe(htmlReplacer, data);
}
/**
 * Encodes all non-ASCII characters, as well as characters not valid in HTML
 * documents using HTML entities. This function will not encode characters that
 * are valid in HTML documents, such as `#`.
 *
 * If a character has no equivalent entity, a numeric hexadecimal reference
 * (eg. `&#xfc;`) will be used.
 */
function encodeNonAsciiHTML(data) {
  return encodeHTMLTrieRe(xmlReplacer, data);
}
function encodeHTMLTrieRe(regExp, str) {
  let ret = "";
  let lastIdx = 0;
  let match;
  while ((match = regExp.exec(str)) !== null) {
    const i = match.index;
    ret += str.substring(lastIdx, i);
    const char = str.charCodeAt(i);
    let next = htmlTrie.get(char);
    if (typeof next === "object") {
      // We are in a branch. Try to match the next char.
      if (i + 1 < str.length) {
        const nextChar = str.charCodeAt(i + 1);
        const value =
          typeof next.n === "number"
            ? next.n === nextChar
              ? next.o
              : undefined
            : next.n.get(nextChar);
        if (value !== undefined) {
          ret += value;
          lastIdx = regExp.lastIndex += 1;
          continue;
        }
      }
      next = next.v;
    }
    // We might have a tree node without a value; skip and use a numeric entity.
    if (next !== undefined) {
      ret += next;
      lastIdx = i + 1;
    } else {
      const cp = getCodePoint(str, i);
      ret += `&#x${cp.toString(16)};`;
      // Increase by 1 if we have a surrogate pair
      lastIdx = regExp.lastIndex += Number(cp !== char);
    }
  }
  return ret + str.substr(lastIdx);
}

/** The level of entities to support. */
var EntityLevel;
(function (EntityLevel) {
  /** Support only XML entities. */
  EntityLevel[(EntityLevel["XML"] = 0)] = "XML";
  /** Support HTML entities, which are a superset of XML entities. */
  EntityLevel[(EntityLevel["HTML"] = 1)] = "HTML";
})(EntityLevel || (EntityLevel = {}));
var EncodingMode;
(function (EncodingMode) {
  /**
   * The output is UTF-8 encoded. Only characters that need escaping within
   * XML will be escaped.
   */
  EncodingMode[(EncodingMode["UTF8"] = 0)] = "UTF8";
  /**
   * The output consists only of ASCII characters. Characters that need
   * escaping within HTML, and characters that aren't ASCII characters will
   * be escaped.
   */
  EncodingMode[(EncodingMode["ASCII"] = 1)] = "ASCII";
  /**
   * Encode all characters that have an equivalent entity, as well as all
   * characters that are not ASCII characters.
   */
  EncodingMode[(EncodingMode["Extensive"] = 2)] = "Extensive";
  /**
   * Encode all characters that have to be escaped in HTML attributes,
   * following {@link https://html.spec.whatwg.org/multipage/parsing.html#escapingString}.
   */
  EncodingMode[(EncodingMode["Attribute"] = 3)] = "Attribute";
  /**
   * Encode all characters that have to be escaped in HTML text,
   * following {@link https://html.spec.whatwg.org/multipage/parsing.html#escapingString}.
   */
  EncodingMode[(EncodingMode["Text"] = 4)] = "Text";
})(EncodingMode || (EncodingMode = {}));
/**
 * Decodes a string with entities.
 *
 * @param data String to decode.
 * @param options Decoding options.
 */
function decode$6(data, options = EntityLevel.XML) {
  const level = typeof options === "number" ? options : options.level;
  if (level === EntityLevel.HTML) {
    const mode = typeof options === "object" ? options.mode : undefined;
    return decodeHTML(data, mode);
  }
  return decodeXML(data);
}
/**
 * Decodes a string with entities. Does not allow missing trailing semicolons for entities.
 *
 * @param data String to decode.
 * @param options Decoding options.
 * @deprecated Use `decode` with the `mode` set to `Strict`.
 */
function decodeStrict(data, options = EntityLevel.XML) {
  var _a;
  const opts = typeof options === "number" ? { level: options } : options;
  (_a = opts.mode) !== null && _a !== void 0
    ? _a
    : (opts.mode = DecodingMode.Strict);
  return decode$6(data, opts);
}
/**
 * Encodes a string with entities.
 *
 * @param data String to encode.
 * @param options Encoding options.
 */
function encode$7(data, options = EntityLevel.XML) {
  const opts = typeof options === "number" ? { level: options } : options;
  // Mode `UTF8` just escapes XML entities
  if (opts.mode === EncodingMode.UTF8) return escapeUTF8(data);
  if (opts.mode === EncodingMode.Attribute) return escapeAttribute(data);
  if (opts.mode === EncodingMode.Text) return escapeText(data);
  if (opts.level === EntityLevel.HTML) {
    if (opts.mode === EncodingMode.ASCII) {
      return encodeNonAsciiHTML(data);
    }
    return encodeHTML(data);
  }
  // ASCII and Extensive are equivalent
  return encodeXML(data);
}

const esm = /*#__PURE__*/ Object.freeze(
  /*#__PURE__*/ Object.defineProperty(
    {
      __proto__: null,
      get DecodingMode() {
        return DecodingMode;
      },
      get EncodingMode() {
        return EncodingMode;
      },
      EntityDecoder,
      get EntityLevel() {
        return EntityLevel;
      },
      decode: decode$6,
      decodeHTML,
      decodeHTML4: decodeHTML,
      decodeHTML4Strict: decodeHTMLStrict,
      decodeHTML5: decodeHTML,
      decodeHTML5Strict: decodeHTMLStrict,
      decodeHTMLAttribute,
      decodeHTMLStrict,
      decodeStrict,
      decodeXML,
      decodeXMLStrict: decodeXML,
      encode: encode$7,
      encodeHTML,
      encodeHTML4: encodeHTML,
      encodeHTML5: encodeHTML,
      encodeNonAsciiHTML,
      encodeXML,
      escape,
      escapeAttribute,
      escapeText,
      escapeUTF8,
    },
    Symbol.toStringTag,
    { value: "Module" },
  ),
);

const require$$1$3 = /*@__PURE__*/ getAugmentedNamespace(esm);

var foreignNames = {};

Object.defineProperty(foreignNames, "__esModule", { value: true });
foreignNames.attributeNames = foreignNames.elementNames = void 0;
foreignNames.elementNames = new Map(
  [
    "altGlyph",
    "altGlyphDef",
    "altGlyphItem",
    "animateColor",
    "animateMotion",
    "animateTransform",
    "clipPath",
    "feBlend",
    "feColorMatrix",
    "feComponentTransfer",
    "feComposite",
    "feConvolveMatrix",
    "feDiffuseLighting",
    "feDisplacementMap",
    "feDistantLight",
    "feDropShadow",
    "feFlood",
    "feFuncA",
    "feFuncB",
    "feFuncG",
    "feFuncR",
    "feGaussianBlur",
    "feImage",
    "feMerge",
    "feMergeNode",
    "feMorphology",
    "feOffset",
    "fePointLight",
    "feSpecularLighting",
    "feSpotLight",
    "feTile",
    "feTurbulence",
    "foreignObject",
    "glyphRef",
    "linearGradient",
    "radialGradient",
    "textPath",
  ].map(function (val) {
    return [val.toLowerCase(), val];
  }),
);
foreignNames.attributeNames = new Map(
  [
    "definitionURL",
    "attributeName",
    "attributeType",
    "baseFrequency",
    "baseProfile",
    "calcMode",
    "clipPathUnits",
    "diffuseConstant",
    "edgeMode",
    "filterUnits",
    "glyphRef",
    "gradientTransform",
    "gradientUnits",
    "kernelMatrix",
    "kernelUnitLength",
    "keyPoints",
    "keySplines",
    "keyTimes",
    "lengthAdjust",
    "limitingConeAngle",
    "markerHeight",
    "markerUnits",
    "markerWidth",
    "maskContentUnits",
    "maskUnits",
    "numOctaves",
    "pathLength",
    "patternContentUnits",
    "patternTransform",
    "patternUnits",
    "pointsAtX",
    "pointsAtY",
    "pointsAtZ",
    "preserveAlpha",
    "preserveAspectRatio",
    "primitiveUnits",
    "refX",
    "refY",
    "repeatCount",
    "repeatDur",
    "requiredExtensions",
    "requiredFeatures",
    "specularConstant",
    "specularExponent",
    "spreadMethod",
    "startOffset",
    "stdDeviation",
    "stitchTiles",
    "surfaceScale",
    "systemLanguage",
    "tableValues",
    "targetX",
    "targetY",
    "textLength",
    "viewBox",
    "viewTarget",
    "xChannelSelector",
    "yChannelSelector",
    "zoomAndPan",
  ].map(function (val) {
    return [val.toLowerCase(), val];
  }),
);

var __assign =
  (commonjsGlobal && commonjsGlobal.__assign) ||
  function () {
    __assign =
      Object.assign ||
      function (t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
      };
    return __assign.apply(this, arguments);
  };
var __createBinding$1 =
  (commonjsGlobal && commonjsGlobal.__createBinding) ||
  (Object.create
    ? function (o, m, k, k2) {
        if (k2 === undefined) k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (
          !desc ||
          ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)
        ) {
          desc = {
            enumerable: true,
            get: function () {
              return m[k];
            },
          };
        }
        Object.defineProperty(o, k2, desc);
      }
    : function (o, m, k, k2) {
        if (k2 === undefined) k2 = k;
        o[k2] = m[k];
      });
var __setModuleDefault$1 =
  (commonjsGlobal && commonjsGlobal.__setModuleDefault) ||
  (Object.create
    ? function (o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
      }
    : function (o, v) {
        o["default"] = v;
      });
var __importStar$1 =
  (commonjsGlobal && commonjsGlobal.__importStar) ||
  function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null)
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding$1(result, mod, k);
    __setModuleDefault$1(result, mod);
    return result;
  };
Object.defineProperty(lib$4, "__esModule", { value: true });
lib$4.render = void 0;
/*
 * Module dependencies
 */
var ElementType = __importStar$1(require$$0$5);
var entities_1 = require$$1$3;
/**
 * Mixed-case SVG and MathML tags & attributes
 * recognized by the HTML parser.
 *
 * @see https://html.spec.whatwg.org/multipage/parsing.html#parsing-main-inforeign
 */
var foreignNames_js_1 = foreignNames;
var unencodedElements$1 = new Set([
  "style",
  "script",
  "xmp",
  "iframe",
  "noembed",
  "noframes",
  "plaintext",
  "noscript",
]);
function replaceQuotes$1(value) {
  return value.replace(/"/g, "&quot;");
}
/**
 * Format attributes
 */
function formatAttributes$1(attributes, opts) {
  var _a;
  if (!attributes) return;
  var encode =
    ((_a = opts.encodeEntities) !== null && _a !== void 0
      ? _a
      : opts.decodeEntities) === false
      ? replaceQuotes$1
      : opts.xmlMode || opts.encodeEntities !== "utf8"
        ? entities_1.encodeXML
        : entities_1.escapeAttribute;
  return Object.keys(attributes)
    .map(function (key) {
      var _a, _b;
      var value = (_a = attributes[key]) !== null && _a !== void 0 ? _a : "";
      if (opts.xmlMode === "foreign") {
        /* Fix up mixed-case attribute names */
        key =
          (_b = foreignNames_js_1.attributeNames.get(key)) !== null &&
          _b !== void 0
            ? _b
            : key;
      }
      if (!opts.emptyAttrs && !opts.xmlMode && value === "") {
        return key;
      }
      return "".concat(key, '="').concat(encode(value), '"');
    })
    .join(" ");
}
/**
 * Self-enclosing tags
 */
var singleTag$1 = new Set([
  "area",
  "base",
  "basefont",
  "br",
  "col",
  "command",
  "embed",
  "frame",
  "hr",
  "img",
  "input",
  "isindex",
  "keygen",
  "link",
  "meta",
  "param",
  "source",
  "track",
  "wbr",
]);
/**
 * Renders a DOM node or an array of DOM nodes to a string.
 *
 * Can be thought of as the equivalent of the `outerHTML` of the passed node(s).
 *
 * @param node Node to be rendered.
 * @param options Changes serialization behavior
 */
function render$2(node, options) {
  if (options === void 0) {
    options = {};
  }
  var nodes = "length" in node ? node : [node];
  var output = "";
  for (var i = 0; i < nodes.length; i++) {
    output += renderNode$1(nodes[i], options);
  }
  return output;
}
lib$4.render = render$2;
var _default$6 = (lib$4.default = render$2);
function renderNode$1(node, options) {
  switch (node.type) {
    case ElementType.Root:
      return render$2(node.children, options);
    // @ts-expect-error We don't use `Doctype` yet
    case ElementType.Doctype:
    case ElementType.Directive:
      return renderDirective$1(node);
    case ElementType.Comment:
      return renderComment$1(node);
    case ElementType.CDATA:
      return renderCdata$1(node);
    case ElementType.Script:
    case ElementType.Style:
    case ElementType.Tag:
      return renderTag$1(node, options);
    case ElementType.Text:
      return renderText$1(node, options);
  }
}
var foreignModeIntegrationPoints$1 = new Set([
  "mi",
  "mo",
  "mn",
  "ms",
  "mtext",
  "annotation-xml",
  "foreignObject",
  "desc",
  "title",
]);
var foreignElements$1 = new Set(["svg", "math"]);
function renderTag$1(elem, opts) {
  var _a;
  // Handle SVG / MathML in HTML
  if (opts.xmlMode === "foreign") {
    /* Fix up mixed-case element names */
    elem.name =
      (_a = foreignNames_js_1.elementNames.get(elem.name)) !== null &&
      _a !== void 0
        ? _a
        : elem.name;
    /* Exit foreign mode at integration points */
    if (elem.parent && foreignModeIntegrationPoints$1.has(elem.parent.name)) {
      opts = __assign(__assign({}, opts), { xmlMode: false });
    }
  }
  if (!opts.xmlMode && foreignElements$1.has(elem.name)) {
    opts = __assign(__assign({}, opts), { xmlMode: "foreign" });
  }
  var tag = "<".concat(elem.name);
  var attribs = formatAttributes$1(elem.attribs, opts);
  if (attribs) {
    tag += " ".concat(attribs);
  }
  if (
    elem.children.length === 0 &&
    (opts.xmlMode
      ? // In XML mode or foreign mode, and user hasn't explicitly turned off self-closing tags
        opts.selfClosingTags !== false
      : // User explicitly asked for self-closing tags, even in HTML mode
        opts.selfClosingTags && singleTag$1.has(elem.name))
  ) {
    if (!opts.xmlMode) tag += " ";
    tag += "/>";
  } else {
    tag += ">";
    if (elem.children.length > 0) {
      tag += render$2(elem.children, opts);
    }
    if (opts.xmlMode || !singleTag$1.has(elem.name)) {
      tag += "</".concat(elem.name, ">");
    }
  }
  return tag;
}
function renderDirective$1(elem) {
  return "<".concat(elem.data, ">");
}
function renderText$1(elem, opts) {
  var _a;
  var data = elem.data || "";
  // If entities weren't decoded, no need to encode them back
  if (
    ((_a = opts.encodeEntities) !== null && _a !== void 0
      ? _a
      : opts.decodeEntities) !== false &&
    !(!opts.xmlMode && elem.parent && unencodedElements$1.has(elem.parent.name))
  ) {
    data =
      opts.xmlMode || opts.encodeEntities !== "utf8"
        ? (0, entities_1.encodeXML)(data)
        : (0, entities_1.escapeText)(data);
  }
  return data;
}
function renderCdata$1(elem) {
  return "<![CDATA[".concat(elem.children[0].data, "]]>");
}
function renderComment$1(elem) {
  return "<!--".concat(elem.data, "-->");
}

var lib$3 = {};

(function (exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Doctype =
    exports.CDATA =
    exports.Tag =
    exports.Style =
    exports.Script =
    exports.Comment =
    exports.Directive =
    exports.Text =
    exports.Root =
    exports.isTag =
    exports.ElementType =
      void 0;
  /** Types of elements found in htmlparser2's DOM */
  var ElementType;
  (function (ElementType) {
    /** Type for the root element of a document */
    ElementType["Root"] = "root";
    /** Type for Text */
    ElementType["Text"] = "text";
    /** Type for <? ... ?> */
    ElementType["Directive"] = "directive";
    /** Type for <!-- ... --> */
    ElementType["Comment"] = "comment";
    /** Type for <script> tags */
    ElementType["Script"] = "script";
    /** Type for <style> tags */
    ElementType["Style"] = "style";
    /** Type for Any tag */
    ElementType["Tag"] = "tag";
    /** Type for <![CDATA[ ... ]]> */
    ElementType["CDATA"] = "cdata";
    /** Type for <!doctype ...> */
    ElementType["Doctype"] = "doctype";
  })((ElementType = exports.ElementType || (exports.ElementType = {})));
  /**
   * Tests whether an element is a tag or not.
   *
   * @param elem Element to test
   */
  function isTag(elem) {
    return (
      elem.type === ElementType.Tag ||
      elem.type === ElementType.Script ||
      elem.type === ElementType.Style
    );
  }
  exports.isTag = isTag;
  // Exports for backwards compatibility
  /** Type for the root element of a document */
  exports.Root = ElementType.Root;
  /** Type for Text */
  exports.Text = ElementType.Text;
  /** Type for <? ... ?> */
  exports.Directive = ElementType.Directive;
  /** Type for <!-- ... --> */
  exports.Comment = ElementType.Comment;
  /** Type for <script> tags */
  exports.Script = ElementType.Script;
  /** Type for <style> tags */
  exports.Style = ElementType.Style;
  /** Type for Any tag */
  exports.Tag = ElementType.Tag;
  /** Type for <![CDATA[ ... ]]> */
  exports.CDATA = ElementType.CDATA;
  /** Type for <!doctype ...> */
  exports.Doctype = ElementType.Doctype;
})(lib$3);

/**
 * @category Stringify
 * @deprecated Use the `dom-serializer` module directly.
 * @param node Node to get the outer HTML of.
 * @param options Options for serialization.
 * @returns `node`'s outer HTML.
 */
function getOuterHTML$1(node, options) {
  return _default$6(node, options);
}
/**
 * @category Stringify
 * @deprecated Use the `dom-serializer` module directly.
 * @param node Node to get the inner HTML of.
 * @param options Options for serialization.
 * @returns `node`'s inner HTML.
 */
function getInnerHTML$1(node, options) {
  return lib$5.hasChildren(node)
    ? node.children.map((node) => getOuterHTML$1(node, options)).join("")
    : "";
}
/**
 * Get a node's inner text. Same as `textContent`, but inserts newlines for `<br>` tags. Ignores comments.
 *
 * @category Stringify
 * @deprecated Use `textContent` instead.
 * @param node Node to get the inner text of.
 * @returns `node`'s inner text.
 */
function getText$2(node) {
  if (Array.isArray(node)) return node.map(getText$2).join("");
  if (lib$5.isTag(node))
    return node.name === "br" ? "\n" : getText$2(node.children);
  if (lib$5.isCDATA(node)) return getText$2(node.children);
  if (lib$5.isText(node)) return node.data;
  return "";
}
/**
 * Get a node's text content. Ignores comments.
 *
 * @category Stringify
 * @param node Node to get the text content of.
 * @returns `node`'s text content.
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/Node/textContent}
 */
function textContent$1(node) {
  if (Array.isArray(node)) return node.map(textContent$1).join("");
  if (lib$5.hasChildren(node) && !lib$5.isComment(node)) {
    return textContent$1(node.children);
  }
  if (lib$5.isText(node)) return node.data;
  return "";
}
/**
 * Get a node's inner text, ignoring `<script>` and `<style>` tags. Ignores comments.
 *
 * @category Stringify
 * @param node Node to get the inner text of.
 * @returns `node`'s inner text.
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/Node/innerText}
 */
function innerText$1(node) {
  if (Array.isArray(node)) return node.map(innerText$1).join("");
  if (
    lib$5.hasChildren(node) &&
    (node.type === lib$3.ElementType.Tag || lib$5.isCDATA(node))
  ) {
    return innerText$1(node.children);
  }
  if (lib$5.isText(node)) return node.data;
  return "";
}

/**
 * Get a node's children.
 *
 * @category Traversal
 * @param elem Node to get the children of.
 * @returns `elem`'s children, or an empty array.
 */
function getChildren$2(elem) {
  return lib$5.hasChildren(elem) ? elem.children : [];
}
/**
 * Get a node's parent.
 *
 * @category Traversal
 * @param elem Node to get the parent of.
 * @returns `elem`'s parent node, or `null` if `elem` is a root node.
 */
function getParent$2(elem) {
  return elem.parent || null;
}
/**
 * Gets an elements siblings, including the element itself.
 *
 * Attempts to get the children through the element's parent first. If we don't
 * have a parent (the element is a root node), we walk the element's `prev` &
 * `next` to get all remaining nodes.
 *
 * @category Traversal
 * @param elem Element to get the siblings of.
 * @returns `elem`'s siblings, including `elem`.
 */
function getSiblings$2(elem) {
  const parent = getParent$2(elem);
  if (parent != null) return getChildren$2(parent);
  const siblings = [elem];
  let { prev, next } = elem;
  while (prev != null) {
    siblings.unshift(prev);
    ({ prev } = prev);
  }
  while (next != null) {
    siblings.push(next);
    ({ next } = next);
  }
  return siblings;
}
/**
 * Gets an attribute from an element.
 *
 * @category Traversal
 * @param elem Element to check.
 * @param name Attribute name to retrieve.
 * @returns The element's attribute value, or `undefined`.
 */
function getAttributeValue$2(elem, name) {
  var _a;
  return (_a = elem.attribs) === null || _a === void 0 ? void 0 : _a[name];
}
/**
 * Checks whether an element has an attribute.
 *
 * @category Traversal
 * @param elem Element to check.
 * @param name Attribute name to look for.
 * @returns Returns whether `elem` has the attribute `name`.
 */
function hasAttrib$2(elem, name) {
  return (
    elem.attribs != null &&
    Object.prototype.hasOwnProperty.call(elem.attribs, name) &&
    elem.attribs[name] != null
  );
}
/**
 * Get the tag name of an element.
 *
 * @category Traversal
 * @param elem The element to get the name for.
 * @returns The tag name of `elem`.
 */
function getName$2(elem) {
  return elem.name;
}
/**
 * Returns the next element sibling of a node.
 *
 * @category Traversal
 * @param elem The element to get the next sibling of.
 * @returns `elem`'s next sibling that is a tag, or `null` if there is no next
 * sibling.
 */
function nextElementSibling$1(elem) {
  let { next } = elem;
  while (next !== null && !lib$5.isTag(next)) ({ next } = next);
  return next;
}
/**
 * Returns the previous element sibling of a node.
 *
 * @category Traversal
 * @param elem The element to get the previous sibling of.
 * @returns `elem`'s previous sibling that is a tag, or `null` if there is no
 * previous sibling.
 */
function prevElementSibling$1(elem) {
  let { prev } = elem;
  while (prev !== null && !lib$5.isTag(prev)) ({ prev } = prev);
  return prev;
}

/**
 * Remove an element from the dom
 *
 * @category Manipulation
 * @param elem The element to be removed
 */
function removeElement$1(elem) {
  if (elem.prev) elem.prev.next = elem.next;
  if (elem.next) elem.next.prev = elem.prev;
  if (elem.parent) {
    const childs = elem.parent.children;
    const childsIndex = childs.lastIndexOf(elem);
    if (childsIndex >= 0) {
      childs.splice(childsIndex, 1);
    }
  }
  elem.next = null;
  elem.prev = null;
  elem.parent = null;
}
/**
 * Replace an element in the dom
 *
 * @category Manipulation
 * @param elem The element to be replaced
 * @param replacement The element to be added
 */
function replaceElement$1(elem, replacement) {
  const prev = (replacement.prev = elem.prev);
  if (prev) {
    prev.next = replacement;
  }
  const next = (replacement.next = elem.next);
  if (next) {
    next.prev = replacement;
  }
  const parent = (replacement.parent = elem.parent);
  if (parent) {
    const childs = parent.children;
    childs[childs.lastIndexOf(elem)] = replacement;
    elem.parent = null;
  }
}
/**
 * Append a child to an element.
 *
 * @category Manipulation
 * @param parent The element to append to.
 * @param child The element to be added as a child.
 */
function appendChild$1(parent, child) {
  removeElement$1(child);
  child.next = null;
  child.parent = parent;
  if (parent.children.push(child) > 1) {
    const sibling = parent.children[parent.children.length - 2];
    sibling.next = child;
    child.prev = sibling;
  } else {
    child.prev = null;
  }
}
/**
 * Append an element after another.
 *
 * @category Manipulation
 * @param elem The element to append after.
 * @param next The element be added.
 */
function append$3(elem, next) {
  removeElement$1(next);
  const { parent } = elem;
  const currNext = elem.next;
  next.next = currNext;
  next.prev = elem;
  elem.next = next;
  next.parent = parent;
  if (currNext) {
    currNext.prev = next;
    if (parent) {
      const childs = parent.children;
      childs.splice(childs.lastIndexOf(currNext), 0, next);
    }
  } else if (parent) {
    parent.children.push(next);
  }
}
/**
 * Prepend a child to an element.
 *
 * @category Manipulation
 * @param parent The element to prepend before.
 * @param child The element to be added as a child.
 */
function prependChild$1(parent, child) {
  removeElement$1(child);
  child.parent = parent;
  child.prev = null;
  if (parent.children.unshift(child) !== 1) {
    const sibling = parent.children[1];
    sibling.prev = child;
    child.next = sibling;
  } else {
    child.next = null;
  }
}
/**
 * Prepend an element before another.
 *
 * @category Manipulation
 * @param elem The element to prepend before.
 * @param prev The element be added.
 */
function prepend$2(elem, prev) {
  removeElement$1(prev);
  const { parent } = elem;
  if (parent) {
    const childs = parent.children;
    childs.splice(childs.indexOf(elem), 0, prev);
  }
  if (elem.prev) {
    elem.prev.next = prev;
  }
  prev.parent = parent;
  prev.prev = elem.prev;
  prev.next = elem;
  elem.prev = prev;
}

/**
 * Search a node and its children for nodes passing a test function. If `node` is not an array, it will be wrapped in one.
 *
 * @category Querying
 * @param test Function to test nodes on.
 * @param node Node to search. Will be included in the result set if it matches.
 * @param recurse Also consider child nodes.
 * @param limit Maximum number of nodes to return.
 * @returns All nodes passing `test`.
 */
function filter$5(test, node, recurse = true, limit = Infinity) {
  return find$6(test, Array.isArray(node) ? node : [node], recurse, limit);
}
/**
 * Search an array of nodes and their children for nodes passing a test function.
 *
 * @category Querying
 * @param test Function to test nodes on.
 * @param nodes Array of nodes to search.
 * @param recurse Also consider child nodes.
 * @param limit Maximum number of nodes to return.
 * @returns All nodes passing `test`.
 */
function find$6(test, nodes, recurse, limit) {
  const result = [];
  /** Stack of the arrays we are looking at. */
  const nodeStack = [nodes];
  /** Stack of the indices within the arrays. */
  const indexStack = [0];
  for (;;) {
    // First, check if the current array has any more elements to look at.
    if (indexStack[0] >= nodeStack[0].length) {
      // If we have no more arrays to look at, we are done.
      if (indexStack.length === 1) {
        return result;
      }
      // Otherwise, remove the current array from the stack.
      nodeStack.shift();
      indexStack.shift();
      // Loop back to the start to continue with the next array.
      continue;
    }
    const elem = nodeStack[0][indexStack[0]++];
    if (test(elem)) {
      result.push(elem);
      if (--limit <= 0) return result;
    }
    if (recurse && lib$5.hasChildren(elem) && elem.children.length > 0) {
      /*
       * Add the children to the stack. We are depth-first, so this is
       * the next array we look at.
       */
      indexStack.unshift(0);
      nodeStack.unshift(elem.children);
    }
  }
}
/**
 * Finds the first element inside of an array that matches a test function. This is an alias for `Array.prototype.find`.
 *
 * @category Querying
 * @param test Function to test nodes on.
 * @param nodes Array of nodes to search.
 * @returns The first node in the array that passes `test`.
 * @deprecated Use `Array.prototype.find` directly.
 */
function findOneChild$1(test, nodes) {
  return nodes.find(test);
}
/**
 * Finds one element in a tree that passes a test.
 *
 * @category Querying
 * @param test Function to test nodes on.
 * @param nodes Node or array of nodes to search.
 * @param recurse Also consider child nodes.
 * @returns The first node that passes `test`.
 */
function findOne$2(test, nodes, recurse = true) {
  let elem = null;
  for (let i = 0; i < nodes.length && !elem; i++) {
    const node = nodes[i];
    if (!lib$5.isTag(node)) {
      continue;
    } else if (test(node)) {
      elem = node;
    } else if (recurse && node.children.length > 0) {
      elem = findOne$2(test, node.children, true);
    }
  }
  return elem;
}
/**
 * Checks if a tree of nodes contains at least one node passing a test.
 *
 * @category Querying
 * @param test Function to test nodes on.
 * @param nodes Array of nodes to search.
 * @returns Whether a tree of nodes contains at least one node passing the test.
 */
function existsOne$2(test, nodes) {
  return nodes.some(
    (checked) =>
      lib$5.isTag(checked) &&
      (test(checked) || existsOne$2(test, checked.children)),
  );
}
/**
 * Search an array of nodes and their children for elements passing a test function.
 *
 * Same as `find`, but limited to elements and with less options, leading to reduced complexity.
 *
 * @category Querying
 * @param test Function to test nodes on.
 * @param nodes Array of nodes to search.
 * @returns All nodes passing `test`.
 */
function findAll$5(test, nodes) {
  const result = [];
  const nodeStack = [nodes];
  const indexStack = [0];
  for (;;) {
    if (indexStack[0] >= nodeStack[0].length) {
      if (nodeStack.length === 1) {
        return result;
      }
      // Otherwise, remove the current array from the stack.
      nodeStack.shift();
      indexStack.shift();
      // Loop back to the start to continue with the next array.
      continue;
    }
    const elem = nodeStack[0][indexStack[0]++];
    if (!lib$5.isTag(elem)) continue;
    if (test(elem)) result.push(elem);
    if (elem.children.length > 0) {
      indexStack.unshift(0);
      nodeStack.unshift(elem.children);
    }
  }
}

/**
 * A map of functions to check nodes against.
 */
const Checks$1 = {
  tag_name(name) {
    if (typeof name === "function") {
      return (elem) => lib$5.isTag(elem) && name(elem.name);
    } else if (name === "*") {
      return lib$5.isTag;
    }
    return (elem) => lib$5.isTag(elem) && elem.name === name;
  },
  tag_type(type) {
    if (typeof type === "function") {
      return (elem) => type(elem.type);
    }
    return (elem) => elem.type === type;
  },
  tag_contains(data) {
    if (typeof data === "function") {
      return (elem) => lib$5.isText(elem) && data(elem.data);
    }
    return (elem) => lib$5.isText(elem) && elem.data === data;
  },
};
/**
 * Returns a function to check whether a node has an attribute with a particular
 * value.
 *
 * @param attrib Attribute to check.
 * @param value Attribute value to look for.
 * @returns A function to check whether the a node has an attribute with a
 *   particular value.
 */
function getAttribCheck$1(attrib, value) {
  if (typeof value === "function") {
    return (elem) => lib$5.isTag(elem) && value(elem.attribs[attrib]);
  }
  return (elem) => lib$5.isTag(elem) && elem.attribs[attrib] === value;
}
/**
 * Returns a function that returns `true` if either of the input functions
 * returns `true` for a node.
 *
 * @param a First function to combine.
 * @param b Second function to combine.
 * @returns A function taking a node and returning `true` if either of the input
 *   functions returns `true` for the node.
 */
function combineFuncs$1(a, b) {
  return (elem) => a(elem) || b(elem);
}
/**
 * Returns a function that executes all checks in `options` and returns `true`
 * if any of them match a node.
 *
 * @param options An object describing nodes to look for.
 * @returns A function that executes all checks in `options` and returns `true`
 *   if any of them match a node.
 */
function compileTest$1(options) {
  const funcs = Object.keys(options).map((key) => {
    const value = options[key];
    return Object.prototype.hasOwnProperty.call(Checks$1, key)
      ? Checks$1[key](value)
      : getAttribCheck$1(key, value);
  });
  return funcs.length === 0 ? null : funcs.reduce(combineFuncs$1);
}
/**
 * Checks whether a node matches the description in `options`.
 *
 * @category Legacy Query Functions
 * @param options An object describing nodes to look for.
 * @param node The element to test.
 * @returns Whether the element matches the description in `options`.
 */
function testElement$1(options, node) {
  const test = compileTest$1(options);
  return test ? test(node) : true;
}
/**
 * Returns all nodes that match `options`.
 *
 * @category Legacy Query Functions
 * @param options An object describing nodes to look for.
 * @param nodes Nodes to search through.
 * @param recurse Also consider child nodes.
 * @param limit Maximum number of nodes to return.
 * @returns All nodes that match `options`.
 */
function getElements$1(options, nodes, recurse, limit = Infinity) {
  const test = compileTest$1(options);
  return test ? filter$5(test, nodes, recurse, limit) : [];
}
/**
 * Returns the node with the supplied ID.
 *
 * @category Legacy Query Functions
 * @param id The unique ID attribute value to look for.
 * @param nodes Nodes to search through.
 * @param recurse Also consider child nodes.
 * @returns The node with the supplied ID.
 */
function getElementById$1(id, nodes, recurse = true) {
  if (!Array.isArray(nodes)) nodes = [nodes];
  return findOne$2(getAttribCheck$1("id", id), nodes, recurse);
}
/**
 * Returns all nodes with the supplied `tagName`.
 *
 * @category Legacy Query Functions
 * @param tagName Tag name to search for.
 * @param nodes Nodes to search through.
 * @param recurse Also consider child nodes.
 * @param limit Maximum number of nodes to return.
 * @returns All nodes with the supplied `tagName`.
 */
function getElementsByTagName$1(
  tagName,
  nodes,
  recurse = true,
  limit = Infinity,
) {
  return filter$5(Checks$1["tag_name"](tagName), nodes, recurse, limit);
}
/**
 * Returns all nodes with the supplied `type`.
 *
 * @category Legacy Query Functions
 * @param type Element type to look for.
 * @param nodes Nodes to search through.
 * @param recurse Also consider child nodes.
 * @param limit Maximum number of nodes to return.
 * @returns All nodes with the supplied `type`.
 */
function getElementsByTagType$1(type, nodes, recurse = true, limit = Infinity) {
  return filter$5(Checks$1["tag_type"](type), nodes, recurse, limit);
}

/**
 * Given an array of nodes, remove any member that is contained by another
 * member.
 *
 * @category Helpers
 * @param nodes Nodes to filter.
 * @returns Remaining nodes that aren't contained by other nodes.
 */
function removeSubsets$1(nodes) {
  let idx = nodes.length;
  /*
   * Check if each node (or one of its ancestors) is already contained in the
   * array.
   */
  while (--idx >= 0) {
    const node = nodes[idx];
    /*
     * Remove the node if it is not unique.
     * We are going through the array from the end, so we only
     * have to check nodes that preceed the node under consideration in the array.
     */
    if (idx > 0 && nodes.lastIndexOf(node, idx - 1) >= 0) {
      nodes.splice(idx, 1);
      continue;
    }
    for (let ancestor = node.parent; ancestor; ancestor = ancestor.parent) {
      if (nodes.includes(ancestor)) {
        nodes.splice(idx, 1);
        break;
      }
    }
  }
  return nodes;
}
/**
 * @category Helpers
 * @see {@link http://dom.spec.whatwg.org/#dom-node-comparedocumentposition}
 */
var DocumentPosition;
(function (DocumentPosition) {
  DocumentPosition[(DocumentPosition["DISCONNECTED"] = 1)] = "DISCONNECTED";
  DocumentPosition[(DocumentPosition["PRECEDING"] = 2)] = "PRECEDING";
  DocumentPosition[(DocumentPosition["FOLLOWING"] = 4)] = "FOLLOWING";
  DocumentPosition[(DocumentPosition["CONTAINS"] = 8)] = "CONTAINS";
  DocumentPosition[(DocumentPosition["CONTAINED_BY"] = 16)] = "CONTAINED_BY";
})(DocumentPosition || (DocumentPosition = {}));
/**
 * Compare the position of one node against another node in any other document,
 * returning a bitmask with the values from {@link DocumentPosition}.
 *
 * Document order:
 * > There is an ordering, document order, defined on all the nodes in the
 * > document corresponding to the order in which the first character of the
 * > XML representation of each node occurs in the XML representation of the
 * > document after expansion of general entities. Thus, the document element
 * > node will be the first node. Element nodes occur before their children.
 * > Thus, document order orders element nodes in order of the occurrence of
 * > their start-tag in the XML (after expansion of entities). The attribute
 * > nodes of an element occur after the element and before its children. The
 * > relative order of attribute nodes is implementation-dependent.
 *
 * Source:
 * http://www.w3.org/TR/DOM-Level-3-Core/glossary.html#dt-document-order
 *
 * @category Helpers
 * @param nodeA The first node to use in the comparison
 * @param nodeB The second node to use in the comparison
 * @returns A bitmask describing the input nodes' relative position.
 *
 * See http://dom.spec.whatwg.org/#dom-node-comparedocumentposition for
 * a description of these values.
 */
function compareDocumentPosition(nodeA, nodeB) {
  const aParents = [];
  const bParents = [];
  if (nodeA === nodeB) {
    return 0;
  }
  let current = lib$5.hasChildren(nodeA) ? nodeA : nodeA.parent;
  while (current) {
    aParents.unshift(current);
    current = current.parent;
  }
  current = lib$5.hasChildren(nodeB) ? nodeB : nodeB.parent;
  while (current) {
    bParents.unshift(current);
    current = current.parent;
  }
  const maxIdx = Math.min(aParents.length, bParents.length);
  let idx = 0;
  while (idx < maxIdx && aParents[idx] === bParents[idx]) {
    idx++;
  }
  if (idx === 0) {
    return DocumentPosition.DISCONNECTED;
  }
  const sharedParent = aParents[idx - 1];
  const siblings = sharedParent.children;
  const aSibling = aParents[idx];
  const bSibling = bParents[idx];
  if (siblings.indexOf(aSibling) > siblings.indexOf(bSibling)) {
    if (sharedParent === nodeB) {
      return DocumentPosition.FOLLOWING | DocumentPosition.CONTAINED_BY;
    }
    return DocumentPosition.FOLLOWING;
  }
  if (sharedParent === nodeA) {
    return DocumentPosition.PRECEDING | DocumentPosition.CONTAINS;
  }
  return DocumentPosition.PRECEDING;
}
/**
 * Sort an array of nodes based on their relative position in the document,
 * removing any duplicate nodes. If the array contains nodes that do not belong
 * to the same document, sort order is unspecified.
 *
 * @category Helpers
 * @param nodes Array of DOM nodes.
 * @returns Collection of unique nodes, sorted in document order.
 */
function uniqueSort(nodes) {
  nodes = nodes.filter((node, i, arr) => !arr.includes(node, i + 1));
  nodes.sort((a, b) => {
    const relative = compareDocumentPosition(a, b);
    if (relative & DocumentPosition.PRECEDING) {
      return -1;
    } else if (relative & DocumentPosition.FOLLOWING) {
      return 1;
    }
    return 0;
  });
  return nodes;
}

/**
 * Get the feed object from the root of a DOM tree.
 *
 * @category Feeds
 * @param doc - The DOM to to extract the feed from.
 * @returns The feed.
 */
function getFeed$1(doc) {
  const feedRoot = getOneElement$1(isValidFeed$1, doc);
  return !feedRoot
    ? null
    : feedRoot.name === "feed"
      ? getAtomFeed$1(feedRoot)
      : getRssFeed$1(feedRoot);
}
/**
 * Parse an Atom feed.
 *
 * @param feedRoot The root of the feed.
 * @returns The parsed feed.
 */
function getAtomFeed$1(feedRoot) {
  var _a;
  const childs = feedRoot.children;
  const feed = {
    type: "atom",
    items: getElementsByTagName$1("entry", childs).map((item) => {
      var _a;
      const { children } = item;
      const entry = { media: getMediaElements$1(children) };
      addConditionally$1(entry, "id", "id", children);
      addConditionally$1(entry, "title", "title", children);
      const href =
        (_a = getOneElement$1("link", children)) === null || _a === void 0
          ? void 0
          : _a.attribs["href"];
      if (href) {
        entry.link = href;
      }
      const description =
        fetch$2("summary", children) || fetch$2("content", children);
      if (description) {
        entry.description = description;
      }
      const pubDate = fetch$2("updated", children);
      if (pubDate) {
        entry.pubDate = new Date(pubDate);
      }
      return entry;
    }),
  };
  addConditionally$1(feed, "id", "id", childs);
  addConditionally$1(feed, "title", "title", childs);
  const href =
    (_a = getOneElement$1("link", childs)) === null || _a === void 0
      ? void 0
      : _a.attribs["href"];
  if (href) {
    feed.link = href;
  }
  addConditionally$1(feed, "description", "subtitle", childs);
  const updated = fetch$2("updated", childs);
  if (updated) {
    feed.updated = new Date(updated);
  }
  addConditionally$1(feed, "author", "email", childs, true);
  return feed;
}
/**
 * Parse a RSS feed.
 *
 * @param feedRoot The root of the feed.
 * @returns The parsed feed.
 */
function getRssFeed$1(feedRoot) {
  var _a, _b;
  const childs =
    (_b =
      (_a = getOneElement$1("channel", feedRoot.children)) === null ||
      _a === void 0
        ? void 0
        : _a.children) !== null && _b !== void 0
      ? _b
      : [];
  const feed = {
    type: feedRoot.name.substr(0, 3),
    id: "",
    items: getElementsByTagName$1("item", feedRoot.children).map((item) => {
      const { children } = item;
      const entry = { media: getMediaElements$1(children) };
      addConditionally$1(entry, "id", "guid", children);
      addConditionally$1(entry, "title", "title", children);
      addConditionally$1(entry, "link", "link", children);
      addConditionally$1(entry, "description", "description", children);
      const pubDate =
        fetch$2("pubDate", children) || fetch$2("dc:date", children);
      if (pubDate) entry.pubDate = new Date(pubDate);
      return entry;
    }),
  };
  addConditionally$1(feed, "title", "title", childs);
  addConditionally$1(feed, "link", "link", childs);
  addConditionally$1(feed, "description", "description", childs);
  const updated = fetch$2("lastBuildDate", childs);
  if (updated) {
    feed.updated = new Date(updated);
  }
  addConditionally$1(feed, "author", "managingEditor", childs, true);
  return feed;
}
const MEDIA_KEYS_STRING$1 = ["url", "type", "lang"];
const MEDIA_KEYS_INT$1 = [
  "fileSize",
  "bitrate",
  "framerate",
  "samplingrate",
  "channels",
  "duration",
  "height",
  "width",
];
/**
 * Get all media elements of a feed item.
 *
 * @param where Nodes to search in.
 * @returns Media elements.
 */
function getMediaElements$1(where) {
  return getElementsByTagName$1("media:content", where).map((elem) => {
    const { attribs } = elem;
    const media = {
      medium: attribs["medium"],
      isDefault: !!attribs["isDefault"],
    };
    for (const attrib of MEDIA_KEYS_STRING$1) {
      if (attribs[attrib]) {
        media[attrib] = attribs[attrib];
      }
    }
    for (const attrib of MEDIA_KEYS_INT$1) {
      if (attribs[attrib]) {
        media[attrib] = parseInt(attribs[attrib], 10);
      }
    }
    if (attribs["expression"]) {
      media.expression = attribs["expression"];
    }
    return media;
  });
}
/**
 * Get one element by tag name.
 *
 * @param tagName Tag name to look for
 * @param node Node to search in
 * @returns The element or null
 */
function getOneElement$1(tagName, node) {
  return getElementsByTagName$1(tagName, node, true, 1)[0];
}
/**
 * Get the text content of an element with a certain tag name.
 *
 * @param tagName Tag name to look for.
 * @param where Node to search in.
 * @param recurse Whether to recurse into child nodes.
 * @returns The text content of the element.
 */
function fetch$2(tagName, where, recurse = false) {
  return textContent$1(
    getElementsByTagName$1(tagName, where, recurse, 1),
  ).trim();
}
/**
 * Adds a property to an object if it has a value.
 *
 * @param obj Object to be extended
 * @param prop Property name
 * @param tagName Tag name that contains the conditionally added property
 * @param where Element to search for the property
 * @param recurse Whether to recurse into child nodes.
 */
function addConditionally$1(obj, prop, tagName, where, recurse = false) {
  const val = fetch$2(tagName, where, recurse);
  if (val) obj[prop] = val;
}
/**
 * Checks if an element is a feed root node.
 *
 * @param value The name of the element to check.
 * @returns Whether an element is a feed root node.
 */
function isValidFeed$1(value) {
  return value === "rss" || value === "feed" || value === "rdf:RDF";
}

const DomUtils$1 = /*#__PURE__*/ Object.freeze(
  /*#__PURE__*/ Object.defineProperty(
    {
      __proto__: null,
      get DocumentPosition() {
        return DocumentPosition;
      },
      append: append$3,
      appendChild: appendChild$1,
      compareDocumentPosition,
      existsOne: existsOne$2,
      filter: filter$5,
      find: find$6,
      findAll: findAll$5,
      findOne: findOne$2,
      findOneChild: findOneChild$1,
      getAttributeValue: getAttributeValue$2,
      getChildren: getChildren$2,
      getElementById: getElementById$1,
      getElements: getElements$1,
      getElementsByTagName: getElementsByTagName$1,
      getElementsByTagType: getElementsByTagType$1,
      getFeed: getFeed$1,
      getInnerHTML: getInnerHTML$1,
      getName: getName$2,
      getOuterHTML: getOuterHTML$1,
      getParent: getParent$2,
      getSiblings: getSiblings$2,
      getText: getText$2,
      hasAttrib: hasAttrib$2,
      hasChildren: lib$5.hasChildren,
      innerText: innerText$1,
      isCDATA: lib$5.isCDATA,
      isComment: lib$5.isComment,
      isDocument: lib$5.isDocument,
      isTag: lib$5.isTag,
      isText: lib$5.isText,
      nextElementSibling: nextElementSibling$1,
      prepend: prepend$2,
      prependChild: prependChild$1,
      prevElementSibling: prevElementSibling$1,
      removeElement: removeElement$1,
      removeSubsets: removeSubsets$1,
      replaceElement: replaceElement$1,
      testElement: testElement$1,
      textContent: textContent$1,
      uniqueSort,
    },
    Symbol.toStringTag,
    { value: "Module" },
  ),
);

/**
 * Helper function to render a DOM.
 *
 * @param that - Cheerio instance to render.
 * @param dom - The DOM to render. Defaults to `that`'s root.
 * @param options - Options for rendering.
 * @returns The rendered document.
 */
function render$1(that, dom, options) {
  if (!that) return "";
  return that(
    dom !== null && dom !== void 0 ? dom : that._root.children,
    null,
    undefined,
    options,
  ).toString();
}
/**
 * Checks if a passed object is an options object.
 *
 * @param dom - Object to check if it is an options object.
 * @returns Whether the object is an options object.
 */
function isOptions(dom, options) {
  return (
    !options &&
    typeof dom === "object" &&
    dom != null &&
    !("length" in dom) &&
    !("type" in dom)
  );
}
function html$1(dom, options) {
  /*
   * Be flexible about parameters, sometimes we call html(),
   * with options as only parameter
   * check dom argument for dom element specific properties
   * assume there is no 'length' or 'type' properties in the options object
   */
  const toRender = isOptions(dom) ? ((options = dom), undefined) : dom;
  /*
   * Sometimes `$.html()` is used without preloading html,
   * so fallback non-existing options to the default ones.
   */
  const opts = {
    ...defaultOpts$2,
    ...(this === null || this === void 0 ? void 0 : this._options),
    ...flatten(options !== null && options !== void 0 ? options : {}),
  };
  return render$1(this, toRender, opts);
}
/**
 * Render the document as XML.
 *
 * @param dom - Element to render.
 * @returns THe rendered document.
 */
function xml(dom) {
  const options = { ...this._options, xmlMode: true };
  return render$1(this, dom, options);
}
/**
 * Render the document as text.
 *
 * This returns the `textContent` of the passed elements. The result will
 * include the contents of `script` and `stype` elements. To avoid this, use
 * `.prop('innerText')` instead.
 *
 * @param elements - Elements to render.
 * @returns The rendered document.
 */
function text$1(elements) {
  const elems = elements ? elements : this ? this.root() : [];
  let ret = "";
  for (let i = 0; i < elems.length; i++) {
    ret += textContent$1(elems[i]);
  }
  return ret;
}
function parseHTML(
  data,
  context,
  keepScripts = typeof context === "boolean" ? context : false,
) {
  if (!data || typeof data !== "string") {
    return null;
  }
  if (typeof context === "boolean") {
    keepScripts = context;
  }
  const parsed = this.load(data, defaultOpts$2, false);
  if (!keepScripts) {
    parsed("script").remove();
  }
  /*
   * The `children` array is used by Cheerio internally to group elements that
   * share the same parents. When nodes created through `parseHTML` are
   * inserted into previously-existing DOM structures, they will be removed
   * from the `children` array. The results of `parseHTML` should remain
   * constant across these operations, so a shallow copy should be returned.
   */
  return parsed.root()[0].children.slice();
}
/**
 * Sometimes you need to work with the top-level root element. To query it, you
 * can use `$.root()`.
 *
 * @example
 *
 * ```js
 * $.root().append('<ul id="vegetables"></ul>').html();
 * //=> <ul id="fruits">...</ul><ul id="vegetables"></ul>
 * ```
 *
 * @returns Cheerio instance wrapping the root node.
 * @alias Cheerio.root
 */
function root() {
  return this(this._root);
}
/**
 * Checks to see if the `contained` DOM element is a descendant of the
 * `container` DOM element.
 *
 * @param container - Potential parent node.
 * @param contained - Potential child node.
 * @returns Indicates if the nodes contain one another.
 * @alias Cheerio.contains
 * @see {@link https://api.jquery.com/jQuery.contains/}
 */
function contains(container, contained) {
  // According to the jQuery API, an element does not "contain" itself
  if (contained === container) {
    return false;
  }
  /*
   * Step up the descendants, stopping when the root element is reached
   * (signaled by `.parent` returning a reference to the same object)
   */
  let next = contained;
  while (next && next !== next.parent) {
    next = next.parent;
    if (next === container) {
      return true;
    }
  }
  return false;
}
/**
 * $.merge().
 *
 * @param arr1 - First array.
 * @param arr2 - Second array.
 * @returns `arr1`, with elements of `arr2` inserted.
 * @alias Cheerio.merge
 * @see {@link https://api.jquery.com/jQuery.merge/}
 */
function merge$1(arr1, arr2) {
  if (!isArrayLike(arr1) || !isArrayLike(arr2)) {
    return;
  }
  let newLength = arr1.length;
  const len = +arr2.length;
  for (let i = 0; i < len; i++) {
    arr1[newLength++] = arr2[i];
  }
  arr1.length = newLength;
  return arr1;
}
/**
 * Checks if an object is array-like.
 *
 * @param item - Item to check.
 * @returns Indicates if the item is array-like.
 */
function isArrayLike(item) {
  if (Array.isArray(item)) {
    return true;
  }
  if (
    typeof item !== "object" ||
    !Object.prototype.hasOwnProperty.call(item, "length") ||
    typeof item.length !== "number" ||
    item.length < 0
  ) {
    return false;
  }
  for (let i = 0; i < item.length; i++) {
    if (!(i in item)) {
      return false;
    }
  }
  return true;
}

const staticMethods = /*#__PURE__*/ Object.freeze(
  /*#__PURE__*/ Object.defineProperty(
    {
      __proto__: null,
      contains,
      html: html$1,
      merge: merge$1,
      parseHTML,
      root,
      text: text$1,
      xml,
    },
    Symbol.toStringTag,
    { value: "Module" },
  ),
);

/**
 * This object will be used as the prototype for Nodes when creating a
 * DOM-Level-1-compliant structure.
 */
let Node$1 = class Node {
  constructor() {
    /** Parent of the node */
    this.parent = null;
    /** Previous sibling */
    this.prev = null;
    /** Next sibling */
    this.next = null;
    /** The start index of the node. Requires `withStartIndices` on the handler to be `true. */
    this.startIndex = null;
    /** The end index of the node. Requires `withEndIndices` on the handler to be `true. */
    this.endIndex = null;
  }
  // Read-write aliases for properties
  /**
   * Same as {@link parent}.
   * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
   */
  get parentNode() {
    return this.parent;
  }
  set parentNode(parent) {
    this.parent = parent;
  }
  /**
   * Same as {@link prev}.
   * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
   */
  get previousSibling() {
    return this.prev;
  }
  set previousSibling(prev) {
    this.prev = prev;
  }
  /**
   * Same as {@link next}.
   * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
   */
  get nextSibling() {
    return this.next;
  }
  set nextSibling(next) {
    this.next = next;
  }
  /**
   * Clone this node, and optionally its children.
   *
   * @param recursive Clone child nodes as well.
   * @returns A clone of the node.
   */
  cloneNode(recursive = false) {
    return cloneNode(this, recursive);
  }
};
/**
 * A node that contains some data.
 */
class DataNode extends Node$1 {
  /**
   * @param data The content of the data node
   */
  constructor(data) {
    super();
    this.data = data;
  }
  /**
   * Same as {@link data}.
   * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
   */
  get nodeValue() {
    return this.data;
  }
  set nodeValue(data) {
    this.data = data;
  }
}
/**
 * Text within the document.
 */
class Text extends DataNode {
  constructor() {
    super(...arguments);
    this.type = ElementType$1.Text;
  }
  get nodeType() {
    return 3;
  }
}
/**
 * Comments within the document.
 */
let Comment$a = class Comment extends DataNode {
  constructor() {
    super(...arguments);
    this.type = ElementType$1.Comment;
  }
  get nodeType() {
    return 8;
  }
};
/**
 * Processing instructions, including doc types.
 */
class ProcessingInstruction extends DataNode {
  constructor(name, data) {
    super(data);
    this.name = name;
    this.type = ElementType$1.Directive;
  }
  get nodeType() {
    return 1;
  }
}
/**
 * A `Node` that can have children.
 */
class NodeWithChildren extends Node$1 {
  /**
   * @param children Children of the node. Only certain node types can have children.
   */
  constructor(children) {
    super();
    this.children = children;
  }
  // Aliases
  /** First child of the node. */
  get firstChild() {
    var _a;
    return (_a = this.children[0]) !== null && _a !== void 0 ? _a : null;
  }
  /** Last child of the node. */
  get lastChild() {
    return this.children.length > 0
      ? this.children[this.children.length - 1]
      : null;
  }
  /**
   * Same as {@link children}.
   * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
   */
  get childNodes() {
    return this.children;
  }
  set childNodes(children) {
    this.children = children;
  }
}
class CDATA extends NodeWithChildren {
  constructor() {
    super(...arguments);
    this.type = ElementType$1.CDATA;
  }
  get nodeType() {
    return 4;
  }
}
/**
 * The root node of the document.
 */
class Document extends NodeWithChildren {
  constructor() {
    super(...arguments);
    this.type = ElementType$1.Root;
  }
  get nodeType() {
    return 9;
  }
}
/**
 * An element within the DOM.
 */
class Element extends NodeWithChildren {
  /**
   * @param name Name of the tag, eg. `div`, `span`.
   * @param attribs Object mapping attribute names to attribute values.
   * @param children Children of the node.
   */
  constructor(
    name,
    attribs,
    children = [],
    type = name === "script"
      ? ElementType$1.Script
      : name === "style"
        ? ElementType$1.Style
        : ElementType$1.Tag,
  ) {
    super(children);
    this.name = name;
    this.attribs = attribs;
    this.type = type;
  }
  get nodeType() {
    return 1;
  }
  // DOM Level 1 aliases
  /**
   * Same as {@link name}.
   * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
   */
  get tagName() {
    return this.name;
  }
  set tagName(name) {
    this.name = name;
  }
  get attributes() {
    return Object.keys(this.attribs).map((name) => {
      var _a, _b;
      return {
        name,
        value: this.attribs[name],
        namespace:
          (_a = this["x-attribsNamespace"]) === null || _a === void 0
            ? void 0
            : _a[name],
        prefix:
          (_b = this["x-attribsPrefix"]) === null || _b === void 0
            ? void 0
            : _b[name],
      };
    });
  }
}
/**
 * @param node Node to check.
 * @returns `true` if the node is a `Element`, `false` otherwise.
 */
function isTag$1(node) {
  return isTag$3(node);
}
/**
 * @param node Node to check.
 * @returns `true` if the node has the type `CDATA`, `false` otherwise.
 */
function isCDATA(node) {
  return node.type === ElementType$1.CDATA;
}
/**
 * @param node Node to check.
 * @returns `true` if the node has the type `Text`, `false` otherwise.
 */
function isText(node) {
  return node.type === ElementType$1.Text;
}
/**
 * @param node Node to check.
 * @returns `true` if the node has the type `Comment`, `false` otherwise.
 */
function isComment(node) {
  return node.type === ElementType$1.Comment;
}
/**
 * @param node Node to check.
 * @returns `true` if the node has the type `ProcessingInstruction`, `false` otherwise.
 */
function isDirective(node) {
  return node.type === ElementType$1.Directive;
}
/**
 * @param node Node to check.
 * @returns `true` if the node has the type `ProcessingInstruction`, `false` otherwise.
 */
function isDocument(node) {
  return node.type === ElementType$1.Root;
}
/**
 * @param node Node to check.
 * @returns `true` if the node has children, `false` otherwise.
 */
function hasChildren(node) {
  return Object.prototype.hasOwnProperty.call(node, "children");
}
/**
 * Clone a node, and optionally its children.
 *
 * @param recursive Clone child nodes as well.
 * @returns A clone of the node.
 */
function cloneNode(node, recursive = false) {
  let result;
  if (isText(node)) {
    result = new Text(node.data);
  } else if (isComment(node)) {
    result = new Comment$a(node.data);
  } else if (isTag$1(node)) {
    const children = recursive ? cloneChildren(node.children) : [];
    const clone = new Element(node.name, { ...node.attribs }, children);
    children.forEach((child) => (child.parent = clone));
    if (node.namespace != null) {
      clone.namespace = node.namespace;
    }
    if (node["x-attribsNamespace"]) {
      clone["x-attribsNamespace"] = { ...node["x-attribsNamespace"] };
    }
    if (node["x-attribsPrefix"]) {
      clone["x-attribsPrefix"] = { ...node["x-attribsPrefix"] };
    }
    result = clone;
  } else if (isCDATA(node)) {
    const children = recursive ? cloneChildren(node.children) : [];
    const clone = new CDATA(children);
    children.forEach((child) => (child.parent = clone));
    result = clone;
  } else if (isDocument(node)) {
    const children = recursive ? cloneChildren(node.children) : [];
    const clone = new Document(children);
    children.forEach((child) => (child.parent = clone));
    if (node["x-mode"]) {
      clone["x-mode"] = node["x-mode"];
    }
    result = clone;
  } else if (isDirective(node)) {
    const instruction = new ProcessingInstruction(node.name, node.data);
    if (node["x-name"] != null) {
      instruction["x-name"] = node["x-name"];
      instruction["x-publicId"] = node["x-publicId"];
      instruction["x-systemId"] = node["x-systemId"];
    }
    result = instruction;
  } else {
    throw new Error(`Not implemented yet: ${node.type}`);
  }
  result.startIndex = node.startIndex;
  result.endIndex = node.endIndex;
  if (node.sourceCodeLocation != null) {
    result.sourceCodeLocation = node.sourceCodeLocation;
  }
  return result;
}
function cloneChildren(childs) {
  const children = childs.map((child) => cloneNode(child, true));
  for (let i = 1; i < children.length; i++) {
    children[i].prev = children[i - 1];
    children[i - 1].next = children[i];
  }
  return children;
}

// Default options
const defaultOpts$1 = {
  withStartIndices: false,
  withEndIndices: false,
  xmlMode: false,
};
class DomHandler {
  /**
   * @param callback Called once parsing has completed.
   * @param options Settings for the handler.
   * @param elementCB Callback whenever a tag is closed.
   */
  constructor(callback, options, elementCB) {
    /** The elements of the DOM */
    this.dom = [];
    /** The root element for the DOM */
    this.root = new Document(this.dom);
    /** Indicated whether parsing has been completed. */
    this.done = false;
    /** Stack of open tags. */
    this.tagStack = [this.root];
    /** A data node that is still being written to. */
    this.lastNode = null;
    /** Reference to the parser instance. Used for location information. */
    this.parser = null;
    // Make it possible to skip arguments, for backwards-compatibility
    if (typeof options === "function") {
      elementCB = options;
      options = defaultOpts$1;
    }
    if (typeof callback === "object") {
      options = callback;
      callback = undefined;
    }
    this.callback = callback !== null && callback !== void 0 ? callback : null;
    this.options =
      options !== null && options !== void 0 ? options : defaultOpts$1;
    this.elementCB =
      elementCB !== null && elementCB !== void 0 ? elementCB : null;
  }
  onparserinit(parser) {
    this.parser = parser;
  }
  // Resets the handler back to starting state
  onreset() {
    this.dom = [];
    this.root = new Document(this.dom);
    this.done = false;
    this.tagStack = [this.root];
    this.lastNode = null;
    this.parser = null;
  }
  // Signals the handler that parsing is done
  onend() {
    if (this.done) return;
    this.done = true;
    this.parser = null;
    this.handleCallback(null);
  }
  onerror(error) {
    this.handleCallback(error);
  }
  onclosetag() {
    this.lastNode = null;
    const elem = this.tagStack.pop();
    if (this.options.withEndIndices) {
      elem.endIndex = this.parser.endIndex;
    }
    if (this.elementCB) this.elementCB(elem);
  }
  onopentag(name, attribs) {
    const type = this.options.xmlMode ? ElementType$1.Tag : undefined;
    const element = new Element(name, attribs, undefined, type);
    this.addNode(element);
    this.tagStack.push(element);
  }
  ontext(data) {
    const { lastNode } = this;
    if (lastNode && lastNode.type === ElementType$1.Text) {
      lastNode.data += data;
      if (this.options.withEndIndices) {
        lastNode.endIndex = this.parser.endIndex;
      }
    } else {
      const node = new Text(data);
      this.addNode(node);
      this.lastNode = node;
    }
  }
  oncomment(data) {
    if (this.lastNode && this.lastNode.type === ElementType$1.Comment) {
      this.lastNode.data += data;
      return;
    }
    const node = new Comment$a(data);
    this.addNode(node);
    this.lastNode = node;
  }
  oncommentend() {
    this.lastNode = null;
  }
  oncdatastart() {
    const text = new Text("");
    const node = new CDATA([text]);
    this.addNode(node);
    text.parent = node;
    this.lastNode = text;
  }
  oncdataend() {
    this.lastNode = null;
  }
  onprocessinginstruction(name, data) {
    const node = new ProcessingInstruction(name, data);
    this.addNode(node);
  }
  handleCallback(error) {
    if (typeof this.callback === "function") {
      this.callback(error, this.dom);
    } else if (error) {
      throw error;
    }
  }
  addNode(node) {
    const parent = this.tagStack[this.tagStack.length - 1];
    const previousSibling = parent.children[parent.children.length - 1];
    if (this.options.withStartIndices) {
      node.startIndex = this.parser.startIndex;
    }
    if (this.options.withEndIndices) {
      node.endIndex = this.parser.endIndex;
    }
    parent.children.push(node);
    if (previousSibling) {
      node.prev = previousSibling;
      previousSibling.next = node;
    }
    node.parent = parent;
    this.lastNode = null;
  }
}

/**
 * Checks if an object is a Cheerio instance.
 *
 * @category Utils
 * @param maybeCheerio - The object to check.
 * @returns Whether the object is a Cheerio instance.
 */
function isCheerio(maybeCheerio) {
  return maybeCheerio.cheerio != null;
}
/**
 * Convert a string to camel case notation.
 *
 * @private
 * @category Utils
 * @param str - The string to be converted.
 * @returns String in camel case notation.
 */
function camelCase(str) {
  return str.replace(/[_.-](\w|$)/g, (_, x) => x.toUpperCase());
}
/**
 * Convert a string from camel case to "CSS case", where word boundaries are
 * described by hyphens ("-") and all characters are lower-case.
 *
 * @private
 * @category Utils
 * @param str - The string to be converted.
 * @returns String in "CSS case".
 */
function cssCase(str) {
  return str.replace(/[A-Z]/g, "-$&").toLowerCase();
}
/**
 * Iterate over each DOM element without creating intermediary Cheerio instances.
 *
 * This is indented for use internally to avoid otherwise unnecessary memory
 * pressure introduced by _make.
 *
 * @category Utils
 * @param array - The array to iterate over.
 * @param fn - Function to call.
 * @returns The original instance.
 */
function domEach(array, fn) {
  const len = array.length;
  for (let i = 0; i < len; i++) fn(array[i], i);
  return array;
}
/**
 * Create a deep copy of the given DOM structure. Sets the parents of the copies
 * of the passed nodes to `null`.
 *
 * @private
 * @category Utils
 * @param dom - The domhandler-compliant DOM structure.
 * @returns - The cloned DOM.
 */
function cloneDom(dom) {
  const clone =
    "length" in dom
      ? Array.prototype.map.call(dom, (el) => cloneNode(el, true))
      : [cloneNode(dom, true)];
  // Add a root node around the cloned nodes
  const root = new Document(clone);
  clone.forEach((node) => {
    node.parent = root;
  });
  return clone;
}
var CharacterCodes;
(function (CharacterCodes) {
  CharacterCodes[(CharacterCodes["LowerA"] = 97)] = "LowerA";
  CharacterCodes[(CharacterCodes["LowerZ"] = 122)] = "LowerZ";
  CharacterCodes[(CharacterCodes["UpperA"] = 65)] = "UpperA";
  CharacterCodes[(CharacterCodes["UpperZ"] = 90)] = "UpperZ";
  CharacterCodes[(CharacterCodes["Exclamation"] = 33)] = "Exclamation";
})(CharacterCodes || (CharacterCodes = {}));
/**
 * Check if string is HTML.
 *
 * Tests for a `<` within a string, immediate followed by a letter and
 * eventually followed by a `>`.
 *
 * @private
 * @category Utils
 * @param str - The string to check.
 * @returns Indicates if `str` is HTML.
 */
function isHtml(str) {
  const tagStart = str.indexOf("<");
  if (tagStart < 0 || tagStart > str.length - 3) return false;
  const tagChar = str.charCodeAt(tagStart + 1);
  return (
    ((tagChar >= CharacterCodes.LowerA && tagChar <= CharacterCodes.LowerZ) ||
      (tagChar >= CharacterCodes.UpperA && tagChar <= CharacterCodes.UpperZ) ||
      tagChar === CharacterCodes.Exclamation) &&
    str.includes(">", tagStart + 2)
  );
}

/**
 * Methods for getting and modifying attributes.
 *
 * @module cheerio/attributes
 */
const hasOwn = Object.prototype.hasOwnProperty;
const rspace = /\s+/;
const dataAttrPrefix = "data-";
/*
 * Lookup table for coercing string data-* attributes to their corresponding
 * JavaScript primitives
 */
const primitives = {
  null: null,
  true: true,
  false: false,
};
// Attributes that are booleans
const rboolean =
  /^(?:autofocus|autoplay|async|checked|controls|defer|disabled|hidden|loop|multiple|open|readonly|required|scoped|selected)$/i;
// Matches strings that look like JSON objects or arrays
const rbrace = /^{[^]*}$|^\[[^]*]$/;
function getAttr(elem, name, xmlMode) {
  var _a;
  if (!elem || !isTag$1(elem)) return undefined;
  (_a = elem.attribs) !== null && _a !== void 0 ? _a : (elem.attribs = {});
  // Return the entire attribs object if no attribute specified
  if (!name) {
    return elem.attribs;
  }
  if (hasOwn.call(elem.attribs, name)) {
    // Get the (decoded) attribute
    return !xmlMode && rboolean.test(name) ? name : elem.attribs[name];
  }
  // Mimic the DOM and return text content as value for `option's`
  if (elem.name === "option" && name === "value") {
    return text$1(elem.children);
  }
  // Mimic DOM with default value for radios/checkboxes
  if (
    elem.name === "input" &&
    (elem.attribs["type"] === "radio" || elem.attribs["type"] === "checkbox") &&
    name === "value"
  ) {
    return "on";
  }
  return undefined;
}
/**
 * Sets the value of an attribute. The attribute will be deleted if the value is `null`.
 *
 * @private
 * @param el - The element to set the attribute on.
 * @param name - The attribute's name.
 * @param value - The attribute's value.
 */
function setAttr(el, name, value) {
  if (value === null) {
    removeAttribute(el, name);
  } else {
    el.attribs[name] = `${value}`;
  }
}
function attr(name, value) {
  // Set the value (with attr map support)
  if (typeof name === "object" || value !== undefined) {
    if (typeof value === "function") {
      if (typeof name !== "string") {
        {
          throw new Error("Bad combination of arguments.");
        }
      }
      return domEach(this, (el, i) => {
        if (isTag$1(el)) setAttr(el, name, value.call(el, i, el.attribs[name]));
      });
    }
    return domEach(this, (el) => {
      if (!isTag$1(el)) return;
      if (typeof name === "object") {
        Object.keys(name).forEach((objName) => {
          const objValue = name[objName];
          setAttr(el, objName, objValue);
        });
      } else {
        setAttr(el, name, value);
      }
    });
  }
  return arguments.length > 1
    ? this
    : getAttr(this[0], name, this.options.xmlMode);
}
/**
 * Gets a node's prop.
 *
 * @private
 * @category Attributes
 * @param el - Element to get the prop of.
 * @param name - Name of the prop.
 * @returns The prop's value.
 */
function getProp(el, name, xmlMode) {
  return name in el
    ? // @ts-expect-error TS doesn't like us accessing the value directly here.
      el[name]
    : !xmlMode && rboolean.test(name)
      ? getAttr(el, name, false) !== undefined
      : getAttr(el, name, xmlMode);
}
/**
 * Sets the value of a prop.
 *
 * @private
 * @param el - The element to set the prop on.
 * @param name - The prop's name.
 * @param value - The prop's value.
 */
function setProp(el, name, value, xmlMode) {
  if (name in el) {
    // @ts-expect-error Overriding value
    el[name] = value;
  } else {
    setAttr(
      el,
      name,
      !xmlMode && rboolean.test(name) ? (value ? "" : null) : `${value}`,
    );
  }
}
function prop(name, value) {
  var _a;
  if (typeof name === "string" && value === undefined) {
    const el = this[0];
    if (!el || !isTag$1(el)) return undefined;
    switch (name) {
      case "style": {
        const property = this.css();
        const keys = Object.keys(property);
        keys.forEach((p, i) => {
          property[i] = p;
        });
        property.length = keys.length;
        return property;
      }
      case "tagName":
      case "nodeName": {
        return el.name.toUpperCase();
      }
      case "href":
      case "src": {
        const prop =
          (_a = el.attribs) === null || _a === void 0 ? void 0 : _a[name];
        /* eslint-disable node/no-unsupported-features/node-builtins */
        if (
          typeof URL !== "undefined" &&
          ((name === "href" && (el.tagName === "a" || el.name === "link")) ||
            (name === "src" &&
              (el.tagName === "img" ||
                el.tagName === "iframe" ||
                el.tagName === "audio" ||
                el.tagName === "video" ||
                el.tagName === "source"))) &&
          prop !== undefined &&
          this.options.baseURI
        ) {
          return new URL(prop, this.options.baseURI).href;
        }
        /* eslint-enable node/no-unsupported-features/node-builtins */
        return prop;
      }
      case "innerText": {
        return innerText$1(el);
      }
      case "textContent": {
        return textContent$1(el);
      }
      case "outerHTML":
        return this.clone().wrap("<container />").parent().html();
      case "innerHTML":
        return this.html();
      default:
        return getProp(el, name, this.options.xmlMode);
    }
  }
  if (typeof name === "object" || value !== undefined) {
    if (typeof value === "function") {
      if (typeof name === "object") {
        throw new Error("Bad combination of arguments.");
      }
      return domEach(this, (el, i) => {
        if (isTag$1(el)) {
          setProp(
            el,
            name,
            value.call(el, i, getProp(el, name, this.options.xmlMode)),
            this.options.xmlMode,
          );
        }
      });
    }
    return domEach(this, (el) => {
      if (!isTag$1(el)) return;
      if (typeof name === "object") {
        Object.keys(name).forEach((key) => {
          const val = name[key];
          setProp(el, key, val, this.options.xmlMode);
        });
      } else {
        setProp(el, name, value, this.options.xmlMode);
      }
    });
  }
  return undefined;
}
/**
 * Sets the value of a data attribute.
 *
 * @private
 * @param el - The element to set the data attribute on.
 * @param name - The data attribute's name.
 * @param value - The data attribute's value.
 */
function setData(el, name, value) {
  var _a;
  const elem = el;
  (_a = elem.data) !== null && _a !== void 0 ? _a : (elem.data = {});
  if (typeof name === "object") Object.assign(elem.data, name);
  else if (typeof name === "string" && value !== undefined) {
    elem.data[name] = value;
  }
}
/**
 * Read the specified attribute from the equivalent HTML5 `data-*` attribute,
 * and (if present) cache the value in the node's internal data store. If no
 * attribute name is specified, read _all_ HTML5 `data-*` attributes in this manner.
 *
 * @private
 * @category Attributes
 * @param el - Element to get the data attribute of.
 * @param name - Name of the data attribute.
 * @returns The data attribute's value, or a map with all of the data attributes.
 */
function readData(el, name) {
  let domNames;
  let jsNames;
  let value;
  if (name == null) {
    domNames = Object.keys(el.attribs).filter((attrName) =>
      attrName.startsWith(dataAttrPrefix),
    );
    jsNames = domNames.map((domName) =>
      camelCase(domName.slice(dataAttrPrefix.length)),
    );
  } else {
    domNames = [dataAttrPrefix + cssCase(name)];
    jsNames = [name];
  }
  for (let idx = 0; idx < domNames.length; ++idx) {
    const domName = domNames[idx];
    const jsName = jsNames[idx];
    if (hasOwn.call(el.attribs, domName) && !hasOwn.call(el.data, jsName)) {
      value = el.attribs[domName];
      if (hasOwn.call(primitives, value)) {
        value = primitives[value];
      } else if (value === String(Number(value))) {
        value = Number(value);
      } else if (rbrace.test(value)) {
        try {
          value = JSON.parse(value);
        } catch (e) {
          /* Ignore */
        }
      }
      el.data[jsName] = value;
    }
  }
  return name == null ? el.data : value;
}
function data$4(name, value) {
  var _a;
  const elem = this[0];
  if (!elem || !isTag$1(elem)) return;
  const dataEl = elem;
  (_a = dataEl.data) !== null && _a !== void 0 ? _a : (dataEl.data = {});
  // Return the entire data object if no data specified
  if (!name) {
    return readData(dataEl);
  }
  // Set the value (with attr map support)
  if (typeof name === "object" || value !== undefined) {
    domEach(this, (el) => {
      if (isTag$1(el)) {
        if (typeof name === "object") setData(el, name);
        else setData(el, name, value);
      }
    });
    return this;
  }
  if (hasOwn.call(dataEl.data, name)) {
    return dataEl.data[name];
  }
  return readData(dataEl, name);
}
function val(value) {
  const querying = arguments.length === 0;
  const element = this[0];
  if (!element || !isTag$1(element)) return querying ? undefined : this;
  switch (element.name) {
    case "textarea":
      return this.text(value);
    case "select": {
      const option = this.find("option:selected");
      if (!querying) {
        if (this.attr("multiple") == null && typeof value === "object") {
          return this;
        }
        this.find("option").removeAttr("selected");
        const values = typeof value !== "object" ? [value] : value;
        for (let i = 0; i < values.length; i++) {
          this.find(`option[value="${values[i]}"]`).attr("selected", "");
        }
        return this;
      }
      return this.attr("multiple")
        ? option.toArray().map((el) => text$1(el.children))
        : option.attr("value");
    }
    case "input":
    case "option":
      return querying ? this.attr("value") : this.attr("value", value);
  }
  return undefined;
}
/**
 * Remove an attribute.
 *
 * @private
 * @param elem - Node to remove attribute from.
 * @param name - Name of the attribute to remove.
 */
function removeAttribute(elem, name) {
  if (!elem.attribs || !hasOwn.call(elem.attribs, name)) return;
  delete elem.attribs[name];
}
/**
 * Splits a space-separated list of names to individual names.
 *
 * @category Attributes
 * @param names - Names to split.
 * @returns - Split names.
 */
function splitNames(names) {
  return names ? names.trim().split(rspace) : [];
}
/**
 * Method for removing attributes by `name`.
 *
 * @category Attributes
 * @example
 *
 * ```js
 * $('.pear').removeAttr('class').html();
 * //=> <li>Pear</li>
 *
 * $('.apple').attr('id', 'favorite');
 * $('.apple').removeAttr('id class').html();
 * //=> <li>Apple</li>
 * ```
 *
 * @param name - Name of the attribute.
 * @returns The instance itself.
 * @see {@link https://api.jquery.com/removeAttr/}
 */
function removeAttr(name) {
  const attrNames = splitNames(name);
  for (let i = 0; i < attrNames.length; i++) {
    domEach(this, (elem) => {
      if (isTag$1(elem)) removeAttribute(elem, attrNames[i]);
    });
  }
  return this;
}
/**
 * Check to see if _any_ of the matched elements have the given `className`.
 *
 * @category Attributes
 * @example
 *
 * ```js
 * $('.pear').hasClass('pear');
 * //=> true
 *
 * $('apple').hasClass('fruit');
 * //=> false
 *
 * $('li').hasClass('pear');
 * //=> true
 * ```
 *
 * @param className - Name of the class.
 * @returns Indicates if an element has the given `className`.
 * @see {@link https://api.jquery.com/hasClass/}
 */
function hasClass(className) {
  return this.toArray().some((elem) => {
    const clazz = isTag$1(elem) && elem.attribs["class"];
    let idx = -1;
    if (clazz && className.length) {
      while ((idx = clazz.indexOf(className, idx + 1)) > -1) {
        const end = idx + className.length;
        if (
          (idx === 0 || rspace.test(clazz[idx - 1])) &&
          (end === clazz.length || rspace.test(clazz[end]))
        ) {
          return true;
        }
      }
    }
    return false;
  });
}
/**
 * Adds class(es) to all of the matched elements. Also accepts a `function`.
 *
 * @category Attributes
 * @example
 *
 * ```js
 * $('.pear').addClass('fruit').html();
 * //=> <li class="pear fruit">Pear</li>
 *
 * $('.apple').addClass('fruit red').html();
 * //=> <li class="apple fruit red">Apple</li>
 * ```
 *
 * @param value - Name of new class.
 * @returns The instance itself.
 * @see {@link https://api.jquery.com/addClass/}
 */
function addClass(value) {
  // Support functions
  if (typeof value === "function") {
    return domEach(this, (el, i) => {
      if (isTag$1(el)) {
        const className = el.attribs["class"] || "";
        addClass.call([el], value.call(el, i, className));
      }
    });
  }
  // Return if no value or not a string or function
  if (!value || typeof value !== "string") return this;
  const classNames = value.split(rspace);
  const numElements = this.length;
  for (let i = 0; i < numElements; i++) {
    const el = this[i];
    // If selected element isn't a tag, move on
    if (!isTag$1(el)) continue;
    // If we don't already have classes  always set xmlMode to false here, as it doesn't matter for classes
    const className = getAttr(el, "class", false);
    if (!className) {
      setAttr(el, "class", classNames.join(" ").trim());
    } else {
      let setClass = ` ${className} `;
      // Check if class already exists
      for (let j = 0; j < classNames.length; j++) {
        const appendClass = `${classNames[j]} `;
        if (!setClass.includes(` ${appendClass}`)) setClass += appendClass;
      }
      setAttr(el, "class", setClass.trim());
    }
  }
  return this;
}
/**
 * Removes one or more space-separated classes from the selected elements. If no
 * `className` is defined, all classes will be removed. Also accepts a `function`.
 *
 * @category Attributes
 * @example
 *
 * ```js
 * $('.pear').removeClass('pear').html();
 * //=> <li class="">Pear</li>
 *
 * $('.apple').addClass('red').removeClass().html();
 * //=> <li class="">Apple</li>
 * ```
 *
 * @param name - Name of the class. If not specified, removes all elements.
 * @returns The instance itself.
 * @see {@link https://api.jquery.com/removeClass/}
 */
function removeClass(name) {
  // Handle if value is a function
  if (typeof name === "function") {
    return domEach(this, (el, i) => {
      if (isTag$1(el)) {
        removeClass.call([el], name.call(el, i, el.attribs["class"] || ""));
      }
    });
  }
  const classes = splitNames(name);
  const numClasses = classes.length;
  const removeAll = arguments.length === 0;
  return domEach(this, (el) => {
    if (!isTag$1(el)) return;
    if (removeAll) {
      // Short circuit the remove all case as this is the nice one
      el.attribs["class"] = "";
    } else {
      const elClasses = splitNames(el.attribs["class"]);
      let changed = false;
      for (let j = 0; j < numClasses; j++) {
        const index = elClasses.indexOf(classes[j]);
        if (index >= 0) {
          elClasses.splice(index, 1);
          changed = true;
          /*
           * We have to do another pass to ensure that there are not duplicate
           * classes listed
           */
          j--;
        }
      }
      if (changed) {
        el.attribs["class"] = elClasses.join(" ");
      }
    }
  });
}
/**
 * Add or remove class(es) from the matched elements, depending on either the
 * class's presence or the value of the switch argument. Also accepts a `function`.
 *
 * @category Attributes
 * @example
 *
 * ```js
 * $('.apple.green').toggleClass('fruit green red').html();
 * //=> <li class="apple fruit red">Apple</li>
 *
 * $('.apple.green').toggleClass('fruit green red', true).html();
 * //=> <li class="apple green fruit red">Apple</li>
 * ```
 *
 * @param value - Name of the class. Can also be a function.
 * @param stateVal - If specified the state of the class.
 * @returns The instance itself.
 * @see {@link https://api.jquery.com/toggleClass/}
 */
function toggleClass(value, stateVal) {
  // Support functions
  if (typeof value === "function") {
    return domEach(this, (el, i) => {
      if (isTag$1(el)) {
        toggleClass.call(
          [el],
          value.call(el, i, el.attribs["class"] || "", stateVal),
          stateVal,
        );
      }
    });
  }
  // Return if no value or not a string or function
  if (!value || typeof value !== "string") return this;
  const classNames = value.split(rspace);
  const numClasses = classNames.length;
  const state = typeof stateVal === "boolean" ? (stateVal ? 1 : -1) : 0;
  const numElements = this.length;
  for (let i = 0; i < numElements; i++) {
    const el = this[i];
    // If selected element isn't a tag, move on
    if (!isTag$1(el)) continue;
    const elementClasses = splitNames(el.attribs["class"]);
    // Check if class already exists
    for (let j = 0; j < numClasses; j++) {
      // Check if the class name is currently defined
      const index = elementClasses.indexOf(classNames[j]);
      // Add if stateValue === true or we are toggling and there is no value
      if (state >= 0 && index < 0) {
        elementClasses.push(classNames[j]);
      } else if (state <= 0 && index >= 0) {
        // Otherwise remove but only if the item exists
        elementClasses.splice(index, 1);
      }
    }
    el.attribs["class"] = elementClasses.join(" ");
  }
  return this;
}

const Attributes = /*#__PURE__*/ Object.freeze(
  /*#__PURE__*/ Object.defineProperty(
    {
      __proto__: null,
      addClass,
      attr,
      data: data$4,
      hasClass,
      prop,
      removeAttr,
      removeClass,
      toggleClass,
      val,
    },
    Symbol.toStringTag,
    { value: "Module" },
  ),
);

var SelectorType;
(function (SelectorType) {
  SelectorType["Attribute"] = "attribute";
  SelectorType["Pseudo"] = "pseudo";
  SelectorType["PseudoElement"] = "pseudo-element";
  SelectorType["Tag"] = "tag";
  SelectorType["Universal"] = "universal";
  // Traversals
  SelectorType["Adjacent"] = "adjacent";
  SelectorType["Child"] = "child";
  SelectorType["Descendant"] = "descendant";
  SelectorType["Parent"] = "parent";
  SelectorType["Sibling"] = "sibling";
  SelectorType["ColumnCombinator"] = "column-combinator";
})(SelectorType || (SelectorType = {}));
/**
 * Modes for ignore case.
 *
 * This could be updated to an enum, and the object is
 * the current stand-in that will allow code to be updated
 * without big changes.
 */
const IgnoreCaseMode = {
  Unknown: null,
  QuirksMode: "quirks",
  IgnoreCase: true,
  CaseSensitive: false,
};
var AttributeAction;
(function (AttributeAction) {
  AttributeAction["Any"] = "any";
  AttributeAction["Element"] = "element";
  AttributeAction["End"] = "end";
  AttributeAction["Equals"] = "equals";
  AttributeAction["Exists"] = "exists";
  AttributeAction["Hyphen"] = "hyphen";
  AttributeAction["Not"] = "not";
  AttributeAction["Start"] = "start";
})(AttributeAction || (AttributeAction = {}));

const reName = /^[^\\#]?(?:\\(?:[\da-f]{1,6}\s?|.)|[\w\-\u00b0-\uFFFF])+/;
const reEscape = /\\([\da-f]{1,6}\s?|(\s)|.)/gi;
const actionTypes = new Map([
  [126 /* Tilde */, AttributeAction.Element],
  [94 /* Circumflex */, AttributeAction.Start],
  [36 /* Dollar */, AttributeAction.End],
  [42 /* Asterisk */, AttributeAction.Any],
  [33 /* ExclamationMark */, AttributeAction.Not],
  [124 /* Pipe */, AttributeAction.Hyphen],
]);
// Pseudos, whose data property is parsed as well.
const unpackPseudos = new Set([
  "has",
  "not",
  "matches",
  "is",
  "where",
  "host",
  "host-context",
]);
/**
 * Checks whether a specific selector is a traversal.
 * This is useful eg. in swapping the order of elements that
 * are not traversals.
 *
 * @param selector Selector to check.
 */
function isTraversal$2(selector) {
  switch (selector.type) {
    case SelectorType.Adjacent:
    case SelectorType.Child:
    case SelectorType.Descendant:
    case SelectorType.Parent:
    case SelectorType.Sibling:
    case SelectorType.ColumnCombinator:
      return true;
    default:
      return false;
  }
}
const stripQuotesFromPseudos = new Set(["contains", "icontains"]);
// Unescape function taken from https://github.com/jquery/sizzle/blob/master/src/sizzle.js#L152
function funescape(_, escaped, escapedWhitespace) {
  const high = parseInt(escaped, 16) - 0x10000;
  // NaN means non-codepoint
  return high !== high || escapedWhitespace
    ? escaped
    : high < 0
      ? // BMP codepoint
        String.fromCharCode(high + 0x10000)
      : // Supplemental Plane codepoint (surrogate pair)
        String.fromCharCode((high >> 10) | 0xd800, (high & 0x3ff) | 0xdc00);
}
function unescapeCSS(str) {
  return str.replace(reEscape, funescape);
}
function isQuote(c) {
  return c === 39 /* SingleQuote */ || c === 34 /* DoubleQuote */;
}
function isWhitespace$2(c) {
  return (
    c === 32 /* Space */ ||
    c === 9 /* Tab */ ||
    c === 10 /* NewLine */ ||
    c === 12 /* FormFeed */ ||
    c === 13 /* CarriageReturn */
  );
}
/**
 * Parses `selector`, optionally with the passed `options`.
 *
 * @param selector Selector to parse.
 * @param options Options for parsing.
 * @returns Returns a two-dimensional array.
 * The first dimension represents selectors separated by commas (eg. `sub1, sub2`),
 * the second contains the relevant tokens for that selector.
 */
function parse$1E(selector) {
  const subselects = [];
  const endIndex = parseSelector(subselects, `${selector}`, 0);
  if (endIndex < selector.length) {
    throw new Error(`Unmatched selector: ${selector.slice(endIndex)}`);
  }
  return subselects;
}
function parseSelector(subselects, selector, selectorIndex) {
  let tokens = [];
  function getName(offset) {
    const match = selector.slice(selectorIndex + offset).match(reName);
    if (!match) {
      throw new Error(`Expected name, found ${selector.slice(selectorIndex)}`);
    }
    const [name] = match;
    selectorIndex += offset + name.length;
    return unescapeCSS(name);
  }
  function stripWhitespace(offset) {
    selectorIndex += offset;
    while (
      selectorIndex < selector.length &&
      isWhitespace$2(selector.charCodeAt(selectorIndex))
    ) {
      selectorIndex++;
    }
  }
  function readValueWithParenthesis() {
    selectorIndex += 1;
    const start = selectorIndex;
    let counter = 1;
    for (; counter > 0 && selectorIndex < selector.length; selectorIndex++) {
      if (
        selector.charCodeAt(selectorIndex) === 40 /* LeftParenthesis */ &&
        !isEscaped(selectorIndex)
      ) {
        counter++;
      } else if (
        selector.charCodeAt(selectorIndex) === 41 /* RightParenthesis */ &&
        !isEscaped(selectorIndex)
      ) {
        counter--;
      }
    }
    if (counter) {
      throw new Error("Parenthesis not matched");
    }
    return unescapeCSS(selector.slice(start, selectorIndex - 1));
  }
  function isEscaped(pos) {
    let slashCount = 0;
    while (selector.charCodeAt(--pos) === 92 /* BackSlash */) slashCount++;
    return (slashCount & 1) === 1;
  }
  function ensureNotTraversal() {
    if (tokens.length > 0 && isTraversal$2(tokens[tokens.length - 1])) {
      throw new Error("Did not expect successive traversals.");
    }
  }
  function addTraversal(type) {
    if (
      tokens.length > 0 &&
      tokens[tokens.length - 1].type === SelectorType.Descendant
    ) {
      tokens[tokens.length - 1].type = type;
      return;
    }
    ensureNotTraversal();
    tokens.push({ type });
  }
  function addSpecialAttribute(name, action) {
    tokens.push({
      type: SelectorType.Attribute,
      name,
      action,
      value: getName(1),
      namespace: null,
      ignoreCase: "quirks",
    });
  }
  /**
   * We have finished parsing the current part of the selector.
   *
   * Remove descendant tokens at the end if they exist,
   * and return the last index, so that parsing can be
   * picked up from here.
   */
  function finalizeSubselector() {
    if (
      tokens.length &&
      tokens[tokens.length - 1].type === SelectorType.Descendant
    ) {
      tokens.pop();
    }
    if (tokens.length === 0) {
      throw new Error("Empty sub-selector");
    }
    subselects.push(tokens);
  }
  stripWhitespace(0);
  if (selector.length === selectorIndex) {
    return selectorIndex;
  }
  loop: while (selectorIndex < selector.length) {
    const firstChar = selector.charCodeAt(selectorIndex);
    switch (firstChar) {
      // Whitespace
      case 32 /* Space */:
      case 9 /* Tab */:
      case 10 /* NewLine */:
      case 12 /* FormFeed */:
      case 13 /* CarriageReturn */: {
        if (tokens.length === 0 || tokens[0].type !== SelectorType.Descendant) {
          ensureNotTraversal();
          tokens.push({ type: SelectorType.Descendant });
        }
        stripWhitespace(1);
        break;
      }
      // Traversals
      case 62 /* GreaterThan */: {
        addTraversal(SelectorType.Child);
        stripWhitespace(1);
        break;
      }
      case 60 /* LessThan */: {
        addTraversal(SelectorType.Parent);
        stripWhitespace(1);
        break;
      }
      case 126 /* Tilde */: {
        addTraversal(SelectorType.Sibling);
        stripWhitespace(1);
        break;
      }
      case 43 /* Plus */: {
        addTraversal(SelectorType.Adjacent);
        stripWhitespace(1);
        break;
      }
      // Special attribute selectors: .class, #id
      case 46 /* Period */: {
        addSpecialAttribute("class", AttributeAction.Element);
        break;
      }
      case 35 /* Hash */: {
        addSpecialAttribute("id", AttributeAction.Equals);
        break;
      }
      case 91 /* LeftSquareBracket */: {
        stripWhitespace(1);
        // Determine attribute name and namespace
        let name;
        let namespace = null;
        if (selector.charCodeAt(selectorIndex) === 124 /* Pipe */) {
          // Equivalent to no namespace
          name = getName(1);
        } else if (selector.startsWith("*|", selectorIndex)) {
          namespace = "*";
          name = getName(2);
        } else {
          name = getName(0);
          if (
            selector.charCodeAt(selectorIndex) === 124 /* Pipe */ &&
            selector.charCodeAt(selectorIndex + 1) !== 61 /* Equal */
          ) {
            namespace = name;
            name = getName(1);
          }
        }
        stripWhitespace(0);
        // Determine comparison operation
        let action = AttributeAction.Exists;
        const possibleAction = actionTypes.get(
          selector.charCodeAt(selectorIndex),
        );
        if (possibleAction) {
          action = possibleAction;
          if (selector.charCodeAt(selectorIndex + 1) !== 61 /* Equal */) {
            throw new Error("Expected `=`");
          }
          stripWhitespace(2);
        } else if (selector.charCodeAt(selectorIndex) === 61 /* Equal */) {
          action = AttributeAction.Equals;
          stripWhitespace(1);
        }
        // Determine value
        let value = "";
        let ignoreCase = null;
        if (action !== "exists") {
          if (isQuote(selector.charCodeAt(selectorIndex))) {
            const quote = selector.charCodeAt(selectorIndex);
            let sectionEnd = selectorIndex + 1;
            while (
              sectionEnd < selector.length &&
              (selector.charCodeAt(sectionEnd) !== quote ||
                isEscaped(sectionEnd))
            ) {
              sectionEnd += 1;
            }
            if (selector.charCodeAt(sectionEnd) !== quote) {
              throw new Error("Attribute value didn't end");
            }
            value = unescapeCSS(selector.slice(selectorIndex + 1, sectionEnd));
            selectorIndex = sectionEnd + 1;
          } else {
            const valueStart = selectorIndex;
            while (
              selectorIndex < selector.length &&
              ((!isWhitespace$2(selector.charCodeAt(selectorIndex)) &&
                selector.charCodeAt(selectorIndex) !==
                  93) /* RightSquareBracket */ ||
                isEscaped(selectorIndex))
            ) {
              selectorIndex += 1;
            }
            value = unescapeCSS(selector.slice(valueStart, selectorIndex));
          }
          stripWhitespace(0);
          // See if we have a force ignore flag
          const forceIgnore = selector.charCodeAt(selectorIndex) | 0x20;
          // If the forceIgnore flag is set (either `i` or `s`), use that value
          if (forceIgnore === 115 /* LowerS */) {
            ignoreCase = false;
            stripWhitespace(1);
          } else if (forceIgnore === 105 /* LowerI */) {
            ignoreCase = true;
            stripWhitespace(1);
          }
        }
        if (
          selector.charCodeAt(selectorIndex) !== 93 /* RightSquareBracket */
        ) {
          throw new Error("Attribute selector didn't terminate");
        }
        selectorIndex += 1;
        const attributeSelector = {
          type: SelectorType.Attribute,
          name,
          action,
          value,
          namespace,
          ignoreCase,
        };
        tokens.push(attributeSelector);
        break;
      }
      case 58 /* Colon */: {
        if (selector.charCodeAt(selectorIndex + 1) === 58 /* Colon */) {
          tokens.push({
            type: SelectorType.PseudoElement,
            name: getName(2).toLowerCase(),
            data:
              selector.charCodeAt(selectorIndex) === 40 /* LeftParenthesis */
                ? readValueWithParenthesis()
                : null,
          });
          continue;
        }
        const name = getName(1).toLowerCase();
        let data = null;
        if (selector.charCodeAt(selectorIndex) === 40 /* LeftParenthesis */) {
          if (unpackPseudos.has(name)) {
            if (isQuote(selector.charCodeAt(selectorIndex + 1))) {
              throw new Error(`Pseudo-selector ${name} cannot be quoted`);
            }
            data = [];
            selectorIndex = parseSelector(data, selector, selectorIndex + 1);
            if (
              selector.charCodeAt(selectorIndex) !== 41 /* RightParenthesis */
            ) {
              throw new Error(
                `Missing closing parenthesis in :${name} (${selector})`,
              );
            }
            selectorIndex += 1;
          } else {
            data = readValueWithParenthesis();
            if (stripQuotesFromPseudos.has(name)) {
              const quot = data.charCodeAt(0);
              if (quot === data.charCodeAt(data.length - 1) && isQuote(quot)) {
                data = data.slice(1, -1);
              }
            }
            data = unescapeCSS(data);
          }
        }
        tokens.push({ type: SelectorType.Pseudo, name, data });
        break;
      }
      case 44 /* Comma */: {
        finalizeSubselector();
        tokens = [];
        stripWhitespace(1);
        break;
      }
      default: {
        if (selector.startsWith("/*", selectorIndex)) {
          const endIndex = selector.indexOf("*/", selectorIndex + 2);
          if (endIndex < 0) {
            throw new Error("Comment was not terminated");
          }
          selectorIndex = endIndex + 2;
          // Remove leading whitespace
          if (tokens.length === 0) {
            stripWhitespace(0);
          }
          break;
        }
        let namespace = null;
        let name;
        if (firstChar === 42 /* Asterisk */) {
          selectorIndex += 1;
          name = "*";
        } else if (firstChar === 124 /* Pipe */) {
          name = "";
          if (selector.charCodeAt(selectorIndex + 1) === 124 /* Pipe */) {
            addTraversal(SelectorType.ColumnCombinator);
            stripWhitespace(2);
            break;
          }
        } else if (reName.test(selector.slice(selectorIndex))) {
          name = getName(0);
        } else {
          break loop;
        }
        if (
          selector.charCodeAt(selectorIndex) === 124 /* Pipe */ &&
          selector.charCodeAt(selectorIndex + 1) !== 124 /* Pipe */
        ) {
          namespace = name;
          if (selector.charCodeAt(selectorIndex + 1) === 42 /* Asterisk */) {
            name = "*";
            selectorIndex += 2;
          } else {
            name = getName(1);
          }
        }
        tokens.push(
          name === "*"
            ? { type: SelectorType.Universal, namespace }
            : { type: SelectorType.Tag, name, namespace },
        );
      }
    }
  }
  finalizeSubselector();
  return selectorIndex;
}

const attribValChars = ["\\", '"'];
const pseudoValChars = [...attribValChars, "(", ")"];
const charsToEscapeInAttributeValue = new Set(
  attribValChars.map((c) => c.charCodeAt(0)),
);
const charsToEscapeInPseudoValue = new Set(
  pseudoValChars.map((c) => c.charCodeAt(0)),
);
const charsToEscapeInName = new Set(
  [
    ...pseudoValChars,
    "~",
    "^",
    "$",
    "*",
    "+",
    "!",
    "|",
    ":",
    "[",
    "]",
    " ",
    ".",
  ].map((c) => c.charCodeAt(0)),
);
/**
 * Turns `selector` back into a string.
 *
 * @param selector Selector to stringify.
 */
function stringify$2(selector) {
  return selector.map((token) => token.map(stringifyToken).join("")).join(", ");
}
function stringifyToken(token, index, arr) {
  switch (token.type) {
    // Simple types
    case SelectorType.Child:
      return index === 0 ? "> " : " > ";
    case SelectorType.Parent:
      return index === 0 ? "< " : " < ";
    case SelectorType.Sibling:
      return index === 0 ? "~ " : " ~ ";
    case SelectorType.Adjacent:
      return index === 0 ? "+ " : " + ";
    case SelectorType.Descendant:
      return " ";
    case SelectorType.ColumnCombinator:
      return index === 0 ? "|| " : " || ";
    case SelectorType.Universal:
      // Return an empty string if the selector isn't needed.
      return token.namespace === "*" &&
        index + 1 < arr.length &&
        "name" in arr[index + 1]
        ? ""
        : `${getNamespace(token.namespace)}*`;
    case SelectorType.Tag:
      return getNamespacedName(token);
    case SelectorType.PseudoElement:
      return `::${escapeName(token.name, charsToEscapeInName)}${
        token.data === null
          ? ""
          : `(${escapeName(token.data, charsToEscapeInPseudoValue)})`
      }`;
    case SelectorType.Pseudo:
      return `:${escapeName(token.name, charsToEscapeInName)}${
        token.data === null
          ? ""
          : `(${
              typeof token.data === "string"
                ? escapeName(token.data, charsToEscapeInPseudoValue)
                : stringify$2(token.data)
            })`
      }`;
    case SelectorType.Attribute: {
      if (
        token.name === "id" &&
        token.action === AttributeAction.Equals &&
        token.ignoreCase === "quirks" &&
        !token.namespace
      ) {
        return `#${escapeName(token.value, charsToEscapeInName)}`;
      }
      if (
        token.name === "class" &&
        token.action === AttributeAction.Element &&
        token.ignoreCase === "quirks" &&
        !token.namespace
      ) {
        return `.${escapeName(token.value, charsToEscapeInName)}`;
      }
      const name = getNamespacedName(token);
      if (token.action === AttributeAction.Exists) {
        return `[${name}]`;
      }
      return `[${name}${getActionValue(token.action)}="${escapeName(
        token.value,
        charsToEscapeInAttributeValue,
      )}"${token.ignoreCase === null ? "" : token.ignoreCase ? " i" : " s"}]`;
    }
  }
}
function getActionValue(action) {
  switch (action) {
    case AttributeAction.Equals:
      return "";
    case AttributeAction.Element:
      return "~";
    case AttributeAction.Start:
      return "^";
    case AttributeAction.End:
      return "$";
    case AttributeAction.Any:
      return "*";
    case AttributeAction.Not:
      return "!";
    case AttributeAction.Hyphen:
      return "|";
    case AttributeAction.Exists:
      throw new Error("Shouldn't be here");
  }
}
function getNamespacedName(token) {
  return `${getNamespace(token.namespace)}${escapeName(
    token.name,
    charsToEscapeInName,
  )}`;
}
function getNamespace(namespace) {
  return namespace !== null
    ? `${namespace === "*" ? "*" : escapeName(namespace, charsToEscapeInName)}|`
    : "";
}
function escapeName(str, charsToEscape) {
  let lastIdx = 0;
  let ret = "";
  for (let i = 0; i < str.length; i++) {
    if (charsToEscape.has(str.charCodeAt(i))) {
      ret += `${str.slice(lastIdx, i)}\\${str.charAt(i)}`;
      lastIdx = i + 1;
    }
  }
  return ret.length > 0 ? ret + str.slice(lastIdx) : str;
}

const es = /*#__PURE__*/ Object.freeze(
  /*#__PURE__*/ Object.defineProperty(
    {
      __proto__: null,
      get AttributeAction() {
        return AttributeAction;
      },
      IgnoreCaseMode,
      get SelectorType() {
        return SelectorType;
      },
      isTraversal: isTraversal$2,
      parse: parse$1E,
      stringify: stringify$2,
    },
    Symbol.toStringTag,
    { value: "Module" },
  ),
);

var lib$2 = {};

var stringify$1 = {};

var __importDefault$3 =
  (commonjsGlobal && commonjsGlobal.__importDefault) ||
  function (mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
Object.defineProperty(stringify$1, "__esModule", { value: true });
stringify$1.innerText =
  stringify$1.textContent =
  stringify$1.getText =
  stringify$1.getInnerHTML =
  stringify$1.getOuterHTML =
    void 0;
var domhandler_1$3 = lib$5;
var dom_serializer_1 = __importDefault$3(lib$4);
var domelementtype_1 = lib$3;
/**
 * @category Stringify
 * @deprecated Use the `dom-serializer` module directly.
 * @param node Node to get the outer HTML of.
 * @param options Options for serialization.
 * @returns `node`'s outer HTML.
 */
function getOuterHTML(node, options) {
  return (0, dom_serializer_1.default)(node, options);
}
stringify$1.getOuterHTML = getOuterHTML;
/**
 * @category Stringify
 * @deprecated Use the `dom-serializer` module directly.
 * @param node Node to get the inner HTML of.
 * @param options Options for serialization.
 * @returns `node`'s inner HTML.
 */
function getInnerHTML(node, options) {
  return (0, domhandler_1$3.hasChildren)(node)
    ? node.children
        .map(function (node) {
          return getOuterHTML(node, options);
        })
        .join("")
    : "";
}
stringify$1.getInnerHTML = getInnerHTML;
/**
 * Get a node's inner text. Same as `textContent`, but inserts newlines for `<br>` tags. Ignores comments.
 *
 * @category Stringify
 * @deprecated Use `textContent` instead.
 * @param node Node to get the inner text of.
 * @returns `node`'s inner text.
 */
function getText$1(node) {
  if (Array.isArray(node)) return node.map(getText$1).join("");
  if ((0, domhandler_1$3.isTag)(node))
    return node.name === "br" ? "\n" : getText$1(node.children);
  if ((0, domhandler_1$3.isCDATA)(node)) return getText$1(node.children);
  if ((0, domhandler_1$3.isText)(node)) return node.data;
  return "";
}
stringify$1.getText = getText$1;
/**
 * Get a node's text content. Ignores comments.
 *
 * @category Stringify
 * @param node Node to get the text content of.
 * @returns `node`'s text content.
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/Node/textContent}
 */
function textContent(node) {
  if (Array.isArray(node)) return node.map(textContent).join("");
  if (
    (0, domhandler_1$3.hasChildren)(node) &&
    !(0, domhandler_1$3.isComment)(node)
  ) {
    return textContent(node.children);
  }
  if ((0, domhandler_1$3.isText)(node)) return node.data;
  return "";
}
stringify$1.textContent = textContent;
/**
 * Get a node's inner text, ignoring `<script>` and `<style>` tags. Ignores comments.
 *
 * @category Stringify
 * @param node Node to get the inner text of.
 * @returns `node`'s inner text.
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/Node/innerText}
 */
function innerText(node) {
  if (Array.isArray(node)) return node.map(innerText).join("");
  if (
    (0, domhandler_1$3.hasChildren)(node) &&
    (node.type === domelementtype_1.ElementType.Tag ||
      (0, domhandler_1$3.isCDATA)(node))
  ) {
    return innerText(node.children);
  }
  if ((0, domhandler_1$3.isText)(node)) return node.data;
  return "";
}
stringify$1.innerText = innerText;

var traversal = {};

Object.defineProperty(traversal, "__esModule", { value: true });
traversal.prevElementSibling =
  traversal.nextElementSibling =
  traversal.getName =
  traversal.hasAttrib =
  traversal.getAttributeValue =
  traversal.getSiblings =
  traversal.getParent =
  traversal.getChildren =
    void 0;
var domhandler_1$2 = lib$5;
/**
 * Get a node's children.
 *
 * @category Traversal
 * @param elem Node to get the children of.
 * @returns `elem`'s children, or an empty array.
 */
function getChildren$1(elem) {
  return (0, domhandler_1$2.hasChildren)(elem) ? elem.children : [];
}
traversal.getChildren = getChildren$1;
/**
 * Get a node's parent.
 *
 * @category Traversal
 * @param elem Node to get the parent of.
 * @returns `elem`'s parent node, or `null` if `elem` is a root node.
 */
function getParent$1(elem) {
  return elem.parent || null;
}
traversal.getParent = getParent$1;
/**
 * Gets an elements siblings, including the element itself.
 *
 * Attempts to get the children through the element's parent first. If we don't
 * have a parent (the element is a root node), we walk the element's `prev` &
 * `next` to get all remaining nodes.
 *
 * @category Traversal
 * @param elem Element to get the siblings of.
 * @returns `elem`'s siblings, including `elem`.
 */
function getSiblings$1(elem) {
  var _a, _b;
  var parent = getParent$1(elem);
  if (parent != null) return getChildren$1(parent);
  var siblings = [elem];
  var prev = elem.prev,
    next = elem.next;
  while (prev != null) {
    siblings.unshift(prev);
    (_a = prev), (prev = _a.prev);
  }
  while (next != null) {
    siblings.push(next);
    (_b = next), (next = _b.next);
  }
  return siblings;
}
traversal.getSiblings = getSiblings$1;
/**
 * Gets an attribute from an element.
 *
 * @category Traversal
 * @param elem Element to check.
 * @param name Attribute name to retrieve.
 * @returns The element's attribute value, or `undefined`.
 */
function getAttributeValue$1(elem, name) {
  var _a;
  return (_a = elem.attribs) === null || _a === void 0 ? void 0 : _a[name];
}
traversal.getAttributeValue = getAttributeValue$1;
/**
 * Checks whether an element has an attribute.
 *
 * @category Traversal
 * @param elem Element to check.
 * @param name Attribute name to look for.
 * @returns Returns whether `elem` has the attribute `name`.
 */
function hasAttrib$1(elem, name) {
  return (
    elem.attribs != null &&
    Object.prototype.hasOwnProperty.call(elem.attribs, name) &&
    elem.attribs[name] != null
  );
}
traversal.hasAttrib = hasAttrib$1;
/**
 * Get the tag name of an element.
 *
 * @category Traversal
 * @param elem The element to get the name for.
 * @returns The tag name of `elem`.
 */
function getName$1(elem) {
  return elem.name;
}
traversal.getName = getName$1;
/**
 * Returns the next element sibling of a node.
 *
 * @category Traversal
 * @param elem The element to get the next sibling of.
 * @returns `elem`'s next sibling that is a tag, or `null` if there is no next
 * sibling.
 */
function nextElementSibling(elem) {
  var _a;
  var next = elem.next;
  while (next !== null && !(0, domhandler_1$2.isTag)(next))
    (_a = next), (next = _a.next);
  return next;
}
traversal.nextElementSibling = nextElementSibling;
/**
 * Returns the previous element sibling of a node.
 *
 * @category Traversal
 * @param elem The element to get the previous sibling of.
 * @returns `elem`'s previous sibling that is a tag, or `null` if there is no
 * previous sibling.
 */
function prevElementSibling(elem) {
  var _a;
  var prev = elem.prev;
  while (prev !== null && !(0, domhandler_1$2.isTag)(prev))
    (_a = prev), (prev = _a.prev);
  return prev;
}
traversal.prevElementSibling = prevElementSibling;

var manipulation = {};

Object.defineProperty(manipulation, "__esModule", { value: true });
manipulation.prepend =
  manipulation.prependChild =
  manipulation.append =
  manipulation.appendChild =
  manipulation.replaceElement =
  manipulation.removeElement =
    void 0;
/**
 * Remove an element from the dom
 *
 * @category Manipulation
 * @param elem The element to be removed
 */
function removeElement(elem) {
  if (elem.prev) elem.prev.next = elem.next;
  if (elem.next) elem.next.prev = elem.prev;
  if (elem.parent) {
    var childs = elem.parent.children;
    var childsIndex = childs.lastIndexOf(elem);
    if (childsIndex >= 0) {
      childs.splice(childsIndex, 1);
    }
  }
  elem.next = null;
  elem.prev = null;
  elem.parent = null;
}
manipulation.removeElement = removeElement;
/**
 * Replace an element in the dom
 *
 * @category Manipulation
 * @param elem The element to be replaced
 * @param replacement The element to be added
 */
function replaceElement(elem, replacement) {
  var prev = (replacement.prev = elem.prev);
  if (prev) {
    prev.next = replacement;
  }
  var next = (replacement.next = elem.next);
  if (next) {
    next.prev = replacement;
  }
  var parent = (replacement.parent = elem.parent);
  if (parent) {
    var childs = parent.children;
    childs[childs.lastIndexOf(elem)] = replacement;
    elem.parent = null;
  }
}
manipulation.replaceElement = replaceElement;
/**
 * Append a child to an element.
 *
 * @category Manipulation
 * @param parent The element to append to.
 * @param child The element to be added as a child.
 */
function appendChild(parent, child) {
  removeElement(child);
  child.next = null;
  child.parent = parent;
  if (parent.children.push(child) > 1) {
    var sibling = parent.children[parent.children.length - 2];
    sibling.next = child;
    child.prev = sibling;
  } else {
    child.prev = null;
  }
}
manipulation.appendChild = appendChild;
/**
 * Append an element after another.
 *
 * @category Manipulation
 * @param elem The element to append after.
 * @param next The element be added.
 */
function append$2(elem, next) {
  removeElement(next);
  var parent = elem.parent;
  var currNext = elem.next;
  next.next = currNext;
  next.prev = elem;
  elem.next = next;
  next.parent = parent;
  if (currNext) {
    currNext.prev = next;
    if (parent) {
      var childs = parent.children;
      childs.splice(childs.lastIndexOf(currNext), 0, next);
    }
  } else if (parent) {
    parent.children.push(next);
  }
}
manipulation.append = append$2;
/**
 * Prepend a child to an element.
 *
 * @category Manipulation
 * @param parent The element to prepend before.
 * @param child The element to be added as a child.
 */
function prependChild(parent, child) {
  removeElement(child);
  child.parent = parent;
  child.prev = null;
  if (parent.children.unshift(child) !== 1) {
    var sibling = parent.children[1];
    sibling.prev = child;
    child.next = sibling;
  } else {
    child.next = null;
  }
}
manipulation.prependChild = prependChild;
/**
 * Prepend an element before another.
 *
 * @category Manipulation
 * @param elem The element to prepend before.
 * @param prev The element be added.
 */
function prepend$1(elem, prev) {
  removeElement(prev);
  var parent = elem.parent;
  if (parent) {
    var childs = parent.children;
    childs.splice(childs.indexOf(elem), 0, prev);
  }
  if (elem.prev) {
    elem.prev.next = prev;
  }
  prev.parent = parent;
  prev.prev = elem.prev;
  prev.next = elem;
  elem.prev = prev;
}
manipulation.prepend = prepend$1;

var querying = {};

Object.defineProperty(querying, "__esModule", { value: true });
querying.findAll =
  querying.existsOne =
  querying.findOne =
  querying.findOneChild =
  querying.find =
  querying.filter =
    void 0;
var domhandler_1$1 = lib$5;
/**
 * Search a node and its children for nodes passing a test function. If `node` is not an array, it will be wrapped in one.
 *
 * @category Querying
 * @param test Function to test nodes on.
 * @param node Node to search. Will be included in the result set if it matches.
 * @param recurse Also consider child nodes.
 * @param limit Maximum number of nodes to return.
 * @returns All nodes passing `test`.
 */
function filter$4(test, node, recurse, limit) {
  if (recurse === void 0) {
    recurse = true;
  }
  if (limit === void 0) {
    limit = Infinity;
  }
  return find$5(test, Array.isArray(node) ? node : [node], recurse, limit);
}
querying.filter = filter$4;
/**
 * Search an array of nodes and their children for nodes passing a test function.
 *
 * @category Querying
 * @param test Function to test nodes on.
 * @param nodes Array of nodes to search.
 * @param recurse Also consider child nodes.
 * @param limit Maximum number of nodes to return.
 * @returns All nodes passing `test`.
 */
function find$5(test, nodes, recurse, limit) {
  var result = [];
  /** Stack of the arrays we are looking at. */
  var nodeStack = [nodes];
  /** Stack of the indices within the arrays. */
  var indexStack = [0];
  for (;;) {
    // First, check if the current array has any more elements to look at.
    if (indexStack[0] >= nodeStack[0].length) {
      // If we have no more arrays to look at, we are done.
      if (indexStack.length === 1) {
        return result;
      }
      // Otherwise, remove the current array from the stack.
      nodeStack.shift();
      indexStack.shift();
      // Loop back to the start to continue with the next array.
      continue;
    }
    var elem = nodeStack[0][indexStack[0]++];
    if (test(elem)) {
      result.push(elem);
      if (--limit <= 0) return result;
    }
    if (
      recurse &&
      (0, domhandler_1$1.hasChildren)(elem) &&
      elem.children.length > 0
    ) {
      /*
       * Add the children to the stack. We are depth-first, so this is
       * the next array we look at.
       */
      indexStack.unshift(0);
      nodeStack.unshift(elem.children);
    }
  }
}
querying.find = find$5;
/**
 * Finds the first element inside of an array that matches a test function. This is an alias for `Array.prototype.find`.
 *
 * @category Querying
 * @param test Function to test nodes on.
 * @param nodes Array of nodes to search.
 * @returns The first node in the array that passes `test`.
 * @deprecated Use `Array.prototype.find` directly.
 */
function findOneChild(test, nodes) {
  return nodes.find(test);
}
querying.findOneChild = findOneChild;
/**
 * Finds one element in a tree that passes a test.
 *
 * @category Querying
 * @param test Function to test nodes on.
 * @param nodes Node or array of nodes to search.
 * @param recurse Also consider child nodes.
 * @returns The first node that passes `test`.
 */
function findOne$1(test, nodes, recurse) {
  if (recurse === void 0) {
    recurse = true;
  }
  var elem = null;
  for (var i = 0; i < nodes.length && !elem; i++) {
    var node = nodes[i];
    if (!(0, domhandler_1$1.isTag)(node)) {
      continue;
    } else if (test(node)) {
      elem = node;
    } else if (recurse && node.children.length > 0) {
      elem = findOne$1(test, node.children, true);
    }
  }
  return elem;
}
querying.findOne = findOne$1;
/**
 * Checks if a tree of nodes contains at least one node passing a test.
 *
 * @category Querying
 * @param test Function to test nodes on.
 * @param nodes Array of nodes to search.
 * @returns Whether a tree of nodes contains at least one node passing the test.
 */
function existsOne$1(test, nodes) {
  return nodes.some(function (checked) {
    return (
      (0, domhandler_1$1.isTag)(checked) &&
      (test(checked) || existsOne$1(test, checked.children))
    );
  });
}
querying.existsOne = existsOne$1;
/**
 * Search an array of nodes and their children for elements passing a test function.
 *
 * Same as `find`, but limited to elements and with less options, leading to reduced complexity.
 *
 * @category Querying
 * @param test Function to test nodes on.
 * @param nodes Array of nodes to search.
 * @returns All nodes passing `test`.
 */
function findAll$4(test, nodes) {
  var result = [];
  var nodeStack = [nodes];
  var indexStack = [0];
  for (;;) {
    if (indexStack[0] >= nodeStack[0].length) {
      if (nodeStack.length === 1) {
        return result;
      }
      // Otherwise, remove the current array from the stack.
      nodeStack.shift();
      indexStack.shift();
      // Loop back to the start to continue with the next array.
      continue;
    }
    var elem = nodeStack[0][indexStack[0]++];
    if (!(0, domhandler_1$1.isTag)(elem)) continue;
    if (test(elem)) result.push(elem);
    if (elem.children.length > 0) {
      indexStack.unshift(0);
      nodeStack.unshift(elem.children);
    }
  }
}
querying.findAll = findAll$4;

var legacy = {};

Object.defineProperty(legacy, "__esModule", { value: true });
legacy.getElementsByTagType =
  legacy.getElementsByTagName =
  legacy.getElementById =
  legacy.getElements =
  legacy.testElement =
    void 0;
var domhandler_1 = lib$5;
var querying_js_1 = querying;
/**
 * A map of functions to check nodes against.
 */
var Checks = {
  tag_name: function (name) {
    if (typeof name === "function") {
      return function (elem) {
        return (0, domhandler_1.isTag)(elem) && name(elem.name);
      };
    } else if (name === "*") {
      return domhandler_1.isTag;
    }
    return function (elem) {
      return (0, domhandler_1.isTag)(elem) && elem.name === name;
    };
  },
  tag_type: function (type) {
    if (typeof type === "function") {
      return function (elem) {
        return type(elem.type);
      };
    }
    return function (elem) {
      return elem.type === type;
    };
  },
  tag_contains: function (data) {
    if (typeof data === "function") {
      return function (elem) {
        return (0, domhandler_1.isText)(elem) && data(elem.data);
      };
    }
    return function (elem) {
      return (0, domhandler_1.isText)(elem) && elem.data === data;
    };
  },
};
/**
 * Returns a function to check whether a node has an attribute with a particular
 * value.
 *
 * @param attrib Attribute to check.
 * @param value Attribute value to look for.
 * @returns A function to check whether the a node has an attribute with a
 *   particular value.
 */
function getAttribCheck(attrib, value) {
  if (typeof value === "function") {
    return function (elem) {
      return (0, domhandler_1.isTag)(elem) && value(elem.attribs[attrib]);
    };
  }
  return function (elem) {
    return (0, domhandler_1.isTag)(elem) && elem.attribs[attrib] === value;
  };
}
/**
 * Returns a function that returns `true` if either of the input functions
 * returns `true` for a node.
 *
 * @param a First function to combine.
 * @param b Second function to combine.
 * @returns A function taking a node and returning `true` if either of the input
 *   functions returns `true` for the node.
 */
function combineFuncs(a, b) {
  return function (elem) {
    return a(elem) || b(elem);
  };
}
/**
 * Returns a function that executes all checks in `options` and returns `true`
 * if any of them match a node.
 *
 * @param options An object describing nodes to look for.
 * @returns A function that executes all checks in `options` and returns `true`
 *   if any of them match a node.
 */
function compileTest(options) {
  var funcs = Object.keys(options).map(function (key) {
    var value = options[key];
    return Object.prototype.hasOwnProperty.call(Checks, key)
      ? Checks[key](value)
      : getAttribCheck(key, value);
  });
  return funcs.length === 0 ? null : funcs.reduce(combineFuncs);
}
/**
 * Checks whether a node matches the description in `options`.
 *
 * @category Legacy Query Functions
 * @param options An object describing nodes to look for.
 * @param node The element to test.
 * @returns Whether the element matches the description in `options`.
 */
function testElement(options, node) {
  var test = compileTest(options);
  return test ? test(node) : true;
}
legacy.testElement = testElement;
/**
 * Returns all nodes that match `options`.
 *
 * @category Legacy Query Functions
 * @param options An object describing nodes to look for.
 * @param nodes Nodes to search through.
 * @param recurse Also consider child nodes.
 * @param limit Maximum number of nodes to return.
 * @returns All nodes that match `options`.
 */
function getElements(options, nodes, recurse, limit) {
  if (limit === void 0) {
    limit = Infinity;
  }
  var test = compileTest(options);
  return test ? (0, querying_js_1.filter)(test, nodes, recurse, limit) : [];
}
legacy.getElements = getElements;
/**
 * Returns the node with the supplied ID.
 *
 * @category Legacy Query Functions
 * @param id The unique ID attribute value to look for.
 * @param nodes Nodes to search through.
 * @param recurse Also consider child nodes.
 * @returns The node with the supplied ID.
 */
function getElementById(id, nodes, recurse) {
  if (recurse === void 0) {
    recurse = true;
  }
  if (!Array.isArray(nodes)) nodes = [nodes];
  return (0, querying_js_1.findOne)(getAttribCheck("id", id), nodes, recurse);
}
legacy.getElementById = getElementById;
/**
 * Returns all nodes with the supplied `tagName`.
 *
 * @category Legacy Query Functions
 * @param tagName Tag name to search for.
 * @param nodes Nodes to search through.
 * @param recurse Also consider child nodes.
 * @param limit Maximum number of nodes to return.
 * @returns All nodes with the supplied `tagName`.
 */
function getElementsByTagName(tagName, nodes, recurse, limit) {
  if (recurse === void 0) {
    recurse = true;
  }
  if (limit === void 0) {
    limit = Infinity;
  }
  return (0, querying_js_1.filter)(
    Checks["tag_name"](tagName),
    nodes,
    recurse,
    limit,
  );
}
legacy.getElementsByTagName = getElementsByTagName;
/**
 * Returns all nodes with the supplied `type`.
 *
 * @category Legacy Query Functions
 * @param type Element type to look for.
 * @param nodes Nodes to search through.
 * @param recurse Also consider child nodes.
 * @param limit Maximum number of nodes to return.
 * @returns All nodes with the supplied `type`.
 */
function getElementsByTagType(type, nodes, recurse, limit) {
  if (recurse === void 0) {
    recurse = true;
  }
  if (limit === void 0) {
    limit = Infinity;
  }
  return (0, querying_js_1.filter)(
    Checks["tag_type"](type),
    nodes,
    recurse,
    limit,
  );
}
legacy.getElementsByTagType = getElementsByTagType;

var helpers = {};

(function (exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.uniqueSort =
    exports.compareDocumentPosition =
    exports.DocumentPosition =
    exports.removeSubsets =
      void 0;
  var domhandler_1 = lib$5;
  /**
   * Given an array of nodes, remove any member that is contained by another
   * member.
   *
   * @category Helpers
   * @param nodes Nodes to filter.
   * @returns Remaining nodes that aren't contained by other nodes.
   */
  function removeSubsets(nodes) {
    var idx = nodes.length;
    /*
     * Check if each node (or one of its ancestors) is already contained in the
     * array.
     */
    while (--idx >= 0) {
      var node = nodes[idx];
      /*
       * Remove the node if it is not unique.
       * We are going through the array from the end, so we only
       * have to check nodes that preceed the node under consideration in the array.
       */
      if (idx > 0 && nodes.lastIndexOf(node, idx - 1) >= 0) {
        nodes.splice(idx, 1);
        continue;
      }
      for (var ancestor = node.parent; ancestor; ancestor = ancestor.parent) {
        if (nodes.includes(ancestor)) {
          nodes.splice(idx, 1);
          break;
        }
      }
    }
    return nodes;
  }
  exports.removeSubsets = removeSubsets;
  /**
   * @category Helpers
   * @see {@link http://dom.spec.whatwg.org/#dom-node-comparedocumentposition}
   */
  var DocumentPosition;
  (function (DocumentPosition) {
    DocumentPosition[(DocumentPosition["DISCONNECTED"] = 1)] = "DISCONNECTED";
    DocumentPosition[(DocumentPosition["PRECEDING"] = 2)] = "PRECEDING";
    DocumentPosition[(DocumentPosition["FOLLOWING"] = 4)] = "FOLLOWING";
    DocumentPosition[(DocumentPosition["CONTAINS"] = 8)] = "CONTAINS";
    DocumentPosition[(DocumentPosition["CONTAINED_BY"] = 16)] = "CONTAINED_BY";
  })(
    (DocumentPosition =
      exports.DocumentPosition || (exports.DocumentPosition = {})),
  );
  /**
   * Compare the position of one node against another node in any other document,
   * returning a bitmask with the values from {@link DocumentPosition}.
   *
   * Document order:
   * > There is an ordering, document order, defined on all the nodes in the
   * > document corresponding to the order in which the first character of the
   * > XML representation of each node occurs in the XML representation of the
   * > document after expansion of general entities. Thus, the document element
   * > node will be the first node. Element nodes occur before their children.
   * > Thus, document order orders element nodes in order of the occurrence of
   * > their start-tag in the XML (after expansion of entities). The attribute
   * > nodes of an element occur after the element and before its children. The
   * > relative order of attribute nodes is implementation-dependent.
   *
   * Source:
   * http://www.w3.org/TR/DOM-Level-3-Core/glossary.html#dt-document-order
   *
   * @category Helpers
   * @param nodeA The first node to use in the comparison
   * @param nodeB The second node to use in the comparison
   * @returns A bitmask describing the input nodes' relative position.
   *
   * See http://dom.spec.whatwg.org/#dom-node-comparedocumentposition for
   * a description of these values.
   */
  function compareDocumentPosition(nodeA, nodeB) {
    var aParents = [];
    var bParents = [];
    if (nodeA === nodeB) {
      return 0;
    }
    var current = (0, domhandler_1.hasChildren)(nodeA) ? nodeA : nodeA.parent;
    while (current) {
      aParents.unshift(current);
      current = current.parent;
    }
    current = (0, domhandler_1.hasChildren)(nodeB) ? nodeB : nodeB.parent;
    while (current) {
      bParents.unshift(current);
      current = current.parent;
    }
    var maxIdx = Math.min(aParents.length, bParents.length);
    var idx = 0;
    while (idx < maxIdx && aParents[idx] === bParents[idx]) {
      idx++;
    }
    if (idx === 0) {
      return DocumentPosition.DISCONNECTED;
    }
    var sharedParent = aParents[idx - 1];
    var siblings = sharedParent.children;
    var aSibling = aParents[idx];
    var bSibling = bParents[idx];
    if (siblings.indexOf(aSibling) > siblings.indexOf(bSibling)) {
      if (sharedParent === nodeB) {
        return DocumentPosition.FOLLOWING | DocumentPosition.CONTAINED_BY;
      }
      return DocumentPosition.FOLLOWING;
    }
    if (sharedParent === nodeA) {
      return DocumentPosition.PRECEDING | DocumentPosition.CONTAINS;
    }
    return DocumentPosition.PRECEDING;
  }
  exports.compareDocumentPosition = compareDocumentPosition;
  /**
   * Sort an array of nodes based on their relative position in the document,
   * removing any duplicate nodes. If the array contains nodes that do not belong
   * to the same document, sort order is unspecified.
   *
   * @category Helpers
   * @param nodes Array of DOM nodes.
   * @returns Collection of unique nodes, sorted in document order.
   */
  function uniqueSort(nodes) {
    nodes = nodes.filter(function (node, i, arr) {
      return !arr.includes(node, i + 1);
    });
    nodes.sort(function (a, b) {
      var relative = compareDocumentPosition(a, b);
      if (relative & DocumentPosition.PRECEDING) {
        return -1;
      } else if (relative & DocumentPosition.FOLLOWING) {
        return 1;
      }
      return 0;
    });
    return nodes;
  }
  exports.uniqueSort = uniqueSort;
})(helpers);

var feeds = {};

Object.defineProperty(feeds, "__esModule", { value: true });
feeds.getFeed = void 0;
var stringify_js_1 = stringify$1;
var legacy_js_1 = legacy;
/**
 * Get the feed object from the root of a DOM tree.
 *
 * @category Feeds
 * @param doc - The DOM to to extract the feed from.
 * @returns The feed.
 */
function getFeed(doc) {
  var feedRoot = getOneElement(isValidFeed, doc);
  return !feedRoot
    ? null
    : feedRoot.name === "feed"
      ? getAtomFeed(feedRoot)
      : getRssFeed(feedRoot);
}
feeds.getFeed = getFeed;
/**
 * Parse an Atom feed.
 *
 * @param feedRoot The root of the feed.
 * @returns The parsed feed.
 */
function getAtomFeed(feedRoot) {
  var _a;
  var childs = feedRoot.children;
  var feed = {
    type: "atom",
    items: (0, legacy_js_1.getElementsByTagName)("entry", childs).map(
      function (item) {
        var _a;
        var children = item.children;
        var entry = { media: getMediaElements(children) };
        addConditionally(entry, "id", "id", children);
        addConditionally(entry, "title", "title", children);
        var href =
          (_a = getOneElement("link", children)) === null || _a === void 0
            ? void 0
            : _a.attribs["href"];
        if (href) {
          entry.link = href;
        }
        var description =
          fetch$1("summary", children) || fetch$1("content", children);
        if (description) {
          entry.description = description;
        }
        var pubDate = fetch$1("updated", children);
        if (pubDate) {
          entry.pubDate = new Date(pubDate);
        }
        return entry;
      },
    ),
  };
  addConditionally(feed, "id", "id", childs);
  addConditionally(feed, "title", "title", childs);
  var href =
    (_a = getOneElement("link", childs)) === null || _a === void 0
      ? void 0
      : _a.attribs["href"];
  if (href) {
    feed.link = href;
  }
  addConditionally(feed, "description", "subtitle", childs);
  var updated = fetch$1("updated", childs);
  if (updated) {
    feed.updated = new Date(updated);
  }
  addConditionally(feed, "author", "email", childs, true);
  return feed;
}
/**
 * Parse a RSS feed.
 *
 * @param feedRoot The root of the feed.
 * @returns The parsed feed.
 */
function getRssFeed(feedRoot) {
  var _a, _b;
  var childs =
    (_b =
      (_a = getOneElement("channel", feedRoot.children)) === null ||
      _a === void 0
        ? void 0
        : _a.children) !== null && _b !== void 0
      ? _b
      : [];
  var feed = {
    type: feedRoot.name.substr(0, 3),
    id: "",
    items: (0, legacy_js_1.getElementsByTagName)("item", feedRoot.children).map(
      function (item) {
        var children = item.children;
        var entry = { media: getMediaElements(children) };
        addConditionally(entry, "id", "guid", children);
        addConditionally(entry, "title", "title", children);
        addConditionally(entry, "link", "link", children);
        addConditionally(entry, "description", "description", children);
        var pubDate =
          fetch$1("pubDate", children) || fetch$1("dc:date", children);
        if (pubDate) entry.pubDate = new Date(pubDate);
        return entry;
      },
    ),
  };
  addConditionally(feed, "title", "title", childs);
  addConditionally(feed, "link", "link", childs);
  addConditionally(feed, "description", "description", childs);
  var updated = fetch$1("lastBuildDate", childs);
  if (updated) {
    feed.updated = new Date(updated);
  }
  addConditionally(feed, "author", "managingEditor", childs, true);
  return feed;
}
var MEDIA_KEYS_STRING = ["url", "type", "lang"];
var MEDIA_KEYS_INT = [
  "fileSize",
  "bitrate",
  "framerate",
  "samplingrate",
  "channels",
  "duration",
  "height",
  "width",
];
/**
 * Get all media elements of a feed item.
 *
 * @param where Nodes to search in.
 * @returns Media elements.
 */
function getMediaElements(where) {
  return (0, legacy_js_1.getElementsByTagName)("media:content", where).map(
    function (elem) {
      var attribs = elem.attribs;
      var media = {
        medium: attribs["medium"],
        isDefault: !!attribs["isDefault"],
      };
      for (
        var _i = 0, MEDIA_KEYS_STRING_1 = MEDIA_KEYS_STRING;
        _i < MEDIA_KEYS_STRING_1.length;
        _i++
      ) {
        var attrib = MEDIA_KEYS_STRING_1[_i];
        if (attribs[attrib]) {
          media[attrib] = attribs[attrib];
        }
      }
      for (
        var _a = 0, MEDIA_KEYS_INT_1 = MEDIA_KEYS_INT;
        _a < MEDIA_KEYS_INT_1.length;
        _a++
      ) {
        var attrib = MEDIA_KEYS_INT_1[_a];
        if (attribs[attrib]) {
          media[attrib] = parseInt(attribs[attrib], 10);
        }
      }
      if (attribs["expression"]) {
        media.expression = attribs["expression"];
      }
      return media;
    },
  );
}
/**
 * Get one element by tag name.
 *
 * @param tagName Tag name to look for
 * @param node Node to search in
 * @returns The element or null
 */
function getOneElement(tagName, node) {
  return (0, legacy_js_1.getElementsByTagName)(tagName, node, true, 1)[0];
}
/**
 * Get the text content of an element with a certain tag name.
 *
 * @param tagName Tag name to look for.
 * @param where Node to search in.
 * @param recurse Whether to recurse into child nodes.
 * @returns The text content of the element.
 */
function fetch$1(tagName, where, recurse) {
  if (recurse === void 0) {
    recurse = false;
  }
  return (0, stringify_js_1.textContent)(
    (0, legacy_js_1.getElementsByTagName)(tagName, where, recurse, 1),
  ).trim();
}
/**
 * Adds a property to an object if it has a value.
 *
 * @param obj Object to be extended
 * @param prop Property name
 * @param tagName Tag name that contains the conditionally added property
 * @param where Element to search for the property
 * @param recurse Whether to recurse into child nodes.
 */
function addConditionally(obj, prop, tagName, where, recurse) {
  if (recurse === void 0) {
    recurse = false;
  }
  var val = fetch$1(tagName, where, recurse);
  if (val) obj[prop] = val;
}
/**
 * Checks if an element is a feed root node.
 *
 * @param value The name of the element to check.
 * @returns Whether an element is a feed root node.
 */
function isValidFeed(value) {
  return value === "rss" || value === "feed" || value === "rdf:RDF";
}

(function (exports) {
  var __createBinding =
    (commonjsGlobal && commonjsGlobal.__createBinding) ||
    (Object.create
      ? function (o, m, k, k2) {
          if (k2 === undefined) k2 = k;
          var desc = Object.getOwnPropertyDescriptor(m, k);
          if (
            !desc ||
            ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)
          ) {
            desc = {
              enumerable: true,
              get: function () {
                return m[k];
              },
            };
          }
          Object.defineProperty(o, k2, desc);
        }
      : function (o, m, k, k2) {
          if (k2 === undefined) k2 = k;
          o[k2] = m[k];
        });
  var __exportStar =
    (commonjsGlobal && commonjsGlobal.__exportStar) ||
    function (m, exports) {
      for (var p in m)
        if (
          p !== "default" &&
          !Object.prototype.hasOwnProperty.call(exports, p)
        )
          __createBinding(exports, m, p);
    };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.hasChildren =
    exports.isDocument =
    exports.isComment =
    exports.isText =
    exports.isCDATA =
    exports.isTag =
      void 0;
  __exportStar(stringify$1, exports);
  __exportStar(traversal, exports);
  __exportStar(manipulation, exports);
  __exportStar(querying, exports);
  __exportStar(legacy, exports);
  __exportStar(helpers, exports);
  __exportStar(feeds, exports);
  /** @deprecated Use these methods from `domhandler` directly. */
  var domhandler_1 = lib$5;
  Object.defineProperty(exports, "isTag", {
    enumerable: true,
    get: function () {
      return domhandler_1.isTag;
    },
  });
  Object.defineProperty(exports, "isCDATA", {
    enumerable: true,
    get: function () {
      return domhandler_1.isCDATA;
    },
  });
  Object.defineProperty(exports, "isText", {
    enumerable: true,
    get: function () {
      return domhandler_1.isText;
    },
  });
  Object.defineProperty(exports, "isComment", {
    enumerable: true,
    get: function () {
      return domhandler_1.isComment;
    },
  });
  Object.defineProperty(exports, "isDocument", {
    enumerable: true,
    get: function () {
      return domhandler_1.isDocument;
    },
  });
  Object.defineProperty(exports, "hasChildren", {
    enumerable: true,
    get: function () {
      return domhandler_1.hasChildren;
    },
  });
})(lib$2);

const index$l = /*@__PURE__*/ getDefaultExportFromCjs(lib$2);

const DomUtils = /*#__PURE__*/ _mergeNamespaces(
  {
    __proto__: null,
    default: index$l,
  },
  [lib$2],
);

var boolbase = {
  trueFunc: function trueFunc() {
    return true;
  },
  falseFunc: function falseFunc() {
    return false;
  },
};

const boolbase$1 = /*@__PURE__*/ getDefaultExportFromCjs(boolbase);

const procedure$1 = new Map([
  [SelectorType.Universal, 50],
  [SelectorType.Tag, 30],
  [SelectorType.Attribute, 1],
  [SelectorType.Pseudo, 0],
]);
function isTraversal$1(token) {
  return !procedure$1.has(token.type);
}
const attributes$2 = new Map([
  [AttributeAction.Exists, 10],
  [AttributeAction.Equals, 8],
  [AttributeAction.Not, 7],
  [AttributeAction.Start, 6],
  [AttributeAction.End, 6],
  [AttributeAction.Any, 5],
]);
/**
 * Sort the parts of the passed selector,
 * as there is potential for optimization
 * (some types of selectors are faster than others)
 *
 * @param arr Selector to sort
 */
function sortByProcedure$1(arr) {
  const procs = arr.map(getProcedure$1);
  for (let i = 1; i < arr.length; i++) {
    const procNew = procs[i];
    if (procNew < 0) continue;
    for (let j = i - 1; j >= 0 && procNew < procs[j]; j--) {
      const token = arr[j + 1];
      arr[j + 1] = arr[j];
      arr[j] = token;
      procs[j + 1] = procs[j];
      procs[j] = procNew;
    }
  }
}
function getProcedure$1(token) {
  var _a, _b;
  let proc =
    (_a = procedure$1.get(token.type)) !== null && _a !== void 0 ? _a : -1;
  if (token.type === SelectorType.Attribute) {
    proc =
      (_b = attributes$2.get(token.action)) !== null && _b !== void 0 ? _b : 4;
    if (token.action === AttributeAction.Equals && token.name === "id") {
      // Prefer ID selectors (eg. #ID)
      proc = 9;
    }
    if (token.ignoreCase) {
      /*
       * IgnoreCase adds some overhead, prefer "normal" token
       * this is a binary operation, to ensure it's still an int
       */
      proc >>= 1;
    }
  } else if (token.type === SelectorType.Pseudo) {
    if (!token.data) {
      proc = 3;
    } else if (token.name === "has" || token.name === "contains") {
      proc = 0; // Expensive in any case
    } else if (Array.isArray(token.data)) {
      // Eg. :matches, :not
      proc = Math.min(
        ...token.data.map((d) => Math.min(...d.map(getProcedure$1))),
      );
      // If we have traversals, try to avoid executing this selector
      if (proc < 0) {
        proc = 0;
      }
    } else {
      proc = 2;
    }
  }
  return proc;
}

/**
 * All reserved characters in a regex, used for escaping.
 *
 * Taken from XRegExp, (c) 2007-2020 Steven Levithan under the MIT license
 * https://github.com/slevithan/xregexp/blob/95eeebeb8fac8754d54eafe2b4743661ac1cf028/src/xregexp.js#L794
 */
const reChars$1 = /[-[\]{}()*+?.,\\^$|#\s]/g;
function escapeRegex$1(value) {
  return value.replace(reChars$1, "\\$&");
}
/**
 * Attributes that are case-insensitive in HTML.
 *
 * @private
 * @see https://html.spec.whatwg.org/multipage/semantics-other.html#case-sensitivity-of-selectors
 */
const caseInsensitiveAttributes$1 = new Set([
  "accept",
  "accept-charset",
  "align",
  "alink",
  "axis",
  "bgcolor",
  "charset",
  "checked",
  "clear",
  "codetype",
  "color",
  "compact",
  "declare",
  "defer",
  "dir",
  "direction",
  "disabled",
  "enctype",
  "face",
  "frame",
  "hreflang",
  "http-equiv",
  "lang",
  "language",
  "link",
  "media",
  "method",
  "multiple",
  "nohref",
  "noresize",
  "noshade",
  "nowrap",
  "readonly",
  "rel",
  "rev",
  "rules",
  "scope",
  "scrolling",
  "selected",
  "shape",
  "target",
  "text",
  "type",
  "valign",
  "valuetype",
  "vlink",
]);
function shouldIgnoreCase$1(selector, options) {
  return typeof selector.ignoreCase === "boolean"
    ? selector.ignoreCase
    : selector.ignoreCase === "quirks"
      ? !!options.quirksMode
      : !options.xmlMode && caseInsensitiveAttributes$1.has(selector.name);
}
/**
 * Attribute selectors
 */
const attributeRules = {
  equals(next, data, options) {
    const { adapter } = options;
    const { name } = data;
    let { value } = data;
    if (shouldIgnoreCase$1(data, options)) {
      value = value.toLowerCase();
      return (elem) => {
        const attr = adapter.getAttributeValue(elem, name);
        return (
          attr != null &&
          attr.length === value.length &&
          attr.toLowerCase() === value &&
          next(elem)
        );
      };
    }
    return (elem) =>
      adapter.getAttributeValue(elem, name) === value && next(elem);
  },
  hyphen(next, data, options) {
    const { adapter } = options;
    const { name } = data;
    let { value } = data;
    const len = value.length;
    if (shouldIgnoreCase$1(data, options)) {
      value = value.toLowerCase();
      return function hyphenIC(elem) {
        const attr = adapter.getAttributeValue(elem, name);
        return (
          attr != null &&
          (attr.length === len || attr.charAt(len) === "-") &&
          attr.substr(0, len).toLowerCase() === value &&
          next(elem)
        );
      };
    }
    return function hyphen(elem) {
      const attr = adapter.getAttributeValue(elem, name);
      return (
        attr != null &&
        (attr.length === len || attr.charAt(len) === "-") &&
        attr.substr(0, len) === value &&
        next(elem)
      );
    };
  },
  element(next, data, options) {
    const { adapter } = options;
    const { name, value } = data;
    if (/\s/.test(value)) {
      return boolbase$1.falseFunc;
    }
    const regex = new RegExp(
      `(?:^|\\s)${escapeRegex$1(value)}(?:$|\\s)`,
      shouldIgnoreCase$1(data, options) ? "i" : "",
    );
    return function element(elem) {
      const attr = adapter.getAttributeValue(elem, name);
      return (
        attr != null &&
        attr.length >= value.length &&
        regex.test(attr) &&
        next(elem)
      );
    };
  },
  exists(next, { name }, { adapter }) {
    return (elem) => adapter.hasAttrib(elem, name) && next(elem);
  },
  start(next, data, options) {
    const { adapter } = options;
    const { name } = data;
    let { value } = data;
    const len = value.length;
    if (len === 0) {
      return boolbase$1.falseFunc;
    }
    if (shouldIgnoreCase$1(data, options)) {
      value = value.toLowerCase();
      return (elem) => {
        const attr = adapter.getAttributeValue(elem, name);
        return (
          attr != null &&
          attr.length >= len &&
          attr.substr(0, len).toLowerCase() === value &&
          next(elem)
        );
      };
    }
    return (elem) => {
      var _a;
      return (
        !!((_a = adapter.getAttributeValue(elem, name)) === null ||
        _a === void 0
          ? void 0
          : _a.startsWith(value)) && next(elem)
      );
    };
  },
  end(next, data, options) {
    const { adapter } = options;
    const { name } = data;
    let { value } = data;
    const len = -value.length;
    if (len === 0) {
      return boolbase$1.falseFunc;
    }
    if (shouldIgnoreCase$1(data, options)) {
      value = value.toLowerCase();
      return (elem) => {
        var _a;
        return (
          ((_a = adapter.getAttributeValue(elem, name)) === null ||
          _a === void 0
            ? void 0
            : _a.substr(len).toLowerCase()) === value && next(elem)
        );
      };
    }
    return (elem) => {
      var _a;
      return (
        !!((_a = adapter.getAttributeValue(elem, name)) === null ||
        _a === void 0
          ? void 0
          : _a.endsWith(value)) && next(elem)
      );
    };
  },
  any(next, data, options) {
    const { adapter } = options;
    const { name, value } = data;
    if (value === "") {
      return boolbase$1.falseFunc;
    }
    if (shouldIgnoreCase$1(data, options)) {
      const regex = new RegExp(escapeRegex$1(value), "i");
      return function anyIC(elem) {
        const attr = adapter.getAttributeValue(elem, name);
        return (
          attr != null &&
          attr.length >= value.length &&
          regex.test(attr) &&
          next(elem)
        );
      };
    }
    return (elem) => {
      var _a;
      return (
        !!((_a = adapter.getAttributeValue(elem, name)) === null ||
        _a === void 0
          ? void 0
          : _a.includes(value)) && next(elem)
      );
    };
  },
  not(next, data, options) {
    const { adapter } = options;
    const { name } = data;
    let { value } = data;
    if (value === "") {
      return (elem) => !!adapter.getAttributeValue(elem, name) && next(elem);
    } else if (shouldIgnoreCase$1(data, options)) {
      value = value.toLowerCase();
      return (elem) => {
        const attr = adapter.getAttributeValue(elem, name);
        return (
          (attr == null ||
            attr.length !== value.length ||
            attr.toLowerCase() !== value) &&
          next(elem)
        );
      };
    }
    return (elem) =>
      adapter.getAttributeValue(elem, name) !== value && next(elem);
  },
};

var lib$1 = {};

var parse$1D = {};

// Following http://www.w3.org/TR/css3-selectors/#nth-child-pseudo
Object.defineProperty(parse$1D, "__esModule", { value: true });
parse$1D.parse = void 0;
// Whitespace as per https://www.w3.org/TR/selectors-3/#lex is " \t\r\n\f"
var whitespace = new Set([9, 10, 12, 13, 32]);
var ZERO = "0".charCodeAt(0);
var NINE = "9".charCodeAt(0);
/**
 * Parses an expression.
 *
 * @throws An `Error` if parsing fails.
 * @returns An array containing the integer step size and the integer offset of the nth rule.
 * @example nthCheck.parse("2n+3"); // returns [2, 3]
 */
function parse$1C(formula) {
  formula = formula.trim().toLowerCase();
  if (formula === "even") {
    return [2, 0];
  } else if (formula === "odd") {
    return [2, 1];
  }
  // Parse [ ['-'|'+']? INTEGER? {N} [ S* ['-'|'+'] S* INTEGER ]?
  var idx = 0;
  var a = 0;
  var sign = readSign();
  var number = readNumber();
  if (idx < formula.length && formula.charAt(idx) === "n") {
    idx++;
    a = sign * (number !== null && number !== void 0 ? number : 1);
    skipWhitespace();
    if (idx < formula.length) {
      sign = readSign();
      skipWhitespace();
      number = readNumber();
    } else {
      sign = number = 0;
    }
  }
  // Throw if there is anything else
  if (number === null || idx < formula.length) {
    throw new Error("n-th rule couldn't be parsed ('".concat(formula, "')"));
  }
  return [a, sign * number];
  function readSign() {
    if (formula.charAt(idx) === "-") {
      idx++;
      return -1;
    }
    if (formula.charAt(idx) === "+") {
      idx++;
    }
    return 1;
  }
  function readNumber() {
    var start = idx;
    var value = 0;
    while (
      idx < formula.length &&
      formula.charCodeAt(idx) >= ZERO &&
      formula.charCodeAt(idx) <= NINE
    ) {
      value = value * 10 + (formula.charCodeAt(idx) - ZERO);
      idx++;
    }
    // Return `null` if we didn't read anything.
    return idx === start ? null : value;
  }
  function skipWhitespace() {
    while (idx < formula.length && whitespace.has(formula.charCodeAt(idx))) {
      idx++;
    }
  }
}
parse$1D.parse = parse$1C;

var compile$3 = {};

var __importDefault$2 =
  (commonjsGlobal && commonjsGlobal.__importDefault) ||
  function (mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
Object.defineProperty(compile$3, "__esModule", { value: true });
compile$3.generate = compile$3.compile = void 0;
var boolbase_1$2 = __importDefault$2(boolbase);
/**
 * Returns a function that checks if an elements index matches the given rule
 * highly optimized to return the fastest solution.
 *
 * @param parsed A tuple [a, b], as returned by `parse`.
 * @returns A highly optimized function that returns whether an index matches the nth-check.
 * @example
 *
 * ```js
 * const check = nthCheck.compile([2, 3]);
 *
 * check(0); // `false`
 * check(1); // `false`
 * check(2); // `true`
 * check(3); // `false`
 * check(4); // `true`
 * check(5); // `false`
 * check(6); // `true`
 * ```
 */
function compile$2(parsed) {
  var a = parsed[0];
  // Subtract 1 from `b`, to convert from one- to zero-indexed.
  var b = parsed[1] - 1;
  /*
   * When `b <= 0`, `a * n` won't be lead to any matches for `a < 0`.
   * Besides, the specification states that no elements are
   * matched when `a` and `b` are 0.
   *
   * `b < 0` here as we subtracted 1 from `b` above.
   */
  if (b < 0 && a <= 0) return boolbase_1$2.default.falseFunc;
  // When `a` is in the range -1..1, it matches any element (so only `b` is checked).
  if (a === -1)
    return function (index) {
      return index <= b;
    };
  if (a === 0)
    return function (index) {
      return index === b;
    };
  // When `b <= 0` and `a === 1`, they match any element.
  if (a === 1)
    return b < 0
      ? boolbase_1$2.default.trueFunc
      : function (index) {
          return index >= b;
        };
  /*
   * Otherwise, modulo can be used to check if there is a match.
   *
   * Modulo doesn't care about the sign, so let's use `a`s absolute value.
   */
  var absA = Math.abs(a);
  // Get `b mod a`, + a if this is negative.
  var bMod = ((b % absA) + absA) % absA;
  return a > 1
    ? function (index) {
        return index >= b && index % absA === bMod;
      }
    : function (index) {
        return index <= b && index % absA === bMod;
      };
}
compile$3.compile = compile$2;
/**
 * Returns a function that produces a monotonously increasing sequence of indices.
 *
 * If the sequence has an end, the returned function will return `null` after
 * the last index in the sequence.
 *
 * @param parsed A tuple [a, b], as returned by `parse`.
 * @returns A function that produces a sequence of indices.
 * @example <caption>Always increasing (2n+3)</caption>
 *
 * ```js
 * const gen = nthCheck.generate([2, 3])
 *
 * gen() // `1`
 * gen() // `3`
 * gen() // `5`
 * gen() // `8`
 * gen() // `11`
 * ```
 *
 * @example <caption>With end value (-2n+10)</caption>
 *
 * ```js
 *
 * const gen = nthCheck.generate([-2, 5]);
 *
 * gen() // 0
 * gen() // 2
 * gen() // 4
 * gen() // null
 * ```
 */
function generate$1v(parsed) {
  var a = parsed[0];
  // Subtract 1 from `b`, to convert from one- to zero-indexed.
  var b = parsed[1] - 1;
  var n = 0;
  // Make sure to always return an increasing sequence
  if (a < 0) {
    var aPos_1 = -a;
    // Get `b mod a`
    var minValue_1 = ((b % aPos_1) + aPos_1) % aPos_1;
    return function () {
      var val = minValue_1 + aPos_1 * n++;
      return val > b ? null : val;
    };
  }
  if (a === 0)
    return b < 0
      ? // There are no result  always return `null`
        function () {
          return null;
        }
      : // Return `b` exactly once
        function () {
          return n++ === 0 ? b : null;
        };
  if (b < 0) {
    b += a * Math.ceil(-b / a);
  }
  return function () {
    return a * n++ + b;
  };
}
compile$3.generate = generate$1v;

(function (exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.sequence =
    exports.generate =
    exports.compile =
    exports.parse =
      void 0;
  var parse_js_1 = parse$1D;
  Object.defineProperty(exports, "parse", {
    enumerable: true,
    get: function () {
      return parse_js_1.parse;
    },
  });
  var compile_js_1 = compile$3;
  Object.defineProperty(exports, "compile", {
    enumerable: true,
    get: function () {
      return compile_js_1.compile;
    },
  });
  Object.defineProperty(exports, "generate", {
    enumerable: true,
    get: function () {
      return compile_js_1.generate;
    },
  });
  /**
   * Parses and compiles a formula to a highly optimized function.
   * Combination of {@link parse} and {@link compile}.
   *
   * If the formula doesn't match any elements,
   * it returns [`boolbase`](https://github.com/fb55/boolbase)'s `falseFunc`.
   * Otherwise, a function accepting an _index_ is returned, which returns
   * whether or not the passed _index_ matches the formula.
   *
   * Note: The nth-rule starts counting at `1`, the returned function at `0`.
   *
   * @param formula The formula to compile.
   * @example
   * const check = nthCheck("2n+3");
   *
   * check(0); // `false`
   * check(1); // `false`
   * check(2); // `true`
   * check(3); // `false`
   * check(4); // `true`
   * check(5); // `false`
   * check(6); // `true`
   */
  function nthCheck(formula) {
    return (0, compile_js_1.compile)((0, parse_js_1.parse)(formula));
  }
  exports.default = nthCheck;
  /**
   * Parses and compiles a formula to a generator that produces a sequence of indices.
   * Combination of {@link parse} and {@link generate}.
   *
   * @param formula The formula to compile.
   * @returns A function that produces a sequence of indices.
   * @example <caption>Always increasing</caption>
   *
   * ```js
   * const gen = nthCheck.sequence('2n+3')
   *
   * gen() // `1`
   * gen() // `3`
   * gen() // `5`
   * gen() // `8`
   * gen() // `11`
   * ```
   *
   * @example <caption>With end value</caption>
   *
   * ```js
   *
   * const gen = nthCheck.sequence('-2n+5');
   *
   * gen() // 0
   * gen() // 2
   * gen() // 4
   * gen() // null
   * ```
   */
  function sequence(formula) {
    return (0, compile_js_1.generate)((0, parse_js_1.parse)(formula));
  }
  exports.sequence = sequence;
})(lib$1);

const getNCheck = /*@__PURE__*/ getDefaultExportFromCjs(lib$1);

function getChildFunc(next, adapter) {
  return (elem) => {
    const parent = adapter.getParent(elem);
    return parent != null && adapter.isTag(parent) && next(elem);
  };
}
const filters$2 = {
  contains(next, text, { adapter }) {
    return function contains(elem) {
      return next(elem) && adapter.getText(elem).includes(text);
    };
  },
  icontains(next, text, { adapter }) {
    const itext = text.toLowerCase();
    return function icontains(elem) {
      return next(elem) && adapter.getText(elem).toLowerCase().includes(itext);
    };
  },
  // Location specific methods
  "nth-child"(next, rule, { adapter, equals }) {
    const func = getNCheck(rule);
    if (func === boolbase$1.falseFunc) return boolbase$1.falseFunc;
    if (func === boolbase$1.trueFunc) return getChildFunc(next, adapter);
    return function nthChild(elem) {
      const siblings = adapter.getSiblings(elem);
      let pos = 0;
      for (let i = 0; i < siblings.length; i++) {
        if (equals(elem, siblings[i])) break;
        if (adapter.isTag(siblings[i])) {
          pos++;
        }
      }
      return func(pos) && next(elem);
    };
  },
  "nth-last-child"(next, rule, { adapter, equals }) {
    const func = getNCheck(rule);
    if (func === boolbase$1.falseFunc) return boolbase$1.falseFunc;
    if (func === boolbase$1.trueFunc) return getChildFunc(next, adapter);
    return function nthLastChild(elem) {
      const siblings = adapter.getSiblings(elem);
      let pos = 0;
      for (let i = siblings.length - 1; i >= 0; i--) {
        if (equals(elem, siblings[i])) break;
        if (adapter.isTag(siblings[i])) {
          pos++;
        }
      }
      return func(pos) && next(elem);
    };
  },
  "nth-of-type"(next, rule, { adapter, equals }) {
    const func = getNCheck(rule);
    if (func === boolbase$1.falseFunc) return boolbase$1.falseFunc;
    if (func === boolbase$1.trueFunc) return getChildFunc(next, adapter);
    return function nthOfType(elem) {
      const siblings = adapter.getSiblings(elem);
      let pos = 0;
      for (let i = 0; i < siblings.length; i++) {
        const currentSibling = siblings[i];
        if (equals(elem, currentSibling)) break;
        if (
          adapter.isTag(currentSibling) &&
          adapter.getName(currentSibling) === adapter.getName(elem)
        ) {
          pos++;
        }
      }
      return func(pos) && next(elem);
    };
  },
  "nth-last-of-type"(next, rule, { adapter, equals }) {
    const func = getNCheck(rule);
    if (func === boolbase$1.falseFunc) return boolbase$1.falseFunc;
    if (func === boolbase$1.trueFunc) return getChildFunc(next, adapter);
    return function nthLastOfType(elem) {
      const siblings = adapter.getSiblings(elem);
      let pos = 0;
      for (let i = siblings.length - 1; i >= 0; i--) {
        const currentSibling = siblings[i];
        if (equals(elem, currentSibling)) break;
        if (
          adapter.isTag(currentSibling) &&
          adapter.getName(currentSibling) === adapter.getName(elem)
        ) {
          pos++;
        }
      }
      return func(pos) && next(elem);
    };
  },
  // TODO determine the actual root element
  root(next, _rule, { adapter }) {
    return (elem) => {
      const parent = adapter.getParent(elem);
      return (parent == null || !adapter.isTag(parent)) && next(elem);
    };
  },
  scope(next, rule, options, context) {
    const { equals } = options;
    if (!context || context.length === 0) {
      // Equivalent to :root
      return filters$2["root"](next, rule, options);
    }
    if (context.length === 1) {
      // NOTE: can't be unpacked, as :has uses this for side-effects
      return (elem) => equals(context[0], elem) && next(elem);
    }
    return (elem) => context.includes(elem) && next(elem);
  },
  hover: dynamicStatePseudo("isHovered"),
  visited: dynamicStatePseudo("isVisited"),
  active: dynamicStatePseudo("isActive"),
};
/**
 * Dynamic state pseudos. These depend on optional Adapter methods.
 *
 * @param name The name of the adapter method to call.
 * @returns Pseudo for the `filters` object.
 */
function dynamicStatePseudo(name) {
  return function dynamicPseudo(next, _rule, { adapter }) {
    const func = adapter[name];
    if (typeof func !== "function") {
      return boolbase$1.falseFunc;
    }
    return function active(elem) {
      return func(elem) && next(elem);
    };
  };
}

// While filters are precompiled, pseudos get called when they are needed
const pseudos$1 = {
  empty(elem, { adapter }) {
    return !adapter.getChildren(elem).some(
      (elem) =>
        // FIXME: `getText` call is potentially expensive.
        adapter.isTag(elem) || adapter.getText(elem) !== "",
    );
  },
  "first-child"(elem, { adapter, equals }) {
    if (adapter.prevElementSibling) {
      return adapter.prevElementSibling(elem) == null;
    }
    const firstChild = adapter
      .getSiblings(elem)
      .find((elem) => adapter.isTag(elem));
    return firstChild != null && equals(elem, firstChild);
  },
  "last-child"(elem, { adapter, equals }) {
    const siblings = adapter.getSiblings(elem);
    for (let i = siblings.length - 1; i >= 0; i--) {
      if (equals(elem, siblings[i])) return true;
      if (adapter.isTag(siblings[i])) break;
    }
    return false;
  },
  "first-of-type"(elem, { adapter, equals }) {
    const siblings = adapter.getSiblings(elem);
    const elemName = adapter.getName(elem);
    for (let i = 0; i < siblings.length; i++) {
      const currentSibling = siblings[i];
      if (equals(elem, currentSibling)) return true;
      if (
        adapter.isTag(currentSibling) &&
        adapter.getName(currentSibling) === elemName
      ) {
        break;
      }
    }
    return false;
  },
  "last-of-type"(elem, { adapter, equals }) {
    const siblings = adapter.getSiblings(elem);
    const elemName = adapter.getName(elem);
    for (let i = siblings.length - 1; i >= 0; i--) {
      const currentSibling = siblings[i];
      if (equals(elem, currentSibling)) return true;
      if (
        adapter.isTag(currentSibling) &&
        adapter.getName(currentSibling) === elemName
      ) {
        break;
      }
    }
    return false;
  },
  "only-of-type"(elem, { adapter, equals }) {
    const elemName = adapter.getName(elem);
    return adapter
      .getSiblings(elem)
      .every(
        (sibling) =>
          equals(elem, sibling) ||
          !adapter.isTag(sibling) ||
          adapter.getName(sibling) !== elemName,
      );
  },
  "only-child"(elem, { adapter, equals }) {
    return adapter
      .getSiblings(elem)
      .every((sibling) => equals(elem, sibling) || !adapter.isTag(sibling));
  },
};
function verifyPseudoArgs$1(func, name, subselect, argIndex) {
  if (subselect === null) {
    if (func.length > argIndex) {
      throw new Error(`Pseudo-class :${name} requires an argument`);
    }
  } else if (func.length === argIndex) {
    throw new Error(`Pseudo-class :${name} doesn't have any arguments`);
  }
}

/**
 * Aliases are pseudos that are expressed as selectors.
 */
const aliases$1 = {
  // Links
  "any-link": ":is(a, area, link)[href]",
  link: ":any-link:not(:visited)",
  // Forms
  // https://html.spec.whatwg.org/multipage/scripting.html#disabled-elements
  disabled: `:is(
        :is(button, input, select, textarea, optgroup, option)[disabled],
        optgroup[disabled] > option,
        fieldset[disabled]:not(fieldset[disabled] legend:first-of-type *)
    )`,
  enabled: ":not(:disabled)",
  checked:
    ":is(:is(input[type=radio], input[type=checkbox])[checked], option:selected)",
  required: ":is(input, select, textarea)[required]",
  optional: ":is(input, select, textarea):not([required])",
  // JQuery extensions
  // https://html.spec.whatwg.org/multipage/form-elements.html#concept-option-selectedness
  selected:
    "option:is([selected], select:not([multiple]):not(:has(> option[selected])) > :first-of-type)",
  checkbox: "[type=checkbox]",
  file: "[type=file]",
  password: "[type=password]",
  radio: "[type=radio]",
  reset: "[type=reset]",
  image: "[type=image]",
  submit: "[type=submit]",
  parent: ":not(:empty)",
  header: ":is(h1, h2, h3, h4, h5, h6)",
  button: ":is(button, input[type=button])",
  input: ":is(input, textarea, select, button)",
  text: "input:is(:not([type!='']), [type=text])",
};

/** Used as a placeholder for :has. Will be replaced with the actual element. */
const PLACEHOLDER_ELEMENT = {};
function ensureIsTag(next, adapter) {
  if (next === boolbase$1.falseFunc) return boolbase$1.falseFunc;
  return (elem) => adapter.isTag(elem) && next(elem);
}
function getNextSiblings(elem, adapter) {
  const siblings = adapter.getSiblings(elem);
  if (siblings.length <= 1) return [];
  const elemIndex = siblings.indexOf(elem);
  if (elemIndex < 0 || elemIndex === siblings.length - 1) return [];
  return siblings.slice(elemIndex + 1).filter(adapter.isTag);
}
function copyOptions(options) {
  // Not copied: context, rootFunc
  return {
    xmlMode: !!options.xmlMode,
    lowerCaseAttributeNames: !!options.lowerCaseAttributeNames,
    lowerCaseTags: !!options.lowerCaseTags,
    quirksMode: !!options.quirksMode,
    cacheResults: !!options.cacheResults,
    pseudos: options.pseudos,
    adapter: options.adapter,
    equals: options.equals,
  };
}
const is$3 = (next, token, options, context, compileToken) => {
  const func = compileToken(token, copyOptions(options), context);
  return func === boolbase$1.trueFunc
    ? next
    : func === boolbase$1.falseFunc
      ? boolbase$1.falseFunc
      : (elem) => func(elem) && next(elem);
};
/*
 * :not, :has, :is, :matches and :where have to compile selectors
 * doing this in src/pseudos.ts would lead to circular dependencies,
 * so we add them here
 */
const subselects$1 = {
  is: is$3,
  /**
   * `:matches` and `:where` are aliases for `:is`.
   */
  matches: is$3,
  where: is$3,
  not(next, token, options, context, compileToken) {
    const func = compileToken(token, copyOptions(options), context);
    return func === boolbase$1.falseFunc
      ? next
      : func === boolbase$1.trueFunc
        ? boolbase$1.falseFunc
        : (elem) => !func(elem) && next(elem);
  },
  has(next, subselect, options, _context, compileToken) {
    const { adapter } = options;
    const opts = copyOptions(options);
    opts.relativeSelector = true;
    const context = subselect.some((s) => s.some(isTraversal$1))
      ? // Used as a placeholder. Will be replaced with the actual element.
        [PLACEHOLDER_ELEMENT]
      : undefined;
    const compiled = compileToken(subselect, opts, context);
    if (compiled === boolbase$1.falseFunc) return boolbase$1.falseFunc;
    const hasElement = ensureIsTag(compiled, adapter);
    // If `compiled` is `trueFunc`, we can skip this.
    if (context && compiled !== boolbase$1.trueFunc) {
      /*
       * `shouldTestNextSiblings` will only be true if the query starts with
       * a traversal (sibling or adjacent). That means we will always have a context.
       */
      const { shouldTestNextSiblings = false } = compiled;
      return (elem) => {
        if (!next(elem)) return false;
        context[0] = elem;
        const childs = adapter.getChildren(elem);
        const nextElements = shouldTestNextSiblings
          ? [...childs, ...getNextSiblings(elem, adapter)]
          : childs;
        return adapter.existsOne(hasElement, nextElements);
      };
    }
    return (elem) =>
      next(elem) && adapter.existsOne(hasElement, adapter.getChildren(elem));
  },
};

function compilePseudoSelector(next, selector, options, context, compileToken) {
  var _a;
  const { name, data } = selector;
  if (Array.isArray(data)) {
    if (!(name in subselects$1)) {
      throw new Error(`Unknown pseudo-class :${name}(${data})`);
    }
    return subselects$1[name](next, data, options, context, compileToken);
  }
  const userPseudo =
    (_a = options.pseudos) === null || _a === void 0 ? void 0 : _a[name];
  const stringPseudo =
    typeof userPseudo === "string" ? userPseudo : aliases$1[name];
  if (typeof stringPseudo === "string") {
    if (data != null) {
      throw new Error(`Pseudo ${name} doesn't have any arguments`);
    }
    // The alias has to be parsed here, to make sure options are respected.
    const alias = parse$1E(stringPseudo);
    return subselects$1["is"](next, alias, options, context, compileToken);
  }
  if (typeof userPseudo === "function") {
    verifyPseudoArgs$1(userPseudo, name, data, 1);
    return (elem) => userPseudo(elem, data) && next(elem);
  }
  if (name in filters$2) {
    return filters$2[name](next, data, options, context);
  }
  if (name in pseudos$1) {
    const pseudo = pseudos$1[name];
    verifyPseudoArgs$1(pseudo, name, data, 2);
    return (elem) => pseudo(elem, options, data) && next(elem);
  }
  throw new Error(`Unknown pseudo-class :${name}`);
}

function getElementParent$1(node, adapter) {
  const parent = adapter.getParent(node);
  if (parent && adapter.isTag(parent)) {
    return parent;
  }
  return null;
}
/*
 * All available rules
 */
function compileGeneralSelector$1(
  next,
  selector,
  options,
  context,
  compileToken,
) {
  const { adapter, equals } = options;
  switch (selector.type) {
    case SelectorType.PseudoElement: {
      throw new Error("Pseudo-elements are not supported by css-select");
    }
    case SelectorType.ColumnCombinator: {
      throw new Error("Column combinators are not yet supported by css-select");
    }
    case SelectorType.Attribute: {
      if (selector.namespace != null) {
        throw new Error(
          "Namespaced attributes are not yet supported by css-select",
        );
      }
      if (!options.xmlMode || options.lowerCaseAttributeNames) {
        selector.name = selector.name.toLowerCase();
      }
      return attributeRules[selector.action](next, selector, options);
    }
    case SelectorType.Pseudo: {
      return compilePseudoSelector(
        next,
        selector,
        options,
        context,
        compileToken,
      );
    }
    // Tags
    case SelectorType.Tag: {
      if (selector.namespace != null) {
        throw new Error(
          "Namespaced tag names are not yet supported by css-select",
        );
      }
      let { name } = selector;
      if (!options.xmlMode || options.lowerCaseTags) {
        name = name.toLowerCase();
      }
      return function tag(elem) {
        return adapter.getName(elem) === name && next(elem);
      };
    }
    // Traversal
    case SelectorType.Descendant: {
      if (options.cacheResults === false || typeof WeakSet === "undefined") {
        return function descendant(elem) {
          let current = elem;
          while ((current = getElementParent$1(current, adapter))) {
            if (next(current)) {
              return true;
            }
          }
          return false;
        };
      }
      // @ts-expect-error `ElementNode` is not extending object
      const isFalseCache = new WeakSet();
      return function cachedDescendant(elem) {
        let current = elem;
        while ((current = getElementParent$1(current, adapter))) {
          if (!isFalseCache.has(current)) {
            if (adapter.isTag(current) && next(current)) {
              return true;
            }
            isFalseCache.add(current);
          }
        }
        return false;
      };
    }
    case "_flexibleDescendant": {
      // Include element itself, only used while querying an array
      return function flexibleDescendant(elem) {
        let current = elem;
        do {
          if (next(current)) return true;
        } while ((current = getElementParent$1(current, adapter)));
        return false;
      };
    }
    case SelectorType.Parent: {
      return function parent(elem) {
        return adapter
          .getChildren(elem)
          .some((elem) => adapter.isTag(elem) && next(elem));
      };
    }
    case SelectorType.Child: {
      return function child(elem) {
        const parent = adapter.getParent(elem);
        return parent != null && adapter.isTag(parent) && next(parent);
      };
    }
    case SelectorType.Sibling: {
      return function sibling(elem) {
        const siblings = adapter.getSiblings(elem);
        for (let i = 0; i < siblings.length; i++) {
          const currentSibling = siblings[i];
          if (equals(elem, currentSibling)) break;
          if (adapter.isTag(currentSibling) && next(currentSibling)) {
            return true;
          }
        }
        return false;
      };
    }
    case SelectorType.Adjacent: {
      if (adapter.prevElementSibling) {
        return function adjacent(elem) {
          const previous = adapter.prevElementSibling(elem);
          return previous != null && next(previous);
        };
      }
      return function adjacent(elem) {
        const siblings = adapter.getSiblings(elem);
        let lastElement;
        for (let i = 0; i < siblings.length; i++) {
          const currentSibling = siblings[i];
          if (equals(elem, currentSibling)) break;
          if (adapter.isTag(currentSibling)) {
            lastElement = currentSibling;
          }
        }
        return !!lastElement && next(lastElement);
      };
    }
    case SelectorType.Universal: {
      if (selector.namespace != null && selector.namespace !== "*") {
        throw new Error(
          "Namespaced universal selectors are not yet supported by css-select",
        );
      }
      return next;
    }
  }
}

function includesScopePseudo$1(t) {
  return (
    t.type === SelectorType.Pseudo &&
    (t.name === "scope" ||
      (Array.isArray(t.data) &&
        t.data.some((data) => data.some(includesScopePseudo$1))))
  );
}
const DESCENDANT_TOKEN$1 = { type: SelectorType.Descendant };
const FLEXIBLE_DESCENDANT_TOKEN$1 = {
  type: "_flexibleDescendant",
};
const SCOPE_TOKEN$1 = {
  type: SelectorType.Pseudo,
  name: "scope",
  data: null,
};
/*
 * CSS 4 Spec (Draft): 3.4.1. Absolutizing a Relative Selector
 * http://www.w3.org/TR/selectors4/#absolutizing
 */
function absolutize$1(token, { adapter }, context) {
  // TODO Use better check if the context is a document
  const hasContext = !!(context === null || context === void 0
    ? void 0
    : context.every((e) => {
        const parent = adapter.isTag(e) && adapter.getParent(e);
        return e === PLACEHOLDER_ELEMENT || (parent && adapter.isTag(parent));
      }));
  for (const t of token) {
    if (
      t.length > 0 &&
      isTraversal$1(t[0]) &&
      t[0].type !== SelectorType.Descendant
    );
    else if (hasContext && !t.some(includesScopePseudo$1)) {
      t.unshift(DESCENDANT_TOKEN$1);
    } else {
      continue;
    }
    t.unshift(SCOPE_TOKEN$1);
  }
}
function compileToken$1(token, options, context) {
  var _a;
  token.forEach(sortByProcedure$1);
  context = (_a = options.context) !== null && _a !== void 0 ? _a : context;
  const isArrayContext = Array.isArray(context);
  const finalContext =
    context && (Array.isArray(context) ? context : [context]);
  // Check if the selector is relative
  if (options.relativeSelector !== false) {
    absolutize$1(token, options, finalContext);
  } else if (token.some((t) => t.length > 0 && isTraversal$1(t[0]))) {
    throw new Error(
      "Relative selectors are not allowed when the `relativeSelector` option is disabled",
    );
  }
  let shouldTestNextSiblings = false;
  const query = token
    .map((rules) => {
      if (rules.length >= 2) {
        const [first, second] = rules;
        if (first.type !== SelectorType.Pseudo || first.name !== "scope");
        else if (isArrayContext && second.type === SelectorType.Descendant) {
          rules[1] = FLEXIBLE_DESCENDANT_TOKEN$1;
        } else if (
          second.type === SelectorType.Adjacent ||
          second.type === SelectorType.Sibling
        ) {
          shouldTestNextSiblings = true;
        }
      }
      return compileRules$1(rules, options, finalContext);
    })
    .reduce(reduceRules$1, boolbase$1.falseFunc);
  query.shouldTestNextSiblings = shouldTestNextSiblings;
  return query;
}
function compileRules$1(rules, options, context) {
  var _a;
  return rules.reduce(
    (previous, rule) =>
      previous === boolbase$1.falseFunc
        ? boolbase$1.falseFunc
        : compileGeneralSelector$1(
            previous,
            rule,
            options,
            context,
            compileToken$1,
          ),
    (_a = options.rootFunc) !== null && _a !== void 0
      ? _a
      : boolbase$1.trueFunc,
  );
}
function reduceRules$1(a, b) {
  if (b === boolbase$1.falseFunc || a === boolbase$1.trueFunc) {
    return a;
  }
  if (a === boolbase$1.falseFunc || b === boolbase$1.trueFunc) {
    return b;
  }
  return function combine(elem) {
    return a(elem) || b(elem);
  };
}

const defaultEquals = (a, b) => a === b;
const defaultOptions = {
  adapter: DomUtils,
  equals: defaultEquals,
};
function convertOptionFormats(options) {
  var _a, _b, _c, _d;
  /*
   * We force one format of options to the other one.
   */
  // @ts-expect-error Default options may have incompatible `Node` / `ElementNode`.
  const opts =
    options !== null && options !== void 0 ? options : defaultOptions;
  // @ts-expect-error Same as above.
  (_a = opts.adapter) !== null && _a !== void 0
    ? _a
    : (opts.adapter = DomUtils);
  // @ts-expect-error `equals` does not exist on `Options`
  (_b = opts.equals) !== null && _b !== void 0
    ? _b
    : (opts.equals =
        (_d =
          (_c = opts.adapter) === null || _c === void 0
            ? void 0
            : _c.equals) !== null && _d !== void 0
          ? _d
          : defaultEquals);
  return opts;
}
function wrapCompile(func) {
  return function addAdapter(selector, options, context) {
    const opts = convertOptionFormats(options);
    return func(selector, opts, context);
  };
}
const _compileToken = wrapCompile(compileToken$1);
function prepareContext(elems, adapter, shouldTestNextSiblings = false) {
  /*
   * Add siblings if the query requires them.
   * See https://github.com/fb55/css-select/pull/43#issuecomment-225414692
   */
  if (shouldTestNextSiblings) {
    elems = appendNextSiblings(elems, adapter);
  }
  return Array.isArray(elems)
    ? adapter.removeSubsets(elems)
    : adapter.getChildren(elems);
}
function appendNextSiblings(elem, adapter) {
  // Order matters because jQuery seems to check the children before the siblings
  const elems = Array.isArray(elem) ? elem.slice(0) : [elem];
  const elemsLength = elems.length;
  for (let i = 0; i < elemsLength; i++) {
    const nextSiblings = getNextSiblings(elems[i], adapter);
    elems.push(...nextSiblings);
  }
  return elems;
}

const filterNames = new Set([
  "first",
  "last",
  "eq",
  "gt",
  "nth",
  "lt",
  "even",
  "odd",
]);
function isFilter(s) {
  if (s.type !== "pseudo") return false;
  if (filterNames.has(s.name)) return true;
  if (s.name === "not" && Array.isArray(s.data)) {
    // Only consider `:not` with embedded filters
    return s.data.some((s) => s.some(isFilter));
  }
  return false;
}
function getLimit(filter, data, partLimit) {
  const num = data != null ? parseInt(data, 10) : NaN;
  switch (filter) {
    case "first":
      return 1;
    case "nth":
    case "eq":
      return isFinite(num) ? (num >= 0 ? num + 1 : Infinity) : 0;
    case "lt":
      return isFinite(num)
        ? num >= 0
          ? Math.min(num, partLimit)
          : Infinity
        : 0;
    case "gt":
      return isFinite(num) ? Infinity : 0;
    case "odd":
      return 2 * partLimit;
    case "even":
      return 2 * partLimit - 1;
    case "last":
    case "not":
      return Infinity;
  }
}

function getDocumentRoot(node) {
  while (node.parent) node = node.parent;
  return node;
}
function groupSelectors(selectors) {
  const filteredSelectors = [];
  const plainSelectors = [];
  for (const selector of selectors) {
    if (selector.some(isFilter)) {
      filteredSelectors.push(selector);
    } else {
      plainSelectors.push(selector);
    }
  }
  return [plainSelectors, filteredSelectors];
}

const UNIVERSAL_SELECTOR = {
  type: SelectorType.Universal,
  namespace: null,
};
const SCOPE_PSEUDO = {
  type: SelectorType.Pseudo,
  name: "scope",
  data: null,
};
function is$2(element, selector, options = {}) {
  return some([element], selector, options);
}
function some(elements, selector, options = {}) {
  if (typeof selector === "function") return elements.some(selector);
  const [plain, filtered] = groupSelectors(parse$1E(selector));
  return (
    (plain.length > 0 && elements.some(_compileToken(plain, options))) ||
    filtered.some((sel) => filterBySelector(sel, elements, options).length > 0)
  );
}
function filterByPosition(filter, elems, data, options) {
  const num = typeof data === "string" ? parseInt(data, 10) : NaN;
  switch (filter) {
    case "first":
    case "lt":
      // Already done in `getLimit`
      return elems;
    case "last":
      return elems.length > 0 ? [elems[elems.length - 1]] : elems;
    case "nth":
    case "eq":
      return isFinite(num) && Math.abs(num) < elems.length
        ? [num < 0 ? elems[elems.length + num] : elems[num]]
        : [];
    case "gt":
      return isFinite(num) ? elems.slice(num + 1) : [];
    case "even":
      return elems.filter((_, i) => i % 2 === 0);
    case "odd":
      return elems.filter((_, i) => i % 2 === 1);
    case "not": {
      const filtered = new Set(filterParsed(data, elems, options));
      return elems.filter((e) => !filtered.has(e));
    }
  }
}
function filter$3(selector, elements, options = {}) {
  return filterParsed(parse$1E(selector), elements, options);
}
/**
 * Filter a set of elements by a selector.
 *
 * Will return elements in the original order.
 *
 * @param selector Selector to filter by.
 * @param elements Elements to filter.
 * @param options Options for selector.
 */
function filterParsed(selector, elements, options) {
  if (elements.length === 0) return [];
  const [plainSelectors, filteredSelectors] = groupSelectors(selector);
  let found;
  if (plainSelectors.length) {
    const filtered = filterElements(elements, plainSelectors, options);
    // If there are no filters, just return
    if (filteredSelectors.length === 0) {
      return filtered;
    }
    // Otherwise, we have to do some filtering
    if (filtered.length) {
      found = new Set(filtered);
    }
  }
  for (
    let i = 0;
    i < filteredSelectors.length &&
    (found === null || found === void 0 ? void 0 : found.size) !==
      elements.length;
    i++
  ) {
    const filteredSelector = filteredSelectors[i];
    const missing = found
      ? elements.filter((e) => lib$5.isTag(e) && !found.has(e))
      : elements;
    if (missing.length === 0) break;
    const filtered = filterBySelector(filteredSelector, elements, options);
    if (filtered.length) {
      if (!found) {
        /*
         * If we haven't found anything before the last selector,
         * just return what we found now.
         */
        if (i === filteredSelectors.length - 1) {
          return filtered;
        }
        found = new Set(filtered);
      } else {
        filtered.forEach((el) => found.add(el));
      }
    }
  }
  return typeof found !== "undefined"
    ? found.size === elements.length
      ? elements
      : // Filter elements to preserve order
        elements.filter((el) => found.has(el))
    : [];
}
function filterBySelector(selector, elements, options) {
  var _a;
  if (selector.some(isTraversal$2)) {
    /*
     * Get root node, run selector with the scope
     * set to all of our nodes.
     */
    const root =
      (_a = options.root) !== null && _a !== void 0
        ? _a
        : getDocumentRoot(elements[0]);
    const opts = { ...options, context: elements, relativeSelector: false };
    selector.push(SCOPE_PSEUDO);
    return findFilterElements(root, selector, opts, true, elements.length);
  }
  // Performance optimization: If we don't have to traverse, just filter set.
  return findFilterElements(
    elements,
    selector,
    options,
    false,
    elements.length,
  );
}
function select(selector, root, options = {}, limit = Infinity) {
  if (typeof selector === "function") {
    return find$4(root, selector);
  }
  const [plain, filtered] = groupSelectors(parse$1E(selector));
  const results = filtered.map((sel) =>
    findFilterElements(root, sel, options, true, limit),
  );
  // Plain selectors can be queried in a single go
  if (plain.length) {
    results.push(findElements(root, plain, options, limit));
  }
  if (results.length === 0) {
    return [];
  }
  // If there was only a single selector, just return the result
  if (results.length === 1) {
    return results[0];
  }
  // Sort results, filtering for duplicates
  return uniqueSort(results.reduce((a, b) => [...a, ...b]));
}
/**
 *
 * @param root Element(s) to search from.
 * @param selector Selector to look for.
 * @param options Options for querying.
 * @param queryForSelector Query multiple levels deep for the initial selector, even if it doesn't contain a traversal.
 */
function findFilterElements(
  root,
  selector,
  options,
  queryForSelector,
  totalLimit,
) {
  const filterIndex = selector.findIndex(isFilter);
  const sub = selector.slice(0, filterIndex);
  const filter = selector[filterIndex];
  // If we are at the end of the selector, we can limit the number of elements to retrieve.
  const partLimit = selector.length - 1 === filterIndex ? totalLimit : Infinity;
  /*
   * Set the number of elements to retrieve.
   * Eg. for :first, we only have to get a single element.
   */
  const limit = getLimit(filter.name, filter.data, partLimit);
  if (limit === 0) return [];
  /*
   * Skip `findElements` call if our selector starts with a positional
   * pseudo.
   */
  const elemsNoLimit =
    sub.length === 0 && !Array.isArray(root)
      ? getChildren$2(root).filter(lib$5.isTag)
      : sub.length === 0
        ? (Array.isArray(root) ? root : [root]).filter(lib$5.isTag)
        : queryForSelector || sub.some(isTraversal$2)
          ? findElements(root, [sub], options, limit)
          : filterElements(root, [sub], options);
  const elems = elemsNoLimit.slice(0, limit);
  let result = filterByPosition(filter.name, elems, filter.data, options);
  if (result.length === 0 || selector.length === filterIndex + 1) {
    return result;
  }
  const remainingSelector = selector.slice(filterIndex + 1);
  const remainingHasTraversal = remainingSelector.some(isTraversal$2);
  if (remainingHasTraversal) {
    if (isTraversal$2(remainingSelector[0])) {
      const { type } = remainingSelector[0];
      if (type === SelectorType.Sibling || type === SelectorType.Adjacent) {
        // If we have a sibling traversal, we need to also look at the siblings.
        result = prepareContext(result, DomUtils$1, true);
      }
      // Avoid a traversal-first selector error.
      remainingSelector.unshift(UNIVERSAL_SELECTOR);
    }
    options = {
      ...options,
      // Avoid absolutizing the selector
      relativeSelector: false,
      /*
       * Add a custom root func, to make sure traversals don't match elements
       * that aren't a part of the considered tree.
       */
      rootFunc: (el) => result.includes(el),
    };
  } else if (options.rootFunc && options.rootFunc !== boolbase.trueFunc) {
    options = { ...options, rootFunc: boolbase.trueFunc };
  }
  /*
   * If we have another filter, recursively call `findFilterElements`,
   * with the `recursive` flag disabled. We only have to look for more
   * elements when we see a traversal.
   *
   * Otherwise,
   */
  return remainingSelector.some(isFilter)
    ? findFilterElements(result, remainingSelector, options, false, totalLimit)
    : remainingHasTraversal
      ? // Query existing elements to resolve traversal.
        findElements(result, [remainingSelector], options, totalLimit)
      : // If we don't have any more traversals, simply filter elements.
        filterElements(result, [remainingSelector], options);
}
function findElements(root, sel, options, limit) {
  const query = _compileToken(sel, options, root);
  return find$4(root, query, limit);
}
function find$4(root, query, limit = Infinity) {
  const elems = prepareContext(root, DomUtils$1, query.shouldTestNextSiblings);
  return find$6((node) => lib$5.isTag(node) && query(node), elems, true, limit);
}
function filterElements(elements, sel, options) {
  const els = (Array.isArray(elements) ? elements : [elements]).filter(
    lib$5.isTag,
  );
  if (els.length === 0) return els;
  const query = _compileToken(sel, options);
  return query === boolbase.trueFunc ? els : els.filter(query);
}

/**
 * Methods for traversing the DOM structure.
 *
 * @module cheerio/traversing
 */
const reSiblingSelector = /^\s*[~+]/;
/**
 * Get the descendants of each element in the current set of matched elements,
 * filtered by a selector, jQuery object, or element.
 *
 * @category Traversing
 * @example
 *
 * ```js
 * $('#fruits').find('li').length;
 * //=> 3
 * $('#fruits').find($('.apple')).length;
 * //=> 1
 * ```
 *
 * @param selectorOrHaystack - Element to look for.
 * @returns The found elements.
 * @see {@link https://api.jquery.com/find/}
 */
function find$3(selectorOrHaystack) {
  var _a;
  if (!selectorOrHaystack) {
    return this._make([]);
  }
  const context = this.toArray();
  if (typeof selectorOrHaystack !== "string") {
    const haystack = isCheerio(selectorOrHaystack)
      ? selectorOrHaystack.toArray()
      : [selectorOrHaystack];
    return this._make(
      haystack.filter((elem) => context.some((node) => contains(node, elem))),
    );
  }
  const elems = reSiblingSelector.test(selectorOrHaystack)
    ? context
    : this.children().toArray();
  const options = {
    context,
    root: (_a = this._root) === null || _a === void 0 ? void 0 : _a[0],
    // Pass options that are recognized by `cheerio-select`
    xmlMode: this.options.xmlMode,
    lowerCaseTags: this.options.lowerCaseTags,
    lowerCaseAttributeNames: this.options.lowerCaseAttributeNames,
    pseudos: this.options.pseudos,
    quirksMode: this.options.quirksMode,
  };
  return this._make(select(selectorOrHaystack, elems, options));
}
/**
 * Creates a matcher, using a particular mapping function. Matchers provide a
 * function that finds elements using a generating function, supporting filtering.
 *
 * @private
 * @param matchMap - Mapping function.
 * @returns - Function for wrapping generating functions.
 */
function _getMatcher(matchMap) {
  return function (fn, ...postFns) {
    return function (selector) {
      var _a;
      let matched = matchMap(fn, this);
      if (selector) {
        matched = filterArray(
          matched,
          selector,
          this.options.xmlMode,
          (_a = this._root) === null || _a === void 0 ? void 0 : _a[0],
        );
      }
      return this._make(
        // Post processing is only necessary if there is more than one element.
        this.length > 1 && matched.length > 1
          ? postFns.reduce((elems, fn) => fn(elems), matched)
          : matched,
      );
    };
  };
}
/** Matcher that adds multiple elements for each entry in the input. */
const _matcher = _getMatcher((fn, elems) => {
  const ret = [];
  for (let i = 0; i < elems.length; i++) {
    const value = fn(elems[i]);
    ret.push(value);
  }
  return new Array().concat(...ret);
});
/** Matcher that adds at most one element for each entry in the input. */
const _singleMatcher = _getMatcher((fn, elems) => {
  const ret = [];
  for (let i = 0; i < elems.length; i++) {
    const value = fn(elems[i]);
    if (value !== null) {
      ret.push(value);
    }
  }
  return ret;
});
/**
 * Matcher that supports traversing until a condition is met.
 *
 * @returns A function usable for `*Until` methods.
 */
function _matchUntil(nextElem, ...postFns) {
  // We use a variable here that is used from within the matcher.
  let matches = null;
  const innerMatcher = _getMatcher((nextElem, elems) => {
    const matched = [];
    domEach(elems, (elem) => {
      for (let next; (next = nextElem(elem)); elem = next) {
        // FIXME: `matched` might contain duplicates here and the index is too large.
        if (
          matches === null || matches === void 0
            ? void 0
            : matches(next, matched.length)
        )
          break;
        matched.push(next);
      }
    });
    return matched;
  })(nextElem, ...postFns);
  return function (selector, filterSelector) {
    // Override `matches` variable with the new target.
    matches =
      typeof selector === "string"
        ? (elem) => is$2(elem, selector, this.options)
        : selector
          ? getFilterFn(selector)
          : null;
    const ret = innerMatcher.call(this, filterSelector);
    // Set `matches` to `null`, so we don't waste memory.
    matches = null;
    return ret;
  };
}
function _removeDuplicates(elems) {
  return Array.from(new Set(elems));
}
/**
 * Get the parent of each element in the current set of matched elements,
 * optionally filtered by a selector.
 *
 * @category Traversing
 * @example
 *
 * ```js
 * $('.pear').parent().attr('id');
 * //=> fruits
 * ```
 *
 * @param selector - If specified filter for parent.
 * @returns The parents.
 * @see {@link https://api.jquery.com/parent/}
 */
const parent = _singleMatcher(
  ({ parent }) => (parent && !isDocument(parent) ? parent : null),
  _removeDuplicates,
);
/**
 * Get a set of parents filtered by `selector` of each element in the current
 * set of match elements.
 *
 * @category Traversing
 * @example
 *
 * ```js
 * $('.orange').parents().length;
 * //=> 2
 * $('.orange').parents('#fruits').length;
 * //=> 1
 * ```
 *
 * @param selector - If specified filter for parents.
 * @returns The parents.
 * @see {@link https://api.jquery.com/parents/}
 */
const parents = _matcher(
  (elem) => {
    const matched = [];
    while (elem.parent && !isDocument(elem.parent)) {
      matched.push(elem.parent);
      elem = elem.parent;
    }
    return matched;
  },
  uniqueSort,
  (elems) => elems.reverse(),
);
/**
 * Get the ancestors of each element in the current set of matched elements, up
 * to but not including the element matched by the selector, DOM node, or cheerio object.
 *
 * @category Traversing
 * @example
 *
 * ```js
 * $('.orange').parentsUntil('#food').length;
 * //=> 1
 * ```
 *
 * @param selector - Selector for element to stop at.
 * @param filterSelector - Optional filter for parents.
 * @returns The parents.
 * @see {@link https://api.jquery.com/parentsUntil/}
 */
const parentsUntil = _matchUntil(
  ({ parent }) => (parent && !isDocument(parent) ? parent : null),
  uniqueSort,
  (elems) => elems.reverse(),
);
/**
 * For each element in the set, get the first element that matches the selector
 * by testing the element itself and traversing up through its ancestors in the DOM tree.
 *
 * @category Traversing
 * @example
 *
 * ```js
 * $('.orange').closest();
 * //=> []
 *
 * $('.orange').closest('.apple');
 * // => []
 *
 * $('.orange').closest('li');
 * //=> [<li class="orange">Orange</li>]
 *
 * $('.orange').closest('#fruits');
 * //=> [<ul id="fruits"> ... </ul>]
 * ```
 *
 * @param selector - Selector for the element to find.
 * @returns The closest nodes.
 * @see {@link https://api.jquery.com/closest/}
 */
function closest(selector) {
  var _a;
  const set = [];
  if (!selector) {
    return this._make(set);
  }
  const selectOpts = {
    xmlMode: this.options.xmlMode,
    root: (_a = this._root) === null || _a === void 0 ? void 0 : _a[0],
  };
  const selectFn =
    typeof selector === "string"
      ? (elem) => is$2(elem, selector, selectOpts)
      : getFilterFn(selector);
  domEach(this, (elem) => {
    while (elem && isTag$1(elem)) {
      if (selectFn(elem, 0)) {
        // Do not add duplicate elements to the set
        if (!set.includes(elem)) {
          set.push(elem);
        }
        break;
      }
      elem = elem.parent;
    }
  });
  return this._make(set);
}
/**
 * Gets the next sibling of the first selected element, optionally filtered by a selector.
 *
 * @category Traversing
 * @example
 *
 * ```js
 * $('.apple').next().hasClass('orange');
 * //=> true
 * ```
 *
 * @param selector - If specified filter for sibling.
 * @returns The next nodes.
 * @see {@link https://api.jquery.com/next/}
 */
const next = _singleMatcher((elem) => nextElementSibling$1(elem));
/**
 * Gets all the following siblings of the first selected element, optionally
 * filtered by a selector.
 *
 * @category Traversing
 * @example
 *
 * ```js
 * $('.apple').nextAll();
 * //=> [<li class="orange">Orange</li>, <li class="pear">Pear</li>]
 * $('.apple').nextAll('.orange');
 * //=> [<li class="orange">Orange</li>]
 * ```
 *
 * @param selector - If specified filter for siblings.
 * @returns The next nodes.
 * @see {@link https://api.jquery.com/nextAll/}
 */
const nextAll = _matcher((elem) => {
  const matched = [];
  while (elem.next) {
    elem = elem.next;
    if (isTag$1(elem)) matched.push(elem);
  }
  return matched;
}, _removeDuplicates);
/**
 * Gets all the following siblings up to but not including the element matched
 * by the selector, optionally filtered by another selector.
 *
 * @category Traversing
 * @example
 *
 * ```js
 * $('.apple').nextUntil('.pear');
 * //=> [<li class="orange">Orange</li>]
 * ```
 *
 * @param selector - Selector for element to stop at.
 * @param filterSelector - If specified filter for siblings.
 * @returns The next nodes.
 * @see {@link https://api.jquery.com/nextUntil/}
 */
const nextUntil = _matchUntil(
  (el) => nextElementSibling$1(el),
  _removeDuplicates,
);
/**
 * Gets the previous sibling of the first selected element optionally filtered
 * by a selector.
 *
 * @category Traversing
 * @example
 *
 * ```js
 * $('.orange').prev().hasClass('apple');
 * //=> true
 * ```
 *
 * @param selector - If specified filter for siblings.
 * @returns The previous nodes.
 * @see {@link https://api.jquery.com/prev/}
 */
const prev = _singleMatcher((elem) => prevElementSibling$1(elem));
/**
 * Gets all the preceding siblings of the first selected element, optionally
 * filtered by a selector.
 *
 * @category Traversing
 * @example
 *
 * ```js
 * $('.pear').prevAll();
 * //=> [<li class="orange">Orange</li>, <li class="apple">Apple</li>]
 *
 * $('.pear').prevAll('.orange');
 * //=> [<li class="orange">Orange</li>]
 * ```
 *
 * @param selector - If specified filter for siblings.
 * @returns The previous nodes.
 * @see {@link https://api.jquery.com/prevAll/}
 */
const prevAll = _matcher((elem) => {
  const matched = [];
  while (elem.prev) {
    elem = elem.prev;
    if (isTag$1(elem)) matched.push(elem);
  }
  return matched;
}, _removeDuplicates);
/**
 * Gets all the preceding siblings up to but not including the element matched
 * by the selector, optionally filtered by another selector.
 *
 * @category Traversing
 * @example
 *
 * ```js
 * $('.pear').prevUntil('.apple');
 * //=> [<li class="orange">Orange</li>]
 * ```
 *
 * @param selector - Selector for element to stop at.
 * @param filterSelector - If specified filter for siblings.
 * @returns The previous nodes.
 * @see {@link https://api.jquery.com/prevUntil/}
 */
const prevUntil = _matchUntil(
  (el) => prevElementSibling$1(el),
  _removeDuplicates,
);
/**
 * Get the siblings of each element (excluding the element) in the set of
 * matched elements, optionally filtered by a selector.
 *
 * @category Traversing
 * @example
 *
 * ```js
 * $('.pear').siblings().length;
 * //=> 2
 *
 * $('.pear').siblings('.orange').length;
 * //=> 1
 * ```
 *
 * @param selector - If specified filter for siblings.
 * @returns The siblings.
 * @see {@link https://api.jquery.com/siblings/}
 */
const siblings = _matcher(
  (elem) => getSiblings$2(elem).filter((el) => isTag$1(el) && el !== elem),
  uniqueSort,
);
/**
 * Gets the element children of each element in the set of matched elements.
 *
 * @category Traversing
 * @example
 *
 * ```js
 * $('#fruits').children().length;
 * //=> 3
 *
 * $('#fruits').children('.pear').text();
 * //=> Pear
 * ```
 *
 * @param selector - If specified filter for children.
 * @returns The children.
 * @see {@link https://api.jquery.com/children/}
 */
const children = _matcher(
  (elem) => getChildren$2(elem).filter(isTag$1),
  _removeDuplicates,
);
/**
 * Gets the children of each element in the set of matched elements, including
 * text and comment nodes.
 *
 * @category Traversing
 * @example
 *
 * ```js
 * $('#fruits').contents().length;
 * //=> 3
 * ```
 *
 * @returns The children.
 * @see {@link https://api.jquery.com/contents/}
 */
function contents() {
  const elems = this.toArray().reduce(
    (newElems, elem) =>
      hasChildren(elem) ? newElems.concat(elem.children) : newElems,
    [],
  );
  return this._make(elems);
}
/**
 * Iterates over a cheerio object, executing a function for each matched
 * element. When the callback is fired, the function is fired in the context of
 * the DOM element, so `this` refers to the current element, which is equivalent
 * to the function parameter `element`. To break out of the `each` loop early,
 * return with `false`.
 *
 * @category Traversing
 * @example
 *
 * ```js
 * const fruits = [];
 *
 * $('li').each(function (i, elem) {
 *   fruits[i] = $(this).text();
 * });
 *
 * fruits.join(', ');
 * //=> Apple, Orange, Pear
 * ```
 *
 * @param fn - Function to execute.
 * @returns The instance itself, useful for chaining.
 * @see {@link https://api.jquery.com/each/}
 */
function each(fn) {
  let i = 0;
  const len = this.length;
  while (i < len && fn.call(this[i], i, this[i]) !== false) ++i;
  return this;
}
/**
 * Pass each element in the current matched set through a function, producing a
 * new Cheerio object containing the return values. The function can return an
 * individual data item or an array of data items to be inserted into the
 * resulting set. If an array is returned, the elements inside the array are
 * inserted into the set. If the function returns null or undefined, no element
 * will be inserted.
 *
 * @category Traversing
 * @example
 *
 * ```js
 * $('li')
 *   .map(function (i, el) {
 *     // this === el
 *     return $(this).text();
 *   })
 *   .toArray()
 *   .join(' ');
 * //=> "apple orange pear"
 * ```
 *
 * @param fn - Function to execute.
 * @returns The mapped elements, wrapped in a Cheerio collection.
 * @see {@link https://api.jquery.com/map/}
 */
function map(fn) {
  let elems = [];
  for (let i = 0; i < this.length; i++) {
    const el = this[i];
    const val = fn.call(el, i, el);
    if (val != null) {
      elems = elems.concat(val);
    }
  }
  return this._make(elems);
}
/**
 * Creates a function to test if a filter is matched.
 *
 * @param match - A filter.
 * @returns A function that determines if a filter has been matched.
 */
function getFilterFn(match) {
  if (typeof match === "function") {
    return (el, i) => match.call(el, i, el);
  }
  if (isCheerio(match)) {
    return (el) => Array.prototype.includes.call(match, el);
  }
  return function (el) {
    return match === el;
  };
}
function filter$2(match) {
  var _a;
  return this._make(
    filterArray(
      this.toArray(),
      match,
      this.options.xmlMode,
      (_a = this._root) === null || _a === void 0 ? void 0 : _a[0],
    ),
  );
}
function filterArray(nodes, match, xmlMode, root) {
  return typeof match === "string"
    ? filter$3(match, nodes, { xmlMode, root })
    : nodes.filter(getFilterFn(match));
}
/**
 * Checks the current list of elements and returns `true` if _any_ of the
 * elements match the selector. If using an element or Cheerio selection,
 * returns `true` if _any_ of the elements match. If using a predicate function,
 * the function is executed in the context of the selected element, so `this`
 * refers to the current element.
 *
 * @category Attributes
 * @param selector - Selector for the selection.
 * @returns Whether or not the selector matches an element of the instance.
 * @see {@link https://api.jquery.com/is/}
 */
function is$1(selector) {
  const nodes = this.toArray();
  return typeof selector === "string"
    ? some(nodes.filter(isTag$1), selector, this.options)
    : selector
      ? nodes.some(getFilterFn(selector))
      : false;
}
/**
 * Remove elements from the set of matched elements. Given a Cheerio object that
 * represents a set of DOM elements, the `.not()` method constructs a new
 * Cheerio object from a subset of the matching elements. The supplied selector
 * is tested against each element; the elements that don't match the selector
 * will be included in the result.
 *
 * The `.not()` method can take a function as its argument in the same way that
 * `.filter()` does. Elements for which the function returns `true` are excluded
 * from the filtered set; all other elements are included.
 *
 * @category Traversing
 * @example <caption>Selector</caption>
 *
 * ```js
 * $('li').not('.apple').length;
 * //=> 2
 * ```
 *
 * @example <caption>Function</caption>
 *
 * ```js
 * $('li').not(function (i, el) {
 *   // this === el
 *   return $(this).attr('class') === 'orange';
 * }).length; //=> 2
 * ```
 *
 * @param match - Value to look for, following the rules above.
 * @param container - Optional node to filter instead.
 * @returns The filtered collection.
 * @see {@link https://api.jquery.com/not/}
 */
function not(match) {
  let nodes = this.toArray();
  if (typeof match === "string") {
    const matches = new Set(filter$3(match, nodes, this.options));
    nodes = nodes.filter((el) => !matches.has(el));
  } else {
    const filterFn = getFilterFn(match);
    nodes = nodes.filter((el, i) => !filterFn(el, i));
  }
  return this._make(nodes);
}
/**
 * Filters the set of matched elements to only those which have the given DOM
 * element as a descendant or which have a descendant that matches the given
 * selector. Equivalent to `.filter(':has(selector)')`.
 *
 * @category Traversing
 * @example <caption>Selector</caption>
 *
 * ```js
 * $('ul').has('.pear').attr('id');
 * //=> fruits
 * ```
 *
 * @example <caption>Element</caption>
 *
 * ```js
 * $('ul').has($('.pear')[0]).attr('id');
 * //=> fruits
 * ```
 *
 * @param selectorOrHaystack - Element to look for.
 * @returns The filtered collection.
 * @see {@link https://api.jquery.com/has/}
 */
function has$1(selectorOrHaystack) {
  return this.filter(
    typeof selectorOrHaystack === "string"
      ? // Using the `:has` selector here short-circuits searches.
        `:has(${selectorOrHaystack})`
      : (_, el) => this._make(el).find(selectorOrHaystack).length > 0,
  );
}
/**
 * Will select the first element of a cheerio object.
 *
 * @category Traversing
 * @example
 *
 * ```js
 * $('#fruits').children().first().text();
 * //=> Apple
 * ```
 *
 * @returns The first element.
 * @see {@link https://api.jquery.com/first/}
 */
function first() {
  return this.length > 1 ? this._make(this[0]) : this;
}
/**
 * Will select the last element of a cheerio object.
 *
 * @category Traversing
 * @example
 *
 * ```js
 * $('#fruits').children().last().text();
 * //=> Pear
 * ```
 *
 * @returns The last element.
 * @see {@link https://api.jquery.com/last/}
 */
function last() {
  return this.length > 0 ? this._make(this[this.length - 1]) : this;
}
/**
 * Reduce the set of matched elements to the one at the specified index. Use
 * `.eq(-i)` to count backwards from the last selected element.
 *
 * @category Traversing
 * @example
 *
 * ```js
 * $('li').eq(0).text();
 * //=> Apple
 *
 * $('li').eq(-1).text();
 * //=> Pear
 * ```
 *
 * @param i - Index of the element to select.
 * @returns The element at the `i`th position.
 * @see {@link https://api.jquery.com/eq/}
 */
function eq(i) {
  var _a;
  i = +i;
  // Use the first identity optimization if possible
  if (i === 0 && this.length <= 1) return this;
  if (i < 0) i = this.length + i;
  return this._make((_a = this[i]) !== null && _a !== void 0 ? _a : []);
}
function get$1(i) {
  if (i == null) {
    return this.toArray();
  }
  return this[i < 0 ? this.length + i : i];
}
/**
 * Retrieve all the DOM elements contained in the jQuery set as an array.
 *
 * @example
 *
 * ```js
 * $('li').toArray();
 * //=> [ {...}, {...}, {...} ]
 * ```
 *
 * @returns The contained items.
 */
function toArray() {
  return Array.prototype.slice.call(this);
}
/**
 * Search for a given element from among the matched elements.
 *
 * @category Traversing
 * @example
 *
 * ```js
 * $('.pear').index();
 * //=> 2 $('.orange').index('li');
 * //=> 1
 * $('.apple').index($('#fruit, li'));
 * //=> 1
 * ```
 *
 * @param selectorOrNeedle - Element to look for.
 * @returns The index of the element.
 * @see {@link https://api.jquery.com/index/}
 */
function index$k(selectorOrNeedle) {
  let $haystack;
  let needle;
  if (selectorOrNeedle == null) {
    $haystack = this.parent().children();
    needle = this[0];
  } else if (typeof selectorOrNeedle === "string") {
    $haystack = this._make(selectorOrNeedle);
    needle = this[0];
  } else {
    // eslint-disable-next-line @typescript-eslint/no-this-alias
    $haystack = this;
    needle = isCheerio(selectorOrNeedle)
      ? selectorOrNeedle[0]
      : selectorOrNeedle;
  }
  return Array.prototype.indexOf.call($haystack, needle);
}
/**
 * Gets the elements matching the specified range (0-based position).
 *
 * @category Traversing
 * @example
 *
 * ```js
 * $('li').slice(1).eq(0).text();
 * //=> 'Orange'
 *
 * $('li').slice(1, 2).length;
 * //=> 1
 * ```
 *
 * @param start - A position at which the elements begin to be selected. If
 *   negative, it indicates an offset from the end of the set.
 * @param end - A position at which the elements stop being selected. If
 *   negative, it indicates an offset from the end of the set. If omitted, the
 *   range continues until the end of the set.
 * @returns The elements matching the specified range.
 * @see {@link https://api.jquery.com/slice/}
 */
function slice(start, end) {
  return this._make(Array.prototype.slice.call(this, start, end));
}
/**
 * End the most recent filtering operation in the current chain and return the
 * set of matched elements to its previous state.
 *
 * @category Traversing
 * @example
 *
 * ```js
 * $('li').eq(0).end().length;
 * //=> 3
 * ```
 *
 * @returns The previous state of the set of matched elements.
 * @see {@link https://api.jquery.com/end/}
 */
function end() {
  var _a;
  return (_a = this.prevObject) !== null && _a !== void 0 ? _a : this._make([]);
}
/**
 * Add elements to the set of matched elements.
 *
 * @category Traversing
 * @example
 *
 * ```js
 * $('.apple').add('.orange').length;
 * //=> 2
 * ```
 *
 * @param other - Elements to add.
 * @param context - Optionally the context of the new selection.
 * @returns The combined set.
 * @see {@link https://api.jquery.com/add/}
 */
function add(other, context) {
  const selection = this._make(other, context);
  const contents = uniqueSort([...this.get(), ...selection.get()]);
  return this._make(contents);
}
/**
 * Add the previous set of elements on the stack to the current set, optionally
 * filtered by a selector.
 *
 * @category Traversing
 * @example
 *
 * ```js
 * $('li').eq(0).addBack('.orange').length;
 * //=> 2
 * ```
 *
 * @param selector - Selector for the elements to add.
 * @returns The combined set.
 * @see {@link https://api.jquery.com/addBack/}
 */
function addBack(selector) {
  return this.prevObject
    ? this.add(selector ? this.prevObject.filter(selector) : this.prevObject)
    : this;
}

const Traversing = /*#__PURE__*/ Object.freeze(
  /*#__PURE__*/ Object.defineProperty(
    {
      __proto__: null,
      add,
      addBack,
      children,
      closest,
      contents,
      each,
      end,
      eq,
      filter: filter$2,
      filterArray,
      find: find$3,
      first,
      get: get$1,
      has: has$1,
      index: index$k,
      is: is$1,
      last,
      map,
      next,
      nextAll,
      nextUntil,
      not,
      parent,
      parents,
      parentsUntil,
      prev,
      prevAll,
      prevUntil,
      siblings,
      slice,
      toArray,
    },
    Symbol.toStringTag,
    { value: "Module" },
  ),
);

/**
 * Get the parse function with options.
 *
 * @param parser - The parser function.
 * @returns The parse function with options.
 */
function getParse(parser) {
  /**
   * Parse a HTML string or a node.
   *
   * @param content - The HTML string or node.
   * @param options - The parser options.
   * @param isDocument - If `content` is a document.
   * @param context - The context node in the DOM tree.
   * @returns The parsed document node.
   */
  return function parse(content, options, isDocument$1, context) {
    if (typeof Buffer !== "undefined" && Buffer.isBuffer(content)) {
      content = content.toString();
    }
    if (typeof content === "string") {
      return parser(content, options, isDocument$1, context);
    }
    const doc = content;
    if (!Array.isArray(doc) && isDocument(doc)) {
      // If `doc` is already a root, just return it
      return doc;
    }
    // Add conent to new root element
    const root = new Document([]);
    // Update the DOM using the root
    update(doc, root);
    return root;
  };
}
/**
 * Update the dom structure, for one changed layer.
 *
 * @param newChilds - The new children.
 * @param parent - The new parent.
 * @returns The parent node.
 */
function update(newChilds, parent) {
  // Normalize
  const arr = Array.isArray(newChilds) ? newChilds : [newChilds];
  // Update parent
  if (parent) {
    parent.children = arr;
  } else {
    parent = null;
  }
  // Update neighbors
  for (let i = 0; i < arr.length; i++) {
    const node = arr[i];
    // Cleanly remove existing nodes from their previous structures.
    if (node.parent && node.parent.children !== arr) {
      removeElement$1(node);
    }
    if (parent) {
      node.prev = arr[i - 1] || null;
      node.next = arr[i + 1] || null;
    } else {
      node.prev = node.next = null;
    }
    node.parent = parent;
  }
  return parent;
}

/**
 * Methods for modifying the DOM structure.
 *
 * @module cheerio/manipulation
 */
/**
 * Create an array of nodes, recursing into arrays and parsing strings if necessary.
 *
 * @private
 * @category Manipulation
 * @param elem - Elements to make an array of.
 * @param clone - Optionally clone nodes.
 * @returns The array of nodes.
 */
function _makeDomArray(elem, clone) {
  if (elem == null) {
    return [];
  }
  if (isCheerio(elem)) {
    return clone ? cloneDom(elem.get()) : elem.get();
  }
  if (Array.isArray(elem)) {
    return elem.reduce(
      (newElems, el) => newElems.concat(this._makeDomArray(el, clone)),
      [],
    );
  }
  if (typeof elem === "string") {
    return this._parse(elem, this.options, false, null).children;
  }
  return clone ? cloneDom([elem]) : [elem];
}
function _insert(concatenator) {
  return function (...elems) {
    const lastIdx = this.length - 1;
    return domEach(this, (el, i) => {
      if (!hasChildren(el)) return;
      const domSrc =
        typeof elems[0] === "function"
          ? elems[0].call(el, i, this._render(el.children))
          : elems;
      const dom = this._makeDomArray(domSrc, i < lastIdx);
      concatenator(dom, el.children, el);
    });
  };
}
/**
 * Modify an array in-place, removing some number of elements and adding new
 * elements directly following them.
 *
 * @private
 * @category Manipulation
 * @param array - Target array to splice.
 * @param spliceIdx - Index at which to begin changing the array.
 * @param spliceCount - Number of elements to remove from the array.
 * @param newElems - Elements to insert into the array.
 * @param parent - The parent of the node.
 * @returns The spliced array.
 */
function uniqueSplice(array, spliceIdx, spliceCount, newElems, parent) {
  var _a, _b;
  const spliceArgs = [spliceIdx, spliceCount, ...newElems];
  const prev = spliceIdx === 0 ? null : array[spliceIdx - 1];
  const next =
    spliceIdx + spliceCount >= array.length
      ? null
      : array[spliceIdx + spliceCount];
  /*
   * Before splicing in new elements, ensure they do not already appear in the
   * current array.
   */
  for (let idx = 0; idx < newElems.length; ++idx) {
    const node = newElems[idx];
    const oldParent = node.parent;
    if (oldParent) {
      const oldSiblings = oldParent.children;
      const prevIdx = oldSiblings.indexOf(node);
      if (prevIdx > -1) {
        oldParent.children.splice(prevIdx, 1);
        if (parent === oldParent && spliceIdx > prevIdx) {
          spliceArgs[0]--;
        }
      }
    }
    node.parent = parent;
    if (node.prev) {
      node.prev.next = (_a = node.next) !== null && _a !== void 0 ? _a : null;
    }
    if (node.next) {
      node.next.prev = (_b = node.prev) !== null && _b !== void 0 ? _b : null;
    }
    node.prev = idx === 0 ? prev : newElems[idx - 1];
    node.next = idx === newElems.length - 1 ? next : newElems[idx + 1];
  }
  if (prev) {
    prev.next = newElems[0];
  }
  if (next) {
    next.prev = newElems[newElems.length - 1];
  }
  return array.splice(...spliceArgs);
}
/**
 * Insert every element in the set of matched elements to the end of the target.
 *
 * @category Manipulation
 * @example
 *
 * ```js
 * $('<li class="plum">Plum</li>').appendTo('#fruits');
 * $.html();
 * //=>  <ul id="fruits">
 * //      <li class="apple">Apple</li>
 * //      <li class="orange">Orange</li>
 * //      <li class="pear">Pear</li>
 * //      <li class="plum">Plum</li>
 * //    </ul>
 * ```
 *
 * @param target - Element to append elements to.
 * @returns The instance itself.
 * @see {@link https://api.jquery.com/appendTo/}
 */
function appendTo(target) {
  const appendTarget = isCheerio(target) ? target : this._make(target);
  appendTarget.append(this);
  return this;
}
/**
 * Insert every element in the set of matched elements to the beginning of the target.
 *
 * @category Manipulation
 * @example
 *
 * ```js
 * $('<li class="plum">Plum</li>').prependTo('#fruits');
 * $.html();
 * //=>  <ul id="fruits">
 * //      <li class="plum">Plum</li>
 * //      <li class="apple">Apple</li>
 * //      <li class="orange">Orange</li>
 * //      <li class="pear">Pear</li>
 * //    </ul>
 * ```
 *
 * @param target - Element to prepend elements to.
 * @returns The instance itself.
 * @see {@link https://api.jquery.com/prependTo/}
 */
function prependTo(target) {
  const prependTarget = isCheerio(target) ? target : this._make(target);
  prependTarget.prepend(this);
  return this;
}
/**
 * Inserts content as the _last_ child of each of the selected elements.
 *
 * @category Manipulation
 * @example
 *
 * ```js
 * $('ul').append('<li class="plum">Plum</li>');
 * $.html();
 * //=>  <ul id="fruits">
 * //      <li class="apple">Apple</li>
 * //      <li class="orange">Orange</li>
 * //      <li class="pear">Pear</li>
 * //      <li class="plum">Plum</li>
 * //    </ul>
 * ```
 *
 * @see {@link https://api.jquery.com/append/}
 */
const append$1 = _insert((dom, children, parent) => {
  uniqueSplice(children, children.length, 0, dom, parent);
});
/**
 * Inserts content as the _first_ child of each of the selected elements.
 *
 * @category Manipulation
 * @example
 *
 * ```js
 * $('ul').prepend('<li class="plum">Plum</li>');
 * $.html();
 * //=>  <ul id="fruits">
 * //      <li class="plum">Plum</li>
 * //      <li class="apple">Apple</li>
 * //      <li class="orange">Orange</li>
 * //      <li class="pear">Pear</li>
 * //    </ul>
 * ```
 *
 * @see {@link https://api.jquery.com/prepend/}
 */
const prepend = _insert((dom, children, parent) => {
  uniqueSplice(children, 0, 0, dom, parent);
});
function _wrap(insert) {
  return function (wrapper) {
    const lastIdx = this.length - 1;
    const lastParent = this.parents().last();
    for (let i = 0; i < this.length; i++) {
      const el = this[i];
      const wrap =
        typeof wrapper === "function"
          ? wrapper.call(el, i, el)
          : typeof wrapper === "string" && !isHtml(wrapper)
            ? lastParent.find(wrapper).clone()
            : wrapper;
      const [wrapperDom] = this._makeDomArray(wrap, i < lastIdx);
      if (!wrapperDom || !hasChildren(wrapperDom)) continue;
      let elInsertLocation = wrapperDom;
      /*
       * Find the deepest child. Only consider the first tag child of each node
       * (ignore text); stop if no children are found.
       */
      let j = 0;
      while (j < elInsertLocation.children.length) {
        const child = elInsertLocation.children[j];
        if (isTag$1(child)) {
          elInsertLocation = child;
          j = 0;
        } else {
          j++;
        }
      }
      insert(el, elInsertLocation, [wrapperDom]);
    }
    return this;
  };
}
/**
 * The .wrap() function can take any string or object that could be passed to
 * the $() factory function to specify a DOM structure. This structure may be
 * nested several levels deep, but should contain only one inmost element. A
 * copy of this structure will be wrapped around each of the elements in the set
 * of matched elements. This method returns the original set of elements for
 * chaining purposes.
 *
 * @category Manipulation
 * @example
 *
 * ```js
 * const redFruit = $('<div class="red-fruit"></div>');
 * $('.apple').wrap(redFruit);
 *
 * //=> <ul id="fruits">
 * //     <div class="red-fruit">
 * //      <li class="apple">Apple</li>
 * //     </div>
 * //     <li class="orange">Orange</li>
 * //     <li class="plum">Plum</li>
 * //   </ul>
 *
 * const healthy = $('<div class="healthy"></div>');
 * $('li').wrap(healthy);
 *
 * //=> <ul id="fruits">
 * //     <div class="healthy">
 * //       <li class="apple">Apple</li>
 * //     </div>
 * //     <div class="healthy">
 * //       <li class="orange">Orange</li>
 * //     </div>
 * //     <div class="healthy">
 * //        <li class="plum">Plum</li>
 * //     </div>
 * //   </ul>
 * ```
 *
 * @param wrapper - The DOM structure to wrap around each element in the selection.
 * @see {@link https://api.jquery.com/wrap/}
 */
const wrap = _wrap((el, elInsertLocation, wrapperDom) => {
  const { parent } = el;
  if (!parent) return;
  const siblings = parent.children;
  const index = siblings.indexOf(el);
  update([el], elInsertLocation);
  /*
   * The previous operation removed the current element from the `siblings`
   * array, so the `dom` array can be inserted without removing any
   * additional elements.
   */
  uniqueSplice(siblings, index, 0, wrapperDom, parent);
});
/**
 * The .wrapInner() function can take any string or object that could be passed
 * to the $() factory function to specify a DOM structure. This structure may be
 * nested several levels deep, but should contain only one inmost element. The
 * structure will be wrapped around the content of each of the elements in the
 * set of matched elements.
 *
 * @category Manipulation
 * @example
 *
 * ```js
 * const redFruit = $('<div class="red-fruit"></div>');
 * $('.apple').wrapInner(redFruit);
 *
 * //=> <ul id="fruits">
 * //     <li class="apple">
 * //       <div class="red-fruit">Apple</div>
 * //     </li>
 * //     <li class="orange">Orange</li>
 * //     <li class="pear">Pear</li>
 * //   </ul>
 *
 * const healthy = $('<div class="healthy"></div>');
 * $('li').wrapInner(healthy);
 *
 * //=> <ul id="fruits">
 * //     <li class="apple">
 * //       <div class="healthy">Apple</div>
 * //     </li>
 * //     <li class="orange">
 * //       <div class="healthy">Orange</div>
 * //     </li>
 * //     <li class="pear">
 * //       <div class="healthy">Pear</div>
 * //     </li>
 * //   </ul>
 * ```
 *
 * @param wrapper - The DOM structure to wrap around the content of each element
 *   in the selection.
 * @returns The instance itself, for chaining.
 * @see {@link https://api.jquery.com/wrapInner/}
 */
const wrapInner = _wrap((el, elInsertLocation, wrapperDom) => {
  if (!hasChildren(el)) return;
  update(el.children, elInsertLocation);
  update(wrapperDom, el);
});
/**
 * The .unwrap() function, removes the parents of the set of matched elements
 * from the DOM, leaving the matched elements in their place.
 *
 * @category Manipulation
 * @example <caption>without selector</caption>
 *
 * ```js
 * const $ = cheerio.load(
 *   '<div id=test>\n  <div><p>Hello</p></div>\n  <div><p>World</p></div>\n</div>'
 * );
 * $('#test p').unwrap();
 *
 * //=> <div id=test>
 * //     <p>Hello</p>
 * //     <p>World</p>
 * //   </div>
 * ```
 *
 * @example <caption>with selector</caption>
 *
 * ```js
 * const $ = cheerio.load(
 *   '<div id=test>\n  <p>Hello</p>\n  <b><p>World</p></b>\n</div>'
 * );
 * $('#test p').unwrap('b');
 *
 * //=> <div id=test>
 * //     <p>Hello</p>
 * //     <p>World</p>
 * //   </div>
 * ```
 *
 * @param selector - A selector to check the parent element against. If an
 *   element's parent does not match the selector, the element won't be unwrapped.
 * @returns The instance itself, for chaining.
 * @see {@link https://api.jquery.com/unwrap/}
 */
function unwrap(selector) {
  this.parent(selector)
    .not("body")
    .each((_, el) => {
      this._make(el).replaceWith(el.children);
    });
  return this;
}
/**
 * The .wrapAll() function can take any string or object that could be passed to
 * the $() function to specify a DOM structure. This structure may be nested
 * several levels deep, but should contain only one inmost element. The
 * structure will be wrapped around all of the elements in the set of matched
 * elements, as a single group.
 *
 * @category Manipulation
 * @example <caption>With markup passed to `wrapAll`</caption>
 *
 * ```js
 * const $ = cheerio.load(
 *   '<div class="container"><div class="inner">First</div><div class="inner">Second</div></div>'
 * );
 * $('.inner').wrapAll("<div class='new'></div>");
 *
 * //=> <div class="container">
 * //     <div class='new'>
 * //       <div class="inner">First</div>
 * //       <div class="inner">Second</div>
 * //     </div>
 * //   </div>
 * ```
 *
 * @example <caption>With an existing cheerio instance</caption>
 *
 * ```js
 * const $ = cheerio.load(
 *   '<span>Span 1</span><strong>Strong</strong><span>Span 2</span>'
 * );
 * const wrap = $('<div><p><em><b></b></em></p></div>');
 * $('span').wrapAll(wrap);
 *
 * //=> <div>
 * //     <p>
 * //       <em>
 * //         <b>
 * //           <span>Span 1</span>
 * //           <span>Span 2</span>
 * //         </b>
 * //       </em>
 * //     </p>
 * //   </div>
 * //   <strong>Strong</strong>
 * ```
 *
 * @param wrapper - The DOM structure to wrap around all matched elements in the
 *   selection.
 * @returns The instance itself.
 * @see {@link https://api.jquery.com/wrapAll/}
 */
function wrapAll(wrapper) {
  const el = this[0];
  if (el) {
    const wrap = this._make(
      typeof wrapper === "function" ? wrapper.call(el, 0, el) : wrapper,
    ).insertBefore(el);
    // If html is given as wrapper, wrap may contain text elements
    let elInsertLocation;
    for (let i = 0; i < wrap.length; i++) {
      if (wrap[i].type === "tag") elInsertLocation = wrap[i];
    }
    let j = 0;
    /*
     * Find the deepest child. Only consider the first tag child of each node
     * (ignore text); stop if no children are found.
     */
    while (elInsertLocation && j < elInsertLocation.children.length) {
      const child = elInsertLocation.children[j];
      if (child.type === "tag") {
        elInsertLocation = child;
        j = 0;
      } else {
        j++;
      }
    }
    if (elInsertLocation) this._make(elInsertLocation).append(this);
  }
  return this;
}
/* eslint-disable jsdoc/check-param-names*/
/**
 * Insert content next to each element in the set of matched elements.
 *
 * @category Manipulation
 * @example
 *
 * ```js
 * $('.apple').after('<li class="plum">Plum</li>');
 * $.html();
 * //=>  <ul id="fruits">
 * //      <li class="apple">Apple</li>
 * //      <li class="plum">Plum</li>
 * //      <li class="orange">Orange</li>
 * //      <li class="pear">Pear</li>
 * //    </ul>
 * ```
 *
 * @param content - HTML string, DOM element, array of DOM elements or Cheerio
 *   to insert after each element in the set of matched elements.
 * @returns The instance itself.
 * @see {@link https://api.jquery.com/after/}
 */
function after(...elems) {
  const lastIdx = this.length - 1;
  return domEach(this, (el, i) => {
    const { parent } = el;
    if (!hasChildren(el) || !parent) {
      return;
    }
    const siblings = parent.children;
    const index = siblings.indexOf(el);
    // If not found, move on
    /* istanbul ignore next */
    if (index < 0) return;
    const domSrc =
      typeof elems[0] === "function"
        ? elems[0].call(el, i, this._render(el.children))
        : elems;
    const dom = this._makeDomArray(domSrc, i < lastIdx);
    // Add element after `this` element
    uniqueSplice(siblings, index + 1, 0, dom, parent);
  });
}
/* eslint-enable jsdoc/check-param-names*/
/**
 * Insert every element in the set of matched elements after the target.
 *
 * @category Manipulation
 * @example
 *
 * ```js
 * $('<li class="plum">Plum</li>').insertAfter('.apple');
 * $.html();
 * //=>  <ul id="fruits">
 * //      <li class="apple">Apple</li>
 * //      <li class="plum">Plum</li>
 * //      <li class="orange">Orange</li>
 * //      <li class="pear">Pear</li>
 * //    </ul>
 * ```
 *
 * @param target - Element to insert elements after.
 * @returns The set of newly inserted elements.
 * @see {@link https://api.jquery.com/insertAfter/}
 */
function insertAfter(target) {
  if (typeof target === "string") {
    target = this._make(target);
  }
  this.remove();
  const clones = [];
  this._makeDomArray(target).forEach((el) => {
    const clonedSelf = this.clone().toArray();
    const { parent } = el;
    if (!parent) {
      return;
    }
    const siblings = parent.children;
    const index = siblings.indexOf(el);
    // If not found, move on
    /* istanbul ignore next */
    if (index < 0) return;
    // Add cloned `this` element(s) after target element
    uniqueSplice(siblings, index + 1, 0, clonedSelf, parent);
    clones.push(...clonedSelf);
  });
  return this._make(clones);
}
/* eslint-disable jsdoc/check-param-names*/
/**
 * Insert content previous to each element in the set of matched elements.
 *
 * @category Manipulation
 * @example
 *
 * ```js
 * $('.apple').before('<li class="plum">Plum</li>');
 * $.html();
 * //=>  <ul id="fruits">
 * //      <li class="plum">Plum</li>
 * //      <li class="apple">Apple</li>
 * //      <li class="orange">Orange</li>
 * //      <li class="pear">Pear</li>
 * //    </ul>
 * ```
 *
 * @param content - HTML string, DOM element, array of DOM elements or Cheerio
 *   to insert before each element in the set of matched elements.
 * @returns The instance itself.
 * @see {@link https://api.jquery.com/before/}
 */
function before(...elems) {
  const lastIdx = this.length - 1;
  return domEach(this, (el, i) => {
    const { parent } = el;
    if (!hasChildren(el) || !parent) {
      return;
    }
    const siblings = parent.children;
    const index = siblings.indexOf(el);
    // If not found, move on
    /* istanbul ignore next */
    if (index < 0) return;
    const domSrc =
      typeof elems[0] === "function"
        ? elems[0].call(el, i, this._render(el.children))
        : elems;
    const dom = this._makeDomArray(domSrc, i < lastIdx);
    // Add element before `el` element
    uniqueSplice(siblings, index, 0, dom, parent);
  });
}
/* eslint-enable jsdoc/check-param-names*/
/**
 * Insert every element in the set of matched elements before the target.
 *
 * @category Manipulation
 * @example
 *
 * ```js
 * $('<li class="plum">Plum</li>').insertBefore('.apple');
 * $.html();
 * //=>  <ul id="fruits">
 * //      <li class="plum">Plum</li>
 * //      <li class="apple">Apple</li>
 * //      <li class="orange">Orange</li>
 * //      <li class="pear">Pear</li>
 * //    </ul>
 * ```
 *
 * @param target - Element to insert elements before.
 * @returns The set of newly inserted elements.
 * @see {@link https://api.jquery.com/insertBefore/}
 */
function insertBefore(target) {
  const targetArr = this._make(target);
  this.remove();
  const clones = [];
  domEach(targetArr, (el) => {
    const clonedSelf = this.clone().toArray();
    const { parent } = el;
    if (!parent) {
      return;
    }
    const siblings = parent.children;
    const index = siblings.indexOf(el);
    // If not found, move on
    /* istanbul ignore next */
    if (index < 0) return;
    // Add cloned `this` element(s) after target element
    uniqueSplice(siblings, index, 0, clonedSelf, parent);
    clones.push(...clonedSelf);
  });
  return this._make(clones);
}
/**
 * Removes the set of matched elements from the DOM and all their children.
 * `selector` filters the set of matched elements to be removed.
 *
 * @category Manipulation
 * @example
 *
 * ```js
 * $('.pear').remove();
 * $.html();
 * //=>  <ul id="fruits">
 * //      <li class="apple">Apple</li>
 * //      <li class="orange">Orange</li>
 * //    </ul>
 * ```
 *
 * @param selector - Optional selector for elements to remove.
 * @returns The instance itself.
 * @see {@link https://api.jquery.com/remove/}
 */
function remove(selector) {
  // Filter if we have selector
  const elems = selector ? this.filter(selector) : this;
  domEach(elems, (el) => {
    removeElement$1(el);
    el.prev = el.next = el.parent = null;
  });
  return this;
}
/**
 * Replaces matched elements with `content`.
 *
 * @category Manipulation
 * @example
 *
 * ```js
 * const plum = $('<li class="plum">Plum</li>');
 * $('.pear').replaceWith(plum);
 * $.html();
 * //=> <ul id="fruits">
 * //     <li class="apple">Apple</li>
 * //     <li class="orange">Orange</li>
 * //     <li class="plum">Plum</li>
 * //   </ul>
 * ```
 *
 * @param content - Replacement for matched elements.
 * @returns The instance itself.
 * @see {@link https://api.jquery.com/replaceWith/}
 */
function replaceWith(content) {
  return domEach(this, (el, i) => {
    const { parent } = el;
    if (!parent) {
      return;
    }
    const siblings = parent.children;
    const cont =
      typeof content === "function" ? content.call(el, i, el) : content;
    const dom = this._makeDomArray(cont);
    /*
     * In the case that `dom` contains nodes that already exist in other
     * structures, ensure those nodes are properly removed.
     */
    update(dom, null);
    const index = siblings.indexOf(el);
    // Completely remove old element
    uniqueSplice(siblings, index, 1, dom, parent);
    if (!dom.includes(el)) {
      el.parent = el.prev = el.next = null;
    }
  });
}
/**
 * Empties an element, removing all its children.
 *
 * @category Manipulation
 * @example
 *
 * ```js
 * $('ul').empty();
 * $.html();
 * //=>  <ul id="fruits"></ul>
 * ```
 *
 * @returns The instance itself.
 * @see {@link https://api.jquery.com/empty/}
 */
function empty() {
  return domEach(this, (el) => {
    if (!hasChildren(el)) return;
    el.children.forEach((child) => {
      child.next = child.prev = child.parent = null;
    });
    el.children.length = 0;
  });
}
function html(str) {
  if (str === undefined) {
    const el = this[0];
    if (!el || !hasChildren(el)) return null;
    return this._render(el.children);
  }
  return domEach(this, (el) => {
    if (!hasChildren(el)) return;
    el.children.forEach((child) => {
      child.next = child.prev = child.parent = null;
    });
    const content = isCheerio(str)
      ? str.toArray()
      : this._parse(`${str}`, this.options, false, el).children;
    update(content, el);
  });
}
/**
 * Turns the collection to a string. Alias for `.html()`.
 *
 * @category Manipulation
 * @returns The rendered document.
 */
function toString() {
  return this._render(this);
}
function text(str) {
  // If `str` is undefined, act as a "getter"
  if (str === undefined) {
    return text$1(this);
  }
  if (typeof str === "function") {
    // Function support
    return domEach(this, (el, i) =>
      this._make(el).text(str.call(el, i, text$1([el]))),
    );
  }
  // Append text node to each selected elements
  return domEach(this, (el) => {
    if (!hasChildren(el)) return;
    el.children.forEach((child) => {
      child.next = child.prev = child.parent = null;
    });
    const textNode = new Text(`${str}`);
    update(textNode, el);
  });
}
/**
 * Clone the cheerio object.
 *
 * @category Manipulation
 * @example
 *
 * ```js
 * const moreFruit = $('#fruits').clone();
 * ```
 *
 * @returns The cloned object.
 * @see {@link https://api.jquery.com/clone/}
 */
function clone$6() {
  return this._make(cloneDom(this.get()));
}

const Manipulation = /*#__PURE__*/ Object.freeze(
  /*#__PURE__*/ Object.defineProperty(
    {
      __proto__: null,
      _makeDomArray,
      after,
      append: append$1,
      appendTo,
      before,
      clone: clone$6,
      empty,
      html,
      insertAfter,
      insertBefore,
      prepend,
      prependTo,
      remove,
      replaceWith,
      text,
      toString,
      unwrap,
      wrap,
      wrapAll,
      wrapInner,
    },
    Symbol.toStringTag,
    { value: "Module" },
  ),
);

/**
 * Set multiple CSS properties for every matched element.
 *
 * @category CSS
 * @param prop - The names of the properties.
 * @param val - The new values.
 * @returns The instance itself.
 * @see {@link https://api.jquery.com/css/}
 */
function css(prop, val) {
  if (
    (prop != null && val != null) ||
    // When `prop` is a "plain" object
    (typeof prop === "object" && !Array.isArray(prop))
  ) {
    return domEach(this, (el, i) => {
      if (isTag$1(el)) {
        // `prop` can't be an array here anymore.
        setCss(el, prop, val, i);
      }
    });
  }
  if (this.length === 0) {
    return undefined;
  }
  return getCss(this[0], prop);
}
/**
 * Set styles of all elements.
 *
 * @private
 * @param el - Element to set style of.
 * @param prop - Name of property.
 * @param value - Value to set property to.
 * @param idx - Optional index within the selection.
 */
function setCss(el, prop, value, idx) {
  if (typeof prop === "string") {
    const styles = getCss(el);
    const val =
      typeof value === "function" ? value.call(el, idx, styles[prop]) : value;
    if (val === "") {
      delete styles[prop];
    } else if (val != null) {
      styles[prop] = val;
    }
    el.attribs["style"] = stringify(styles);
  } else if (typeof prop === "object") {
    Object.keys(prop).forEach((k, i) => {
      setCss(el, k, prop[k], i);
    });
  }
}
function getCss(el, prop) {
  if (!el || !isTag$1(el)) return;
  const styles = parse$1B(el.attribs["style"]);
  if (typeof prop === "string") {
    return styles[prop];
  }
  if (Array.isArray(prop)) {
    const newStyles = {};
    prop.forEach((item) => {
      if (styles[item] != null) {
        newStyles[item] = styles[item];
      }
    });
    return newStyles;
  }
  return styles;
}
/**
 * Stringify `obj` to styles.
 *
 * @private
 * @category CSS
 * @param obj - Object to stringify.
 * @returns The serialized styles.
 */
function stringify(obj) {
  return Object.keys(obj).reduce(
    (str, prop) => `${str}${str ? " " : ""}${prop}: ${obj[prop]};`,
    "",
  );
}
/**
 * Parse `styles`.
 *
 * @private
 * @category CSS
 * @param styles - Styles to be parsed.
 * @returns The parsed styles.
 */
function parse$1B(styles) {
  styles = (styles || "").trim();
  if (!styles) return {};
  const obj = {};
  let key;
  for (const str of styles.split(";")) {
    const n = str.indexOf(":");
    // If there is no :, or if it is the first/last character, add to the previous item's value
    if (n < 1 || n === str.length - 1) {
      const trimmed = str.trimEnd();
      if (trimmed.length > 0 && key !== undefined) {
        obj[key] += `;${trimmed}`;
      }
    } else {
      key = str.slice(0, n).trim();
      obj[key] = str.slice(n + 1).trim();
    }
  }
  return obj;
}

const Css = /*#__PURE__*/ Object.freeze(
  /*#__PURE__*/ Object.defineProperty(
    {
      __proto__: null,
      css,
    },
    Symbol.toStringTag,
    { value: "Module" },
  ),
);

/*
 * https://github.com/jquery/jquery/blob/2.1.3/src/manipulation/var/rcheckableType.js
 * https://github.com/jquery/jquery/blob/2.1.3/src/serialize.js
 */
const submittableSelector = "input,select,textarea,keygen";
const r20 = /%20/g;
const rCRLF = /\r?\n/g;
/**
 * Encode a set of form elements as a string for submission.
 *
 * @category Forms
 * @example
 *
 * ```js
 * $('<form><input name="foo" value="bar" /></form>').serialize();
 * //=> 'foo=bar'
 * ```
 *
 * @returns The serialized form.
 * @see {@link https://api.jquery.com/serialize/}
 */
function serialize() {
  // Convert form elements into name/value objects
  const arr = this.serializeArray();
  // Serialize each element into a key/value string
  const retArr = arr.map(
    (data) =>
      `${encodeURIComponent(data.name)}=${encodeURIComponent(data.value)}`,
  );
  // Return the resulting serialization
  return retArr.join("&").replace(r20, "+");
}
/**
 * Encode a set of form elements as an array of names and values.
 *
 * @category Forms
 * @example
 *
 * ```js
 * $('<form><input name="foo" value="bar" /></form>').serializeArray();
 * //=> [ { name: 'foo', value: 'bar' } ]
 * ```
 *
 * @returns The serialized form.
 * @see {@link https://api.jquery.com/serializeArray/}
 */
function serializeArray() {
  // Resolve all form elements from either forms or collections of form elements
  return this.map((_, elem) => {
    const $elem = this._make(elem);
    if (isTag$1(elem) && elem.name === "form") {
      return $elem.find(submittableSelector).toArray();
    }
    return $elem.filter(submittableSelector).toArray();
  })
    .filter(
      // Verify elements have a name (`attr.name`) and are not disabled (`:enabled`)
      '[name!=""]:enabled' +
        // And cannot be clicked (`[type=submit]`) or are used in `x-www-form-urlencoded` (`[type=file]`)
        ":not(:submit, :button, :image, :reset, :file)" +
        // And are either checked/don't have a checkable state
        ":matches([checked], :not(:checkbox, :radio))",
      // Convert each of the elements to its value(s)
    )
    .map((_, elem) => {
      var _a;
      const $elem = this._make(elem);
      const name = $elem.attr("name"); // We have filtered for elements with a name before.
      // If there is no value set (e.g. `undefined`, `null`), then default value to empty
      const value = (_a = $elem.val()) !== null && _a !== void 0 ? _a : "";
      // If we have an array of values (e.g. `<select multiple>`), return an array of key/value pairs
      if (Array.isArray(value)) {
        return value.map((val) =>
          /*
           * We trim replace any line endings (e.g. `\r` or `\r\n` with `\r\n`) to guarantee consistency across platforms
           * These can occur inside of `<textarea>'s`
           */
          ({ name, value: val.replace(rCRLF, "\r\n") }),
        );
      }
      // Otherwise (e.g. `<input type="text">`, return only one key/value pair
      return { name, value: value.replace(rCRLF, "\r\n") };
    })
    .toArray();
}

const Forms = /*#__PURE__*/ Object.freeze(
  /*#__PURE__*/ Object.defineProperty(
    {
      __proto__: null,
      serialize,
      serializeArray,
    },
    Symbol.toStringTag,
    { value: "Module" },
  ),
);

class Cheerio {
  /**
   * Instance of cheerio. Methods are specified in the modules. Usage of this
   * constructor is not recommended. Please use `$.load` instead.
   *
   * @private
   * @param elements - The new selection.
   * @param root - Sets the root node.
   * @param options - Options for the instance.
   */
  constructor(elements, root, options) {
    this.length = 0;
    this.options = options;
    this._root = root;
    if (elements) {
      for (let idx = 0; idx < elements.length; idx++) {
        this[idx] = elements[idx];
      }
      this.length = elements.length;
    }
  }
}
/** Set a signature of the object. */
Cheerio.prototype.cheerio = "[cheerio object]";
/*
 * Make cheerio an array-like object
 */
Cheerio.prototype.splice = Array.prototype.splice;
// Support for (const element of $(...)) iteration:
Cheerio.prototype[Symbol.iterator] = Array.prototype[Symbol.iterator];
// Plug in the API
Object.assign(
  Cheerio.prototype,
  Attributes,
  Traversing,
  Manipulation,
  Css,
  Forms,
);

function getLoad(parse, render) {
  /**
   * Create a querying function, bound to a document created from the provided markup.
   *
   * Note that similar to web browser contexts, this operation may introduce
   * `<html>`, `<head>`, and `<body>` elements; set `isDocument` to `false` to
   * switch to fragment mode and disable this.
   *
   * @param content - Markup to be loaded.
   * @param options - Options for the created instance.
   * @param isDocument - Allows parser to be switched to fragment mode.
   * @returns The loaded document.
   * @see {@link https://cheerio.js.org#loading} for additional usage information.
   */
  return function load(content, options, isDocument = true) {
    if (content == null) {
      throw new Error("cheerio.load() expects a string");
    }
    const internalOpts = { ...defaultOpts$2, ...flatten(options) };
    const initialRoot = parse(content, internalOpts, isDocument, null);
    /** Create an extended class here, so that extensions only live on one instance. */
    class LoadedCheerio extends Cheerio {
      _make(selector, context) {
        const cheerio = initialize(selector, context);
        cheerio.prevObject = this;
        return cheerio;
      }
      _parse(content, options, isDocument, context) {
        return parse(content, options, isDocument, context);
      }
      _render(dom) {
        return render(dom, this.options);
      }
    }
    function initialize(selector, context, root = initialRoot, opts) {
      // $($)
      if (selector && isCheerio(selector)) return selector;
      const options = {
        ...internalOpts,
        ...flatten(opts),
      };
      const r =
        typeof root === "string"
          ? [parse(root, options, false, null)]
          : "length" in root
            ? root
            : [root];
      const rootInstance = isCheerio(r)
        ? r
        : new LoadedCheerio(r, null, options);
      // Add a cyclic reference, so that calling methods on `_root` never fails.
      rootInstance._root = rootInstance;
      // $(), $(null), $(undefined), $(false)
      if (!selector) {
        return new LoadedCheerio(undefined, rootInstance, options);
      }
      const elements =
        typeof selector === "string" && isHtml(selector)
          ? // $(<html>)
            parse(selector, options, false, null).children
          : isNode(selector)
            ? // $(dom)
              [selector]
            : Array.isArray(selector)
              ? // $([dom])
                selector
              : undefined;
      const instance = new LoadedCheerio(elements, rootInstance, options);
      if (elements) {
        return instance;
      }
      if (typeof selector !== "string") {
        throw new Error("Unexpected type of selector");
      }
      // We know that our selector is a string now.
      let search = selector;
      const searchContext = !context
        ? // If we don't have a context, maybe we have a root, from loading
          rootInstance
        : typeof context === "string"
          ? isHtml(context)
            ? // $('li', '<ul>...</ul>')
              new LoadedCheerio(
                [parse(context, options, false, null)],
                rootInstance,
                options,
              )
            : // $('li', 'ul')
              ((search = `${context} ${search}`), rootInstance)
          : isCheerio(context)
            ? // $('li', $)
              context
            : // $('li', node), $('li', [nodes])
              new LoadedCheerio(
                Array.isArray(context) ? context : [context],
                rootInstance,
                options,
              );
      // If we still don't have a context, return
      if (!searchContext) return instance;
      /*
       * #id, .class, tag
       */
      return searchContext.find(search);
    }
    // Add in static methods & properties
    Object.assign(initialize, staticMethods, {
      load,
      // `_root` and `_options` are used in static methods.
      _root: initialRoot,
      _options: internalOpts,
      // Add `fn` for plugins
      fn: LoadedCheerio.prototype,
      // Add the prototype here to maintain `instanceof` behavior.
      prototype: LoadedCheerio.prototype,
    });
    return initialize;
  };
}
function isNode(obj) {
  return (
    !!obj.name ||
    obj.type === "root" ||
    obj.type === "text" ||
    obj.type === "comment"
  );
}

const UNDEFINED_CODE_POINTS = new Set([
  65534, 65535, 131070, 131071, 196606, 196607, 262142, 262143, 327678, 327679,
  393214, 393215, 458750, 458751, 524286, 524287, 589822, 589823, 655358,
  655359, 720894, 720895, 786430, 786431, 851966, 851967, 917502, 917503,
  983038, 983039, 1048574, 1048575, 1114110, 1114111,
]);
const REPLACEMENT_CHARACTER = "\uFFFD";
var CODE_POINTS;
(function (CODE_POINTS) {
  CODE_POINTS[(CODE_POINTS["EOF"] = -1)] = "EOF";
  CODE_POINTS[(CODE_POINTS["NULL"] = 0)] = "NULL";
  CODE_POINTS[(CODE_POINTS["TABULATION"] = 9)] = "TABULATION";
  CODE_POINTS[(CODE_POINTS["CARRIAGE_RETURN"] = 13)] = "CARRIAGE_RETURN";
  CODE_POINTS[(CODE_POINTS["LINE_FEED"] = 10)] = "LINE_FEED";
  CODE_POINTS[(CODE_POINTS["FORM_FEED"] = 12)] = "FORM_FEED";
  CODE_POINTS[(CODE_POINTS["SPACE"] = 32)] = "SPACE";
  CODE_POINTS[(CODE_POINTS["EXCLAMATION_MARK"] = 33)] = "EXCLAMATION_MARK";
  CODE_POINTS[(CODE_POINTS["QUOTATION_MARK"] = 34)] = "QUOTATION_MARK";
  CODE_POINTS[(CODE_POINTS["NUMBER_SIGN"] = 35)] = "NUMBER_SIGN";
  CODE_POINTS[(CODE_POINTS["AMPERSAND"] = 38)] = "AMPERSAND";
  CODE_POINTS[(CODE_POINTS["APOSTROPHE"] = 39)] = "APOSTROPHE";
  CODE_POINTS[(CODE_POINTS["HYPHEN_MINUS"] = 45)] = "HYPHEN_MINUS";
  CODE_POINTS[(CODE_POINTS["SOLIDUS"] = 47)] = "SOLIDUS";
  CODE_POINTS[(CODE_POINTS["DIGIT_0"] = 48)] = "DIGIT_0";
  CODE_POINTS[(CODE_POINTS["DIGIT_9"] = 57)] = "DIGIT_9";
  CODE_POINTS[(CODE_POINTS["SEMICOLON"] = 59)] = "SEMICOLON";
  CODE_POINTS[(CODE_POINTS["LESS_THAN_SIGN"] = 60)] = "LESS_THAN_SIGN";
  CODE_POINTS[(CODE_POINTS["EQUALS_SIGN"] = 61)] = "EQUALS_SIGN";
  CODE_POINTS[(CODE_POINTS["GREATER_THAN_SIGN"] = 62)] = "GREATER_THAN_SIGN";
  CODE_POINTS[(CODE_POINTS["QUESTION_MARK"] = 63)] = "QUESTION_MARK";
  CODE_POINTS[(CODE_POINTS["LATIN_CAPITAL_A"] = 65)] = "LATIN_CAPITAL_A";
  CODE_POINTS[(CODE_POINTS["LATIN_CAPITAL_F"] = 70)] = "LATIN_CAPITAL_F";
  CODE_POINTS[(CODE_POINTS["LATIN_CAPITAL_X"] = 88)] = "LATIN_CAPITAL_X";
  CODE_POINTS[(CODE_POINTS["LATIN_CAPITAL_Z"] = 90)] = "LATIN_CAPITAL_Z";
  CODE_POINTS[(CODE_POINTS["RIGHT_SQUARE_BRACKET"] = 93)] =
    "RIGHT_SQUARE_BRACKET";
  CODE_POINTS[(CODE_POINTS["GRAVE_ACCENT"] = 96)] = "GRAVE_ACCENT";
  CODE_POINTS[(CODE_POINTS["LATIN_SMALL_A"] = 97)] = "LATIN_SMALL_A";
  CODE_POINTS[(CODE_POINTS["LATIN_SMALL_F"] = 102)] = "LATIN_SMALL_F";
  CODE_POINTS[(CODE_POINTS["LATIN_SMALL_X"] = 120)] = "LATIN_SMALL_X";
  CODE_POINTS[(CODE_POINTS["LATIN_SMALL_Z"] = 122)] = "LATIN_SMALL_Z";
  CODE_POINTS[(CODE_POINTS["REPLACEMENT_CHARACTER"] = 65533)] =
    "REPLACEMENT_CHARACTER";
})((CODE_POINTS = CODE_POINTS || (CODE_POINTS = {})));
const SEQUENCES = {
  DASH_DASH: "--",
  CDATA_START: "[CDATA[",
  DOCTYPE: "doctype",
  SCRIPT: "script",
  PUBLIC: "public",
  SYSTEM: "system",
};
//Surrogates
function isSurrogate(cp) {
  return cp >= 55296 && cp <= 57343;
}
function isSurrogatePair(cp) {
  return cp >= 56320 && cp <= 57343;
}
function getSurrogatePairCodePoint(cp1, cp2) {
  return (cp1 - 55296) * 1024 + 9216 + cp2;
}
//NOTE: excluding NULL and ASCII whitespace
function isControlCodePoint(cp) {
  return (
    (cp !== 0x20 &&
      cp !== 0x0a &&
      cp !== 0x0d &&
      cp !== 0x09 &&
      cp !== 0x0c &&
      cp >= 0x01 &&
      cp <= 0x1f) ||
    (cp >= 0x7f && cp <= 0x9f)
  );
}
function isUndefinedCodePoint(cp) {
  return (cp >= 64976 && cp <= 65007) || UNDEFINED_CODE_POINTS.has(cp);
}

var ERR;
(function (ERR) {
  ERR["controlCharacterInInputStream"] = "control-character-in-input-stream";
  ERR["noncharacterInInputStream"] = "noncharacter-in-input-stream";
  ERR["surrogateInInputStream"] = "surrogate-in-input-stream";
  ERR["nonVoidHtmlElementStartTagWithTrailingSolidus"] =
    "non-void-html-element-start-tag-with-trailing-solidus";
  ERR["endTagWithAttributes"] = "end-tag-with-attributes";
  ERR["endTagWithTrailingSolidus"] = "end-tag-with-trailing-solidus";
  ERR["unexpectedSolidusInTag"] = "unexpected-solidus-in-tag";
  ERR["unexpectedNullCharacter"] = "unexpected-null-character";
  ERR["unexpectedQuestionMarkInsteadOfTagName"] =
    "unexpected-question-mark-instead-of-tag-name";
  ERR["invalidFirstCharacterOfTagName"] = "invalid-first-character-of-tag-name";
  ERR["unexpectedEqualsSignBeforeAttributeName"] =
    "unexpected-equals-sign-before-attribute-name";
  ERR["missingEndTagName"] = "missing-end-tag-name";
  ERR["unexpectedCharacterInAttributeName"] =
    "unexpected-character-in-attribute-name";
  ERR["unknownNamedCharacterReference"] = "unknown-named-character-reference";
  ERR["missingSemicolonAfterCharacterReference"] =
    "missing-semicolon-after-character-reference";
  ERR["unexpectedCharacterAfterDoctypeSystemIdentifier"] =
    "unexpected-character-after-doctype-system-identifier";
  ERR["unexpectedCharacterInUnquotedAttributeValue"] =
    "unexpected-character-in-unquoted-attribute-value";
  ERR["eofBeforeTagName"] = "eof-before-tag-name";
  ERR["eofInTag"] = "eof-in-tag";
  ERR["missingAttributeValue"] = "missing-attribute-value";
  ERR["missingWhitespaceBetweenAttributes"] =
    "missing-whitespace-between-attributes";
  ERR["missingWhitespaceAfterDoctypePublicKeyword"] =
    "missing-whitespace-after-doctype-public-keyword";
  ERR["missingWhitespaceBetweenDoctypePublicAndSystemIdentifiers"] =
    "missing-whitespace-between-doctype-public-and-system-identifiers";
  ERR["missingWhitespaceAfterDoctypeSystemKeyword"] =
    "missing-whitespace-after-doctype-system-keyword";
  ERR["missingQuoteBeforeDoctypePublicIdentifier"] =
    "missing-quote-before-doctype-public-identifier";
  ERR["missingQuoteBeforeDoctypeSystemIdentifier"] =
    "missing-quote-before-doctype-system-identifier";
  ERR["missingDoctypePublicIdentifier"] = "missing-doctype-public-identifier";
  ERR["missingDoctypeSystemIdentifier"] = "missing-doctype-system-identifier";
  ERR["abruptDoctypePublicIdentifier"] = "abrupt-doctype-public-identifier";
  ERR["abruptDoctypeSystemIdentifier"] = "abrupt-doctype-system-identifier";
  ERR["cdataInHtmlContent"] = "cdata-in-html-content";
  ERR["incorrectlyOpenedComment"] = "incorrectly-opened-comment";
  ERR["eofInScriptHtmlCommentLikeText"] =
    "eof-in-script-html-comment-like-text";
  ERR["eofInDoctype"] = "eof-in-doctype";
  ERR["nestedComment"] = "nested-comment";
  ERR["abruptClosingOfEmptyComment"] = "abrupt-closing-of-empty-comment";
  ERR["eofInComment"] = "eof-in-comment";
  ERR["incorrectlyClosedComment"] = "incorrectly-closed-comment";
  ERR["eofInCdata"] = "eof-in-cdata";
  ERR["absenceOfDigitsInNumericCharacterReference"] =
    "absence-of-digits-in-numeric-character-reference";
  ERR["nullCharacterReference"] = "null-character-reference";
  ERR["surrogateCharacterReference"] = "surrogate-character-reference";
  ERR["characterReferenceOutsideUnicodeRange"] =
    "character-reference-outside-unicode-range";
  ERR["controlCharacterReference"] = "control-character-reference";
  ERR["noncharacterCharacterReference"] = "noncharacter-character-reference";
  ERR["missingWhitespaceBeforeDoctypeName"] =
    "missing-whitespace-before-doctype-name";
  ERR["missingDoctypeName"] = "missing-doctype-name";
  ERR["invalidCharacterSequenceAfterDoctypeName"] =
    "invalid-character-sequence-after-doctype-name";
  ERR["duplicateAttribute"] = "duplicate-attribute";
  ERR["nonConformingDoctype"] = "non-conforming-doctype";
  ERR["missingDoctype"] = "missing-doctype";
  ERR["misplacedDoctype"] = "misplaced-doctype";
  ERR["endTagWithoutMatchingOpenElement"] =
    "end-tag-without-matching-open-element";
  ERR["closingOfElementWithOpenChildElements"] =
    "closing-of-element-with-open-child-elements";
  ERR["disallowedContentInNoscriptInHead"] =
    "disallowed-content-in-noscript-in-head";
  ERR["openElementsLeftAfterEof"] = "open-elements-left-after-eof";
  ERR["abandonedHeadElementChild"] = "abandoned-head-element-child";
  ERR["misplacedStartTagForHeadElement"] =
    "misplaced-start-tag-for-head-element";
  ERR["nestedNoscriptInHead"] = "nested-noscript-in-head";
  ERR["eofInElementThatCanContainOnlyText"] =
    "eof-in-element-that-can-contain-only-text";
})((ERR = ERR || (ERR = {})));

//Const
const DEFAULT_BUFFER_WATERLINE = 1 << 16;
//Preprocessor
//NOTE: HTML input preprocessing
//(see: http://www.whatwg.org/specs/web-apps/current-work/multipage/parsing.html#preprocessing-the-input-stream)
class Preprocessor {
  constructor(handler) {
    this.handler = handler;
    this.html = "";
    this.pos = -1;
    // NOTE: Initial `lastGapPos` is -2, to ensure `col` on initialisation is 0
    this.lastGapPos = -2;
    this.gapStack = [];
    this.skipNextNewLine = false;
    this.lastChunkWritten = false;
    this.endOfChunkHit = false;
    this.bufferWaterline = DEFAULT_BUFFER_WATERLINE;
    this.isEol = false;
    this.lineStartPos = 0;
    this.droppedBufferSize = 0;
    this.line = 1;
    //NOTE: avoid reporting errors twice on advance/retreat
    this.lastErrOffset = -1;
  }
  /** The column on the current line. If we just saw a gap (eg. a surrogate pair), return the index before. */
  get col() {
    return this.pos - this.lineStartPos + Number(this.lastGapPos !== this.pos);
  }
  get offset() {
    return this.droppedBufferSize + this.pos;
  }
  getError(code) {
    const { line, col, offset } = this;
    return {
      code,
      startLine: line,
      endLine: line,
      startCol: col,
      endCol: col,
      startOffset: offset,
      endOffset: offset,
    };
  }
  _err(code) {
    if (this.handler.onParseError && this.lastErrOffset !== this.offset) {
      this.lastErrOffset = this.offset;
      this.handler.onParseError(this.getError(code));
    }
  }
  _addGap() {
    this.gapStack.push(this.lastGapPos);
    this.lastGapPos = this.pos;
  }
  _processSurrogate(cp) {
    //NOTE: try to peek a surrogate pair
    if (this.pos !== this.html.length - 1) {
      const nextCp = this.html.charCodeAt(this.pos + 1);
      if (isSurrogatePair(nextCp)) {
        //NOTE: we have a surrogate pair. Peek pair character and recalculate code point.
        this.pos++;
        //NOTE: add a gap that should be avoided during retreat
        this._addGap();
        return getSurrogatePairCodePoint(cp, nextCp);
      }
    }
    //NOTE: we are at the end of a chunk, therefore we can't infer the surrogate pair yet.
    else if (!this.lastChunkWritten) {
      this.endOfChunkHit = true;
      return CODE_POINTS.EOF;
    }
    //NOTE: isolated surrogate
    this._err(ERR.surrogateInInputStream);
    return cp;
  }
  willDropParsedChunk() {
    return this.pos > this.bufferWaterline;
  }
  dropParsedChunk() {
    if (this.willDropParsedChunk()) {
      this.html = this.html.substring(this.pos);
      this.lineStartPos -= this.pos;
      this.droppedBufferSize += this.pos;
      this.pos = 0;
      this.lastGapPos = -2;
      this.gapStack.length = 0;
    }
  }
  write(chunk, isLastChunk) {
    if (this.html.length > 0) {
      this.html += chunk;
    } else {
      this.html = chunk;
    }
    this.endOfChunkHit = false;
    this.lastChunkWritten = isLastChunk;
  }
  insertHtmlAtCurrentPos(chunk) {
    this.html =
      this.html.substring(0, this.pos + 1) +
      chunk +
      this.html.substring(this.pos + 1);
    this.endOfChunkHit = false;
  }
  startsWith(pattern, caseSensitive) {
    // Check if our buffer has enough characters
    if (this.pos + pattern.length > this.html.length) {
      this.endOfChunkHit = !this.lastChunkWritten;
      return false;
    }
    if (caseSensitive) {
      return this.html.startsWith(pattern, this.pos);
    }
    for (let i = 0; i < pattern.length; i++) {
      const cp = this.html.charCodeAt(this.pos + i) | 0x20;
      if (cp !== pattern.charCodeAt(i)) {
        return false;
      }
    }
    return true;
  }
  peek(offset) {
    const pos = this.pos + offset;
    if (pos >= this.html.length) {
      this.endOfChunkHit = !this.lastChunkWritten;
      return CODE_POINTS.EOF;
    }
    const code = this.html.charCodeAt(pos);
    return code === CODE_POINTS.CARRIAGE_RETURN ? CODE_POINTS.LINE_FEED : code;
  }
  advance() {
    this.pos++;
    //NOTE: LF should be in the last column of the line
    if (this.isEol) {
      this.isEol = false;
      this.line++;
      this.lineStartPos = this.pos;
    }
    if (this.pos >= this.html.length) {
      this.endOfChunkHit = !this.lastChunkWritten;
      return CODE_POINTS.EOF;
    }
    let cp = this.html.charCodeAt(this.pos);
    //NOTE: all U+000D CARRIAGE RETURN (CR) characters must be converted to U+000A LINE FEED (LF) characters
    if (cp === CODE_POINTS.CARRIAGE_RETURN) {
      this.isEol = true;
      this.skipNextNewLine = true;
      return CODE_POINTS.LINE_FEED;
    }
    //NOTE: any U+000A LINE FEED (LF) characters that immediately follow a U+000D CARRIAGE RETURN (CR) character
    //must be ignored.
    if (cp === CODE_POINTS.LINE_FEED) {
      this.isEol = true;
      if (this.skipNextNewLine) {
        // `line` will be bumped again in the recursive call.
        this.line--;
        this.skipNextNewLine = false;
        this._addGap();
        return this.advance();
      }
    }
    this.skipNextNewLine = false;
    if (isSurrogate(cp)) {
      cp = this._processSurrogate(cp);
    }
    //OPTIMIZATION: first check if code point is in the common allowed
    //range (ASCII alphanumeric, whitespaces, big chunk of BMP)
    //before going into detailed performance cost validation.
    const isCommonValidRange =
      this.handler.onParseError === null ||
      (cp > 0x1f && cp < 0x7f) ||
      cp === CODE_POINTS.LINE_FEED ||
      cp === CODE_POINTS.CARRIAGE_RETURN ||
      (cp > 0x9f && cp < 64976);
    if (!isCommonValidRange) {
      this._checkForProblematicCharacters(cp);
    }
    return cp;
  }
  _checkForProblematicCharacters(cp) {
    if (isControlCodePoint(cp)) {
      this._err(ERR.controlCharacterInInputStream);
    } else if (isUndefinedCodePoint(cp)) {
      this._err(ERR.noncharacterInInputStream);
    }
  }
  retreat(count) {
    this.pos -= count;
    while (this.pos < this.lastGapPos) {
      this.lastGapPos = this.gapStack.pop();
      this.pos--;
    }
    this.isEol = false;
  }
}

var TokenType;
(function (TokenType) {
  TokenType[(TokenType["CHARACTER"] = 0)] = "CHARACTER";
  TokenType[(TokenType["NULL_CHARACTER"] = 1)] = "NULL_CHARACTER";
  TokenType[(TokenType["WHITESPACE_CHARACTER"] = 2)] = "WHITESPACE_CHARACTER";
  TokenType[(TokenType["START_TAG"] = 3)] = "START_TAG";
  TokenType[(TokenType["END_TAG"] = 4)] = "END_TAG";
  TokenType[(TokenType["COMMENT"] = 5)] = "COMMENT";
  TokenType[(TokenType["DOCTYPE"] = 6)] = "DOCTYPE";
  TokenType[(TokenType["EOF"] = 7)] = "EOF";
  TokenType[(TokenType["HIBERNATION"] = 8)] = "HIBERNATION";
})((TokenType = TokenType || (TokenType = {})));
function getTokenAttr(token, attrName) {
  for (let i = token.attrs.length - 1; i >= 0; i--) {
    if (token.attrs[i].name === attrName) {
      return token.attrs[i].value;
    }
  }
  return null;
}

/** All valid namespaces in HTML. */
var NS;
(function (NS) {
  NS["HTML"] = "http://www.w3.org/1999/xhtml";
  NS["MATHML"] = "http://www.w3.org/1998/Math/MathML";
  NS["SVG"] = "http://www.w3.org/2000/svg";
  NS["XLINK"] = "http://www.w3.org/1999/xlink";
  NS["XML"] = "http://www.w3.org/XML/1998/namespace";
  NS["XMLNS"] = "http://www.w3.org/2000/xmlns/";
})((NS = NS || (NS = {})));
var ATTRS;
(function (ATTRS) {
  ATTRS["TYPE"] = "type";
  ATTRS["ACTION"] = "action";
  ATTRS["ENCODING"] = "encoding";
  ATTRS["PROMPT"] = "prompt";
  ATTRS["NAME"] = "name";
  ATTRS["COLOR"] = "color";
  ATTRS["FACE"] = "face";
  ATTRS["SIZE"] = "size";
})((ATTRS = ATTRS || (ATTRS = {})));
/**
 * The mode of the document.
 *
 * @see {@link https://dom.spec.whatwg.org/#concept-document-limited-quirks}
 */
var DOCUMENT_MODE;
(function (DOCUMENT_MODE) {
  DOCUMENT_MODE["NO_QUIRKS"] = "no-quirks";
  DOCUMENT_MODE["QUIRKS"] = "quirks";
  DOCUMENT_MODE["LIMITED_QUIRKS"] = "limited-quirks";
})((DOCUMENT_MODE = DOCUMENT_MODE || (DOCUMENT_MODE = {})));
var TAG_NAMES;
(function (TAG_NAMES) {
  TAG_NAMES["A"] = "a";
  TAG_NAMES["ADDRESS"] = "address";
  TAG_NAMES["ANNOTATION_XML"] = "annotation-xml";
  TAG_NAMES["APPLET"] = "applet";
  TAG_NAMES["AREA"] = "area";
  TAG_NAMES["ARTICLE"] = "article";
  TAG_NAMES["ASIDE"] = "aside";
  TAG_NAMES["B"] = "b";
  TAG_NAMES["BASE"] = "base";
  TAG_NAMES["BASEFONT"] = "basefont";
  TAG_NAMES["BGSOUND"] = "bgsound";
  TAG_NAMES["BIG"] = "big";
  TAG_NAMES["BLOCKQUOTE"] = "blockquote";
  TAG_NAMES["BODY"] = "body";
  TAG_NAMES["BR"] = "br";
  TAG_NAMES["BUTTON"] = "button";
  TAG_NAMES["CAPTION"] = "caption";
  TAG_NAMES["CENTER"] = "center";
  TAG_NAMES["CODE"] = "code";
  TAG_NAMES["COL"] = "col";
  TAG_NAMES["COLGROUP"] = "colgroup";
  TAG_NAMES["DD"] = "dd";
  TAG_NAMES["DESC"] = "desc";
  TAG_NAMES["DETAILS"] = "details";
  TAG_NAMES["DIALOG"] = "dialog";
  TAG_NAMES["DIR"] = "dir";
  TAG_NAMES["DIV"] = "div";
  TAG_NAMES["DL"] = "dl";
  TAG_NAMES["DT"] = "dt";
  TAG_NAMES["EM"] = "em";
  TAG_NAMES["EMBED"] = "embed";
  TAG_NAMES["FIELDSET"] = "fieldset";
  TAG_NAMES["FIGCAPTION"] = "figcaption";
  TAG_NAMES["FIGURE"] = "figure";
  TAG_NAMES["FONT"] = "font";
  TAG_NAMES["FOOTER"] = "footer";
  TAG_NAMES["FOREIGN_OBJECT"] = "foreignObject";
  TAG_NAMES["FORM"] = "form";
  TAG_NAMES["FRAME"] = "frame";
  TAG_NAMES["FRAMESET"] = "frameset";
  TAG_NAMES["H1"] = "h1";
  TAG_NAMES["H2"] = "h2";
  TAG_NAMES["H3"] = "h3";
  TAG_NAMES["H4"] = "h4";
  TAG_NAMES["H5"] = "h5";
  TAG_NAMES["H6"] = "h6";
  TAG_NAMES["HEAD"] = "head";
  TAG_NAMES["HEADER"] = "header";
  TAG_NAMES["HGROUP"] = "hgroup";
  TAG_NAMES["HR"] = "hr";
  TAG_NAMES["HTML"] = "html";
  TAG_NAMES["I"] = "i";
  TAG_NAMES["IMG"] = "img";
  TAG_NAMES["IMAGE"] = "image";
  TAG_NAMES["INPUT"] = "input";
  TAG_NAMES["IFRAME"] = "iframe";
  TAG_NAMES["KEYGEN"] = "keygen";
  TAG_NAMES["LABEL"] = "label";
  TAG_NAMES["LI"] = "li";
  TAG_NAMES["LINK"] = "link";
  TAG_NAMES["LISTING"] = "listing";
  TAG_NAMES["MAIN"] = "main";
  TAG_NAMES["MALIGNMARK"] = "malignmark";
  TAG_NAMES["MARQUEE"] = "marquee";
  TAG_NAMES["MATH"] = "math";
  TAG_NAMES["MENU"] = "menu";
  TAG_NAMES["META"] = "meta";
  TAG_NAMES["MGLYPH"] = "mglyph";
  TAG_NAMES["MI"] = "mi";
  TAG_NAMES["MO"] = "mo";
  TAG_NAMES["MN"] = "mn";
  TAG_NAMES["MS"] = "ms";
  TAG_NAMES["MTEXT"] = "mtext";
  TAG_NAMES["NAV"] = "nav";
  TAG_NAMES["NOBR"] = "nobr";
  TAG_NAMES["NOFRAMES"] = "noframes";
  TAG_NAMES["NOEMBED"] = "noembed";
  TAG_NAMES["NOSCRIPT"] = "noscript";
  TAG_NAMES["OBJECT"] = "object";
  TAG_NAMES["OL"] = "ol";
  TAG_NAMES["OPTGROUP"] = "optgroup";
  TAG_NAMES["OPTION"] = "option";
  TAG_NAMES["P"] = "p";
  TAG_NAMES["PARAM"] = "param";
  TAG_NAMES["PLAINTEXT"] = "plaintext";
  TAG_NAMES["PRE"] = "pre";
  TAG_NAMES["RB"] = "rb";
  TAG_NAMES["RP"] = "rp";
  TAG_NAMES["RT"] = "rt";
  TAG_NAMES["RTC"] = "rtc";
  TAG_NAMES["RUBY"] = "ruby";
  TAG_NAMES["S"] = "s";
  TAG_NAMES["SCRIPT"] = "script";
  TAG_NAMES["SECTION"] = "section";
  TAG_NAMES["SELECT"] = "select";
  TAG_NAMES["SOURCE"] = "source";
  TAG_NAMES["SMALL"] = "small";
  TAG_NAMES["SPAN"] = "span";
  TAG_NAMES["STRIKE"] = "strike";
  TAG_NAMES["STRONG"] = "strong";
  TAG_NAMES["STYLE"] = "style";
  TAG_NAMES["SUB"] = "sub";
  TAG_NAMES["SUMMARY"] = "summary";
  TAG_NAMES["SUP"] = "sup";
  TAG_NAMES["TABLE"] = "table";
  TAG_NAMES["TBODY"] = "tbody";
  TAG_NAMES["TEMPLATE"] = "template";
  TAG_NAMES["TEXTAREA"] = "textarea";
  TAG_NAMES["TFOOT"] = "tfoot";
  TAG_NAMES["TD"] = "td";
  TAG_NAMES["TH"] = "th";
  TAG_NAMES["THEAD"] = "thead";
  TAG_NAMES["TITLE"] = "title";
  TAG_NAMES["TR"] = "tr";
  TAG_NAMES["TRACK"] = "track";
  TAG_NAMES["TT"] = "tt";
  TAG_NAMES["U"] = "u";
  TAG_NAMES["UL"] = "ul";
  TAG_NAMES["SVG"] = "svg";
  TAG_NAMES["VAR"] = "var";
  TAG_NAMES["WBR"] = "wbr";
  TAG_NAMES["XMP"] = "xmp";
})((TAG_NAMES = TAG_NAMES || (TAG_NAMES = {})));
/**
 * Tag IDs are numeric IDs for known tag names.
 *
 * We use tag IDs to improve the performance of tag name comparisons.
 */
var TAG_ID;
(function (TAG_ID) {
  TAG_ID[(TAG_ID["UNKNOWN"] = 0)] = "UNKNOWN";
  TAG_ID[(TAG_ID["A"] = 1)] = "A";
  TAG_ID[(TAG_ID["ADDRESS"] = 2)] = "ADDRESS";
  TAG_ID[(TAG_ID["ANNOTATION_XML"] = 3)] = "ANNOTATION_XML";
  TAG_ID[(TAG_ID["APPLET"] = 4)] = "APPLET";
  TAG_ID[(TAG_ID["AREA"] = 5)] = "AREA";
  TAG_ID[(TAG_ID["ARTICLE"] = 6)] = "ARTICLE";
  TAG_ID[(TAG_ID["ASIDE"] = 7)] = "ASIDE";
  TAG_ID[(TAG_ID["B"] = 8)] = "B";
  TAG_ID[(TAG_ID["BASE"] = 9)] = "BASE";
  TAG_ID[(TAG_ID["BASEFONT"] = 10)] = "BASEFONT";
  TAG_ID[(TAG_ID["BGSOUND"] = 11)] = "BGSOUND";
  TAG_ID[(TAG_ID["BIG"] = 12)] = "BIG";
  TAG_ID[(TAG_ID["BLOCKQUOTE"] = 13)] = "BLOCKQUOTE";
  TAG_ID[(TAG_ID["BODY"] = 14)] = "BODY";
  TAG_ID[(TAG_ID["BR"] = 15)] = "BR";
  TAG_ID[(TAG_ID["BUTTON"] = 16)] = "BUTTON";
  TAG_ID[(TAG_ID["CAPTION"] = 17)] = "CAPTION";
  TAG_ID[(TAG_ID["CENTER"] = 18)] = "CENTER";
  TAG_ID[(TAG_ID["CODE"] = 19)] = "CODE";
  TAG_ID[(TAG_ID["COL"] = 20)] = "COL";
  TAG_ID[(TAG_ID["COLGROUP"] = 21)] = "COLGROUP";
  TAG_ID[(TAG_ID["DD"] = 22)] = "DD";
  TAG_ID[(TAG_ID["DESC"] = 23)] = "DESC";
  TAG_ID[(TAG_ID["DETAILS"] = 24)] = "DETAILS";
  TAG_ID[(TAG_ID["DIALOG"] = 25)] = "DIALOG";
  TAG_ID[(TAG_ID["DIR"] = 26)] = "DIR";
  TAG_ID[(TAG_ID["DIV"] = 27)] = "DIV";
  TAG_ID[(TAG_ID["DL"] = 28)] = "DL";
  TAG_ID[(TAG_ID["DT"] = 29)] = "DT";
  TAG_ID[(TAG_ID["EM"] = 30)] = "EM";
  TAG_ID[(TAG_ID["EMBED"] = 31)] = "EMBED";
  TAG_ID[(TAG_ID["FIELDSET"] = 32)] = "FIELDSET";
  TAG_ID[(TAG_ID["FIGCAPTION"] = 33)] = "FIGCAPTION";
  TAG_ID[(TAG_ID["FIGURE"] = 34)] = "FIGURE";
  TAG_ID[(TAG_ID["FONT"] = 35)] = "FONT";
  TAG_ID[(TAG_ID["FOOTER"] = 36)] = "FOOTER";
  TAG_ID[(TAG_ID["FOREIGN_OBJECT"] = 37)] = "FOREIGN_OBJECT";
  TAG_ID[(TAG_ID["FORM"] = 38)] = "FORM";
  TAG_ID[(TAG_ID["FRAME"] = 39)] = "FRAME";
  TAG_ID[(TAG_ID["FRAMESET"] = 40)] = "FRAMESET";
  TAG_ID[(TAG_ID["H1"] = 41)] = "H1";
  TAG_ID[(TAG_ID["H2"] = 42)] = "H2";
  TAG_ID[(TAG_ID["H3"] = 43)] = "H3";
  TAG_ID[(TAG_ID["H4"] = 44)] = "H4";
  TAG_ID[(TAG_ID["H5"] = 45)] = "H5";
  TAG_ID[(TAG_ID["H6"] = 46)] = "H6";
  TAG_ID[(TAG_ID["HEAD"] = 47)] = "HEAD";
  TAG_ID[(TAG_ID["HEADER"] = 48)] = "HEADER";
  TAG_ID[(TAG_ID["HGROUP"] = 49)] = "HGROUP";
  TAG_ID[(TAG_ID["HR"] = 50)] = "HR";
  TAG_ID[(TAG_ID["HTML"] = 51)] = "HTML";
  TAG_ID[(TAG_ID["I"] = 52)] = "I";
  TAG_ID[(TAG_ID["IMG"] = 53)] = "IMG";
  TAG_ID[(TAG_ID["IMAGE"] = 54)] = "IMAGE";
  TAG_ID[(TAG_ID["INPUT"] = 55)] = "INPUT";
  TAG_ID[(TAG_ID["IFRAME"] = 56)] = "IFRAME";
  TAG_ID[(TAG_ID["KEYGEN"] = 57)] = "KEYGEN";
  TAG_ID[(TAG_ID["LABEL"] = 58)] = "LABEL";
  TAG_ID[(TAG_ID["LI"] = 59)] = "LI";
  TAG_ID[(TAG_ID["LINK"] = 60)] = "LINK";
  TAG_ID[(TAG_ID["LISTING"] = 61)] = "LISTING";
  TAG_ID[(TAG_ID["MAIN"] = 62)] = "MAIN";
  TAG_ID[(TAG_ID["MALIGNMARK"] = 63)] = "MALIGNMARK";
  TAG_ID[(TAG_ID["MARQUEE"] = 64)] = "MARQUEE";
  TAG_ID[(TAG_ID["MATH"] = 65)] = "MATH";
  TAG_ID[(TAG_ID["MENU"] = 66)] = "MENU";
  TAG_ID[(TAG_ID["META"] = 67)] = "META";
  TAG_ID[(TAG_ID["MGLYPH"] = 68)] = "MGLYPH";
  TAG_ID[(TAG_ID["MI"] = 69)] = "MI";
  TAG_ID[(TAG_ID["MO"] = 70)] = "MO";
  TAG_ID[(TAG_ID["MN"] = 71)] = "MN";
  TAG_ID[(TAG_ID["MS"] = 72)] = "MS";
  TAG_ID[(TAG_ID["MTEXT"] = 73)] = "MTEXT";
  TAG_ID[(TAG_ID["NAV"] = 74)] = "NAV";
  TAG_ID[(TAG_ID["NOBR"] = 75)] = "NOBR";
  TAG_ID[(TAG_ID["NOFRAMES"] = 76)] = "NOFRAMES";
  TAG_ID[(TAG_ID["NOEMBED"] = 77)] = "NOEMBED";
  TAG_ID[(TAG_ID["NOSCRIPT"] = 78)] = "NOSCRIPT";
  TAG_ID[(TAG_ID["OBJECT"] = 79)] = "OBJECT";
  TAG_ID[(TAG_ID["OL"] = 80)] = "OL";
  TAG_ID[(TAG_ID["OPTGROUP"] = 81)] = "OPTGROUP";
  TAG_ID[(TAG_ID["OPTION"] = 82)] = "OPTION";
  TAG_ID[(TAG_ID["P"] = 83)] = "P";
  TAG_ID[(TAG_ID["PARAM"] = 84)] = "PARAM";
  TAG_ID[(TAG_ID["PLAINTEXT"] = 85)] = "PLAINTEXT";
  TAG_ID[(TAG_ID["PRE"] = 86)] = "PRE";
  TAG_ID[(TAG_ID["RB"] = 87)] = "RB";
  TAG_ID[(TAG_ID["RP"] = 88)] = "RP";
  TAG_ID[(TAG_ID["RT"] = 89)] = "RT";
  TAG_ID[(TAG_ID["RTC"] = 90)] = "RTC";
  TAG_ID[(TAG_ID["RUBY"] = 91)] = "RUBY";
  TAG_ID[(TAG_ID["S"] = 92)] = "S";
  TAG_ID[(TAG_ID["SCRIPT"] = 93)] = "SCRIPT";
  TAG_ID[(TAG_ID["SECTION"] = 94)] = "SECTION";
  TAG_ID[(TAG_ID["SELECT"] = 95)] = "SELECT";
  TAG_ID[(TAG_ID["SOURCE"] = 96)] = "SOURCE";
  TAG_ID[(TAG_ID["SMALL"] = 97)] = "SMALL";
  TAG_ID[(TAG_ID["SPAN"] = 98)] = "SPAN";
  TAG_ID[(TAG_ID["STRIKE"] = 99)] = "STRIKE";
  TAG_ID[(TAG_ID["STRONG"] = 100)] = "STRONG";
  TAG_ID[(TAG_ID["STYLE"] = 101)] = "STYLE";
  TAG_ID[(TAG_ID["SUB"] = 102)] = "SUB";
  TAG_ID[(TAG_ID["SUMMARY"] = 103)] = "SUMMARY";
  TAG_ID[(TAG_ID["SUP"] = 104)] = "SUP";
  TAG_ID[(TAG_ID["TABLE"] = 105)] = "TABLE";
  TAG_ID[(TAG_ID["TBODY"] = 106)] = "TBODY";
  TAG_ID[(TAG_ID["TEMPLATE"] = 107)] = "TEMPLATE";
  TAG_ID[(TAG_ID["TEXTAREA"] = 108)] = "TEXTAREA";
  TAG_ID[(TAG_ID["TFOOT"] = 109)] = "TFOOT";
  TAG_ID[(TAG_ID["TD"] = 110)] = "TD";
  TAG_ID[(TAG_ID["TH"] = 111)] = "TH";
  TAG_ID[(TAG_ID["THEAD"] = 112)] = "THEAD";
  TAG_ID[(TAG_ID["TITLE"] = 113)] = "TITLE";
  TAG_ID[(TAG_ID["TR"] = 114)] = "TR";
  TAG_ID[(TAG_ID["TRACK"] = 115)] = "TRACK";
  TAG_ID[(TAG_ID["TT"] = 116)] = "TT";
  TAG_ID[(TAG_ID["U"] = 117)] = "U";
  TAG_ID[(TAG_ID["UL"] = 118)] = "UL";
  TAG_ID[(TAG_ID["SVG"] = 119)] = "SVG";
  TAG_ID[(TAG_ID["VAR"] = 120)] = "VAR";
  TAG_ID[(TAG_ID["WBR"] = 121)] = "WBR";
  TAG_ID[(TAG_ID["XMP"] = 122)] = "XMP";
})((TAG_ID = TAG_ID || (TAG_ID = {})));
const TAG_NAME_TO_ID = new Map([
  [TAG_NAMES.A, TAG_ID.A],
  [TAG_NAMES.ADDRESS, TAG_ID.ADDRESS],
  [TAG_NAMES.ANNOTATION_XML, TAG_ID.ANNOTATION_XML],
  [TAG_NAMES.APPLET, TAG_ID.APPLET],
  [TAG_NAMES.AREA, TAG_ID.AREA],
  [TAG_NAMES.ARTICLE, TAG_ID.ARTICLE],
  [TAG_NAMES.ASIDE, TAG_ID.ASIDE],
  [TAG_NAMES.B, TAG_ID.B],
  [TAG_NAMES.BASE, TAG_ID.BASE],
  [TAG_NAMES.BASEFONT, TAG_ID.BASEFONT],
  [TAG_NAMES.BGSOUND, TAG_ID.BGSOUND],
  [TAG_NAMES.BIG, TAG_ID.BIG],
  [TAG_NAMES.BLOCKQUOTE, TAG_ID.BLOCKQUOTE],
  [TAG_NAMES.BODY, TAG_ID.BODY],
  [TAG_NAMES.BR, TAG_ID.BR],
  [TAG_NAMES.BUTTON, TAG_ID.BUTTON],
  [TAG_NAMES.CAPTION, TAG_ID.CAPTION],
  [TAG_NAMES.CENTER, TAG_ID.CENTER],
  [TAG_NAMES.CODE, TAG_ID.CODE],
  [TAG_NAMES.COL, TAG_ID.COL],
  [TAG_NAMES.COLGROUP, TAG_ID.COLGROUP],
  [TAG_NAMES.DD, TAG_ID.DD],
  [TAG_NAMES.DESC, TAG_ID.DESC],
  [TAG_NAMES.DETAILS, TAG_ID.DETAILS],
  [TAG_NAMES.DIALOG, TAG_ID.DIALOG],
  [TAG_NAMES.DIR, TAG_ID.DIR],
  [TAG_NAMES.DIV, TAG_ID.DIV],
  [TAG_NAMES.DL, TAG_ID.DL],
  [TAG_NAMES.DT, TAG_ID.DT],
  [TAG_NAMES.EM, TAG_ID.EM],
  [TAG_NAMES.EMBED, TAG_ID.EMBED],
  [TAG_NAMES.FIELDSET, TAG_ID.FIELDSET],
  [TAG_NAMES.FIGCAPTION, TAG_ID.FIGCAPTION],
  [TAG_NAMES.FIGURE, TAG_ID.FIGURE],
  [TAG_NAMES.FONT, TAG_ID.FONT],
  [TAG_NAMES.FOOTER, TAG_ID.FOOTER],
  [TAG_NAMES.FOREIGN_OBJECT, TAG_ID.FOREIGN_OBJECT],
  [TAG_NAMES.FORM, TAG_ID.FORM],
  [TAG_NAMES.FRAME, TAG_ID.FRAME],
  [TAG_NAMES.FRAMESET, TAG_ID.FRAMESET],
  [TAG_NAMES.H1, TAG_ID.H1],
  [TAG_NAMES.H2, TAG_ID.H2],
  [TAG_NAMES.H3, TAG_ID.H3],
  [TAG_NAMES.H4, TAG_ID.H4],
  [TAG_NAMES.H5, TAG_ID.H5],
  [TAG_NAMES.H6, TAG_ID.H6],
  [TAG_NAMES.HEAD, TAG_ID.HEAD],
  [TAG_NAMES.HEADER, TAG_ID.HEADER],
  [TAG_NAMES.HGROUP, TAG_ID.HGROUP],
  [TAG_NAMES.HR, TAG_ID.HR],
  [TAG_NAMES.HTML, TAG_ID.HTML],
  [TAG_NAMES.I, TAG_ID.I],
  [TAG_NAMES.IMG, TAG_ID.IMG],
  [TAG_NAMES.IMAGE, TAG_ID.IMAGE],
  [TAG_NAMES.INPUT, TAG_ID.INPUT],
  [TAG_NAMES.IFRAME, TAG_ID.IFRAME],
  [TAG_NAMES.KEYGEN, TAG_ID.KEYGEN],
  [TAG_NAMES.LABEL, TAG_ID.LABEL],
  [TAG_NAMES.LI, TAG_ID.LI],
  [TAG_NAMES.LINK, TAG_ID.LINK],
  [TAG_NAMES.LISTING, TAG_ID.LISTING],
  [TAG_NAMES.MAIN, TAG_ID.MAIN],
  [TAG_NAMES.MALIGNMARK, TAG_ID.MALIGNMARK],
  [TAG_NAMES.MARQUEE, TAG_ID.MARQUEE],
  [TAG_NAMES.MATH, TAG_ID.MATH],
  [TAG_NAMES.MENU, TAG_ID.MENU],
  [TAG_NAMES.META, TAG_ID.META],
  [TAG_NAMES.MGLYPH, TAG_ID.MGLYPH],
  [TAG_NAMES.MI, TAG_ID.MI],
  [TAG_NAMES.MO, TAG_ID.MO],
  [TAG_NAMES.MN, TAG_ID.MN],
  [TAG_NAMES.MS, TAG_ID.MS],
  [TAG_NAMES.MTEXT, TAG_ID.MTEXT],
  [TAG_NAMES.NAV, TAG_ID.NAV],
  [TAG_NAMES.NOBR, TAG_ID.NOBR],
  [TAG_NAMES.NOFRAMES, TAG_ID.NOFRAMES],
  [TAG_NAMES.NOEMBED, TAG_ID.NOEMBED],
  [TAG_NAMES.NOSCRIPT, TAG_ID.NOSCRIPT],
  [TAG_NAMES.OBJECT, TAG_ID.OBJECT],
  [TAG_NAMES.OL, TAG_ID.OL],
  [TAG_NAMES.OPTGROUP, TAG_ID.OPTGROUP],
  [TAG_NAMES.OPTION, TAG_ID.OPTION],
  [TAG_NAMES.P, TAG_ID.P],
  [TAG_NAMES.PARAM, TAG_ID.PARAM],
  [TAG_NAMES.PLAINTEXT, TAG_ID.PLAINTEXT],
  [TAG_NAMES.PRE, TAG_ID.PRE],
  [TAG_NAMES.RB, TAG_ID.RB],
  [TAG_NAMES.RP, TAG_ID.RP],
  [TAG_NAMES.RT, TAG_ID.RT],
  [TAG_NAMES.RTC, TAG_ID.RTC],
  [TAG_NAMES.RUBY, TAG_ID.RUBY],
  [TAG_NAMES.S, TAG_ID.S],
  [TAG_NAMES.SCRIPT, TAG_ID.SCRIPT],
  [TAG_NAMES.SECTION, TAG_ID.SECTION],
  [TAG_NAMES.SELECT, TAG_ID.SELECT],
  [TAG_NAMES.SOURCE, TAG_ID.SOURCE],
  [TAG_NAMES.SMALL, TAG_ID.SMALL],
  [TAG_NAMES.SPAN, TAG_ID.SPAN],
  [TAG_NAMES.STRIKE, TAG_ID.STRIKE],
  [TAG_NAMES.STRONG, TAG_ID.STRONG],
  [TAG_NAMES.STYLE, TAG_ID.STYLE],
  [TAG_NAMES.SUB, TAG_ID.SUB],
  [TAG_NAMES.SUMMARY, TAG_ID.SUMMARY],
  [TAG_NAMES.SUP, TAG_ID.SUP],
  [TAG_NAMES.TABLE, TAG_ID.TABLE],
  [TAG_NAMES.TBODY, TAG_ID.TBODY],
  [TAG_NAMES.TEMPLATE, TAG_ID.TEMPLATE],
  [TAG_NAMES.TEXTAREA, TAG_ID.TEXTAREA],
  [TAG_NAMES.TFOOT, TAG_ID.TFOOT],
  [TAG_NAMES.TD, TAG_ID.TD],
  [TAG_NAMES.TH, TAG_ID.TH],
  [TAG_NAMES.THEAD, TAG_ID.THEAD],
  [TAG_NAMES.TITLE, TAG_ID.TITLE],
  [TAG_NAMES.TR, TAG_ID.TR],
  [TAG_NAMES.TRACK, TAG_ID.TRACK],
  [TAG_NAMES.TT, TAG_ID.TT],
  [TAG_NAMES.U, TAG_ID.U],
  [TAG_NAMES.UL, TAG_ID.UL],
  [TAG_NAMES.SVG, TAG_ID.SVG],
  [TAG_NAMES.VAR, TAG_ID.VAR],
  [TAG_NAMES.WBR, TAG_ID.WBR],
  [TAG_NAMES.XMP, TAG_ID.XMP],
]);
function getTagID(tagName) {
  var _a;
  return (_a = TAG_NAME_TO_ID.get(tagName)) !== null && _a !== void 0
    ? _a
    : TAG_ID.UNKNOWN;
}
const $ = TAG_ID;
const SPECIAL_ELEMENTS = {
  [NS.HTML]: new Set([
    $.ADDRESS,
    $.APPLET,
    $.AREA,
    $.ARTICLE,
    $.ASIDE,
    $.BASE,
    $.BASEFONT,
    $.BGSOUND,
    $.BLOCKQUOTE,
    $.BODY,
    $.BR,
    $.BUTTON,
    $.CAPTION,
    $.CENTER,
    $.COL,
    $.COLGROUP,
    $.DD,
    $.DETAILS,
    $.DIR,
    $.DIV,
    $.DL,
    $.DT,
    $.EMBED,
    $.FIELDSET,
    $.FIGCAPTION,
    $.FIGURE,
    $.FOOTER,
    $.FORM,
    $.FRAME,
    $.FRAMESET,
    $.H1,
    $.H2,
    $.H3,
    $.H4,
    $.H5,
    $.H6,
    $.HEAD,
    $.HEADER,
    $.HGROUP,
    $.HR,
    $.HTML,
    $.IFRAME,
    $.IMG,
    $.INPUT,
    $.LI,
    $.LINK,
    $.LISTING,
    $.MAIN,
    $.MARQUEE,
    $.MENU,
    $.META,
    $.NAV,
    $.NOEMBED,
    $.NOFRAMES,
    $.NOSCRIPT,
    $.OBJECT,
    $.OL,
    $.P,
    $.PARAM,
    $.PLAINTEXT,
    $.PRE,
    $.SCRIPT,
    $.SECTION,
    $.SELECT,
    $.SOURCE,
    $.STYLE,
    $.SUMMARY,
    $.TABLE,
    $.TBODY,
    $.TD,
    $.TEMPLATE,
    $.TEXTAREA,
    $.TFOOT,
    $.TH,
    $.THEAD,
    $.TITLE,
    $.TR,
    $.TRACK,
    $.UL,
    $.WBR,
    $.XMP,
  ]),
  [NS.MATHML]: new Set([$.MI, $.MO, $.MN, $.MS, $.MTEXT, $.ANNOTATION_XML]),
  [NS.SVG]: new Set([$.TITLE, $.FOREIGN_OBJECT, $.DESC]),
  [NS.XLINK]: new Set(),
  [NS.XML]: new Set(),
  [NS.XMLNS]: new Set(),
};
function isNumberedHeader(tn) {
  return (
    tn === $.H1 ||
    tn === $.H2 ||
    tn === $.H3 ||
    tn === $.H4 ||
    tn === $.H5 ||
    tn === $.H6
  );
}
const UNESCAPED_TEXT = new Set([
  TAG_NAMES.STYLE,
  TAG_NAMES.SCRIPT,
  TAG_NAMES.XMP,
  TAG_NAMES.IFRAME,
  TAG_NAMES.NOEMBED,
  TAG_NAMES.NOFRAMES,
  TAG_NAMES.PLAINTEXT,
]);
function hasUnescapedText(tn, scriptingEnabled) {
  return (
    UNESCAPED_TEXT.has(tn) || (scriptingEnabled && tn === TAG_NAMES.NOSCRIPT)
  );
}

//C1 Unicode control character reference replacements
const C1_CONTROLS_REFERENCE_REPLACEMENTS = new Map([
  [0x80, 8364],
  [0x82, 8218],
  [0x83, 402],
  [0x84, 8222],
  [0x85, 8230],
  [0x86, 8224],
  [0x87, 8225],
  [0x88, 710],
  [0x89, 8240],
  [0x8a, 352],
  [0x8b, 8249],
  [0x8c, 338],
  [0x8e, 381],
  [0x91, 8216],
  [0x92, 8217],
  [0x93, 8220],
  [0x94, 8221],
  [0x95, 8226],
  [0x96, 8211],
  [0x97, 8212],
  [0x98, 732],
  [0x99, 8482],
  [0x9a, 353],
  [0x9b, 8250],
  [0x9c, 339],
  [0x9e, 382],
  [0x9f, 376],
]);
//States
var State$1;
(function (State) {
  State[(State["DATA"] = 0)] = "DATA";
  State[(State["RCDATA"] = 1)] = "RCDATA";
  State[(State["RAWTEXT"] = 2)] = "RAWTEXT";
  State[(State["SCRIPT_DATA"] = 3)] = "SCRIPT_DATA";
  State[(State["PLAINTEXT"] = 4)] = "PLAINTEXT";
  State[(State["TAG_OPEN"] = 5)] = "TAG_OPEN";
  State[(State["END_TAG_OPEN"] = 6)] = "END_TAG_OPEN";
  State[(State["TAG_NAME"] = 7)] = "TAG_NAME";
  State[(State["RCDATA_LESS_THAN_SIGN"] = 8)] = "RCDATA_LESS_THAN_SIGN";
  State[(State["RCDATA_END_TAG_OPEN"] = 9)] = "RCDATA_END_TAG_OPEN";
  State[(State["RCDATA_END_TAG_NAME"] = 10)] = "RCDATA_END_TAG_NAME";
  State[(State["RAWTEXT_LESS_THAN_SIGN"] = 11)] = "RAWTEXT_LESS_THAN_SIGN";
  State[(State["RAWTEXT_END_TAG_OPEN"] = 12)] = "RAWTEXT_END_TAG_OPEN";
  State[(State["RAWTEXT_END_TAG_NAME"] = 13)] = "RAWTEXT_END_TAG_NAME";
  State[(State["SCRIPT_DATA_LESS_THAN_SIGN"] = 14)] =
    "SCRIPT_DATA_LESS_THAN_SIGN";
  State[(State["SCRIPT_DATA_END_TAG_OPEN"] = 15)] = "SCRIPT_DATA_END_TAG_OPEN";
  State[(State["SCRIPT_DATA_END_TAG_NAME"] = 16)] = "SCRIPT_DATA_END_TAG_NAME";
  State[(State["SCRIPT_DATA_ESCAPE_START"] = 17)] = "SCRIPT_DATA_ESCAPE_START";
  State[(State["SCRIPT_DATA_ESCAPE_START_DASH"] = 18)] =
    "SCRIPT_DATA_ESCAPE_START_DASH";
  State[(State["SCRIPT_DATA_ESCAPED"] = 19)] = "SCRIPT_DATA_ESCAPED";
  State[(State["SCRIPT_DATA_ESCAPED_DASH"] = 20)] = "SCRIPT_DATA_ESCAPED_DASH";
  State[(State["SCRIPT_DATA_ESCAPED_DASH_DASH"] = 21)] =
    "SCRIPT_DATA_ESCAPED_DASH_DASH";
  State[(State["SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN"] = 22)] =
    "SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN";
  State[(State["SCRIPT_DATA_ESCAPED_END_TAG_OPEN"] = 23)] =
    "SCRIPT_DATA_ESCAPED_END_TAG_OPEN";
  State[(State["SCRIPT_DATA_ESCAPED_END_TAG_NAME"] = 24)] =
    "SCRIPT_DATA_ESCAPED_END_TAG_NAME";
  State[(State["SCRIPT_DATA_DOUBLE_ESCAPE_START"] = 25)] =
    "SCRIPT_DATA_DOUBLE_ESCAPE_START";
  State[(State["SCRIPT_DATA_DOUBLE_ESCAPED"] = 26)] =
    "SCRIPT_DATA_DOUBLE_ESCAPED";
  State[(State["SCRIPT_DATA_DOUBLE_ESCAPED_DASH"] = 27)] =
    "SCRIPT_DATA_DOUBLE_ESCAPED_DASH";
  State[(State["SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH"] = 28)] =
    "SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH";
  State[(State["SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN"] = 29)] =
    "SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN";
  State[(State["SCRIPT_DATA_DOUBLE_ESCAPE_END"] = 30)] =
    "SCRIPT_DATA_DOUBLE_ESCAPE_END";
  State[(State["BEFORE_ATTRIBUTE_NAME"] = 31)] = "BEFORE_ATTRIBUTE_NAME";
  State[(State["ATTRIBUTE_NAME"] = 32)] = "ATTRIBUTE_NAME";
  State[(State["AFTER_ATTRIBUTE_NAME"] = 33)] = "AFTER_ATTRIBUTE_NAME";
  State[(State["BEFORE_ATTRIBUTE_VALUE"] = 34)] = "BEFORE_ATTRIBUTE_VALUE";
  State[(State["ATTRIBUTE_VALUE_DOUBLE_QUOTED"] = 35)] =
    "ATTRIBUTE_VALUE_DOUBLE_QUOTED";
  State[(State["ATTRIBUTE_VALUE_SINGLE_QUOTED"] = 36)] =
    "ATTRIBUTE_VALUE_SINGLE_QUOTED";
  State[(State["ATTRIBUTE_VALUE_UNQUOTED"] = 37)] = "ATTRIBUTE_VALUE_UNQUOTED";
  State[(State["AFTER_ATTRIBUTE_VALUE_QUOTED"] = 38)] =
    "AFTER_ATTRIBUTE_VALUE_QUOTED";
  State[(State["SELF_CLOSING_START_TAG"] = 39)] = "SELF_CLOSING_START_TAG";
  State[(State["BOGUS_COMMENT"] = 40)] = "BOGUS_COMMENT";
  State[(State["MARKUP_DECLARATION_OPEN"] = 41)] = "MARKUP_DECLARATION_OPEN";
  State[(State["COMMENT_START"] = 42)] = "COMMENT_START";
  State[(State["COMMENT_START_DASH"] = 43)] = "COMMENT_START_DASH";
  State[(State["COMMENT"] = 44)] = "COMMENT";
  State[(State["COMMENT_LESS_THAN_SIGN"] = 45)] = "COMMENT_LESS_THAN_SIGN";
  State[(State["COMMENT_LESS_THAN_SIGN_BANG"] = 46)] =
    "COMMENT_LESS_THAN_SIGN_BANG";
  State[(State["COMMENT_LESS_THAN_SIGN_BANG_DASH"] = 47)] =
    "COMMENT_LESS_THAN_SIGN_BANG_DASH";
  State[(State["COMMENT_LESS_THAN_SIGN_BANG_DASH_DASH"] = 48)] =
    "COMMENT_LESS_THAN_SIGN_BANG_DASH_DASH";
  State[(State["COMMENT_END_DASH"] = 49)] = "COMMENT_END_DASH";
  State[(State["COMMENT_END"] = 50)] = "COMMENT_END";
  State[(State["COMMENT_END_BANG"] = 51)] = "COMMENT_END_BANG";
  State[(State["DOCTYPE"] = 52)] = "DOCTYPE";
  State[(State["BEFORE_DOCTYPE_NAME"] = 53)] = "BEFORE_DOCTYPE_NAME";
  State[(State["DOCTYPE_NAME"] = 54)] = "DOCTYPE_NAME";
  State[(State["AFTER_DOCTYPE_NAME"] = 55)] = "AFTER_DOCTYPE_NAME";
  State[(State["AFTER_DOCTYPE_PUBLIC_KEYWORD"] = 56)] =
    "AFTER_DOCTYPE_PUBLIC_KEYWORD";
  State[(State["BEFORE_DOCTYPE_PUBLIC_IDENTIFIER"] = 57)] =
    "BEFORE_DOCTYPE_PUBLIC_IDENTIFIER";
  State[(State["DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED"] = 58)] =
    "DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED";
  State[(State["DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED"] = 59)] =
    "DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED";
  State[(State["AFTER_DOCTYPE_PUBLIC_IDENTIFIER"] = 60)] =
    "AFTER_DOCTYPE_PUBLIC_IDENTIFIER";
  State[(State["BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS"] = 61)] =
    "BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS";
  State[(State["AFTER_DOCTYPE_SYSTEM_KEYWORD"] = 62)] =
    "AFTER_DOCTYPE_SYSTEM_KEYWORD";
  State[(State["BEFORE_DOCTYPE_SYSTEM_IDENTIFIER"] = 63)] =
    "BEFORE_DOCTYPE_SYSTEM_IDENTIFIER";
  State[(State["DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED"] = 64)] =
    "DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED";
  State[(State["DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED"] = 65)] =
    "DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED";
  State[(State["AFTER_DOCTYPE_SYSTEM_IDENTIFIER"] = 66)] =
    "AFTER_DOCTYPE_SYSTEM_IDENTIFIER";
  State[(State["BOGUS_DOCTYPE"] = 67)] = "BOGUS_DOCTYPE";
  State[(State["CDATA_SECTION"] = 68)] = "CDATA_SECTION";
  State[(State["CDATA_SECTION_BRACKET"] = 69)] = "CDATA_SECTION_BRACKET";
  State[(State["CDATA_SECTION_END"] = 70)] = "CDATA_SECTION_END";
  State[(State["CHARACTER_REFERENCE"] = 71)] = "CHARACTER_REFERENCE";
  State[(State["NAMED_CHARACTER_REFERENCE"] = 72)] =
    "NAMED_CHARACTER_REFERENCE";
  State[(State["AMBIGUOUS_AMPERSAND"] = 73)] = "AMBIGUOUS_AMPERSAND";
  State[(State["NUMERIC_CHARACTER_REFERENCE"] = 74)] =
    "NUMERIC_CHARACTER_REFERENCE";
  State[(State["HEXADEMICAL_CHARACTER_REFERENCE_START"] = 75)] =
    "HEXADEMICAL_CHARACTER_REFERENCE_START";
  State[(State["HEXADEMICAL_CHARACTER_REFERENCE"] = 76)] =
    "HEXADEMICAL_CHARACTER_REFERENCE";
  State[(State["DECIMAL_CHARACTER_REFERENCE"] = 77)] =
    "DECIMAL_CHARACTER_REFERENCE";
  State[(State["NUMERIC_CHARACTER_REFERENCE_END"] = 78)] =
    "NUMERIC_CHARACTER_REFERENCE_END";
})(State$1 || (State$1 = {}));
//Tokenizer initial states for different modes
const TokenizerMode = {
  DATA: State$1.DATA,
  RCDATA: State$1.RCDATA,
  RAWTEXT: State$1.RAWTEXT,
  SCRIPT_DATA: State$1.SCRIPT_DATA,
  PLAINTEXT: State$1.PLAINTEXT,
  CDATA_SECTION: State$1.CDATA_SECTION,
};
//Utils
//OPTIMIZATION: these utility functions should not be moved out of this module. V8 Crankshaft will not inline
//this functions if they will be situated in another module due to context switch.
//Always perform inlining check before modifying this functions ('node --trace-inlining').
function isAsciiDigit(cp) {
  return cp >= CODE_POINTS.DIGIT_0 && cp <= CODE_POINTS.DIGIT_9;
}
function isAsciiUpper(cp) {
  return cp >= CODE_POINTS.LATIN_CAPITAL_A && cp <= CODE_POINTS.LATIN_CAPITAL_Z;
}
function isAsciiLower(cp) {
  return cp >= CODE_POINTS.LATIN_SMALL_A && cp <= CODE_POINTS.LATIN_SMALL_Z;
}
function isAsciiLetter(cp) {
  return isAsciiLower(cp) || isAsciiUpper(cp);
}
function isAsciiAlphaNumeric(cp) {
  return isAsciiLetter(cp) || isAsciiDigit(cp);
}
function isAsciiUpperHexDigit(cp) {
  return cp >= CODE_POINTS.LATIN_CAPITAL_A && cp <= CODE_POINTS.LATIN_CAPITAL_F;
}
function isAsciiLowerHexDigit(cp) {
  return cp >= CODE_POINTS.LATIN_SMALL_A && cp <= CODE_POINTS.LATIN_SMALL_F;
}
function isAsciiHexDigit(cp) {
  return (
    isAsciiDigit(cp) || isAsciiUpperHexDigit(cp) || isAsciiLowerHexDigit(cp)
  );
}
function toAsciiLower(cp) {
  return cp + 32;
}
function isWhitespace$1(cp) {
  return (
    cp === CODE_POINTS.SPACE ||
    cp === CODE_POINTS.LINE_FEED ||
    cp === CODE_POINTS.TABULATION ||
    cp === CODE_POINTS.FORM_FEED
  );
}
function isEntityInAttributeInvalidEnd(nextCp) {
  return nextCp === CODE_POINTS.EQUALS_SIGN || isAsciiAlphaNumeric(nextCp);
}
function isScriptDataDoubleEscapeSequenceEnd(cp) {
  return (
    isWhitespace$1(cp) ||
    cp === CODE_POINTS.SOLIDUS ||
    cp === CODE_POINTS.GREATER_THAN_SIGN
  );
}
//Tokenizer
let Tokenizer$3 = class Tokenizer {
  constructor(options, handler) {
    this.options = options;
    this.handler = handler;
    this.paused = false;
    /** Ensures that the parsing loop isn't run multiple times at once. */
    this.inLoop = false;
    /**
     * Indicates that the current adjusted node exists, is not an element in the HTML namespace,
     * and that it is not an integration point for either MathML or HTML.
     *
     * @see {@link https://html.spec.whatwg.org/multipage/parsing.html#tree-construction}
     */
    this.inForeignNode = false;
    this.lastStartTagName = "";
    this.active = false;
    this.state = State$1.DATA;
    this.returnState = State$1.DATA;
    this.charRefCode = -1;
    this.consumedAfterSnapshot = -1;
    this.currentCharacterToken = null;
    this.currentToken = null;
    this.currentAttr = { name: "", value: "" };
    this.preprocessor = new Preprocessor(handler);
    this.currentLocation = this.getCurrentLocation(-1);
  }
  //Errors
  _err(code) {
    var _a, _b;
    (_b = (_a = this.handler).onParseError) === null || _b === void 0
      ? void 0
      : _b.call(_a, this.preprocessor.getError(code));
  }
  // NOTE: `offset` may never run across line boundaries.
  getCurrentLocation(offset) {
    if (!this.options.sourceCodeLocationInfo) {
      return null;
    }
    return {
      startLine: this.preprocessor.line,
      startCol: this.preprocessor.col - offset,
      startOffset: this.preprocessor.offset - offset,
      endLine: -1,
      endCol: -1,
      endOffset: -1,
    };
  }
  _runParsingLoop() {
    if (this.inLoop) return;
    this.inLoop = true;
    while (this.active && !this.paused) {
      this.consumedAfterSnapshot = 0;
      const cp = this._consume();
      if (!this._ensureHibernation()) {
        this._callState(cp);
      }
    }
    this.inLoop = false;
  }
  //API
  pause() {
    this.paused = true;
  }
  resume(writeCallback) {
    if (!this.paused) {
      throw new Error("Parser was already resumed");
    }
    this.paused = false;
    // Necessary for synchronous resume.
    if (this.inLoop) return;
    this._runParsingLoop();
    if (!this.paused) {
      writeCallback === null || writeCallback === void 0
        ? void 0
        : writeCallback();
    }
  }
  write(chunk, isLastChunk, writeCallback) {
    this.active = true;
    this.preprocessor.write(chunk, isLastChunk);
    this._runParsingLoop();
    if (!this.paused) {
      writeCallback === null || writeCallback === void 0
        ? void 0
        : writeCallback();
    }
  }
  insertHtmlAtCurrentPos(chunk) {
    this.active = true;
    this.preprocessor.insertHtmlAtCurrentPos(chunk);
    this._runParsingLoop();
  }
  //Hibernation
  _ensureHibernation() {
    if (this.preprocessor.endOfChunkHit) {
      this._unconsume(this.consumedAfterSnapshot);
      this.active = false;
      return true;
    }
    return false;
  }
  //Consumption
  _consume() {
    this.consumedAfterSnapshot++;
    return this.preprocessor.advance();
  }
  _unconsume(count) {
    this.consumedAfterSnapshot -= count;
    this.preprocessor.retreat(count);
  }
  _reconsumeInState(state, cp) {
    this.state = state;
    this._callState(cp);
  }
  _advanceBy(count) {
    this.consumedAfterSnapshot += count;
    for (let i = 0; i < count; i++) {
      this.preprocessor.advance();
    }
  }
  _consumeSequenceIfMatch(pattern, caseSensitive) {
    if (this.preprocessor.startsWith(pattern, caseSensitive)) {
      // We will already have consumed one character before calling this method.
      this._advanceBy(pattern.length - 1);
      return true;
    }
    return false;
  }
  //Token creation
  _createStartTagToken() {
    this.currentToken = {
      type: TokenType.START_TAG,
      tagName: "",
      tagID: TAG_ID.UNKNOWN,
      selfClosing: false,
      ackSelfClosing: false,
      attrs: [],
      location: this.getCurrentLocation(1),
    };
  }
  _createEndTagToken() {
    this.currentToken = {
      type: TokenType.END_TAG,
      tagName: "",
      tagID: TAG_ID.UNKNOWN,
      selfClosing: false,
      ackSelfClosing: false,
      attrs: [],
      location: this.getCurrentLocation(2),
    };
  }
  _createCommentToken(offset) {
    this.currentToken = {
      type: TokenType.COMMENT,
      data: "",
      location: this.getCurrentLocation(offset),
    };
  }
  _createDoctypeToken(initialName) {
    this.currentToken = {
      type: TokenType.DOCTYPE,
      name: initialName,
      forceQuirks: false,
      publicId: null,
      systemId: null,
      location: this.currentLocation,
    };
  }
  _createCharacterToken(type, chars) {
    this.currentCharacterToken = {
      type,
      chars,
      location: this.currentLocation,
    };
  }
  //Tag attributes
  _createAttr(attrNameFirstCh) {
    this.currentAttr = {
      name: attrNameFirstCh,
      value: "",
    };
    this.currentLocation = this.getCurrentLocation(0);
  }
  _leaveAttrName() {
    var _a;
    var _b;
    const token = this.currentToken;
    if (getTokenAttr(token, this.currentAttr.name) === null) {
      token.attrs.push(this.currentAttr);
      if (token.location && this.currentLocation) {
        const attrLocations =
          (_a = (_b = token.location).attrs) !== null && _a !== void 0
            ? _a
            : (_b.attrs = Object.create(null));
        attrLocations[this.currentAttr.name] = this.currentLocation;
        // Set end location
        this._leaveAttrValue();
      }
    } else {
      this._err(ERR.duplicateAttribute);
    }
  }
  _leaveAttrValue() {
    if (this.currentLocation) {
      this.currentLocation.endLine = this.preprocessor.line;
      this.currentLocation.endCol = this.preprocessor.col;
      this.currentLocation.endOffset = this.preprocessor.offset;
    }
  }
  //Token emission
  prepareToken(ct) {
    this._emitCurrentCharacterToken(ct.location);
    this.currentToken = null;
    if (ct.location) {
      ct.location.endLine = this.preprocessor.line;
      ct.location.endCol = this.preprocessor.col + 1;
      ct.location.endOffset = this.preprocessor.offset + 1;
    }
    this.currentLocation = this.getCurrentLocation(-1);
  }
  emitCurrentTagToken() {
    const ct = this.currentToken;
    this.prepareToken(ct);
    ct.tagID = getTagID(ct.tagName);
    if (ct.type === TokenType.START_TAG) {
      this.lastStartTagName = ct.tagName;
      this.handler.onStartTag(ct);
    } else {
      if (ct.attrs.length > 0) {
        this._err(ERR.endTagWithAttributes);
      }
      if (ct.selfClosing) {
        this._err(ERR.endTagWithTrailingSolidus);
      }
      this.handler.onEndTag(ct);
    }
    this.preprocessor.dropParsedChunk();
  }
  emitCurrentComment(ct) {
    this.prepareToken(ct);
    this.handler.onComment(ct);
    this.preprocessor.dropParsedChunk();
  }
  emitCurrentDoctype(ct) {
    this.prepareToken(ct);
    this.handler.onDoctype(ct);
    this.preprocessor.dropParsedChunk();
  }
  _emitCurrentCharacterToken(nextLocation) {
    if (this.currentCharacterToken) {
      //NOTE: if we have a pending character token, make it's end location equal to the
      //current token's start location.
      if (nextLocation && this.currentCharacterToken.location) {
        this.currentCharacterToken.location.endLine = nextLocation.startLine;
        this.currentCharacterToken.location.endCol = nextLocation.startCol;
        this.currentCharacterToken.location.endOffset =
          nextLocation.startOffset;
      }
      switch (this.currentCharacterToken.type) {
        case TokenType.CHARACTER: {
          this.handler.onCharacter(this.currentCharacterToken);
          break;
        }
        case TokenType.NULL_CHARACTER: {
          this.handler.onNullCharacter(this.currentCharacterToken);
          break;
        }
        case TokenType.WHITESPACE_CHARACTER: {
          this.handler.onWhitespaceCharacter(this.currentCharacterToken);
          break;
        }
      }
      this.currentCharacterToken = null;
    }
  }
  _emitEOFToken() {
    const location = this.getCurrentLocation(0);
    if (location) {
      location.endLine = location.startLine;
      location.endCol = location.startCol;
      location.endOffset = location.startOffset;
    }
    this._emitCurrentCharacterToken(location);
    this.handler.onEof({ type: TokenType.EOF, location });
    this.active = false;
  }
  //Characters emission
  //OPTIMIZATION: specification uses only one type of character tokens (one token per character).
  //This causes a huge memory overhead and a lot of unnecessary parser loops. parse5 uses 3 groups of characters.
  //If we have a sequence of characters that belong to the same group, the parser can process it
  //as a single solid character token.
  //So, there are 3 types of character tokens in parse5:
  //1)TokenType.NULL_CHARACTER - \u0000-character sequences (e.g. '\u0000\u0000\u0000')
  //2)TokenType.WHITESPACE_CHARACTER - any whitespace/new-line character sequences (e.g. '\n  \r\t   \f')
  //3)TokenType.CHARACTER - any character sequence which don't belong to groups 1 and 2 (e.g. 'abcdef1234@@#$%^')
  _appendCharToCurrentCharacterToken(type, ch) {
    if (this.currentCharacterToken) {
      if (this.currentCharacterToken.type !== type) {
        this.currentLocation = this.getCurrentLocation(0);
        this._emitCurrentCharacterToken(this.currentLocation);
        this.preprocessor.dropParsedChunk();
      } else {
        this.currentCharacterToken.chars += ch;
        return;
      }
    }
    this._createCharacterToken(type, ch);
  }
  _emitCodePoint(cp) {
    const type = isWhitespace$1(cp)
      ? TokenType.WHITESPACE_CHARACTER
      : cp === CODE_POINTS.NULL
        ? TokenType.NULL_CHARACTER
        : TokenType.CHARACTER;
    this._appendCharToCurrentCharacterToken(type, String.fromCodePoint(cp));
  }
  //NOTE: used when we emit characters explicitly.
  //This is always for non-whitespace and non-null characters, which allows us to avoid additional checks.
  _emitChars(ch) {
    this._appendCharToCurrentCharacterToken(TokenType.CHARACTER, ch);
  }
  // Character reference helpers
  _matchNamedCharacterReference(cp) {
    let result = null;
    let excess = 0;
    let withoutSemicolon = false;
    for (let i = 0, current = htmlDecodeTree[0]; i >= 0; cp = this._consume()) {
      i = determineBranch(htmlDecodeTree, current, i + 1, cp);
      if (i < 0) break;
      excess += 1;
      current = htmlDecodeTree[i];
      const masked = current & BinTrieFlags.VALUE_LENGTH;
      // If the branch is a value, store it and continue
      if (masked) {
        // The mask is the number of bytes of the value, including the current byte.
        const valueLength = (masked >> 14) - 1;
        // Attribute values that aren't terminated properly aren't parsed, and shouldn't lead to a parser error.
        // See the example in https://html.spec.whatwg.org/multipage/parsing.html#named-character-reference-state
        if (
          cp !== CODE_POINTS.SEMICOLON &&
          this._isCharacterReferenceInAttribute() &&
          isEntityInAttributeInvalidEnd(this.preprocessor.peek(1))
        ) {
          //NOTE: we don't flush all consumed code points here, and instead switch back to the original state after
          //emitting an ampersand. This is fine, as alphanumeric characters won't be parsed differently in attributes.
          result = [CODE_POINTS.AMPERSAND];
          // Skip over the value.
          i += valueLength;
        } else {
          // If this is a surrogate pair, consume the next two bytes.
          result =
            valueLength === 0
              ? [htmlDecodeTree[i] & ~BinTrieFlags.VALUE_LENGTH]
              : valueLength === 1
                ? [htmlDecodeTree[++i]]
                : [htmlDecodeTree[++i], htmlDecodeTree[++i]];
          excess = 0;
          withoutSemicolon = cp !== CODE_POINTS.SEMICOLON;
        }
        if (valueLength === 0) {
          // If the value is zero-length, we're done.
          this._consume();
          break;
        }
      }
    }
    this._unconsume(excess);
    if (withoutSemicolon && !this.preprocessor.endOfChunkHit) {
      this._err(ERR.missingSemicolonAfterCharacterReference);
    }
    // We want to emit the error above on the code point after the entity.
    // We always consume one code point too many in the loop, and we wait to
    // unconsume it until after the error is emitted.
    this._unconsume(1);
    return result;
  }
  _isCharacterReferenceInAttribute() {
    return (
      this.returnState === State$1.ATTRIBUTE_VALUE_DOUBLE_QUOTED ||
      this.returnState === State$1.ATTRIBUTE_VALUE_SINGLE_QUOTED ||
      this.returnState === State$1.ATTRIBUTE_VALUE_UNQUOTED
    );
  }
  _flushCodePointConsumedAsCharacterReference(cp) {
    if (this._isCharacterReferenceInAttribute()) {
      this.currentAttr.value += String.fromCodePoint(cp);
    } else {
      this._emitCodePoint(cp);
    }
  }
  // Calling states this way turns out to be much faster than any other approach.
  _callState(cp) {
    switch (this.state) {
      case State$1.DATA: {
        this._stateData(cp);
        break;
      }
      case State$1.RCDATA: {
        this._stateRcdata(cp);
        break;
      }
      case State$1.RAWTEXT: {
        this._stateRawtext(cp);
        break;
      }
      case State$1.SCRIPT_DATA: {
        this._stateScriptData(cp);
        break;
      }
      case State$1.PLAINTEXT: {
        this._statePlaintext(cp);
        break;
      }
      case State$1.TAG_OPEN: {
        this._stateTagOpen(cp);
        break;
      }
      case State$1.END_TAG_OPEN: {
        this._stateEndTagOpen(cp);
        break;
      }
      case State$1.TAG_NAME: {
        this._stateTagName(cp);
        break;
      }
      case State$1.RCDATA_LESS_THAN_SIGN: {
        this._stateRcdataLessThanSign(cp);
        break;
      }
      case State$1.RCDATA_END_TAG_OPEN: {
        this._stateRcdataEndTagOpen(cp);
        break;
      }
      case State$1.RCDATA_END_TAG_NAME: {
        this._stateRcdataEndTagName(cp);
        break;
      }
      case State$1.RAWTEXT_LESS_THAN_SIGN: {
        this._stateRawtextLessThanSign(cp);
        break;
      }
      case State$1.RAWTEXT_END_TAG_OPEN: {
        this._stateRawtextEndTagOpen(cp);
        break;
      }
      case State$1.RAWTEXT_END_TAG_NAME: {
        this._stateRawtextEndTagName(cp);
        break;
      }
      case State$1.SCRIPT_DATA_LESS_THAN_SIGN: {
        this._stateScriptDataLessThanSign(cp);
        break;
      }
      case State$1.SCRIPT_DATA_END_TAG_OPEN: {
        this._stateScriptDataEndTagOpen(cp);
        break;
      }
      case State$1.SCRIPT_DATA_END_TAG_NAME: {
        this._stateScriptDataEndTagName(cp);
        break;
      }
      case State$1.SCRIPT_DATA_ESCAPE_START: {
        this._stateScriptDataEscapeStart(cp);
        break;
      }
      case State$1.SCRIPT_DATA_ESCAPE_START_DASH: {
        this._stateScriptDataEscapeStartDash(cp);
        break;
      }
      case State$1.SCRIPT_DATA_ESCAPED: {
        this._stateScriptDataEscaped(cp);
        break;
      }
      case State$1.SCRIPT_DATA_ESCAPED_DASH: {
        this._stateScriptDataEscapedDash(cp);
        break;
      }
      case State$1.SCRIPT_DATA_ESCAPED_DASH_DASH: {
        this._stateScriptDataEscapedDashDash(cp);
        break;
      }
      case State$1.SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN: {
        this._stateScriptDataEscapedLessThanSign(cp);
        break;
      }
      case State$1.SCRIPT_DATA_ESCAPED_END_TAG_OPEN: {
        this._stateScriptDataEscapedEndTagOpen(cp);
        break;
      }
      case State$1.SCRIPT_DATA_ESCAPED_END_TAG_NAME: {
        this._stateScriptDataEscapedEndTagName(cp);
        break;
      }
      case State$1.SCRIPT_DATA_DOUBLE_ESCAPE_START: {
        this._stateScriptDataDoubleEscapeStart(cp);
        break;
      }
      case State$1.SCRIPT_DATA_DOUBLE_ESCAPED: {
        this._stateScriptDataDoubleEscaped(cp);
        break;
      }
      case State$1.SCRIPT_DATA_DOUBLE_ESCAPED_DASH: {
        this._stateScriptDataDoubleEscapedDash(cp);
        break;
      }
      case State$1.SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH: {
        this._stateScriptDataDoubleEscapedDashDash(cp);
        break;
      }
      case State$1.SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN: {
        this._stateScriptDataDoubleEscapedLessThanSign(cp);
        break;
      }
      case State$1.SCRIPT_DATA_DOUBLE_ESCAPE_END: {
        this._stateScriptDataDoubleEscapeEnd(cp);
        break;
      }
      case State$1.BEFORE_ATTRIBUTE_NAME: {
        this._stateBeforeAttributeName(cp);
        break;
      }
      case State$1.ATTRIBUTE_NAME: {
        this._stateAttributeName(cp);
        break;
      }
      case State$1.AFTER_ATTRIBUTE_NAME: {
        this._stateAfterAttributeName(cp);
        break;
      }
      case State$1.BEFORE_ATTRIBUTE_VALUE: {
        this._stateBeforeAttributeValue(cp);
        break;
      }
      case State$1.ATTRIBUTE_VALUE_DOUBLE_QUOTED: {
        this._stateAttributeValueDoubleQuoted(cp);
        break;
      }
      case State$1.ATTRIBUTE_VALUE_SINGLE_QUOTED: {
        this._stateAttributeValueSingleQuoted(cp);
        break;
      }
      case State$1.ATTRIBUTE_VALUE_UNQUOTED: {
        this._stateAttributeValueUnquoted(cp);
        break;
      }
      case State$1.AFTER_ATTRIBUTE_VALUE_QUOTED: {
        this._stateAfterAttributeValueQuoted(cp);
        break;
      }
      case State$1.SELF_CLOSING_START_TAG: {
        this._stateSelfClosingStartTag(cp);
        break;
      }
      case State$1.BOGUS_COMMENT: {
        this._stateBogusComment(cp);
        break;
      }
      case State$1.MARKUP_DECLARATION_OPEN: {
        this._stateMarkupDeclarationOpen(cp);
        break;
      }
      case State$1.COMMENT_START: {
        this._stateCommentStart(cp);
        break;
      }
      case State$1.COMMENT_START_DASH: {
        this._stateCommentStartDash(cp);
        break;
      }
      case State$1.COMMENT: {
        this._stateComment(cp);
        break;
      }
      case State$1.COMMENT_LESS_THAN_SIGN: {
        this._stateCommentLessThanSign(cp);
        break;
      }
      case State$1.COMMENT_LESS_THAN_SIGN_BANG: {
        this._stateCommentLessThanSignBang(cp);
        break;
      }
      case State$1.COMMENT_LESS_THAN_SIGN_BANG_DASH: {
        this._stateCommentLessThanSignBangDash(cp);
        break;
      }
      case State$1.COMMENT_LESS_THAN_SIGN_BANG_DASH_DASH: {
        this._stateCommentLessThanSignBangDashDash(cp);
        break;
      }
      case State$1.COMMENT_END_DASH: {
        this._stateCommentEndDash(cp);
        break;
      }
      case State$1.COMMENT_END: {
        this._stateCommentEnd(cp);
        break;
      }
      case State$1.COMMENT_END_BANG: {
        this._stateCommentEndBang(cp);
        break;
      }
      case State$1.DOCTYPE: {
        this._stateDoctype(cp);
        break;
      }
      case State$1.BEFORE_DOCTYPE_NAME: {
        this._stateBeforeDoctypeName(cp);
        break;
      }
      case State$1.DOCTYPE_NAME: {
        this._stateDoctypeName(cp);
        break;
      }
      case State$1.AFTER_DOCTYPE_NAME: {
        this._stateAfterDoctypeName(cp);
        break;
      }
      case State$1.AFTER_DOCTYPE_PUBLIC_KEYWORD: {
        this._stateAfterDoctypePublicKeyword(cp);
        break;
      }
      case State$1.BEFORE_DOCTYPE_PUBLIC_IDENTIFIER: {
        this._stateBeforeDoctypePublicIdentifier(cp);
        break;
      }
      case State$1.DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED: {
        this._stateDoctypePublicIdentifierDoubleQuoted(cp);
        break;
      }
      case State$1.DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED: {
        this._stateDoctypePublicIdentifierSingleQuoted(cp);
        break;
      }
      case State$1.AFTER_DOCTYPE_PUBLIC_IDENTIFIER: {
        this._stateAfterDoctypePublicIdentifier(cp);
        break;
      }
      case State$1.BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS: {
        this._stateBetweenDoctypePublicAndSystemIdentifiers(cp);
        break;
      }
      case State$1.AFTER_DOCTYPE_SYSTEM_KEYWORD: {
        this._stateAfterDoctypeSystemKeyword(cp);
        break;
      }
      case State$1.BEFORE_DOCTYPE_SYSTEM_IDENTIFIER: {
        this._stateBeforeDoctypeSystemIdentifier(cp);
        break;
      }
      case State$1.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED: {
        this._stateDoctypeSystemIdentifierDoubleQuoted(cp);
        break;
      }
      case State$1.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED: {
        this._stateDoctypeSystemIdentifierSingleQuoted(cp);
        break;
      }
      case State$1.AFTER_DOCTYPE_SYSTEM_IDENTIFIER: {
        this._stateAfterDoctypeSystemIdentifier(cp);
        break;
      }
      case State$1.BOGUS_DOCTYPE: {
        this._stateBogusDoctype(cp);
        break;
      }
      case State$1.CDATA_SECTION: {
        this._stateCdataSection(cp);
        break;
      }
      case State$1.CDATA_SECTION_BRACKET: {
        this._stateCdataSectionBracket(cp);
        break;
      }
      case State$1.CDATA_SECTION_END: {
        this._stateCdataSectionEnd(cp);
        break;
      }
      case State$1.CHARACTER_REFERENCE: {
        this._stateCharacterReference(cp);
        break;
      }
      case State$1.NAMED_CHARACTER_REFERENCE: {
        this._stateNamedCharacterReference(cp);
        break;
      }
      case State$1.AMBIGUOUS_AMPERSAND: {
        this._stateAmbiguousAmpersand(cp);
        break;
      }
      case State$1.NUMERIC_CHARACTER_REFERENCE: {
        this._stateNumericCharacterReference(cp);
        break;
      }
      case State$1.HEXADEMICAL_CHARACTER_REFERENCE_START: {
        this._stateHexademicalCharacterReferenceStart(cp);
        break;
      }
      case State$1.HEXADEMICAL_CHARACTER_REFERENCE: {
        this._stateHexademicalCharacterReference(cp);
        break;
      }
      case State$1.DECIMAL_CHARACTER_REFERENCE: {
        this._stateDecimalCharacterReference(cp);
        break;
      }
      case State$1.NUMERIC_CHARACTER_REFERENCE_END: {
        this._stateNumericCharacterReferenceEnd(cp);
        break;
      }
      default: {
        throw new Error("Unknown state");
      }
    }
  }
  // State machine
  // Data state
  //------------------------------------------------------------------
  _stateData(cp) {
    switch (cp) {
      case CODE_POINTS.LESS_THAN_SIGN: {
        this.state = State$1.TAG_OPEN;
        break;
      }
      case CODE_POINTS.AMPERSAND: {
        this.returnState = State$1.DATA;
        this.state = State$1.CHARACTER_REFERENCE;
        break;
      }
      case CODE_POINTS.NULL: {
        this._err(ERR.unexpectedNullCharacter);
        this._emitCodePoint(cp);
        break;
      }
      case CODE_POINTS.EOF: {
        this._emitEOFToken();
        break;
      }
      default: {
        this._emitCodePoint(cp);
      }
    }
  }
  //  RCDATA state
  //------------------------------------------------------------------
  _stateRcdata(cp) {
    switch (cp) {
      case CODE_POINTS.AMPERSAND: {
        this.returnState = State$1.RCDATA;
        this.state = State$1.CHARACTER_REFERENCE;
        break;
      }
      case CODE_POINTS.LESS_THAN_SIGN: {
        this.state = State$1.RCDATA_LESS_THAN_SIGN;
        break;
      }
      case CODE_POINTS.NULL: {
        this._err(ERR.unexpectedNullCharacter);
        this._emitChars(REPLACEMENT_CHARACTER);
        break;
      }
      case CODE_POINTS.EOF: {
        this._emitEOFToken();
        break;
      }
      default: {
        this._emitCodePoint(cp);
      }
    }
  }
  // RAWTEXT state
  //------------------------------------------------------------------
  _stateRawtext(cp) {
    switch (cp) {
      case CODE_POINTS.LESS_THAN_SIGN: {
        this.state = State$1.RAWTEXT_LESS_THAN_SIGN;
        break;
      }
      case CODE_POINTS.NULL: {
        this._err(ERR.unexpectedNullCharacter);
        this._emitChars(REPLACEMENT_CHARACTER);
        break;
      }
      case CODE_POINTS.EOF: {
        this._emitEOFToken();
        break;
      }
      default: {
        this._emitCodePoint(cp);
      }
    }
  }
  // Script data state
  //------------------------------------------------------------------
  _stateScriptData(cp) {
    switch (cp) {
      case CODE_POINTS.LESS_THAN_SIGN: {
        this.state = State$1.SCRIPT_DATA_LESS_THAN_SIGN;
        break;
      }
      case CODE_POINTS.NULL: {
        this._err(ERR.unexpectedNullCharacter);
        this._emitChars(REPLACEMENT_CHARACTER);
        break;
      }
      case CODE_POINTS.EOF: {
        this._emitEOFToken();
        break;
      }
      default: {
        this._emitCodePoint(cp);
      }
    }
  }
  // PLAINTEXT state
  //------------------------------------------------------------------
  _statePlaintext(cp) {
    switch (cp) {
      case CODE_POINTS.NULL: {
        this._err(ERR.unexpectedNullCharacter);
        this._emitChars(REPLACEMENT_CHARACTER);
        break;
      }
      case CODE_POINTS.EOF: {
        this._emitEOFToken();
        break;
      }
      default: {
        this._emitCodePoint(cp);
      }
    }
  }
  // Tag open state
  //------------------------------------------------------------------
  _stateTagOpen(cp) {
    if (isAsciiLetter(cp)) {
      this._createStartTagToken();
      this.state = State$1.TAG_NAME;
      this._stateTagName(cp);
    } else
      switch (cp) {
        case CODE_POINTS.EXCLAMATION_MARK: {
          this.state = State$1.MARKUP_DECLARATION_OPEN;
          break;
        }
        case CODE_POINTS.SOLIDUS: {
          this.state = State$1.END_TAG_OPEN;
          break;
        }
        case CODE_POINTS.QUESTION_MARK: {
          this._err(ERR.unexpectedQuestionMarkInsteadOfTagName);
          this._createCommentToken(1);
          this.state = State$1.BOGUS_COMMENT;
          this._stateBogusComment(cp);
          break;
        }
        case CODE_POINTS.EOF: {
          this._err(ERR.eofBeforeTagName);
          this._emitChars("<");
          this._emitEOFToken();
          break;
        }
        default: {
          this._err(ERR.invalidFirstCharacterOfTagName);
          this._emitChars("<");
          this.state = State$1.DATA;
          this._stateData(cp);
        }
      }
  }
  // End tag open state
  //------------------------------------------------------------------
  _stateEndTagOpen(cp) {
    if (isAsciiLetter(cp)) {
      this._createEndTagToken();
      this.state = State$1.TAG_NAME;
      this._stateTagName(cp);
    } else
      switch (cp) {
        case CODE_POINTS.GREATER_THAN_SIGN: {
          this._err(ERR.missingEndTagName);
          this.state = State$1.DATA;
          break;
        }
        case CODE_POINTS.EOF: {
          this._err(ERR.eofBeforeTagName);
          this._emitChars("</");
          this._emitEOFToken();
          break;
        }
        default: {
          this._err(ERR.invalidFirstCharacterOfTagName);
          this._createCommentToken(2);
          this.state = State$1.BOGUS_COMMENT;
          this._stateBogusComment(cp);
        }
      }
  }
  // Tag name state
  //------------------------------------------------------------------
  _stateTagName(cp) {
    const token = this.currentToken;
    switch (cp) {
      case CODE_POINTS.SPACE:
      case CODE_POINTS.LINE_FEED:
      case CODE_POINTS.TABULATION:
      case CODE_POINTS.FORM_FEED: {
        this.state = State$1.BEFORE_ATTRIBUTE_NAME;
        break;
      }
      case CODE_POINTS.SOLIDUS: {
        this.state = State$1.SELF_CLOSING_START_TAG;
        break;
      }
      case CODE_POINTS.GREATER_THAN_SIGN: {
        this.state = State$1.DATA;
        this.emitCurrentTagToken();
        break;
      }
      case CODE_POINTS.NULL: {
        this._err(ERR.unexpectedNullCharacter);
        token.tagName += REPLACEMENT_CHARACTER;
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInTag);
        this._emitEOFToken();
        break;
      }
      default: {
        token.tagName += String.fromCodePoint(
          isAsciiUpper(cp) ? toAsciiLower(cp) : cp,
        );
      }
    }
  }
  // RCDATA less-than sign state
  //------------------------------------------------------------------
  _stateRcdataLessThanSign(cp) {
    if (cp === CODE_POINTS.SOLIDUS) {
      this.state = State$1.RCDATA_END_TAG_OPEN;
    } else {
      this._emitChars("<");
      this.state = State$1.RCDATA;
      this._stateRcdata(cp);
    }
  }
  // RCDATA end tag open state
  //------------------------------------------------------------------
  _stateRcdataEndTagOpen(cp) {
    if (isAsciiLetter(cp)) {
      this.state = State$1.RCDATA_END_TAG_NAME;
      this._stateRcdataEndTagName(cp);
    } else {
      this._emitChars("</");
      this.state = State$1.RCDATA;
      this._stateRcdata(cp);
    }
  }
  handleSpecialEndTag(_cp) {
    if (!this.preprocessor.startsWith(this.lastStartTagName, false)) {
      return !this._ensureHibernation();
    }
    this._createEndTagToken();
    const token = this.currentToken;
    token.tagName = this.lastStartTagName;
    const cp = this.preprocessor.peek(this.lastStartTagName.length);
    switch (cp) {
      case CODE_POINTS.SPACE:
      case CODE_POINTS.LINE_FEED:
      case CODE_POINTS.TABULATION:
      case CODE_POINTS.FORM_FEED: {
        this._advanceBy(this.lastStartTagName.length);
        this.state = State$1.BEFORE_ATTRIBUTE_NAME;
        return false;
      }
      case CODE_POINTS.SOLIDUS: {
        this._advanceBy(this.lastStartTagName.length);
        this.state = State$1.SELF_CLOSING_START_TAG;
        return false;
      }
      case CODE_POINTS.GREATER_THAN_SIGN: {
        this._advanceBy(this.lastStartTagName.length);
        this.emitCurrentTagToken();
        this.state = State$1.DATA;
        return false;
      }
      default: {
        return !this._ensureHibernation();
      }
    }
  }
  // RCDATA end tag name state
  //------------------------------------------------------------------
  _stateRcdataEndTagName(cp) {
    if (this.handleSpecialEndTag(cp)) {
      this._emitChars("</");
      this.state = State$1.RCDATA;
      this._stateRcdata(cp);
    }
  }
  // RAWTEXT less-than sign state
  //------------------------------------------------------------------
  _stateRawtextLessThanSign(cp) {
    if (cp === CODE_POINTS.SOLIDUS) {
      this.state = State$1.RAWTEXT_END_TAG_OPEN;
    } else {
      this._emitChars("<");
      this.state = State$1.RAWTEXT;
      this._stateRawtext(cp);
    }
  }
  // RAWTEXT end tag open state
  //------------------------------------------------------------------
  _stateRawtextEndTagOpen(cp) {
    if (isAsciiLetter(cp)) {
      this.state = State$1.RAWTEXT_END_TAG_NAME;
      this._stateRawtextEndTagName(cp);
    } else {
      this._emitChars("</");
      this.state = State$1.RAWTEXT;
      this._stateRawtext(cp);
    }
  }
  // RAWTEXT end tag name state
  //------------------------------------------------------------------
  _stateRawtextEndTagName(cp) {
    if (this.handleSpecialEndTag(cp)) {
      this._emitChars("</");
      this.state = State$1.RAWTEXT;
      this._stateRawtext(cp);
    }
  }
  // Script data less-than sign state
  //------------------------------------------------------------------
  _stateScriptDataLessThanSign(cp) {
    switch (cp) {
      case CODE_POINTS.SOLIDUS: {
        this.state = State$1.SCRIPT_DATA_END_TAG_OPEN;
        break;
      }
      case CODE_POINTS.EXCLAMATION_MARK: {
        this.state = State$1.SCRIPT_DATA_ESCAPE_START;
        this._emitChars("<!");
        break;
      }
      default: {
        this._emitChars("<");
        this.state = State$1.SCRIPT_DATA;
        this._stateScriptData(cp);
      }
    }
  }
  // Script data end tag open state
  //------------------------------------------------------------------
  _stateScriptDataEndTagOpen(cp) {
    if (isAsciiLetter(cp)) {
      this.state = State$1.SCRIPT_DATA_END_TAG_NAME;
      this._stateScriptDataEndTagName(cp);
    } else {
      this._emitChars("</");
      this.state = State$1.SCRIPT_DATA;
      this._stateScriptData(cp);
    }
  }
  // Script data end tag name state
  //------------------------------------------------------------------
  _stateScriptDataEndTagName(cp) {
    if (this.handleSpecialEndTag(cp)) {
      this._emitChars("</");
      this.state = State$1.SCRIPT_DATA;
      this._stateScriptData(cp);
    }
  }
  // Script data escape start state
  //------------------------------------------------------------------
  _stateScriptDataEscapeStart(cp) {
    if (cp === CODE_POINTS.HYPHEN_MINUS) {
      this.state = State$1.SCRIPT_DATA_ESCAPE_START_DASH;
      this._emitChars("-");
    } else {
      this.state = State$1.SCRIPT_DATA;
      this._stateScriptData(cp);
    }
  }
  // Script data escape start dash state
  //------------------------------------------------------------------
  _stateScriptDataEscapeStartDash(cp) {
    if (cp === CODE_POINTS.HYPHEN_MINUS) {
      this.state = State$1.SCRIPT_DATA_ESCAPED_DASH_DASH;
      this._emitChars("-");
    } else {
      this.state = State$1.SCRIPT_DATA;
      this._stateScriptData(cp);
    }
  }
  // Script data escaped state
  //------------------------------------------------------------------
  _stateScriptDataEscaped(cp) {
    switch (cp) {
      case CODE_POINTS.HYPHEN_MINUS: {
        this.state = State$1.SCRIPT_DATA_ESCAPED_DASH;
        this._emitChars("-");
        break;
      }
      case CODE_POINTS.LESS_THAN_SIGN: {
        this.state = State$1.SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN;
        break;
      }
      case CODE_POINTS.NULL: {
        this._err(ERR.unexpectedNullCharacter);
        this._emitChars(REPLACEMENT_CHARACTER);
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInScriptHtmlCommentLikeText);
        this._emitEOFToken();
        break;
      }
      default: {
        this._emitCodePoint(cp);
      }
    }
  }
  // Script data escaped dash state
  //------------------------------------------------------------------
  _stateScriptDataEscapedDash(cp) {
    switch (cp) {
      case CODE_POINTS.HYPHEN_MINUS: {
        this.state = State$1.SCRIPT_DATA_ESCAPED_DASH_DASH;
        this._emitChars("-");
        break;
      }
      case CODE_POINTS.LESS_THAN_SIGN: {
        this.state = State$1.SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN;
        break;
      }
      case CODE_POINTS.NULL: {
        this._err(ERR.unexpectedNullCharacter);
        this.state = State$1.SCRIPT_DATA_ESCAPED;
        this._emitChars(REPLACEMENT_CHARACTER);
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInScriptHtmlCommentLikeText);
        this._emitEOFToken();
        break;
      }
      default: {
        this.state = State$1.SCRIPT_DATA_ESCAPED;
        this._emitCodePoint(cp);
      }
    }
  }
  // Script data escaped dash dash state
  //------------------------------------------------------------------
  _stateScriptDataEscapedDashDash(cp) {
    switch (cp) {
      case CODE_POINTS.HYPHEN_MINUS: {
        this._emitChars("-");
        break;
      }
      case CODE_POINTS.LESS_THAN_SIGN: {
        this.state = State$1.SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN;
        break;
      }
      case CODE_POINTS.GREATER_THAN_SIGN: {
        this.state = State$1.SCRIPT_DATA;
        this._emitChars(">");
        break;
      }
      case CODE_POINTS.NULL: {
        this._err(ERR.unexpectedNullCharacter);
        this.state = State$1.SCRIPT_DATA_ESCAPED;
        this._emitChars(REPLACEMENT_CHARACTER);
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInScriptHtmlCommentLikeText);
        this._emitEOFToken();
        break;
      }
      default: {
        this.state = State$1.SCRIPT_DATA_ESCAPED;
        this._emitCodePoint(cp);
      }
    }
  }
  // Script data escaped less-than sign state
  //------------------------------------------------------------------
  _stateScriptDataEscapedLessThanSign(cp) {
    if (cp === CODE_POINTS.SOLIDUS) {
      this.state = State$1.SCRIPT_DATA_ESCAPED_END_TAG_OPEN;
    } else if (isAsciiLetter(cp)) {
      this._emitChars("<");
      this.state = State$1.SCRIPT_DATA_DOUBLE_ESCAPE_START;
      this._stateScriptDataDoubleEscapeStart(cp);
    } else {
      this._emitChars("<");
      this.state = State$1.SCRIPT_DATA_ESCAPED;
      this._stateScriptDataEscaped(cp);
    }
  }
  // Script data escaped end tag open state
  //------------------------------------------------------------------
  _stateScriptDataEscapedEndTagOpen(cp) {
    if (isAsciiLetter(cp)) {
      this.state = State$1.SCRIPT_DATA_ESCAPED_END_TAG_NAME;
      this._stateScriptDataEscapedEndTagName(cp);
    } else {
      this._emitChars("</");
      this.state = State$1.SCRIPT_DATA_ESCAPED;
      this._stateScriptDataEscaped(cp);
    }
  }
  // Script data escaped end tag name state
  //------------------------------------------------------------------
  _stateScriptDataEscapedEndTagName(cp) {
    if (this.handleSpecialEndTag(cp)) {
      this._emitChars("</");
      this.state = State$1.SCRIPT_DATA_ESCAPED;
      this._stateScriptDataEscaped(cp);
    }
  }
  // Script data double escape start state
  //------------------------------------------------------------------
  _stateScriptDataDoubleEscapeStart(cp) {
    if (
      this.preprocessor.startsWith(SEQUENCES.SCRIPT, false) &&
      isScriptDataDoubleEscapeSequenceEnd(
        this.preprocessor.peek(SEQUENCES.SCRIPT.length),
      )
    ) {
      this._emitCodePoint(cp);
      for (let i = 0; i < SEQUENCES.SCRIPT.length; i++) {
        this._emitCodePoint(this._consume());
      }
      this.state = State$1.SCRIPT_DATA_DOUBLE_ESCAPED;
    } else if (!this._ensureHibernation()) {
      this.state = State$1.SCRIPT_DATA_ESCAPED;
      this._stateScriptDataEscaped(cp);
    }
  }
  // Script data double escaped state
  //------------------------------------------------------------------
  _stateScriptDataDoubleEscaped(cp) {
    switch (cp) {
      case CODE_POINTS.HYPHEN_MINUS: {
        this.state = State$1.SCRIPT_DATA_DOUBLE_ESCAPED_DASH;
        this._emitChars("-");
        break;
      }
      case CODE_POINTS.LESS_THAN_SIGN: {
        this.state = State$1.SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN;
        this._emitChars("<");
        break;
      }
      case CODE_POINTS.NULL: {
        this._err(ERR.unexpectedNullCharacter);
        this._emitChars(REPLACEMENT_CHARACTER);
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInScriptHtmlCommentLikeText);
        this._emitEOFToken();
        break;
      }
      default: {
        this._emitCodePoint(cp);
      }
    }
  }
  // Script data double escaped dash state
  //------------------------------------------------------------------
  _stateScriptDataDoubleEscapedDash(cp) {
    switch (cp) {
      case CODE_POINTS.HYPHEN_MINUS: {
        this.state = State$1.SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH;
        this._emitChars("-");
        break;
      }
      case CODE_POINTS.LESS_THAN_SIGN: {
        this.state = State$1.SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN;
        this._emitChars("<");
        break;
      }
      case CODE_POINTS.NULL: {
        this._err(ERR.unexpectedNullCharacter);
        this.state = State$1.SCRIPT_DATA_DOUBLE_ESCAPED;
        this._emitChars(REPLACEMENT_CHARACTER);
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInScriptHtmlCommentLikeText);
        this._emitEOFToken();
        break;
      }
      default: {
        this.state = State$1.SCRIPT_DATA_DOUBLE_ESCAPED;
        this._emitCodePoint(cp);
      }
    }
  }
  // Script data double escaped dash dash state
  //------------------------------------------------------------------
  _stateScriptDataDoubleEscapedDashDash(cp) {
    switch (cp) {
      case CODE_POINTS.HYPHEN_MINUS: {
        this._emitChars("-");
        break;
      }
      case CODE_POINTS.LESS_THAN_SIGN: {
        this.state = State$1.SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN;
        this._emitChars("<");
        break;
      }
      case CODE_POINTS.GREATER_THAN_SIGN: {
        this.state = State$1.SCRIPT_DATA;
        this._emitChars(">");
        break;
      }
      case CODE_POINTS.NULL: {
        this._err(ERR.unexpectedNullCharacter);
        this.state = State$1.SCRIPT_DATA_DOUBLE_ESCAPED;
        this._emitChars(REPLACEMENT_CHARACTER);
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInScriptHtmlCommentLikeText);
        this._emitEOFToken();
        break;
      }
      default: {
        this.state = State$1.SCRIPT_DATA_DOUBLE_ESCAPED;
        this._emitCodePoint(cp);
      }
    }
  }
  // Script data double escaped less-than sign state
  //------------------------------------------------------------------
  _stateScriptDataDoubleEscapedLessThanSign(cp) {
    if (cp === CODE_POINTS.SOLIDUS) {
      this.state = State$1.SCRIPT_DATA_DOUBLE_ESCAPE_END;
      this._emitChars("/");
    } else {
      this.state = State$1.SCRIPT_DATA_DOUBLE_ESCAPED;
      this._stateScriptDataDoubleEscaped(cp);
    }
  }
  // Script data double escape end state
  //------------------------------------------------------------------
  _stateScriptDataDoubleEscapeEnd(cp) {
    if (
      this.preprocessor.startsWith(SEQUENCES.SCRIPT, false) &&
      isScriptDataDoubleEscapeSequenceEnd(
        this.preprocessor.peek(SEQUENCES.SCRIPT.length),
      )
    ) {
      this._emitCodePoint(cp);
      for (let i = 0; i < SEQUENCES.SCRIPT.length; i++) {
        this._emitCodePoint(this._consume());
      }
      this.state = State$1.SCRIPT_DATA_ESCAPED;
    } else if (!this._ensureHibernation()) {
      this.state = State$1.SCRIPT_DATA_DOUBLE_ESCAPED;
      this._stateScriptDataDoubleEscaped(cp);
    }
  }
  // Before attribute name state
  //------------------------------------------------------------------
  _stateBeforeAttributeName(cp) {
    switch (cp) {
      case CODE_POINTS.SPACE:
      case CODE_POINTS.LINE_FEED:
      case CODE_POINTS.TABULATION:
      case CODE_POINTS.FORM_FEED: {
        // Ignore whitespace
        break;
      }
      case CODE_POINTS.SOLIDUS:
      case CODE_POINTS.GREATER_THAN_SIGN:
      case CODE_POINTS.EOF: {
        this.state = State$1.AFTER_ATTRIBUTE_NAME;
        this._stateAfterAttributeName(cp);
        break;
      }
      case CODE_POINTS.EQUALS_SIGN: {
        this._err(ERR.unexpectedEqualsSignBeforeAttributeName);
        this._createAttr("=");
        this.state = State$1.ATTRIBUTE_NAME;
        break;
      }
      default: {
        this._createAttr("");
        this.state = State$1.ATTRIBUTE_NAME;
        this._stateAttributeName(cp);
      }
    }
  }
  // Attribute name state
  //------------------------------------------------------------------
  _stateAttributeName(cp) {
    switch (cp) {
      case CODE_POINTS.SPACE:
      case CODE_POINTS.LINE_FEED:
      case CODE_POINTS.TABULATION:
      case CODE_POINTS.FORM_FEED:
      case CODE_POINTS.SOLIDUS:
      case CODE_POINTS.GREATER_THAN_SIGN:
      case CODE_POINTS.EOF: {
        this._leaveAttrName();
        this.state = State$1.AFTER_ATTRIBUTE_NAME;
        this._stateAfterAttributeName(cp);
        break;
      }
      case CODE_POINTS.EQUALS_SIGN: {
        this._leaveAttrName();
        this.state = State$1.BEFORE_ATTRIBUTE_VALUE;
        break;
      }
      case CODE_POINTS.QUOTATION_MARK:
      case CODE_POINTS.APOSTROPHE:
      case CODE_POINTS.LESS_THAN_SIGN: {
        this._err(ERR.unexpectedCharacterInAttributeName);
        this.currentAttr.name += String.fromCodePoint(cp);
        break;
      }
      case CODE_POINTS.NULL: {
        this._err(ERR.unexpectedNullCharacter);
        this.currentAttr.name += REPLACEMENT_CHARACTER;
        break;
      }
      default: {
        this.currentAttr.name += String.fromCodePoint(
          isAsciiUpper(cp) ? toAsciiLower(cp) : cp,
        );
      }
    }
  }
  // After attribute name state
  //------------------------------------------------------------------
  _stateAfterAttributeName(cp) {
    switch (cp) {
      case CODE_POINTS.SPACE:
      case CODE_POINTS.LINE_FEED:
      case CODE_POINTS.TABULATION:
      case CODE_POINTS.FORM_FEED: {
        // Ignore whitespace
        break;
      }
      case CODE_POINTS.SOLIDUS: {
        this.state = State$1.SELF_CLOSING_START_TAG;
        break;
      }
      case CODE_POINTS.EQUALS_SIGN: {
        this.state = State$1.BEFORE_ATTRIBUTE_VALUE;
        break;
      }
      case CODE_POINTS.GREATER_THAN_SIGN: {
        this.state = State$1.DATA;
        this.emitCurrentTagToken();
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInTag);
        this._emitEOFToken();
        break;
      }
      default: {
        this._createAttr("");
        this.state = State$1.ATTRIBUTE_NAME;
        this._stateAttributeName(cp);
      }
    }
  }
  // Before attribute value state
  //------------------------------------------------------------------
  _stateBeforeAttributeValue(cp) {
    switch (cp) {
      case CODE_POINTS.SPACE:
      case CODE_POINTS.LINE_FEED:
      case CODE_POINTS.TABULATION:
      case CODE_POINTS.FORM_FEED: {
        // Ignore whitespace
        break;
      }
      case CODE_POINTS.QUOTATION_MARK: {
        this.state = State$1.ATTRIBUTE_VALUE_DOUBLE_QUOTED;
        break;
      }
      case CODE_POINTS.APOSTROPHE: {
        this.state = State$1.ATTRIBUTE_VALUE_SINGLE_QUOTED;
        break;
      }
      case CODE_POINTS.GREATER_THAN_SIGN: {
        this._err(ERR.missingAttributeValue);
        this.state = State$1.DATA;
        this.emitCurrentTagToken();
        break;
      }
      default: {
        this.state = State$1.ATTRIBUTE_VALUE_UNQUOTED;
        this._stateAttributeValueUnquoted(cp);
      }
    }
  }
  // Attribute value (double-quoted) state
  //------------------------------------------------------------------
  _stateAttributeValueDoubleQuoted(cp) {
    switch (cp) {
      case CODE_POINTS.QUOTATION_MARK: {
        this.state = State$1.AFTER_ATTRIBUTE_VALUE_QUOTED;
        break;
      }
      case CODE_POINTS.AMPERSAND: {
        this.returnState = State$1.ATTRIBUTE_VALUE_DOUBLE_QUOTED;
        this.state = State$1.CHARACTER_REFERENCE;
        break;
      }
      case CODE_POINTS.NULL: {
        this._err(ERR.unexpectedNullCharacter);
        this.currentAttr.value += REPLACEMENT_CHARACTER;
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInTag);
        this._emitEOFToken();
        break;
      }
      default: {
        this.currentAttr.value += String.fromCodePoint(cp);
      }
    }
  }
  // Attribute value (single-quoted) state
  //------------------------------------------------------------------
  _stateAttributeValueSingleQuoted(cp) {
    switch (cp) {
      case CODE_POINTS.APOSTROPHE: {
        this.state = State$1.AFTER_ATTRIBUTE_VALUE_QUOTED;
        break;
      }
      case CODE_POINTS.AMPERSAND: {
        this.returnState = State$1.ATTRIBUTE_VALUE_SINGLE_QUOTED;
        this.state = State$1.CHARACTER_REFERENCE;
        break;
      }
      case CODE_POINTS.NULL: {
        this._err(ERR.unexpectedNullCharacter);
        this.currentAttr.value += REPLACEMENT_CHARACTER;
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInTag);
        this._emitEOFToken();
        break;
      }
      default: {
        this.currentAttr.value += String.fromCodePoint(cp);
      }
    }
  }
  // Attribute value (unquoted) state
  //------------------------------------------------------------------
  _stateAttributeValueUnquoted(cp) {
    switch (cp) {
      case CODE_POINTS.SPACE:
      case CODE_POINTS.LINE_FEED:
      case CODE_POINTS.TABULATION:
      case CODE_POINTS.FORM_FEED: {
        this._leaveAttrValue();
        this.state = State$1.BEFORE_ATTRIBUTE_NAME;
        break;
      }
      case CODE_POINTS.AMPERSAND: {
        this.returnState = State$1.ATTRIBUTE_VALUE_UNQUOTED;
        this.state = State$1.CHARACTER_REFERENCE;
        break;
      }
      case CODE_POINTS.GREATER_THAN_SIGN: {
        this._leaveAttrValue();
        this.state = State$1.DATA;
        this.emitCurrentTagToken();
        break;
      }
      case CODE_POINTS.NULL: {
        this._err(ERR.unexpectedNullCharacter);
        this.currentAttr.value += REPLACEMENT_CHARACTER;
        break;
      }
      case CODE_POINTS.QUOTATION_MARK:
      case CODE_POINTS.APOSTROPHE:
      case CODE_POINTS.LESS_THAN_SIGN:
      case CODE_POINTS.EQUALS_SIGN:
      case CODE_POINTS.GRAVE_ACCENT: {
        this._err(ERR.unexpectedCharacterInUnquotedAttributeValue);
        this.currentAttr.value += String.fromCodePoint(cp);
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInTag);
        this._emitEOFToken();
        break;
      }
      default: {
        this.currentAttr.value += String.fromCodePoint(cp);
      }
    }
  }
  // After attribute value (quoted) state
  //------------------------------------------------------------------
  _stateAfterAttributeValueQuoted(cp) {
    switch (cp) {
      case CODE_POINTS.SPACE:
      case CODE_POINTS.LINE_FEED:
      case CODE_POINTS.TABULATION:
      case CODE_POINTS.FORM_FEED: {
        this._leaveAttrValue();
        this.state = State$1.BEFORE_ATTRIBUTE_NAME;
        break;
      }
      case CODE_POINTS.SOLIDUS: {
        this._leaveAttrValue();
        this.state = State$1.SELF_CLOSING_START_TAG;
        break;
      }
      case CODE_POINTS.GREATER_THAN_SIGN: {
        this._leaveAttrValue();
        this.state = State$1.DATA;
        this.emitCurrentTagToken();
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInTag);
        this._emitEOFToken();
        break;
      }
      default: {
        this._err(ERR.missingWhitespaceBetweenAttributes);
        this.state = State$1.BEFORE_ATTRIBUTE_NAME;
        this._stateBeforeAttributeName(cp);
      }
    }
  }
  // Self-closing start tag state
  //------------------------------------------------------------------
  _stateSelfClosingStartTag(cp) {
    switch (cp) {
      case CODE_POINTS.GREATER_THAN_SIGN: {
        const token = this.currentToken;
        token.selfClosing = true;
        this.state = State$1.DATA;
        this.emitCurrentTagToken();
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInTag);
        this._emitEOFToken();
        break;
      }
      default: {
        this._err(ERR.unexpectedSolidusInTag);
        this.state = State$1.BEFORE_ATTRIBUTE_NAME;
        this._stateBeforeAttributeName(cp);
      }
    }
  }
  // Bogus comment state
  //------------------------------------------------------------------
  _stateBogusComment(cp) {
    const token = this.currentToken;
    switch (cp) {
      case CODE_POINTS.GREATER_THAN_SIGN: {
        this.state = State$1.DATA;
        this.emitCurrentComment(token);
        break;
      }
      case CODE_POINTS.EOF: {
        this.emitCurrentComment(token);
        this._emitEOFToken();
        break;
      }
      case CODE_POINTS.NULL: {
        this._err(ERR.unexpectedNullCharacter);
        token.data += REPLACEMENT_CHARACTER;
        break;
      }
      default: {
        token.data += String.fromCodePoint(cp);
      }
    }
  }
  // Markup declaration open state
  //------------------------------------------------------------------
  _stateMarkupDeclarationOpen(cp) {
    if (this._consumeSequenceIfMatch(SEQUENCES.DASH_DASH, true)) {
      this._createCommentToken(SEQUENCES.DASH_DASH.length + 1);
      this.state = State$1.COMMENT_START;
    } else if (this._consumeSequenceIfMatch(SEQUENCES.DOCTYPE, false)) {
      // NOTE: Doctypes tokens are created without fixed offsets. We keep track of the moment a doctype *might* start here.
      this.currentLocation = this.getCurrentLocation(
        SEQUENCES.DOCTYPE.length + 1,
      );
      this.state = State$1.DOCTYPE;
    } else if (this._consumeSequenceIfMatch(SEQUENCES.CDATA_START, true)) {
      if (this.inForeignNode) {
        this.state = State$1.CDATA_SECTION;
      } else {
        this._err(ERR.cdataInHtmlContent);
        this._createCommentToken(SEQUENCES.CDATA_START.length + 1);
        this.currentToken.data = "[CDATA[";
        this.state = State$1.BOGUS_COMMENT;
      }
    }
    //NOTE: Sequence lookups can be abrupted by hibernation. In that case, lookup
    //results are no longer valid and we will need to start over.
    else if (!this._ensureHibernation()) {
      this._err(ERR.incorrectlyOpenedComment);
      this._createCommentToken(2);
      this.state = State$1.BOGUS_COMMENT;
      this._stateBogusComment(cp);
    }
  }
  // Comment start state
  //------------------------------------------------------------------
  _stateCommentStart(cp) {
    switch (cp) {
      case CODE_POINTS.HYPHEN_MINUS: {
        this.state = State$1.COMMENT_START_DASH;
        break;
      }
      case CODE_POINTS.GREATER_THAN_SIGN: {
        this._err(ERR.abruptClosingOfEmptyComment);
        this.state = State$1.DATA;
        const token = this.currentToken;
        this.emitCurrentComment(token);
        break;
      }
      default: {
        this.state = State$1.COMMENT;
        this._stateComment(cp);
      }
    }
  }
  // Comment start dash state
  //------------------------------------------------------------------
  _stateCommentStartDash(cp) {
    const token = this.currentToken;
    switch (cp) {
      case CODE_POINTS.HYPHEN_MINUS: {
        this.state = State$1.COMMENT_END;
        break;
      }
      case CODE_POINTS.GREATER_THAN_SIGN: {
        this._err(ERR.abruptClosingOfEmptyComment);
        this.state = State$1.DATA;
        this.emitCurrentComment(token);
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInComment);
        this.emitCurrentComment(token);
        this._emitEOFToken();
        break;
      }
      default: {
        token.data += "-";
        this.state = State$1.COMMENT;
        this._stateComment(cp);
      }
    }
  }
  // Comment state
  //------------------------------------------------------------------
  _stateComment(cp) {
    const token = this.currentToken;
    switch (cp) {
      case CODE_POINTS.HYPHEN_MINUS: {
        this.state = State$1.COMMENT_END_DASH;
        break;
      }
      case CODE_POINTS.LESS_THAN_SIGN: {
        token.data += "<";
        this.state = State$1.COMMENT_LESS_THAN_SIGN;
        break;
      }
      case CODE_POINTS.NULL: {
        this._err(ERR.unexpectedNullCharacter);
        token.data += REPLACEMENT_CHARACTER;
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInComment);
        this.emitCurrentComment(token);
        this._emitEOFToken();
        break;
      }
      default: {
        token.data += String.fromCodePoint(cp);
      }
    }
  }
  // Comment less-than sign state
  //------------------------------------------------------------------
  _stateCommentLessThanSign(cp) {
    const token = this.currentToken;
    switch (cp) {
      case CODE_POINTS.EXCLAMATION_MARK: {
        token.data += "!";
        this.state = State$1.COMMENT_LESS_THAN_SIGN_BANG;
        break;
      }
      case CODE_POINTS.LESS_THAN_SIGN: {
        token.data += "<";
        break;
      }
      default: {
        this.state = State$1.COMMENT;
        this._stateComment(cp);
      }
    }
  }
  // Comment less-than sign bang state
  //------------------------------------------------------------------
  _stateCommentLessThanSignBang(cp) {
    if (cp === CODE_POINTS.HYPHEN_MINUS) {
      this.state = State$1.COMMENT_LESS_THAN_SIGN_BANG_DASH;
    } else {
      this.state = State$1.COMMENT;
      this._stateComment(cp);
    }
  }
  // Comment less-than sign bang dash state
  //------------------------------------------------------------------
  _stateCommentLessThanSignBangDash(cp) {
    if (cp === CODE_POINTS.HYPHEN_MINUS) {
      this.state = State$1.COMMENT_LESS_THAN_SIGN_BANG_DASH_DASH;
    } else {
      this.state = State$1.COMMENT_END_DASH;
      this._stateCommentEndDash(cp);
    }
  }
  // Comment less-than sign bang dash dash state
  //------------------------------------------------------------------
  _stateCommentLessThanSignBangDashDash(cp) {
    if (cp !== CODE_POINTS.GREATER_THAN_SIGN && cp !== CODE_POINTS.EOF) {
      this._err(ERR.nestedComment);
    }
    this.state = State$1.COMMENT_END;
    this._stateCommentEnd(cp);
  }
  // Comment end dash state
  //------------------------------------------------------------------
  _stateCommentEndDash(cp) {
    const token = this.currentToken;
    switch (cp) {
      case CODE_POINTS.HYPHEN_MINUS: {
        this.state = State$1.COMMENT_END;
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInComment);
        this.emitCurrentComment(token);
        this._emitEOFToken();
        break;
      }
      default: {
        token.data += "-";
        this.state = State$1.COMMENT;
        this._stateComment(cp);
      }
    }
  }
  // Comment end state
  //------------------------------------------------------------------
  _stateCommentEnd(cp) {
    const token = this.currentToken;
    switch (cp) {
      case CODE_POINTS.GREATER_THAN_SIGN: {
        this.state = State$1.DATA;
        this.emitCurrentComment(token);
        break;
      }
      case CODE_POINTS.EXCLAMATION_MARK: {
        this.state = State$1.COMMENT_END_BANG;
        break;
      }
      case CODE_POINTS.HYPHEN_MINUS: {
        token.data += "-";
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInComment);
        this.emitCurrentComment(token);
        this._emitEOFToken();
        break;
      }
      default: {
        token.data += "--";
        this.state = State$1.COMMENT;
        this._stateComment(cp);
      }
    }
  }
  // Comment end bang state
  //------------------------------------------------------------------
  _stateCommentEndBang(cp) {
    const token = this.currentToken;
    switch (cp) {
      case CODE_POINTS.HYPHEN_MINUS: {
        token.data += "--!";
        this.state = State$1.COMMENT_END_DASH;
        break;
      }
      case CODE_POINTS.GREATER_THAN_SIGN: {
        this._err(ERR.incorrectlyClosedComment);
        this.state = State$1.DATA;
        this.emitCurrentComment(token);
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInComment);
        this.emitCurrentComment(token);
        this._emitEOFToken();
        break;
      }
      default: {
        token.data += "--!";
        this.state = State$1.COMMENT;
        this._stateComment(cp);
      }
    }
  }
  // DOCTYPE state
  //------------------------------------------------------------------
  _stateDoctype(cp) {
    switch (cp) {
      case CODE_POINTS.SPACE:
      case CODE_POINTS.LINE_FEED:
      case CODE_POINTS.TABULATION:
      case CODE_POINTS.FORM_FEED: {
        this.state = State$1.BEFORE_DOCTYPE_NAME;
        break;
      }
      case CODE_POINTS.GREATER_THAN_SIGN: {
        this.state = State$1.BEFORE_DOCTYPE_NAME;
        this._stateBeforeDoctypeName(cp);
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInDoctype);
        this._createDoctypeToken(null);
        const token = this.currentToken;
        token.forceQuirks = true;
        this.emitCurrentDoctype(token);
        this._emitEOFToken();
        break;
      }
      default: {
        this._err(ERR.missingWhitespaceBeforeDoctypeName);
        this.state = State$1.BEFORE_DOCTYPE_NAME;
        this._stateBeforeDoctypeName(cp);
      }
    }
  }
  // Before DOCTYPE name state
  //------------------------------------------------------------------
  _stateBeforeDoctypeName(cp) {
    if (isAsciiUpper(cp)) {
      this._createDoctypeToken(String.fromCharCode(toAsciiLower(cp)));
      this.state = State$1.DOCTYPE_NAME;
    } else
      switch (cp) {
        case CODE_POINTS.SPACE:
        case CODE_POINTS.LINE_FEED:
        case CODE_POINTS.TABULATION:
        case CODE_POINTS.FORM_FEED: {
          // Ignore whitespace
          break;
        }
        case CODE_POINTS.NULL: {
          this._err(ERR.unexpectedNullCharacter);
          this._createDoctypeToken(REPLACEMENT_CHARACTER);
          this.state = State$1.DOCTYPE_NAME;
          break;
        }
        case CODE_POINTS.GREATER_THAN_SIGN: {
          this._err(ERR.missingDoctypeName);
          this._createDoctypeToken(null);
          const token = this.currentToken;
          token.forceQuirks = true;
          this.emitCurrentDoctype(token);
          this.state = State$1.DATA;
          break;
        }
        case CODE_POINTS.EOF: {
          this._err(ERR.eofInDoctype);
          this._createDoctypeToken(null);
          const token = this.currentToken;
          token.forceQuirks = true;
          this.emitCurrentDoctype(token);
          this._emitEOFToken();
          break;
        }
        default: {
          this._createDoctypeToken(String.fromCodePoint(cp));
          this.state = State$1.DOCTYPE_NAME;
        }
      }
  }
  // DOCTYPE name state
  //------------------------------------------------------------------
  _stateDoctypeName(cp) {
    const token = this.currentToken;
    switch (cp) {
      case CODE_POINTS.SPACE:
      case CODE_POINTS.LINE_FEED:
      case CODE_POINTS.TABULATION:
      case CODE_POINTS.FORM_FEED: {
        this.state = State$1.AFTER_DOCTYPE_NAME;
        break;
      }
      case CODE_POINTS.GREATER_THAN_SIGN: {
        this.state = State$1.DATA;
        this.emitCurrentDoctype(token);
        break;
      }
      case CODE_POINTS.NULL: {
        this._err(ERR.unexpectedNullCharacter);
        token.name += REPLACEMENT_CHARACTER;
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInDoctype);
        token.forceQuirks = true;
        this.emitCurrentDoctype(token);
        this._emitEOFToken();
        break;
      }
      default: {
        token.name += String.fromCodePoint(
          isAsciiUpper(cp) ? toAsciiLower(cp) : cp,
        );
      }
    }
  }
  // After DOCTYPE name state
  //------------------------------------------------------------------
  _stateAfterDoctypeName(cp) {
    const token = this.currentToken;
    switch (cp) {
      case CODE_POINTS.SPACE:
      case CODE_POINTS.LINE_FEED:
      case CODE_POINTS.TABULATION:
      case CODE_POINTS.FORM_FEED: {
        // Ignore whitespace
        break;
      }
      case CODE_POINTS.GREATER_THAN_SIGN: {
        this.state = State$1.DATA;
        this.emitCurrentDoctype(token);
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInDoctype);
        token.forceQuirks = true;
        this.emitCurrentDoctype(token);
        this._emitEOFToken();
        break;
      }
      default: {
        if (this._consumeSequenceIfMatch(SEQUENCES.PUBLIC, false)) {
          this.state = State$1.AFTER_DOCTYPE_PUBLIC_KEYWORD;
        } else if (this._consumeSequenceIfMatch(SEQUENCES.SYSTEM, false)) {
          this.state = State$1.AFTER_DOCTYPE_SYSTEM_KEYWORD;
        }
        //NOTE: sequence lookup can be abrupted by hibernation. In that case lookup
        //results are no longer valid and we will need to start over.
        else if (!this._ensureHibernation()) {
          this._err(ERR.invalidCharacterSequenceAfterDoctypeName);
          token.forceQuirks = true;
          this.state = State$1.BOGUS_DOCTYPE;
          this._stateBogusDoctype(cp);
        }
      }
    }
  }
  // After DOCTYPE public keyword state
  //------------------------------------------------------------------
  _stateAfterDoctypePublicKeyword(cp) {
    const token = this.currentToken;
    switch (cp) {
      case CODE_POINTS.SPACE:
      case CODE_POINTS.LINE_FEED:
      case CODE_POINTS.TABULATION:
      case CODE_POINTS.FORM_FEED: {
        this.state = State$1.BEFORE_DOCTYPE_PUBLIC_IDENTIFIER;
        break;
      }
      case CODE_POINTS.QUOTATION_MARK: {
        this._err(ERR.missingWhitespaceAfterDoctypePublicKeyword);
        token.publicId = "";
        this.state = State$1.DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED;
        break;
      }
      case CODE_POINTS.APOSTROPHE: {
        this._err(ERR.missingWhitespaceAfterDoctypePublicKeyword);
        token.publicId = "";
        this.state = State$1.DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED;
        break;
      }
      case CODE_POINTS.GREATER_THAN_SIGN: {
        this._err(ERR.missingDoctypePublicIdentifier);
        token.forceQuirks = true;
        this.state = State$1.DATA;
        this.emitCurrentDoctype(token);
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInDoctype);
        token.forceQuirks = true;
        this.emitCurrentDoctype(token);
        this._emitEOFToken();
        break;
      }
      default: {
        this._err(ERR.missingQuoteBeforeDoctypePublicIdentifier);
        token.forceQuirks = true;
        this.state = State$1.BOGUS_DOCTYPE;
        this._stateBogusDoctype(cp);
      }
    }
  }
  // Before DOCTYPE public identifier state
  //------------------------------------------------------------------
  _stateBeforeDoctypePublicIdentifier(cp) {
    const token = this.currentToken;
    switch (cp) {
      case CODE_POINTS.SPACE:
      case CODE_POINTS.LINE_FEED:
      case CODE_POINTS.TABULATION:
      case CODE_POINTS.FORM_FEED: {
        // Ignore whitespace
        break;
      }
      case CODE_POINTS.QUOTATION_MARK: {
        token.publicId = "";
        this.state = State$1.DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED;
        break;
      }
      case CODE_POINTS.APOSTROPHE: {
        token.publicId = "";
        this.state = State$1.DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED;
        break;
      }
      case CODE_POINTS.GREATER_THAN_SIGN: {
        this._err(ERR.missingDoctypePublicIdentifier);
        token.forceQuirks = true;
        this.state = State$1.DATA;
        this.emitCurrentDoctype(token);
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInDoctype);
        token.forceQuirks = true;
        this.emitCurrentDoctype(token);
        this._emitEOFToken();
        break;
      }
      default: {
        this._err(ERR.missingQuoteBeforeDoctypePublicIdentifier);
        token.forceQuirks = true;
        this.state = State$1.BOGUS_DOCTYPE;
        this._stateBogusDoctype(cp);
      }
    }
  }
  // DOCTYPE public identifier (double-quoted) state
  //------------------------------------------------------------------
  _stateDoctypePublicIdentifierDoubleQuoted(cp) {
    const token = this.currentToken;
    switch (cp) {
      case CODE_POINTS.QUOTATION_MARK: {
        this.state = State$1.AFTER_DOCTYPE_PUBLIC_IDENTIFIER;
        break;
      }
      case CODE_POINTS.NULL: {
        this._err(ERR.unexpectedNullCharacter);
        token.publicId += REPLACEMENT_CHARACTER;
        break;
      }
      case CODE_POINTS.GREATER_THAN_SIGN: {
        this._err(ERR.abruptDoctypePublicIdentifier);
        token.forceQuirks = true;
        this.emitCurrentDoctype(token);
        this.state = State$1.DATA;
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInDoctype);
        token.forceQuirks = true;
        this.emitCurrentDoctype(token);
        this._emitEOFToken();
        break;
      }
      default: {
        token.publicId += String.fromCodePoint(cp);
      }
    }
  }
  // DOCTYPE public identifier (single-quoted) state
  //------------------------------------------------------------------
  _stateDoctypePublicIdentifierSingleQuoted(cp) {
    const token = this.currentToken;
    switch (cp) {
      case CODE_POINTS.APOSTROPHE: {
        this.state = State$1.AFTER_DOCTYPE_PUBLIC_IDENTIFIER;
        break;
      }
      case CODE_POINTS.NULL: {
        this._err(ERR.unexpectedNullCharacter);
        token.publicId += REPLACEMENT_CHARACTER;
        break;
      }
      case CODE_POINTS.GREATER_THAN_SIGN: {
        this._err(ERR.abruptDoctypePublicIdentifier);
        token.forceQuirks = true;
        this.emitCurrentDoctype(token);
        this.state = State$1.DATA;
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInDoctype);
        token.forceQuirks = true;
        this.emitCurrentDoctype(token);
        this._emitEOFToken();
        break;
      }
      default: {
        token.publicId += String.fromCodePoint(cp);
      }
    }
  }
  // After DOCTYPE public identifier state
  //------------------------------------------------------------------
  _stateAfterDoctypePublicIdentifier(cp) {
    const token = this.currentToken;
    switch (cp) {
      case CODE_POINTS.SPACE:
      case CODE_POINTS.LINE_FEED:
      case CODE_POINTS.TABULATION:
      case CODE_POINTS.FORM_FEED: {
        this.state = State$1.BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS;
        break;
      }
      case CODE_POINTS.GREATER_THAN_SIGN: {
        this.state = State$1.DATA;
        this.emitCurrentDoctype(token);
        break;
      }
      case CODE_POINTS.QUOTATION_MARK: {
        this._err(
          ERR.missingWhitespaceBetweenDoctypePublicAndSystemIdentifiers,
        );
        token.systemId = "";
        this.state = State$1.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED;
        break;
      }
      case CODE_POINTS.APOSTROPHE: {
        this._err(
          ERR.missingWhitespaceBetweenDoctypePublicAndSystemIdentifiers,
        );
        token.systemId = "";
        this.state = State$1.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED;
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInDoctype);
        token.forceQuirks = true;
        this.emitCurrentDoctype(token);
        this._emitEOFToken();
        break;
      }
      default: {
        this._err(ERR.missingQuoteBeforeDoctypeSystemIdentifier);
        token.forceQuirks = true;
        this.state = State$1.BOGUS_DOCTYPE;
        this._stateBogusDoctype(cp);
      }
    }
  }
  // Between DOCTYPE public and system identifiers state
  //------------------------------------------------------------------
  _stateBetweenDoctypePublicAndSystemIdentifiers(cp) {
    const token = this.currentToken;
    switch (cp) {
      case CODE_POINTS.SPACE:
      case CODE_POINTS.LINE_FEED:
      case CODE_POINTS.TABULATION:
      case CODE_POINTS.FORM_FEED: {
        // Ignore whitespace
        break;
      }
      case CODE_POINTS.GREATER_THAN_SIGN: {
        this.emitCurrentDoctype(token);
        this.state = State$1.DATA;
        break;
      }
      case CODE_POINTS.QUOTATION_MARK: {
        token.systemId = "";
        this.state = State$1.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED;
        break;
      }
      case CODE_POINTS.APOSTROPHE: {
        token.systemId = "";
        this.state = State$1.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED;
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInDoctype);
        token.forceQuirks = true;
        this.emitCurrentDoctype(token);
        this._emitEOFToken();
        break;
      }
      default: {
        this._err(ERR.missingQuoteBeforeDoctypeSystemIdentifier);
        token.forceQuirks = true;
        this.state = State$1.BOGUS_DOCTYPE;
        this._stateBogusDoctype(cp);
      }
    }
  }
  // After DOCTYPE system keyword state
  //------------------------------------------------------------------
  _stateAfterDoctypeSystemKeyword(cp) {
    const token = this.currentToken;
    switch (cp) {
      case CODE_POINTS.SPACE:
      case CODE_POINTS.LINE_FEED:
      case CODE_POINTS.TABULATION:
      case CODE_POINTS.FORM_FEED: {
        this.state = State$1.BEFORE_DOCTYPE_SYSTEM_IDENTIFIER;
        break;
      }
      case CODE_POINTS.QUOTATION_MARK: {
        this._err(ERR.missingWhitespaceAfterDoctypeSystemKeyword);
        token.systemId = "";
        this.state = State$1.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED;
        break;
      }
      case CODE_POINTS.APOSTROPHE: {
        this._err(ERR.missingWhitespaceAfterDoctypeSystemKeyword);
        token.systemId = "";
        this.state = State$1.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED;
        break;
      }
      case CODE_POINTS.GREATER_THAN_SIGN: {
        this._err(ERR.missingDoctypeSystemIdentifier);
        token.forceQuirks = true;
        this.state = State$1.DATA;
        this.emitCurrentDoctype(token);
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInDoctype);
        token.forceQuirks = true;
        this.emitCurrentDoctype(token);
        this._emitEOFToken();
        break;
      }
      default: {
        this._err(ERR.missingQuoteBeforeDoctypeSystemIdentifier);
        token.forceQuirks = true;
        this.state = State$1.BOGUS_DOCTYPE;
        this._stateBogusDoctype(cp);
      }
    }
  }
  // Before DOCTYPE system identifier state
  //------------------------------------------------------------------
  _stateBeforeDoctypeSystemIdentifier(cp) {
    const token = this.currentToken;
    switch (cp) {
      case CODE_POINTS.SPACE:
      case CODE_POINTS.LINE_FEED:
      case CODE_POINTS.TABULATION:
      case CODE_POINTS.FORM_FEED: {
        // Ignore whitespace
        break;
      }
      case CODE_POINTS.QUOTATION_MARK: {
        token.systemId = "";
        this.state = State$1.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED;
        break;
      }
      case CODE_POINTS.APOSTROPHE: {
        token.systemId = "";
        this.state = State$1.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED;
        break;
      }
      case CODE_POINTS.GREATER_THAN_SIGN: {
        this._err(ERR.missingDoctypeSystemIdentifier);
        token.forceQuirks = true;
        this.state = State$1.DATA;
        this.emitCurrentDoctype(token);
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInDoctype);
        token.forceQuirks = true;
        this.emitCurrentDoctype(token);
        this._emitEOFToken();
        break;
      }
      default: {
        this._err(ERR.missingQuoteBeforeDoctypeSystemIdentifier);
        token.forceQuirks = true;
        this.state = State$1.BOGUS_DOCTYPE;
        this._stateBogusDoctype(cp);
      }
    }
  }
  // DOCTYPE system identifier (double-quoted) state
  //------------------------------------------------------------------
  _stateDoctypeSystemIdentifierDoubleQuoted(cp) {
    const token = this.currentToken;
    switch (cp) {
      case CODE_POINTS.QUOTATION_MARK: {
        this.state = State$1.AFTER_DOCTYPE_SYSTEM_IDENTIFIER;
        break;
      }
      case CODE_POINTS.NULL: {
        this._err(ERR.unexpectedNullCharacter);
        token.systemId += REPLACEMENT_CHARACTER;
        break;
      }
      case CODE_POINTS.GREATER_THAN_SIGN: {
        this._err(ERR.abruptDoctypeSystemIdentifier);
        token.forceQuirks = true;
        this.emitCurrentDoctype(token);
        this.state = State$1.DATA;
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInDoctype);
        token.forceQuirks = true;
        this.emitCurrentDoctype(token);
        this._emitEOFToken();
        break;
      }
      default: {
        token.systemId += String.fromCodePoint(cp);
      }
    }
  }
  // DOCTYPE system identifier (single-quoted) state
  //------------------------------------------------------------------
  _stateDoctypeSystemIdentifierSingleQuoted(cp) {
    const token = this.currentToken;
    switch (cp) {
      case CODE_POINTS.APOSTROPHE: {
        this.state = State$1.AFTER_DOCTYPE_SYSTEM_IDENTIFIER;
        break;
      }
      case CODE_POINTS.NULL: {
        this._err(ERR.unexpectedNullCharacter);
        token.systemId += REPLACEMENT_CHARACTER;
        break;
      }
      case CODE_POINTS.GREATER_THAN_SIGN: {
        this._err(ERR.abruptDoctypeSystemIdentifier);
        token.forceQuirks = true;
        this.emitCurrentDoctype(token);
        this.state = State$1.DATA;
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInDoctype);
        token.forceQuirks = true;
        this.emitCurrentDoctype(token);
        this._emitEOFToken();
        break;
      }
      default: {
        token.systemId += String.fromCodePoint(cp);
      }
    }
  }
  // After DOCTYPE system identifier state
  //------------------------------------------------------------------
  _stateAfterDoctypeSystemIdentifier(cp) {
    const token = this.currentToken;
    switch (cp) {
      case CODE_POINTS.SPACE:
      case CODE_POINTS.LINE_FEED:
      case CODE_POINTS.TABULATION:
      case CODE_POINTS.FORM_FEED: {
        // Ignore whitespace
        break;
      }
      case CODE_POINTS.GREATER_THAN_SIGN: {
        this.emitCurrentDoctype(token);
        this.state = State$1.DATA;
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInDoctype);
        token.forceQuirks = true;
        this.emitCurrentDoctype(token);
        this._emitEOFToken();
        break;
      }
      default: {
        this._err(ERR.unexpectedCharacterAfterDoctypeSystemIdentifier);
        this.state = State$1.BOGUS_DOCTYPE;
        this._stateBogusDoctype(cp);
      }
    }
  }
  // Bogus DOCTYPE state
  //------------------------------------------------------------------
  _stateBogusDoctype(cp) {
    const token = this.currentToken;
    switch (cp) {
      case CODE_POINTS.GREATER_THAN_SIGN: {
        this.emitCurrentDoctype(token);
        this.state = State$1.DATA;
        break;
      }
      case CODE_POINTS.NULL: {
        this._err(ERR.unexpectedNullCharacter);
        break;
      }
      case CODE_POINTS.EOF: {
        this.emitCurrentDoctype(token);
        this._emitEOFToken();
        break;
      }
      // Do nothing
    }
  }
  // CDATA section state
  //------------------------------------------------------------------
  _stateCdataSection(cp) {
    switch (cp) {
      case CODE_POINTS.RIGHT_SQUARE_BRACKET: {
        this.state = State$1.CDATA_SECTION_BRACKET;
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInCdata);
        this._emitEOFToken();
        break;
      }
      default: {
        this._emitCodePoint(cp);
      }
    }
  }
  // CDATA section bracket state
  //------------------------------------------------------------------
  _stateCdataSectionBracket(cp) {
    if (cp === CODE_POINTS.RIGHT_SQUARE_BRACKET) {
      this.state = State$1.CDATA_SECTION_END;
    } else {
      this._emitChars("]");
      this.state = State$1.CDATA_SECTION;
      this._stateCdataSection(cp);
    }
  }
  // CDATA section end state
  //------------------------------------------------------------------
  _stateCdataSectionEnd(cp) {
    switch (cp) {
      case CODE_POINTS.GREATER_THAN_SIGN: {
        this.state = State$1.DATA;
        break;
      }
      case CODE_POINTS.RIGHT_SQUARE_BRACKET: {
        this._emitChars("]");
        break;
      }
      default: {
        this._emitChars("]]");
        this.state = State$1.CDATA_SECTION;
        this._stateCdataSection(cp);
      }
    }
  }
  // Character reference state
  //------------------------------------------------------------------
  _stateCharacterReference(cp) {
    if (cp === CODE_POINTS.NUMBER_SIGN) {
      this.state = State$1.NUMERIC_CHARACTER_REFERENCE;
    } else if (isAsciiAlphaNumeric(cp)) {
      this.state = State$1.NAMED_CHARACTER_REFERENCE;
      this._stateNamedCharacterReference(cp);
    } else {
      this._flushCodePointConsumedAsCharacterReference(CODE_POINTS.AMPERSAND);
      this._reconsumeInState(this.returnState, cp);
    }
  }
  // Named character reference state
  //------------------------------------------------------------------
  _stateNamedCharacterReference(cp) {
    const matchResult = this._matchNamedCharacterReference(cp);
    //NOTE: Matching can be abrupted by hibernation. In that case, match
    //results are no longer valid and we will need to start over.
    if (this._ensureHibernation());
    else if (matchResult) {
      for (let i = 0; i < matchResult.length; i++) {
        this._flushCodePointConsumedAsCharacterReference(matchResult[i]);
      }
      this.state = this.returnState;
    } else {
      this._flushCodePointConsumedAsCharacterReference(CODE_POINTS.AMPERSAND);
      this.state = State$1.AMBIGUOUS_AMPERSAND;
    }
  }
  // Ambiguos ampersand state
  //------------------------------------------------------------------
  _stateAmbiguousAmpersand(cp) {
    if (isAsciiAlphaNumeric(cp)) {
      this._flushCodePointConsumedAsCharacterReference(cp);
    } else {
      if (cp === CODE_POINTS.SEMICOLON) {
        this._err(ERR.unknownNamedCharacterReference);
      }
      this._reconsumeInState(this.returnState, cp);
    }
  }
  // Numeric character reference state
  //------------------------------------------------------------------
  _stateNumericCharacterReference(cp) {
    this.charRefCode = 0;
    if (
      cp === CODE_POINTS.LATIN_SMALL_X ||
      cp === CODE_POINTS.LATIN_CAPITAL_X
    ) {
      this.state = State$1.HEXADEMICAL_CHARACTER_REFERENCE_START;
    }
    // Inlined decimal character reference start state
    else if (isAsciiDigit(cp)) {
      this.state = State$1.DECIMAL_CHARACTER_REFERENCE;
      this._stateDecimalCharacterReference(cp);
    } else {
      this._err(ERR.absenceOfDigitsInNumericCharacterReference);
      this._flushCodePointConsumedAsCharacterReference(CODE_POINTS.AMPERSAND);
      this._flushCodePointConsumedAsCharacterReference(CODE_POINTS.NUMBER_SIGN);
      this._reconsumeInState(this.returnState, cp);
    }
  }
  // Hexademical character reference start state
  //------------------------------------------------------------------
  _stateHexademicalCharacterReferenceStart(cp) {
    if (isAsciiHexDigit(cp)) {
      this.state = State$1.HEXADEMICAL_CHARACTER_REFERENCE;
      this._stateHexademicalCharacterReference(cp);
    } else {
      this._err(ERR.absenceOfDigitsInNumericCharacterReference);
      this._flushCodePointConsumedAsCharacterReference(CODE_POINTS.AMPERSAND);
      this._flushCodePointConsumedAsCharacterReference(CODE_POINTS.NUMBER_SIGN);
      this._unconsume(2);
      this.state = this.returnState;
    }
  }
  // Hexademical character reference state
  //------------------------------------------------------------------
  _stateHexademicalCharacterReference(cp) {
    if (isAsciiUpperHexDigit(cp)) {
      this.charRefCode = this.charRefCode * 16 + cp - 0x37;
    } else if (isAsciiLowerHexDigit(cp)) {
      this.charRefCode = this.charRefCode * 16 + cp - 0x57;
    } else if (isAsciiDigit(cp)) {
      this.charRefCode = this.charRefCode * 16 + cp - 0x30;
    } else if (cp === CODE_POINTS.SEMICOLON) {
      this.state = State$1.NUMERIC_CHARACTER_REFERENCE_END;
    } else {
      this._err(ERR.missingSemicolonAfterCharacterReference);
      this.state = State$1.NUMERIC_CHARACTER_REFERENCE_END;
      this._stateNumericCharacterReferenceEnd(cp);
    }
  }
  // Decimal character reference state
  //------------------------------------------------------------------
  _stateDecimalCharacterReference(cp) {
    if (isAsciiDigit(cp)) {
      this.charRefCode = this.charRefCode * 10 + cp - 0x30;
    } else if (cp === CODE_POINTS.SEMICOLON) {
      this.state = State$1.NUMERIC_CHARACTER_REFERENCE_END;
    } else {
      this._err(ERR.missingSemicolonAfterCharacterReference);
      this.state = State$1.NUMERIC_CHARACTER_REFERENCE_END;
      this._stateNumericCharacterReferenceEnd(cp);
    }
  }
  // Numeric character reference end state
  //------------------------------------------------------------------
  _stateNumericCharacterReferenceEnd(cp) {
    if (this.charRefCode === CODE_POINTS.NULL) {
      this._err(ERR.nullCharacterReference);
      this.charRefCode = CODE_POINTS.REPLACEMENT_CHARACTER;
    } else if (this.charRefCode > 1114111) {
      this._err(ERR.characterReferenceOutsideUnicodeRange);
      this.charRefCode = CODE_POINTS.REPLACEMENT_CHARACTER;
    } else if (isSurrogate(this.charRefCode)) {
      this._err(ERR.surrogateCharacterReference);
      this.charRefCode = CODE_POINTS.REPLACEMENT_CHARACTER;
    } else if (isUndefinedCodePoint(this.charRefCode)) {
      this._err(ERR.noncharacterCharacterReference);
    } else if (
      isControlCodePoint(this.charRefCode) ||
      this.charRefCode === CODE_POINTS.CARRIAGE_RETURN
    ) {
      this._err(ERR.controlCharacterReference);
      const replacement = C1_CONTROLS_REFERENCE_REPLACEMENTS.get(
        this.charRefCode,
      );
      if (replacement !== undefined) {
        this.charRefCode = replacement;
      }
    }
    this._flushCodePointConsumedAsCharacterReference(this.charRefCode);
    this._reconsumeInState(this.returnState, cp);
  }
};

//Element utils
const IMPLICIT_END_TAG_REQUIRED = new Set([
  TAG_ID.DD,
  TAG_ID.DT,
  TAG_ID.LI,
  TAG_ID.OPTGROUP,
  TAG_ID.OPTION,
  TAG_ID.P,
  TAG_ID.RB,
  TAG_ID.RP,
  TAG_ID.RT,
  TAG_ID.RTC,
]);
const IMPLICIT_END_TAG_REQUIRED_THOROUGHLY = new Set([
  ...IMPLICIT_END_TAG_REQUIRED,
  TAG_ID.CAPTION,
  TAG_ID.COLGROUP,
  TAG_ID.TBODY,
  TAG_ID.TD,
  TAG_ID.TFOOT,
  TAG_ID.TH,
  TAG_ID.THEAD,
  TAG_ID.TR,
]);
const SCOPING_ELEMENT_NS = new Map([
  [TAG_ID.APPLET, NS.HTML],
  [TAG_ID.CAPTION, NS.HTML],
  [TAG_ID.HTML, NS.HTML],
  [TAG_ID.MARQUEE, NS.HTML],
  [TAG_ID.OBJECT, NS.HTML],
  [TAG_ID.TABLE, NS.HTML],
  [TAG_ID.TD, NS.HTML],
  [TAG_ID.TEMPLATE, NS.HTML],
  [TAG_ID.TH, NS.HTML],
  [TAG_ID.ANNOTATION_XML, NS.MATHML],
  [TAG_ID.MI, NS.MATHML],
  [TAG_ID.MN, NS.MATHML],
  [TAG_ID.MO, NS.MATHML],
  [TAG_ID.MS, NS.MATHML],
  [TAG_ID.MTEXT, NS.MATHML],
  [TAG_ID.DESC, NS.SVG],
  [TAG_ID.FOREIGN_OBJECT, NS.SVG],
  [TAG_ID.TITLE, NS.SVG],
]);
const NAMED_HEADERS = [
  TAG_ID.H1,
  TAG_ID.H2,
  TAG_ID.H3,
  TAG_ID.H4,
  TAG_ID.H5,
  TAG_ID.H6,
];
const TABLE_ROW_CONTEXT = [TAG_ID.TR, TAG_ID.TEMPLATE, TAG_ID.HTML];
const TABLE_BODY_CONTEXT = [
  TAG_ID.TBODY,
  TAG_ID.TFOOT,
  TAG_ID.THEAD,
  TAG_ID.TEMPLATE,
  TAG_ID.HTML,
];
const TABLE_CONTEXT = [TAG_ID.TABLE, TAG_ID.TEMPLATE, TAG_ID.HTML];
const TABLE_CELLS = [TAG_ID.TD, TAG_ID.TH];
//Stack of open elements
class OpenElementStack {
  get currentTmplContentOrNode() {
    return this._isInTemplate()
      ? this.treeAdapter.getTemplateContent(this.current)
      : this.current;
  }
  constructor(document, treeAdapter, handler) {
    this.treeAdapter = treeAdapter;
    this.handler = handler;
    this.items = [];
    this.tagIDs = [];
    this.stackTop = -1;
    this.tmplCount = 0;
    this.currentTagId = TAG_ID.UNKNOWN;
    this.current = document;
  }
  //Index of element
  _indexOf(element) {
    return this.items.lastIndexOf(element, this.stackTop);
  }
  //Update current element
  _isInTemplate() {
    return (
      this.currentTagId === TAG_ID.TEMPLATE &&
      this.treeAdapter.getNamespaceURI(this.current) === NS.HTML
    );
  }
  _updateCurrentElement() {
    this.current = this.items[this.stackTop];
    this.currentTagId = this.tagIDs[this.stackTop];
  }
  //Mutations
  push(element, tagID) {
    this.stackTop++;
    this.items[this.stackTop] = element;
    this.current = element;
    this.tagIDs[this.stackTop] = tagID;
    this.currentTagId = tagID;
    if (this._isInTemplate()) {
      this.tmplCount++;
    }
    this.handler.onItemPush(element, tagID, true);
  }
  pop() {
    const popped = this.current;
    if (this.tmplCount > 0 && this._isInTemplate()) {
      this.tmplCount--;
    }
    this.stackTop--;
    this._updateCurrentElement();
    this.handler.onItemPop(popped, true);
  }
  replace(oldElement, newElement) {
    const idx = this._indexOf(oldElement);
    this.items[idx] = newElement;
    if (idx === this.stackTop) {
      this.current = newElement;
    }
  }
  insertAfter(referenceElement, newElement, newElementID) {
    const insertionIdx = this._indexOf(referenceElement) + 1;
    this.items.splice(insertionIdx, 0, newElement);
    this.tagIDs.splice(insertionIdx, 0, newElementID);
    this.stackTop++;
    if (insertionIdx === this.stackTop) {
      this._updateCurrentElement();
    }
    this.handler.onItemPush(
      this.current,
      this.currentTagId,
      insertionIdx === this.stackTop,
    );
  }
  popUntilTagNamePopped(tagName) {
    let targetIdx = this.stackTop + 1;
    do {
      targetIdx = this.tagIDs.lastIndexOf(tagName, targetIdx - 1);
    } while (
      targetIdx > 0 &&
      this.treeAdapter.getNamespaceURI(this.items[targetIdx]) !== NS.HTML
    );
    this.shortenToLength(targetIdx < 0 ? 0 : targetIdx);
  }
  shortenToLength(idx) {
    while (this.stackTop >= idx) {
      const popped = this.current;
      if (this.tmplCount > 0 && this._isInTemplate()) {
        this.tmplCount -= 1;
      }
      this.stackTop--;
      this._updateCurrentElement();
      this.handler.onItemPop(popped, this.stackTop < idx);
    }
  }
  popUntilElementPopped(element) {
    const idx = this._indexOf(element);
    this.shortenToLength(idx < 0 ? 0 : idx);
  }
  popUntilPopped(tagNames, targetNS) {
    const idx = this._indexOfTagNames(tagNames, targetNS);
    this.shortenToLength(idx < 0 ? 0 : idx);
  }
  popUntilNumberedHeaderPopped() {
    this.popUntilPopped(NAMED_HEADERS, NS.HTML);
  }
  popUntilTableCellPopped() {
    this.popUntilPopped(TABLE_CELLS, NS.HTML);
  }
  popAllUpToHtmlElement() {
    //NOTE: here we assume that the root <html> element is always first in the open element stack, so
    //we perform this fast stack clean up.
    this.tmplCount = 0;
    this.shortenToLength(1);
  }
  _indexOfTagNames(tagNames, namespace) {
    for (let i = this.stackTop; i >= 0; i--) {
      if (
        tagNames.includes(this.tagIDs[i]) &&
        this.treeAdapter.getNamespaceURI(this.items[i]) === namespace
      ) {
        return i;
      }
    }
    return -1;
  }
  clearBackTo(tagNames, targetNS) {
    const idx = this._indexOfTagNames(tagNames, targetNS);
    this.shortenToLength(idx + 1);
  }
  clearBackToTableContext() {
    this.clearBackTo(TABLE_CONTEXT, NS.HTML);
  }
  clearBackToTableBodyContext() {
    this.clearBackTo(TABLE_BODY_CONTEXT, NS.HTML);
  }
  clearBackToTableRowContext() {
    this.clearBackTo(TABLE_ROW_CONTEXT, NS.HTML);
  }
  remove(element) {
    const idx = this._indexOf(element);
    if (idx >= 0) {
      if (idx === this.stackTop) {
        this.pop();
      } else {
        this.items.splice(idx, 1);
        this.tagIDs.splice(idx, 1);
        this.stackTop--;
        this._updateCurrentElement();
        this.handler.onItemPop(element, false);
      }
    }
  }
  //Search
  tryPeekProperlyNestedBodyElement() {
    //Properly nested <body> element (should be second element in stack).
    return this.stackTop >= 1 && this.tagIDs[1] === TAG_ID.BODY
      ? this.items[1]
      : null;
  }
  contains(element) {
    return this._indexOf(element) > -1;
  }
  getCommonAncestor(element) {
    const elementIdx = this._indexOf(element) - 1;
    return elementIdx >= 0 ? this.items[elementIdx] : null;
  }
  isRootHtmlElementCurrent() {
    return this.stackTop === 0 && this.tagIDs[0] === TAG_ID.HTML;
  }
  //Element in scope
  hasInScope(tagName) {
    for (let i = this.stackTop; i >= 0; i--) {
      const tn = this.tagIDs[i];
      const ns = this.treeAdapter.getNamespaceURI(this.items[i]);
      if (tn === tagName && ns === NS.HTML) {
        return true;
      }
      if (SCOPING_ELEMENT_NS.get(tn) === ns) {
        return false;
      }
    }
    return true;
  }
  hasNumberedHeaderInScope() {
    for (let i = this.stackTop; i >= 0; i--) {
      const tn = this.tagIDs[i];
      const ns = this.treeAdapter.getNamespaceURI(this.items[i]);
      if (isNumberedHeader(tn) && ns === NS.HTML) {
        return true;
      }
      if (SCOPING_ELEMENT_NS.get(tn) === ns) {
        return false;
      }
    }
    return true;
  }
  hasInListItemScope(tagName) {
    for (let i = this.stackTop; i >= 0; i--) {
      const tn = this.tagIDs[i];
      const ns = this.treeAdapter.getNamespaceURI(this.items[i]);
      if (tn === tagName && ns === NS.HTML) {
        return true;
      }
      if (
        ((tn === TAG_ID.UL || tn === TAG_ID.OL) && ns === NS.HTML) ||
        SCOPING_ELEMENT_NS.get(tn) === ns
      ) {
        return false;
      }
    }
    return true;
  }
  hasInButtonScope(tagName) {
    for (let i = this.stackTop; i >= 0; i--) {
      const tn = this.tagIDs[i];
      const ns = this.treeAdapter.getNamespaceURI(this.items[i]);
      if (tn === tagName && ns === NS.HTML) {
        return true;
      }
      if (
        (tn === TAG_ID.BUTTON && ns === NS.HTML) ||
        SCOPING_ELEMENT_NS.get(tn) === ns
      ) {
        return false;
      }
    }
    return true;
  }
  hasInTableScope(tagName) {
    for (let i = this.stackTop; i >= 0; i--) {
      const tn = this.tagIDs[i];
      const ns = this.treeAdapter.getNamespaceURI(this.items[i]);
      if (ns !== NS.HTML) {
        continue;
      }
      if (tn === tagName) {
        return true;
      }
      if (tn === TAG_ID.TABLE || tn === TAG_ID.TEMPLATE || tn === TAG_ID.HTML) {
        return false;
      }
    }
    return true;
  }
  hasTableBodyContextInTableScope() {
    for (let i = this.stackTop; i >= 0; i--) {
      const tn = this.tagIDs[i];
      const ns = this.treeAdapter.getNamespaceURI(this.items[i]);
      if (ns !== NS.HTML) {
        continue;
      }
      if (tn === TAG_ID.TBODY || tn === TAG_ID.THEAD || tn === TAG_ID.TFOOT) {
        return true;
      }
      if (tn === TAG_ID.TABLE || tn === TAG_ID.HTML) {
        return false;
      }
    }
    return true;
  }
  hasInSelectScope(tagName) {
    for (let i = this.stackTop; i >= 0; i--) {
      const tn = this.tagIDs[i];
      const ns = this.treeAdapter.getNamespaceURI(this.items[i]);
      if (ns !== NS.HTML) {
        continue;
      }
      if (tn === tagName) {
        return true;
      }
      if (tn !== TAG_ID.OPTION && tn !== TAG_ID.OPTGROUP) {
        return false;
      }
    }
    return true;
  }
  //Implied end tags
  generateImpliedEndTags() {
    while (IMPLICIT_END_TAG_REQUIRED.has(this.currentTagId)) {
      this.pop();
    }
  }
  generateImpliedEndTagsThoroughly() {
    while (IMPLICIT_END_TAG_REQUIRED_THOROUGHLY.has(this.currentTagId)) {
      this.pop();
    }
  }
  generateImpliedEndTagsWithExclusion(exclusionId) {
    while (
      this.currentTagId !== exclusionId &&
      IMPLICIT_END_TAG_REQUIRED_THOROUGHLY.has(this.currentTagId)
    ) {
      this.pop();
    }
  }
}

//Const
const NOAH_ARK_CAPACITY = 3;
var EntryType;
(function (EntryType) {
  EntryType[(EntryType["Marker"] = 0)] = "Marker";
  EntryType[(EntryType["Element"] = 1)] = "Element";
})((EntryType = EntryType || (EntryType = {})));
const MARKER = { type: EntryType.Marker };
//List of formatting elements
class FormattingElementList {
  constructor(treeAdapter) {
    this.treeAdapter = treeAdapter;
    this.entries = [];
    this.bookmark = null;
  }
  //Noah Ark's condition
  //OPTIMIZATION: at first we try to find possible candidates for exclusion using
  //lightweight heuristics without thorough attributes check.
  _getNoahArkConditionCandidates(newElement, neAttrs) {
    const candidates = [];
    const neAttrsLength = neAttrs.length;
    const neTagName = this.treeAdapter.getTagName(newElement);
    const neNamespaceURI = this.treeAdapter.getNamespaceURI(newElement);
    for (let i = 0; i < this.entries.length; i++) {
      const entry = this.entries[i];
      if (entry.type === EntryType.Marker) {
        break;
      }
      const { element } = entry;
      if (
        this.treeAdapter.getTagName(element) === neTagName &&
        this.treeAdapter.getNamespaceURI(element) === neNamespaceURI
      ) {
        const elementAttrs = this.treeAdapter.getAttrList(element);
        if (elementAttrs.length === neAttrsLength) {
          candidates.push({ idx: i, attrs: elementAttrs });
        }
      }
    }
    return candidates;
  }
  _ensureNoahArkCondition(newElement) {
    if (this.entries.length < NOAH_ARK_CAPACITY) return;
    const neAttrs = this.treeAdapter.getAttrList(newElement);
    const candidates = this._getNoahArkConditionCandidates(newElement, neAttrs);
    if (candidates.length < NOAH_ARK_CAPACITY) return;
    //NOTE: build attrs map for the new element, so we can perform fast lookups
    const neAttrsMap = new Map(
      neAttrs.map((neAttr) => [neAttr.name, neAttr.value]),
    );
    let validCandidates = 0;
    //NOTE: remove bottommost candidates, until Noah's Ark condition will not be met
    for (let i = 0; i < candidates.length; i++) {
      const candidate = candidates[i];
      // We know that `candidate.attrs.length === neAttrs.length`
      if (
        candidate.attrs.every(
          (cAttr) => neAttrsMap.get(cAttr.name) === cAttr.value,
        )
      ) {
        validCandidates += 1;
        if (validCandidates >= NOAH_ARK_CAPACITY) {
          this.entries.splice(candidate.idx, 1);
        }
      }
    }
  }
  //Mutations
  insertMarker() {
    this.entries.unshift(MARKER);
  }
  pushElement(element, token) {
    this._ensureNoahArkCondition(element);
    this.entries.unshift({
      type: EntryType.Element,
      element,
      token,
    });
  }
  insertElementAfterBookmark(element, token) {
    const bookmarkIdx = this.entries.indexOf(this.bookmark);
    this.entries.splice(bookmarkIdx, 0, {
      type: EntryType.Element,
      element,
      token,
    });
  }
  removeEntry(entry) {
    const entryIndex = this.entries.indexOf(entry);
    if (entryIndex >= 0) {
      this.entries.splice(entryIndex, 1);
    }
  }
  /**
   * Clears the list of formatting elements up to the last marker.
   *
   * @see https://html.spec.whatwg.org/multipage/parsing.html#clear-the-list-of-active-formatting-elements-up-to-the-last-marker
   */
  clearToLastMarker() {
    const markerIdx = this.entries.indexOf(MARKER);
    if (markerIdx >= 0) {
      this.entries.splice(0, markerIdx + 1);
    } else {
      this.entries.length = 0;
    }
  }
  //Search
  getElementEntryInScopeWithTagName(tagName) {
    const entry = this.entries.find(
      (entry) =>
        entry.type === EntryType.Marker ||
        this.treeAdapter.getTagName(entry.element) === tagName,
    );
    return entry && entry.type === EntryType.Element ? entry : null;
  }
  getElementEntry(element) {
    return this.entries.find(
      (entry) => entry.type === EntryType.Element && entry.element === element,
    );
  }
}

function createTextNode$1(value) {
  return {
    nodeName: "#text",
    value,
    parentNode: null,
  };
}
const defaultTreeAdapter = {
  //Node construction
  createDocument() {
    return {
      nodeName: "#document",
      mode: DOCUMENT_MODE.NO_QUIRKS,
      childNodes: [],
    };
  },
  createDocumentFragment() {
    return {
      nodeName: "#document-fragment",
      childNodes: [],
    };
  },
  createElement(tagName, namespaceURI, attrs) {
    return {
      nodeName: tagName,
      tagName,
      attrs,
      namespaceURI,
      childNodes: [],
      parentNode: null,
    };
  },
  createCommentNode(data) {
    return {
      nodeName: "#comment",
      data,
      parentNode: null,
    };
  },
  //Tree mutation
  appendChild(parentNode, newNode) {
    parentNode.childNodes.push(newNode);
    newNode.parentNode = parentNode;
  },
  insertBefore(parentNode, newNode, referenceNode) {
    const insertionIdx = parentNode.childNodes.indexOf(referenceNode);
    parentNode.childNodes.splice(insertionIdx, 0, newNode);
    newNode.parentNode = parentNode;
  },
  setTemplateContent(templateElement, contentElement) {
    templateElement.content = contentElement;
  },
  getTemplateContent(templateElement) {
    return templateElement.content;
  },
  setDocumentType(document, name, publicId, systemId) {
    const doctypeNode = document.childNodes.find(
      (node) => node.nodeName === "#documentType",
    );
    if (doctypeNode) {
      doctypeNode.name = name;
      doctypeNode.publicId = publicId;
      doctypeNode.systemId = systemId;
    } else {
      const node = {
        nodeName: "#documentType",
        name,
        publicId,
        systemId,
        parentNode: null,
      };
      defaultTreeAdapter.appendChild(document, node);
    }
  },
  setDocumentMode(document, mode) {
    document.mode = mode;
  },
  getDocumentMode(document) {
    return document.mode;
  },
  detachNode(node) {
    if (node.parentNode) {
      const idx = node.parentNode.childNodes.indexOf(node);
      node.parentNode.childNodes.splice(idx, 1);
      node.parentNode = null;
    }
  },
  insertText(parentNode, text) {
    if (parentNode.childNodes.length > 0) {
      const prevNode = parentNode.childNodes[parentNode.childNodes.length - 1];
      if (defaultTreeAdapter.isTextNode(prevNode)) {
        prevNode.value += text;
        return;
      }
    }
    defaultTreeAdapter.appendChild(parentNode, createTextNode$1(text));
  },
  insertTextBefore(parentNode, text, referenceNode) {
    const prevNode =
      parentNode.childNodes[parentNode.childNodes.indexOf(referenceNode) - 1];
    if (prevNode && defaultTreeAdapter.isTextNode(prevNode)) {
      prevNode.value += text;
    } else {
      defaultTreeAdapter.insertBefore(
        parentNode,
        createTextNode$1(text),
        referenceNode,
      );
    }
  },
  adoptAttributes(recipient, attrs) {
    const recipientAttrsMap = new Set(recipient.attrs.map((attr) => attr.name));
    for (let j = 0; j < attrs.length; j++) {
      if (!recipientAttrsMap.has(attrs[j].name)) {
        recipient.attrs.push(attrs[j]);
      }
    }
  },
  //Tree traversing
  getFirstChild(node) {
    return node.childNodes[0];
  },
  getChildNodes(node) {
    return node.childNodes;
  },
  getParentNode(node) {
    return node.parentNode;
  },
  getAttrList(element) {
    return element.attrs;
  },
  //Node data
  getTagName(element) {
    return element.tagName;
  },
  getNamespaceURI(element) {
    return element.namespaceURI;
  },
  getTextNodeContent(textNode) {
    return textNode.value;
  },
  getCommentNodeContent(commentNode) {
    return commentNode.data;
  },
  getDocumentTypeNodeName(doctypeNode) {
    return doctypeNode.name;
  },
  getDocumentTypeNodePublicId(doctypeNode) {
    return doctypeNode.publicId;
  },
  getDocumentTypeNodeSystemId(doctypeNode) {
    return doctypeNode.systemId;
  },
  //Node types
  isTextNode(node) {
    return node.nodeName === "#text";
  },
  isCommentNode(node) {
    return node.nodeName === "#comment";
  },
  isDocumentTypeNode(node) {
    return node.nodeName === "#documentType";
  },
  isElementNode(node) {
    return Object.prototype.hasOwnProperty.call(node, "tagName");
  },
  // Source code location
  setNodeSourceCodeLocation(node, location) {
    node.sourceCodeLocation = location;
  },
  getNodeSourceCodeLocation(node) {
    return node.sourceCodeLocation;
  },
  updateNodeSourceCodeLocation(node, endLocation) {
    node.sourceCodeLocation = { ...node.sourceCodeLocation, ...endLocation };
  },
};

//Const
const VALID_DOCTYPE_NAME = "html";
const VALID_SYSTEM_ID = "about:legacy-compat";
const QUIRKS_MODE_SYSTEM_ID =
  "http://www.ibm.com/data/dtd/v11/ibmxhtml1-transitional.dtd";
const QUIRKS_MODE_PUBLIC_ID_PREFIXES = [
  "+//silmaril//dtd html pro v0r11 19970101//",
  "-//as//dtd html 3.0 aswedit + extensions//",
  "-//advasoft ltd//dtd html 3.0 aswedit + extensions//",
  "-//ietf//dtd html 2.0 level 1//",
  "-//ietf//dtd html 2.0 level 2//",
  "-//ietf//dtd html 2.0 strict level 1//",
  "-//ietf//dtd html 2.0 strict level 2//",
  "-//ietf//dtd html 2.0 strict//",
  "-//ietf//dtd html 2.0//",
  "-//ietf//dtd html 2.1e//",
  "-//ietf//dtd html 3.0//",
  "-//ietf//dtd html 3.2 final//",
  "-//ietf//dtd html 3.2//",
  "-//ietf//dtd html 3//",
  "-//ietf//dtd html level 0//",
  "-//ietf//dtd html level 1//",
  "-//ietf//dtd html level 2//",
  "-//ietf//dtd html level 3//",
  "-//ietf//dtd html strict level 0//",
  "-//ietf//dtd html strict level 1//",
  "-//ietf//dtd html strict level 2//",
  "-//ietf//dtd html strict level 3//",
  "-//ietf//dtd html strict//",
  "-//ietf//dtd html//",
  "-//metrius//dtd metrius presentational//",
  "-//microsoft//dtd internet explorer 2.0 html strict//",
  "-//microsoft//dtd internet explorer 2.0 html//",
  "-//microsoft//dtd internet explorer 2.0 tables//",
  "-//microsoft//dtd internet explorer 3.0 html strict//",
  "-//microsoft//dtd internet explorer 3.0 html//",
  "-//microsoft//dtd internet explorer 3.0 tables//",
  "-//netscape comm. corp.//dtd html//",
  "-//netscape comm. corp.//dtd strict html//",
  "-//o'reilly and associates//dtd html 2.0//",
  "-//o'reilly and associates//dtd html extended 1.0//",
  "-//o'reilly and associates//dtd html extended relaxed 1.0//",
  "-//sq//dtd html 2.0 hotmetal + extensions//",
  "-//softquad software//dtd hotmetal pro 6.0::19990601::extensions to html 4.0//",
  "-//softquad//dtd hotmetal pro 4.0::19971010::extensions to html 4.0//",
  "-//spyglass//dtd html 2.0 extended//",
  "-//sun microsystems corp.//dtd hotjava html//",
  "-//sun microsystems corp.//dtd hotjava strict html//",
  "-//w3c//dtd html 3 1995-03-24//",
  "-//w3c//dtd html 3.2 draft//",
  "-//w3c//dtd html 3.2 final//",
  "-//w3c//dtd html 3.2//",
  "-//w3c//dtd html 3.2s draft//",
  "-//w3c//dtd html 4.0 frameset//",
  "-//w3c//dtd html 4.0 transitional//",
  "-//w3c//dtd html experimental 19960712//",
  "-//w3c//dtd html experimental 970421//",
  "-//w3c//dtd w3 html//",
  "-//w3o//dtd w3 html 3.0//",
  "-//webtechs//dtd mozilla html 2.0//",
  "-//webtechs//dtd mozilla html//",
];
const QUIRKS_MODE_NO_SYSTEM_ID_PUBLIC_ID_PREFIXES = [
  ...QUIRKS_MODE_PUBLIC_ID_PREFIXES,
  "-//w3c//dtd html 4.01 frameset//",
  "-//w3c//dtd html 4.01 transitional//",
];
const QUIRKS_MODE_PUBLIC_IDS = new Set([
  "-//w3o//dtd w3 html strict 3.0//en//",
  "-/w3c/dtd html 4.0 transitional/en",
  "html",
]);
const LIMITED_QUIRKS_PUBLIC_ID_PREFIXES = [
  "-//w3c//dtd xhtml 1.0 frameset//",
  "-//w3c//dtd xhtml 1.0 transitional//",
];
const LIMITED_QUIRKS_WITH_SYSTEM_ID_PUBLIC_ID_PREFIXES = [
  ...LIMITED_QUIRKS_PUBLIC_ID_PREFIXES,
  "-//w3c//dtd html 4.01 frameset//",
  "-//w3c//dtd html 4.01 transitional//",
];
//Utils
function hasPrefix(publicId, prefixes) {
  return prefixes.some((prefix) => publicId.startsWith(prefix));
}
//API
function isConforming(token) {
  return (
    token.name === VALID_DOCTYPE_NAME &&
    token.publicId === null &&
    (token.systemId === null || token.systemId === VALID_SYSTEM_ID)
  );
}
function getDocumentMode(token) {
  if (token.name !== VALID_DOCTYPE_NAME) {
    return DOCUMENT_MODE.QUIRKS;
  }
  const { systemId } = token;
  if (systemId && systemId.toLowerCase() === QUIRKS_MODE_SYSTEM_ID) {
    return DOCUMENT_MODE.QUIRKS;
  }
  let { publicId } = token;
  if (publicId !== null) {
    publicId = publicId.toLowerCase();
    if (QUIRKS_MODE_PUBLIC_IDS.has(publicId)) {
      return DOCUMENT_MODE.QUIRKS;
    }
    let prefixes =
      systemId === null
        ? QUIRKS_MODE_NO_SYSTEM_ID_PUBLIC_ID_PREFIXES
        : QUIRKS_MODE_PUBLIC_ID_PREFIXES;
    if (hasPrefix(publicId, prefixes)) {
      return DOCUMENT_MODE.QUIRKS;
    }
    prefixes =
      systemId === null
        ? LIMITED_QUIRKS_PUBLIC_ID_PREFIXES
        : LIMITED_QUIRKS_WITH_SYSTEM_ID_PUBLIC_ID_PREFIXES;
    if (hasPrefix(publicId, prefixes)) {
      return DOCUMENT_MODE.LIMITED_QUIRKS;
    }
  }
  return DOCUMENT_MODE.NO_QUIRKS;
}

//MIME types
const MIME_TYPES = {
  TEXT_HTML: "text/html",
  APPLICATION_XML: "application/xhtml+xml",
};
//Attributes
const DEFINITION_URL_ATTR = "definitionurl";
const ADJUSTED_DEFINITION_URL_ATTR = "definitionURL";
const SVG_ATTRS_ADJUSTMENT_MAP = new Map(
  [
    "attributeName",
    "attributeType",
    "baseFrequency",
    "baseProfile",
    "calcMode",
    "clipPathUnits",
    "diffuseConstant",
    "edgeMode",
    "filterUnits",
    "glyphRef",
    "gradientTransform",
    "gradientUnits",
    "kernelMatrix",
    "kernelUnitLength",
    "keyPoints",
    "keySplines",
    "keyTimes",
    "lengthAdjust",
    "limitingConeAngle",
    "markerHeight",
    "markerUnits",
    "markerWidth",
    "maskContentUnits",
    "maskUnits",
    "numOctaves",
    "pathLength",
    "patternContentUnits",
    "patternTransform",
    "patternUnits",
    "pointsAtX",
    "pointsAtY",
    "pointsAtZ",
    "preserveAlpha",
    "preserveAspectRatio",
    "primitiveUnits",
    "refX",
    "refY",
    "repeatCount",
    "repeatDur",
    "requiredExtensions",
    "requiredFeatures",
    "specularConstant",
    "specularExponent",
    "spreadMethod",
    "startOffset",
    "stdDeviation",
    "stitchTiles",
    "surfaceScale",
    "systemLanguage",
    "tableValues",
    "targetX",
    "targetY",
    "textLength",
    "viewBox",
    "viewTarget",
    "xChannelSelector",
    "yChannelSelector",
    "zoomAndPan",
  ].map((attr) => [attr.toLowerCase(), attr]),
);
const XML_ATTRS_ADJUSTMENT_MAP = new Map([
  ["xlink:actuate", { prefix: "xlink", name: "actuate", namespace: NS.XLINK }],
  ["xlink:arcrole", { prefix: "xlink", name: "arcrole", namespace: NS.XLINK }],
  ["xlink:href", { prefix: "xlink", name: "href", namespace: NS.XLINK }],
  ["xlink:role", { prefix: "xlink", name: "role", namespace: NS.XLINK }],
  ["xlink:show", { prefix: "xlink", name: "show", namespace: NS.XLINK }],
  ["xlink:title", { prefix: "xlink", name: "title", namespace: NS.XLINK }],
  ["xlink:type", { prefix: "xlink", name: "type", namespace: NS.XLINK }],
  ["xml:base", { prefix: "xml", name: "base", namespace: NS.XML }],
  ["xml:lang", { prefix: "xml", name: "lang", namespace: NS.XML }],
  ["xml:space", { prefix: "xml", name: "space", namespace: NS.XML }],
  ["xmlns", { prefix: "", name: "xmlns", namespace: NS.XMLNS }],
  ["xmlns:xlink", { prefix: "xmlns", name: "xlink", namespace: NS.XMLNS }],
]);
//SVG tag names adjustment map
const SVG_TAG_NAMES_ADJUSTMENT_MAP = new Map(
  [
    "altGlyph",
    "altGlyphDef",
    "altGlyphItem",
    "animateColor",
    "animateMotion",
    "animateTransform",
    "clipPath",
    "feBlend",
    "feColorMatrix",
    "feComponentTransfer",
    "feComposite",
    "feConvolveMatrix",
    "feDiffuseLighting",
    "feDisplacementMap",
    "feDistantLight",
    "feFlood",
    "feFuncA",
    "feFuncB",
    "feFuncG",
    "feFuncR",
    "feGaussianBlur",
    "feImage",
    "feMerge",
    "feMergeNode",
    "feMorphology",
    "feOffset",
    "fePointLight",
    "feSpecularLighting",
    "feSpotLight",
    "feTile",
    "feTurbulence",
    "foreignObject",
    "glyphRef",
    "linearGradient",
    "radialGradient",
    "textPath",
  ].map((tn) => [tn.toLowerCase(), tn]),
);
//Tags that causes exit from foreign content
const EXITS_FOREIGN_CONTENT = new Set([
  TAG_ID.B,
  TAG_ID.BIG,
  TAG_ID.BLOCKQUOTE,
  TAG_ID.BODY,
  TAG_ID.BR,
  TAG_ID.CENTER,
  TAG_ID.CODE,
  TAG_ID.DD,
  TAG_ID.DIV,
  TAG_ID.DL,
  TAG_ID.DT,
  TAG_ID.EM,
  TAG_ID.EMBED,
  TAG_ID.H1,
  TAG_ID.H2,
  TAG_ID.H3,
  TAG_ID.H4,
  TAG_ID.H5,
  TAG_ID.H6,
  TAG_ID.HEAD,
  TAG_ID.HR,
  TAG_ID.I,
  TAG_ID.IMG,
  TAG_ID.LI,
  TAG_ID.LISTING,
  TAG_ID.MENU,
  TAG_ID.META,
  TAG_ID.NOBR,
  TAG_ID.OL,
  TAG_ID.P,
  TAG_ID.PRE,
  TAG_ID.RUBY,
  TAG_ID.S,
  TAG_ID.SMALL,
  TAG_ID.SPAN,
  TAG_ID.STRONG,
  TAG_ID.STRIKE,
  TAG_ID.SUB,
  TAG_ID.SUP,
  TAG_ID.TABLE,
  TAG_ID.TT,
  TAG_ID.U,
  TAG_ID.UL,
  TAG_ID.VAR,
]);
//Check exit from foreign content
function causesExit(startTagToken) {
  const tn = startTagToken.tagID;
  const isFontWithAttrs =
    tn === TAG_ID.FONT &&
    startTagToken.attrs.some(
      ({ name }) =>
        name === ATTRS.COLOR || name === ATTRS.SIZE || name === ATTRS.FACE,
    );
  return isFontWithAttrs || EXITS_FOREIGN_CONTENT.has(tn);
}
//Token adjustments
function adjustTokenMathMLAttrs(token) {
  for (let i = 0; i < token.attrs.length; i++) {
    if (token.attrs[i].name === DEFINITION_URL_ATTR) {
      token.attrs[i].name = ADJUSTED_DEFINITION_URL_ATTR;
      break;
    }
  }
}
function adjustTokenSVGAttrs(token) {
  for (let i = 0; i < token.attrs.length; i++) {
    const adjustedAttrName = SVG_ATTRS_ADJUSTMENT_MAP.get(token.attrs[i].name);
    if (adjustedAttrName != null) {
      token.attrs[i].name = adjustedAttrName;
    }
  }
}
function adjustTokenXMLAttrs(token) {
  for (let i = 0; i < token.attrs.length; i++) {
    const adjustedAttrEntry = XML_ATTRS_ADJUSTMENT_MAP.get(token.attrs[i].name);
    if (adjustedAttrEntry) {
      token.attrs[i].prefix = adjustedAttrEntry.prefix;
      token.attrs[i].name = adjustedAttrEntry.name;
      token.attrs[i].namespace = adjustedAttrEntry.namespace;
    }
  }
}
function adjustTokenSVGTagName(token) {
  const adjustedTagName = SVG_TAG_NAMES_ADJUSTMENT_MAP.get(token.tagName);
  if (adjustedTagName != null) {
    token.tagName = adjustedTagName;
    token.tagID = getTagID(token.tagName);
  }
}
//Integration points
function isMathMLTextIntegrationPoint(tn, ns) {
  return (
    ns === NS.MATHML &&
    (tn === TAG_ID.MI ||
      tn === TAG_ID.MO ||
      tn === TAG_ID.MN ||
      tn === TAG_ID.MS ||
      tn === TAG_ID.MTEXT)
  );
}
function isHtmlIntegrationPoint(tn, ns, attrs) {
  if (ns === NS.MATHML && tn === TAG_ID.ANNOTATION_XML) {
    for (let i = 0; i < attrs.length; i++) {
      if (attrs[i].name === ATTRS.ENCODING) {
        const value = attrs[i].value.toLowerCase();
        return (
          value === MIME_TYPES.TEXT_HTML || value === MIME_TYPES.APPLICATION_XML
        );
      }
    }
  }
  return (
    ns === NS.SVG &&
    (tn === TAG_ID.FOREIGN_OBJECT || tn === TAG_ID.DESC || tn === TAG_ID.TITLE)
  );
}
function isIntegrationPoint(tn, ns, attrs, foreignNS) {
  return (
    ((!foreignNS || foreignNS === NS.HTML) &&
      isHtmlIntegrationPoint(tn, ns, attrs)) ||
    ((!foreignNS || foreignNS === NS.MATHML) &&
      isMathMLTextIntegrationPoint(tn, ns))
  );
}

//Misc constants
const HIDDEN_INPUT_TYPE = "hidden";
//Adoption agency loops iteration count
const AA_OUTER_LOOP_ITER = 8;
const AA_INNER_LOOP_ITER = 3;
//Insertion modes
var InsertionMode;
(function (InsertionMode) {
  InsertionMode[(InsertionMode["INITIAL"] = 0)] = "INITIAL";
  InsertionMode[(InsertionMode["BEFORE_HTML"] = 1)] = "BEFORE_HTML";
  InsertionMode[(InsertionMode["BEFORE_HEAD"] = 2)] = "BEFORE_HEAD";
  InsertionMode[(InsertionMode["IN_HEAD"] = 3)] = "IN_HEAD";
  InsertionMode[(InsertionMode["IN_HEAD_NO_SCRIPT"] = 4)] = "IN_HEAD_NO_SCRIPT";
  InsertionMode[(InsertionMode["AFTER_HEAD"] = 5)] = "AFTER_HEAD";
  InsertionMode[(InsertionMode["IN_BODY"] = 6)] = "IN_BODY";
  InsertionMode[(InsertionMode["TEXT"] = 7)] = "TEXT";
  InsertionMode[(InsertionMode["IN_TABLE"] = 8)] = "IN_TABLE";
  InsertionMode[(InsertionMode["IN_TABLE_TEXT"] = 9)] = "IN_TABLE_TEXT";
  InsertionMode[(InsertionMode["IN_CAPTION"] = 10)] = "IN_CAPTION";
  InsertionMode[(InsertionMode["IN_COLUMN_GROUP"] = 11)] = "IN_COLUMN_GROUP";
  InsertionMode[(InsertionMode["IN_TABLE_BODY"] = 12)] = "IN_TABLE_BODY";
  InsertionMode[(InsertionMode["IN_ROW"] = 13)] = "IN_ROW";
  InsertionMode[(InsertionMode["IN_CELL"] = 14)] = "IN_CELL";
  InsertionMode[(InsertionMode["IN_SELECT"] = 15)] = "IN_SELECT";
  InsertionMode[(InsertionMode["IN_SELECT_IN_TABLE"] = 16)] =
    "IN_SELECT_IN_TABLE";
  InsertionMode[(InsertionMode["IN_TEMPLATE"] = 17)] = "IN_TEMPLATE";
  InsertionMode[(InsertionMode["AFTER_BODY"] = 18)] = "AFTER_BODY";
  InsertionMode[(InsertionMode["IN_FRAMESET"] = 19)] = "IN_FRAMESET";
  InsertionMode[(InsertionMode["AFTER_FRAMESET"] = 20)] = "AFTER_FRAMESET";
  InsertionMode[(InsertionMode["AFTER_AFTER_BODY"] = 21)] = "AFTER_AFTER_BODY";
  InsertionMode[(InsertionMode["AFTER_AFTER_FRAMESET"] = 22)] =
    "AFTER_AFTER_FRAMESET";
})(InsertionMode || (InsertionMode = {}));
const BASE_LOC = {
  startLine: -1,
  startCol: -1,
  startOffset: -1,
  endLine: -1,
  endCol: -1,
  endOffset: -1,
};
const TABLE_STRUCTURE_TAGS = new Set([
  TAG_ID.TABLE,
  TAG_ID.TBODY,
  TAG_ID.TFOOT,
  TAG_ID.THEAD,
  TAG_ID.TR,
]);
const defaultParserOptions = {
  scriptingEnabled: true,
  sourceCodeLocationInfo: false,
  treeAdapter: defaultTreeAdapter,
  onParseError: null,
};
//Parser
let Parser$2 = class Parser {
  constructor(options, document, fragmentContext = null, scriptHandler = null) {
    this.fragmentContext = fragmentContext;
    this.scriptHandler = scriptHandler;
    this.currentToken = null;
    this.stopped = false;
    this.insertionMode = InsertionMode.INITIAL;
    this.originalInsertionMode = InsertionMode.INITIAL;
    this.headElement = null;
    this.formElement = null;
    /** Indicates that the current node is not an element in the HTML namespace */
    this.currentNotInHTML = false;
    /**
     * The template insertion mode stack is maintained from the left.
     * Ie. the topmost element will always have index 0.
     */
    this.tmplInsertionModeStack = [];
    this.pendingCharacterTokens = [];
    this.hasNonWhitespacePendingCharacterToken = false;
    this.framesetOk = true;
    this.skipNextNewLine = false;
    this.fosterParentingEnabled = false;
    this.options = {
      ...defaultParserOptions,
      ...options,
    };
    this.treeAdapter = this.options.treeAdapter;
    this.onParseError = this.options.onParseError;
    // Always enable location info if we report parse errors.
    if (this.onParseError) {
      this.options.sourceCodeLocationInfo = true;
    }
    this.document =
      document !== null && document !== void 0
        ? document
        : this.treeAdapter.createDocument();
    this.tokenizer = new Tokenizer$3(this.options, this);
    this.activeFormattingElements = new FormattingElementList(this.treeAdapter);
    this.fragmentContextID = fragmentContext
      ? getTagID(this.treeAdapter.getTagName(fragmentContext))
      : TAG_ID.UNKNOWN;
    this._setContextModes(
      fragmentContext !== null && fragmentContext !== void 0
        ? fragmentContext
        : this.document,
      this.fragmentContextID,
    );
    this.openElements = new OpenElementStack(
      this.document,
      this.treeAdapter,
      this,
    );
  }
  // API
  static parse(html, options) {
    const parser = new this(options);
    parser.tokenizer.write(html, true);
    return parser.document;
  }
  static getFragmentParser(fragmentContext, options) {
    const opts = {
      ...defaultParserOptions,
      ...options,
    };
    //NOTE: use a <template> element as the fragment context if no context element was provided,
    //so we will parse in a "forgiving" manner
    fragmentContext !== null && fragmentContext !== void 0
      ? fragmentContext
      : (fragmentContext = opts.treeAdapter.createElement(
          TAG_NAMES.TEMPLATE,
          NS.HTML,
          [],
        ));
    //NOTE: create a fake element which will be used as the `document` for fragment parsing.
    //This is important for jsdom, where a new `document` cannot be created. This led to
    //fragment parsing messing with the main `document`.
    const documentMock = opts.treeAdapter.createElement(
      "documentmock",
      NS.HTML,
      [],
    );
    const parser = new this(opts, documentMock, fragmentContext);
    if (parser.fragmentContextID === TAG_ID.TEMPLATE) {
      parser.tmplInsertionModeStack.unshift(InsertionMode.IN_TEMPLATE);
    }
    parser._initTokenizerForFragmentParsing();
    parser._insertFakeRootElement();
    parser._resetInsertionMode();
    parser._findFormInFragmentContext();
    return parser;
  }
  getFragment() {
    const rootElement = this.treeAdapter.getFirstChild(this.document);
    const fragment = this.treeAdapter.createDocumentFragment();
    this._adoptNodes(rootElement, fragment);
    return fragment;
  }
  //Errors
  _err(token, code, beforeToken) {
    var _a;
    if (!this.onParseError) return;
    const loc = (_a = token.location) !== null && _a !== void 0 ? _a : BASE_LOC;
    const err = {
      code,
      startLine: loc.startLine,
      startCol: loc.startCol,
      startOffset: loc.startOffset,
      endLine: beforeToken ? loc.startLine : loc.endLine,
      endCol: beforeToken ? loc.startCol : loc.endCol,
      endOffset: beforeToken ? loc.startOffset : loc.endOffset,
    };
    this.onParseError(err);
  }
  //Stack events
  onItemPush(node, tid, isTop) {
    var _a, _b;
    (_b = (_a = this.treeAdapter).onItemPush) === null || _b === void 0
      ? void 0
      : _b.call(_a, node);
    if (isTop && this.openElements.stackTop > 0)
      this._setContextModes(node, tid);
  }
  onItemPop(node, isTop) {
    var _a, _b;
    if (this.options.sourceCodeLocationInfo) {
      this._setEndLocation(node, this.currentToken);
    }
    (_b = (_a = this.treeAdapter).onItemPop) === null || _b === void 0
      ? void 0
      : _b.call(_a, node, this.openElements.current);
    if (isTop) {
      let current;
      let currentTagId;
      if (this.openElements.stackTop === 0 && this.fragmentContext) {
        current = this.fragmentContext;
        currentTagId = this.fragmentContextID;
      } else {
        ({ current, currentTagId } = this.openElements);
      }
      this._setContextModes(current, currentTagId);
    }
  }
  _setContextModes(current, tid) {
    const isHTML =
      current === this.document ||
      this.treeAdapter.getNamespaceURI(current) === NS.HTML;
    this.currentNotInHTML = !isHTML;
    this.tokenizer.inForeignNode =
      !isHTML && !this._isIntegrationPoint(tid, current);
  }
  _switchToTextParsing(currentToken, nextTokenizerState) {
    this._insertElement(currentToken, NS.HTML);
    this.tokenizer.state = nextTokenizerState;
    this.originalInsertionMode = this.insertionMode;
    this.insertionMode = InsertionMode.TEXT;
  }
  switchToPlaintextParsing() {
    this.insertionMode = InsertionMode.TEXT;
    this.originalInsertionMode = InsertionMode.IN_BODY;
    this.tokenizer.state = TokenizerMode.PLAINTEXT;
  }
  //Fragment parsing
  _getAdjustedCurrentElement() {
    return this.openElements.stackTop === 0 && this.fragmentContext
      ? this.fragmentContext
      : this.openElements.current;
  }
  _findFormInFragmentContext() {
    let node = this.fragmentContext;
    while (node) {
      if (this.treeAdapter.getTagName(node) === TAG_NAMES.FORM) {
        this.formElement = node;
        break;
      }
      node = this.treeAdapter.getParentNode(node);
    }
  }
  _initTokenizerForFragmentParsing() {
    if (
      !this.fragmentContext ||
      this.treeAdapter.getNamespaceURI(this.fragmentContext) !== NS.HTML
    ) {
      return;
    }
    switch (this.fragmentContextID) {
      case TAG_ID.TITLE:
      case TAG_ID.TEXTAREA: {
        this.tokenizer.state = TokenizerMode.RCDATA;
        break;
      }
      case TAG_ID.STYLE:
      case TAG_ID.XMP:
      case TAG_ID.IFRAME:
      case TAG_ID.NOEMBED:
      case TAG_ID.NOFRAMES:
      case TAG_ID.NOSCRIPT: {
        this.tokenizer.state = TokenizerMode.RAWTEXT;
        break;
      }
      case TAG_ID.SCRIPT: {
        this.tokenizer.state = TokenizerMode.SCRIPT_DATA;
        break;
      }
      case TAG_ID.PLAINTEXT: {
        this.tokenizer.state = TokenizerMode.PLAINTEXT;
        break;
      }
      // Do nothing
    }
  }
  //Tree mutation
  _setDocumentType(token) {
    const name = token.name || "";
    const publicId = token.publicId || "";
    const systemId = token.systemId || "";
    this.treeAdapter.setDocumentType(this.document, name, publicId, systemId);
    if (token.location) {
      const documentChildren = this.treeAdapter.getChildNodes(this.document);
      const docTypeNode = documentChildren.find((node) =>
        this.treeAdapter.isDocumentTypeNode(node),
      );
      if (docTypeNode) {
        this.treeAdapter.setNodeSourceCodeLocation(docTypeNode, token.location);
      }
    }
  }
  _attachElementToTree(element, location) {
    if (this.options.sourceCodeLocationInfo) {
      const loc = location && {
        ...location,
        startTag: location,
      };
      this.treeAdapter.setNodeSourceCodeLocation(element, loc);
    }
    if (this._shouldFosterParentOnInsertion()) {
      this._fosterParentElement(element);
    } else {
      const parent = this.openElements.currentTmplContentOrNode;
      this.treeAdapter.appendChild(parent, element);
    }
  }
  _appendElement(token, namespaceURI) {
    const element = this.treeAdapter.createElement(
      token.tagName,
      namespaceURI,
      token.attrs,
    );
    this._attachElementToTree(element, token.location);
  }
  _insertElement(token, namespaceURI) {
    const element = this.treeAdapter.createElement(
      token.tagName,
      namespaceURI,
      token.attrs,
    );
    this._attachElementToTree(element, token.location);
    this.openElements.push(element, token.tagID);
  }
  _insertFakeElement(tagName, tagID) {
    const element = this.treeAdapter.createElement(tagName, NS.HTML, []);
    this._attachElementToTree(element, null);
    this.openElements.push(element, tagID);
  }
  _insertTemplate(token) {
    const tmpl = this.treeAdapter.createElement(
      token.tagName,
      NS.HTML,
      token.attrs,
    );
    const content = this.treeAdapter.createDocumentFragment();
    this.treeAdapter.setTemplateContent(tmpl, content);
    this._attachElementToTree(tmpl, token.location);
    this.openElements.push(tmpl, token.tagID);
    if (this.options.sourceCodeLocationInfo)
      this.treeAdapter.setNodeSourceCodeLocation(content, null);
  }
  _insertFakeRootElement() {
    const element = this.treeAdapter.createElement(TAG_NAMES.HTML, NS.HTML, []);
    if (this.options.sourceCodeLocationInfo)
      this.treeAdapter.setNodeSourceCodeLocation(element, null);
    this.treeAdapter.appendChild(this.openElements.current, element);
    this.openElements.push(element, TAG_ID.HTML);
  }
  _appendCommentNode(token, parent) {
    const commentNode = this.treeAdapter.createCommentNode(token.data);
    this.treeAdapter.appendChild(parent, commentNode);
    if (this.options.sourceCodeLocationInfo) {
      this.treeAdapter.setNodeSourceCodeLocation(commentNode, token.location);
    }
  }
  _insertCharacters(token) {
    let parent;
    let beforeElement;
    if (this._shouldFosterParentOnInsertion()) {
      ({ parent, beforeElement } = this._findFosterParentingLocation());
      if (beforeElement) {
        this.treeAdapter.insertTextBefore(parent, token.chars, beforeElement);
      } else {
        this.treeAdapter.insertText(parent, token.chars);
      }
    } else {
      parent = this.openElements.currentTmplContentOrNode;
      this.treeAdapter.insertText(parent, token.chars);
    }
    if (!token.location) return;
    const siblings = this.treeAdapter.getChildNodes(parent);
    const textNodeIdx = beforeElement
      ? siblings.lastIndexOf(beforeElement)
      : siblings.length;
    const textNode = siblings[textNodeIdx - 1];
    //NOTE: if we have a location assigned by another token, then just update the end position
    const tnLoc = this.treeAdapter.getNodeSourceCodeLocation(textNode);
    if (tnLoc) {
      const { endLine, endCol, endOffset } = token.location;
      this.treeAdapter.updateNodeSourceCodeLocation(textNode, {
        endLine,
        endCol,
        endOffset,
      });
    } else if (this.options.sourceCodeLocationInfo) {
      this.treeAdapter.setNodeSourceCodeLocation(textNode, token.location);
    }
  }
  _adoptNodes(donor, recipient) {
    for (
      let child = this.treeAdapter.getFirstChild(donor);
      child;
      child = this.treeAdapter.getFirstChild(donor)
    ) {
      this.treeAdapter.detachNode(child);
      this.treeAdapter.appendChild(recipient, child);
    }
  }
  _setEndLocation(element, closingToken) {
    if (
      this.treeAdapter.getNodeSourceCodeLocation(element) &&
      closingToken.location
    ) {
      const ctLoc = closingToken.location;
      const tn = this.treeAdapter.getTagName(element);
      const endLoc =
        // NOTE: For cases like <p> <p> </p> - First 'p' closes without a closing
        // tag and for cases like <td> <p> </td> - 'p' closes without a closing tag.
        closingToken.type === TokenType.END_TAG && tn === closingToken.tagName
          ? {
              endTag: { ...ctLoc },
              endLine: ctLoc.endLine,
              endCol: ctLoc.endCol,
              endOffset: ctLoc.endOffset,
            }
          : {
              endLine: ctLoc.startLine,
              endCol: ctLoc.startCol,
              endOffset: ctLoc.startOffset,
            };
      this.treeAdapter.updateNodeSourceCodeLocation(element, endLoc);
    }
  }
  //Token processing
  shouldProcessStartTagTokenInForeignContent(token) {
    // Check that neither current === document, or ns === NS.HTML
    if (!this.currentNotInHTML) return false;
    let current;
    let currentTagId;
    if (this.openElements.stackTop === 0 && this.fragmentContext) {
      current = this.fragmentContext;
      currentTagId = this.fragmentContextID;
    } else {
      ({ current, currentTagId } = this.openElements);
    }
    if (
      token.tagID === TAG_ID.SVG &&
      this.treeAdapter.getTagName(current) === TAG_NAMES.ANNOTATION_XML &&
      this.treeAdapter.getNamespaceURI(current) === NS.MATHML
    ) {
      return false;
    }
    return (
      // Check that `current` is not an integration point for HTML or MathML elements.
      this.tokenizer.inForeignNode ||
      // If it _is_ an integration point, then we might have to check that it is not an HTML
      // integration point.
      ((token.tagID === TAG_ID.MGLYPH || token.tagID === TAG_ID.MALIGNMARK) &&
        !this._isIntegrationPoint(currentTagId, current, NS.HTML))
    );
  }
  _processToken(token) {
    switch (token.type) {
      case TokenType.CHARACTER: {
        this.onCharacter(token);
        break;
      }
      case TokenType.NULL_CHARACTER: {
        this.onNullCharacter(token);
        break;
      }
      case TokenType.COMMENT: {
        this.onComment(token);
        break;
      }
      case TokenType.DOCTYPE: {
        this.onDoctype(token);
        break;
      }
      case TokenType.START_TAG: {
        this._processStartTag(token);
        break;
      }
      case TokenType.END_TAG: {
        this.onEndTag(token);
        break;
      }
      case TokenType.EOF: {
        this.onEof(token);
        break;
      }
      case TokenType.WHITESPACE_CHARACTER: {
        this.onWhitespaceCharacter(token);
        break;
      }
    }
  }
  //Integration points
  _isIntegrationPoint(tid, element, foreignNS) {
    const ns = this.treeAdapter.getNamespaceURI(element);
    const attrs = this.treeAdapter.getAttrList(element);
    return isIntegrationPoint(tid, ns, attrs, foreignNS);
  }
  //Active formatting elements reconstruction
  _reconstructActiveFormattingElements() {
    const listLength = this.activeFormattingElements.entries.length;
    if (listLength) {
      const endIndex = this.activeFormattingElements.entries.findIndex(
        (entry) =>
          entry.type === EntryType.Marker ||
          this.openElements.contains(entry.element),
      );
      const unopenIdx = endIndex < 0 ? listLength - 1 : endIndex - 1;
      for (let i = unopenIdx; i >= 0; i--) {
        const entry = this.activeFormattingElements.entries[i];
        this._insertElement(
          entry.token,
          this.treeAdapter.getNamespaceURI(entry.element),
        );
        entry.element = this.openElements.current;
      }
    }
  }
  //Close elements
  _closeTableCell() {
    this.openElements.generateImpliedEndTags();
    this.openElements.popUntilTableCellPopped();
    this.activeFormattingElements.clearToLastMarker();
    this.insertionMode = InsertionMode.IN_ROW;
  }
  _closePElement() {
    this.openElements.generateImpliedEndTagsWithExclusion(TAG_ID.P);
    this.openElements.popUntilTagNamePopped(TAG_ID.P);
  }
  //Insertion modes
  _resetInsertionMode() {
    for (let i = this.openElements.stackTop; i >= 0; i--) {
      //Insertion mode reset map
      switch (
        i === 0 && this.fragmentContext
          ? this.fragmentContextID
          : this.openElements.tagIDs[i]
      ) {
        case TAG_ID.TR: {
          this.insertionMode = InsertionMode.IN_ROW;
          return;
        }
        case TAG_ID.TBODY:
        case TAG_ID.THEAD:
        case TAG_ID.TFOOT: {
          this.insertionMode = InsertionMode.IN_TABLE_BODY;
          return;
        }
        case TAG_ID.CAPTION: {
          this.insertionMode = InsertionMode.IN_CAPTION;
          return;
        }
        case TAG_ID.COLGROUP: {
          this.insertionMode = InsertionMode.IN_COLUMN_GROUP;
          return;
        }
        case TAG_ID.TABLE: {
          this.insertionMode = InsertionMode.IN_TABLE;
          return;
        }
        case TAG_ID.BODY: {
          this.insertionMode = InsertionMode.IN_BODY;
          return;
        }
        case TAG_ID.FRAMESET: {
          this.insertionMode = InsertionMode.IN_FRAMESET;
          return;
        }
        case TAG_ID.SELECT: {
          this._resetInsertionModeForSelect(i);
          return;
        }
        case TAG_ID.TEMPLATE: {
          this.insertionMode = this.tmplInsertionModeStack[0];
          return;
        }
        case TAG_ID.HTML: {
          this.insertionMode = this.headElement
            ? InsertionMode.AFTER_HEAD
            : InsertionMode.BEFORE_HEAD;
          return;
        }
        case TAG_ID.TD:
        case TAG_ID.TH: {
          if (i > 0) {
            this.insertionMode = InsertionMode.IN_CELL;
            return;
          }
          break;
        }
        case TAG_ID.HEAD: {
          if (i > 0) {
            this.insertionMode = InsertionMode.IN_HEAD;
            return;
          }
          break;
        }
      }
    }
    this.insertionMode = InsertionMode.IN_BODY;
  }
  _resetInsertionModeForSelect(selectIdx) {
    if (selectIdx > 0) {
      for (let i = selectIdx - 1; i > 0; i--) {
        const tn = this.openElements.tagIDs[i];
        if (tn === TAG_ID.TEMPLATE) {
          break;
        } else if (tn === TAG_ID.TABLE) {
          this.insertionMode = InsertionMode.IN_SELECT_IN_TABLE;
          return;
        }
      }
    }
    this.insertionMode = InsertionMode.IN_SELECT;
  }
  //Foster parenting
  _isElementCausesFosterParenting(tn) {
    return TABLE_STRUCTURE_TAGS.has(tn);
  }
  _shouldFosterParentOnInsertion() {
    return (
      this.fosterParentingEnabled &&
      this._isElementCausesFosterParenting(this.openElements.currentTagId)
    );
  }
  _findFosterParentingLocation() {
    for (let i = this.openElements.stackTop; i >= 0; i--) {
      const openElement = this.openElements.items[i];
      switch (this.openElements.tagIDs[i]) {
        case TAG_ID.TEMPLATE: {
          if (this.treeAdapter.getNamespaceURI(openElement) === NS.HTML) {
            return {
              parent: this.treeAdapter.getTemplateContent(openElement),
              beforeElement: null,
            };
          }
          break;
        }
        case TAG_ID.TABLE: {
          const parent = this.treeAdapter.getParentNode(openElement);
          if (parent) {
            return { parent, beforeElement: openElement };
          }
          return {
            parent: this.openElements.items[i - 1],
            beforeElement: null,
          };
        }
        // Do nothing
      }
    }
    return { parent: this.openElements.items[0], beforeElement: null };
  }
  _fosterParentElement(element) {
    const location = this._findFosterParentingLocation();
    if (location.beforeElement) {
      this.treeAdapter.insertBefore(
        location.parent,
        element,
        location.beforeElement,
      );
    } else {
      this.treeAdapter.appendChild(location.parent, element);
    }
  }
  //Special elements
  _isSpecialElement(element, id) {
    const ns = this.treeAdapter.getNamespaceURI(element);
    return SPECIAL_ELEMENTS[ns].has(id);
  }
  onCharacter(token) {
    this.skipNextNewLine = false;
    if (this.tokenizer.inForeignNode) {
      characterInForeignContent(this, token);
      return;
    }
    switch (this.insertionMode) {
      case InsertionMode.INITIAL: {
        tokenInInitialMode(this, token);
        break;
      }
      case InsertionMode.BEFORE_HTML: {
        tokenBeforeHtml(this, token);
        break;
      }
      case InsertionMode.BEFORE_HEAD: {
        tokenBeforeHead(this, token);
        break;
      }
      case InsertionMode.IN_HEAD: {
        tokenInHead(this, token);
        break;
      }
      case InsertionMode.IN_HEAD_NO_SCRIPT: {
        tokenInHeadNoScript(this, token);
        break;
      }
      case InsertionMode.AFTER_HEAD: {
        tokenAfterHead(this, token);
        break;
      }
      case InsertionMode.IN_BODY:
      case InsertionMode.IN_CAPTION:
      case InsertionMode.IN_CELL:
      case InsertionMode.IN_TEMPLATE: {
        characterInBody(this, token);
        break;
      }
      case InsertionMode.TEXT:
      case InsertionMode.IN_SELECT:
      case InsertionMode.IN_SELECT_IN_TABLE: {
        this._insertCharacters(token);
        break;
      }
      case InsertionMode.IN_TABLE:
      case InsertionMode.IN_TABLE_BODY:
      case InsertionMode.IN_ROW: {
        characterInTable(this, token);
        break;
      }
      case InsertionMode.IN_TABLE_TEXT: {
        characterInTableText(this, token);
        break;
      }
      case InsertionMode.IN_COLUMN_GROUP: {
        tokenInColumnGroup(this, token);
        break;
      }
      case InsertionMode.AFTER_BODY: {
        tokenAfterBody(this, token);
        break;
      }
      case InsertionMode.AFTER_AFTER_BODY: {
        tokenAfterAfterBody(this, token);
        break;
      }
      // Do nothing
    }
  }
  onNullCharacter(token) {
    this.skipNextNewLine = false;
    if (this.tokenizer.inForeignNode) {
      nullCharacterInForeignContent(this, token);
      return;
    }
    switch (this.insertionMode) {
      case InsertionMode.INITIAL: {
        tokenInInitialMode(this, token);
        break;
      }
      case InsertionMode.BEFORE_HTML: {
        tokenBeforeHtml(this, token);
        break;
      }
      case InsertionMode.BEFORE_HEAD: {
        tokenBeforeHead(this, token);
        break;
      }
      case InsertionMode.IN_HEAD: {
        tokenInHead(this, token);
        break;
      }
      case InsertionMode.IN_HEAD_NO_SCRIPT: {
        tokenInHeadNoScript(this, token);
        break;
      }
      case InsertionMode.AFTER_HEAD: {
        tokenAfterHead(this, token);
        break;
      }
      case InsertionMode.TEXT: {
        this._insertCharacters(token);
        break;
      }
      case InsertionMode.IN_TABLE:
      case InsertionMode.IN_TABLE_BODY:
      case InsertionMode.IN_ROW: {
        characterInTable(this, token);
        break;
      }
      case InsertionMode.IN_COLUMN_GROUP: {
        tokenInColumnGroup(this, token);
        break;
      }
      case InsertionMode.AFTER_BODY: {
        tokenAfterBody(this, token);
        break;
      }
      case InsertionMode.AFTER_AFTER_BODY: {
        tokenAfterAfterBody(this, token);
        break;
      }
      // Do nothing
    }
  }
  onComment(token) {
    this.skipNextNewLine = false;
    if (this.currentNotInHTML) {
      appendComment(this, token);
      return;
    }
    switch (this.insertionMode) {
      case InsertionMode.INITIAL:
      case InsertionMode.BEFORE_HTML:
      case InsertionMode.BEFORE_HEAD:
      case InsertionMode.IN_HEAD:
      case InsertionMode.IN_HEAD_NO_SCRIPT:
      case InsertionMode.AFTER_HEAD:
      case InsertionMode.IN_BODY:
      case InsertionMode.IN_TABLE:
      case InsertionMode.IN_CAPTION:
      case InsertionMode.IN_COLUMN_GROUP:
      case InsertionMode.IN_TABLE_BODY:
      case InsertionMode.IN_ROW:
      case InsertionMode.IN_CELL:
      case InsertionMode.IN_SELECT:
      case InsertionMode.IN_SELECT_IN_TABLE:
      case InsertionMode.IN_TEMPLATE:
      case InsertionMode.IN_FRAMESET:
      case InsertionMode.AFTER_FRAMESET: {
        appendComment(this, token);
        break;
      }
      case InsertionMode.IN_TABLE_TEXT: {
        tokenInTableText(this, token);
        break;
      }
      case InsertionMode.AFTER_BODY: {
        appendCommentToRootHtmlElement(this, token);
        break;
      }
      case InsertionMode.AFTER_AFTER_BODY:
      case InsertionMode.AFTER_AFTER_FRAMESET: {
        appendCommentToDocument(this, token);
        break;
      }
      // Do nothing
    }
  }
  onDoctype(token) {
    this.skipNextNewLine = false;
    switch (this.insertionMode) {
      case InsertionMode.INITIAL: {
        doctypeInInitialMode(this, token);
        break;
      }
      case InsertionMode.BEFORE_HEAD:
      case InsertionMode.IN_HEAD:
      case InsertionMode.IN_HEAD_NO_SCRIPT:
      case InsertionMode.AFTER_HEAD: {
        this._err(token, ERR.misplacedDoctype);
        break;
      }
      case InsertionMode.IN_TABLE_TEXT: {
        tokenInTableText(this, token);
        break;
      }
      // Do nothing
    }
  }
  onStartTag(token) {
    this.skipNextNewLine = false;
    this.currentToken = token;
    this._processStartTag(token);
    if (token.selfClosing && !token.ackSelfClosing) {
      this._err(token, ERR.nonVoidHtmlElementStartTagWithTrailingSolidus);
    }
  }
  /**
   * Processes a given start tag.
   *
   * `onStartTag` checks if a self-closing tag was recognized. When a token
   * is moved inbetween multiple insertion modes, this check for self-closing
   * could lead to false positives. To avoid this, `_processStartTag` is used
   * for nested calls.
   *
   * @param token The token to process.
   */
  _processStartTag(token) {
    if (this.shouldProcessStartTagTokenInForeignContent(token)) {
      startTagInForeignContent(this, token);
    } else {
      this._startTagOutsideForeignContent(token);
    }
  }
  _startTagOutsideForeignContent(token) {
    switch (this.insertionMode) {
      case InsertionMode.INITIAL: {
        tokenInInitialMode(this, token);
        break;
      }
      case InsertionMode.BEFORE_HTML: {
        startTagBeforeHtml(this, token);
        break;
      }
      case InsertionMode.BEFORE_HEAD: {
        startTagBeforeHead(this, token);
        break;
      }
      case InsertionMode.IN_HEAD: {
        startTagInHead(this, token);
        break;
      }
      case InsertionMode.IN_HEAD_NO_SCRIPT: {
        startTagInHeadNoScript(this, token);
        break;
      }
      case InsertionMode.AFTER_HEAD: {
        startTagAfterHead(this, token);
        break;
      }
      case InsertionMode.IN_BODY: {
        startTagInBody(this, token);
        break;
      }
      case InsertionMode.IN_TABLE: {
        startTagInTable(this, token);
        break;
      }
      case InsertionMode.IN_TABLE_TEXT: {
        tokenInTableText(this, token);
        break;
      }
      case InsertionMode.IN_CAPTION: {
        startTagInCaption(this, token);
        break;
      }
      case InsertionMode.IN_COLUMN_GROUP: {
        startTagInColumnGroup(this, token);
        break;
      }
      case InsertionMode.IN_TABLE_BODY: {
        startTagInTableBody(this, token);
        break;
      }
      case InsertionMode.IN_ROW: {
        startTagInRow(this, token);
        break;
      }
      case InsertionMode.IN_CELL: {
        startTagInCell(this, token);
        break;
      }
      case InsertionMode.IN_SELECT: {
        startTagInSelect(this, token);
        break;
      }
      case InsertionMode.IN_SELECT_IN_TABLE: {
        startTagInSelectInTable(this, token);
        break;
      }
      case InsertionMode.IN_TEMPLATE: {
        startTagInTemplate(this, token);
        break;
      }
      case InsertionMode.AFTER_BODY: {
        startTagAfterBody(this, token);
        break;
      }
      case InsertionMode.IN_FRAMESET: {
        startTagInFrameset(this, token);
        break;
      }
      case InsertionMode.AFTER_FRAMESET: {
        startTagAfterFrameset(this, token);
        break;
      }
      case InsertionMode.AFTER_AFTER_BODY: {
        startTagAfterAfterBody(this, token);
        break;
      }
      case InsertionMode.AFTER_AFTER_FRAMESET: {
        startTagAfterAfterFrameset(this, token);
        break;
      }
      // Do nothing
    }
  }
  onEndTag(token) {
    this.skipNextNewLine = false;
    this.currentToken = token;
    if (this.currentNotInHTML) {
      endTagInForeignContent(this, token);
    } else {
      this._endTagOutsideForeignContent(token);
    }
  }
  _endTagOutsideForeignContent(token) {
    switch (this.insertionMode) {
      case InsertionMode.INITIAL: {
        tokenInInitialMode(this, token);
        break;
      }
      case InsertionMode.BEFORE_HTML: {
        endTagBeforeHtml(this, token);
        break;
      }
      case InsertionMode.BEFORE_HEAD: {
        endTagBeforeHead(this, token);
        break;
      }
      case InsertionMode.IN_HEAD: {
        endTagInHead(this, token);
        break;
      }
      case InsertionMode.IN_HEAD_NO_SCRIPT: {
        endTagInHeadNoScript(this, token);
        break;
      }
      case InsertionMode.AFTER_HEAD: {
        endTagAfterHead(this, token);
        break;
      }
      case InsertionMode.IN_BODY: {
        endTagInBody(this, token);
        break;
      }
      case InsertionMode.TEXT: {
        endTagInText(this, token);
        break;
      }
      case InsertionMode.IN_TABLE: {
        endTagInTable(this, token);
        break;
      }
      case InsertionMode.IN_TABLE_TEXT: {
        tokenInTableText(this, token);
        break;
      }
      case InsertionMode.IN_CAPTION: {
        endTagInCaption(this, token);
        break;
      }
      case InsertionMode.IN_COLUMN_GROUP: {
        endTagInColumnGroup(this, token);
        break;
      }
      case InsertionMode.IN_TABLE_BODY: {
        endTagInTableBody(this, token);
        break;
      }
      case InsertionMode.IN_ROW: {
        endTagInRow(this, token);
        break;
      }
      case InsertionMode.IN_CELL: {
        endTagInCell(this, token);
        break;
      }
      case InsertionMode.IN_SELECT: {
        endTagInSelect(this, token);
        break;
      }
      case InsertionMode.IN_SELECT_IN_TABLE: {
        endTagInSelectInTable(this, token);
        break;
      }
      case InsertionMode.IN_TEMPLATE: {
        endTagInTemplate(this, token);
        break;
      }
      case InsertionMode.AFTER_BODY: {
        endTagAfterBody(this, token);
        break;
      }
      case InsertionMode.IN_FRAMESET: {
        endTagInFrameset(this, token);
        break;
      }
      case InsertionMode.AFTER_FRAMESET: {
        endTagAfterFrameset(this, token);
        break;
      }
      case InsertionMode.AFTER_AFTER_BODY: {
        tokenAfterAfterBody(this, token);
        break;
      }
      // Do nothing
    }
  }
  onEof(token) {
    switch (this.insertionMode) {
      case InsertionMode.INITIAL: {
        tokenInInitialMode(this, token);
        break;
      }
      case InsertionMode.BEFORE_HTML: {
        tokenBeforeHtml(this, token);
        break;
      }
      case InsertionMode.BEFORE_HEAD: {
        tokenBeforeHead(this, token);
        break;
      }
      case InsertionMode.IN_HEAD: {
        tokenInHead(this, token);
        break;
      }
      case InsertionMode.IN_HEAD_NO_SCRIPT: {
        tokenInHeadNoScript(this, token);
        break;
      }
      case InsertionMode.AFTER_HEAD: {
        tokenAfterHead(this, token);
        break;
      }
      case InsertionMode.IN_BODY:
      case InsertionMode.IN_TABLE:
      case InsertionMode.IN_CAPTION:
      case InsertionMode.IN_COLUMN_GROUP:
      case InsertionMode.IN_TABLE_BODY:
      case InsertionMode.IN_ROW:
      case InsertionMode.IN_CELL:
      case InsertionMode.IN_SELECT:
      case InsertionMode.IN_SELECT_IN_TABLE: {
        eofInBody(this, token);
        break;
      }
      case InsertionMode.TEXT: {
        eofInText(this, token);
        break;
      }
      case InsertionMode.IN_TABLE_TEXT: {
        tokenInTableText(this, token);
        break;
      }
      case InsertionMode.IN_TEMPLATE: {
        eofInTemplate(this, token);
        break;
      }
      case InsertionMode.AFTER_BODY:
      case InsertionMode.IN_FRAMESET:
      case InsertionMode.AFTER_FRAMESET:
      case InsertionMode.AFTER_AFTER_BODY:
      case InsertionMode.AFTER_AFTER_FRAMESET: {
        stopParsing(this, token);
        break;
      }
      // Do nothing
    }
  }
  onWhitespaceCharacter(token) {
    if (this.skipNextNewLine) {
      this.skipNextNewLine = false;
      if (token.chars.charCodeAt(0) === CODE_POINTS.LINE_FEED) {
        if (token.chars.length === 1) {
          return;
        }
        token.chars = token.chars.substr(1);
      }
    }
    if (this.tokenizer.inForeignNode) {
      this._insertCharacters(token);
      return;
    }
    switch (this.insertionMode) {
      case InsertionMode.IN_HEAD:
      case InsertionMode.IN_HEAD_NO_SCRIPT:
      case InsertionMode.AFTER_HEAD:
      case InsertionMode.TEXT:
      case InsertionMode.IN_COLUMN_GROUP:
      case InsertionMode.IN_SELECT:
      case InsertionMode.IN_SELECT_IN_TABLE:
      case InsertionMode.IN_FRAMESET:
      case InsertionMode.AFTER_FRAMESET: {
        this._insertCharacters(token);
        break;
      }
      case InsertionMode.IN_BODY:
      case InsertionMode.IN_CAPTION:
      case InsertionMode.IN_CELL:
      case InsertionMode.IN_TEMPLATE:
      case InsertionMode.AFTER_BODY:
      case InsertionMode.AFTER_AFTER_BODY:
      case InsertionMode.AFTER_AFTER_FRAMESET: {
        whitespaceCharacterInBody(this, token);
        break;
      }
      case InsertionMode.IN_TABLE:
      case InsertionMode.IN_TABLE_BODY:
      case InsertionMode.IN_ROW: {
        characterInTable(this, token);
        break;
      }
      case InsertionMode.IN_TABLE_TEXT: {
        whitespaceCharacterInTableText(this, token);
        break;
      }
      // Do nothing
    }
  }
};
//Adoption agency algorithm
//(see: http://www.whatwg.org/specs/web-apps/current-work/multipage/tree-construction.html#adoptionAgency)
//------------------------------------------------------------------
//Steps 5-8 of the algorithm
function aaObtainFormattingElementEntry(p, token) {
  let formattingElementEntry =
    p.activeFormattingElements.getElementEntryInScopeWithTagName(token.tagName);
  if (formattingElementEntry) {
    if (!p.openElements.contains(formattingElementEntry.element)) {
      p.activeFormattingElements.removeEntry(formattingElementEntry);
      formattingElementEntry = null;
    } else if (!p.openElements.hasInScope(token.tagID)) {
      formattingElementEntry = null;
    }
  } else {
    genericEndTagInBody(p, token);
  }
  return formattingElementEntry;
}
//Steps 9 and 10 of the algorithm
function aaObtainFurthestBlock(p, formattingElementEntry) {
  let furthestBlock = null;
  let idx = p.openElements.stackTop;
  for (; idx >= 0; idx--) {
    const element = p.openElements.items[idx];
    if (element === formattingElementEntry.element) {
      break;
    }
    if (p._isSpecialElement(element, p.openElements.tagIDs[idx])) {
      furthestBlock = element;
    }
  }
  if (!furthestBlock) {
    p.openElements.shortenToLength(idx < 0 ? 0 : idx);
    p.activeFormattingElements.removeEntry(formattingElementEntry);
  }
  return furthestBlock;
}
//Step 13 of the algorithm
function aaInnerLoop(p, furthestBlock, formattingElement) {
  let lastElement = furthestBlock;
  let nextElement = p.openElements.getCommonAncestor(furthestBlock);
  for (
    let i = 0, element = nextElement;
    element !== formattingElement;
    i++, element = nextElement
  ) {
    //NOTE: store the next element for the next loop iteration (it may be deleted from the stack by step 9.5)
    nextElement = p.openElements.getCommonAncestor(element);
    const elementEntry = p.activeFormattingElements.getElementEntry(element);
    const counterOverflow = elementEntry && i >= AA_INNER_LOOP_ITER;
    const shouldRemoveFromOpenElements = !elementEntry || counterOverflow;
    if (shouldRemoveFromOpenElements) {
      if (counterOverflow) {
        p.activeFormattingElements.removeEntry(elementEntry);
      }
      p.openElements.remove(element);
    } else {
      element = aaRecreateElementFromEntry(p, elementEntry);
      if (lastElement === furthestBlock) {
        p.activeFormattingElements.bookmark = elementEntry;
      }
      p.treeAdapter.detachNode(lastElement);
      p.treeAdapter.appendChild(element, lastElement);
      lastElement = element;
    }
  }
  return lastElement;
}
//Step 13.7 of the algorithm
function aaRecreateElementFromEntry(p, elementEntry) {
  const ns = p.treeAdapter.getNamespaceURI(elementEntry.element);
  const newElement = p.treeAdapter.createElement(
    elementEntry.token.tagName,
    ns,
    elementEntry.token.attrs,
  );
  p.openElements.replace(elementEntry.element, newElement);
  elementEntry.element = newElement;
  return newElement;
}
//Step 14 of the algorithm
function aaInsertLastNodeInCommonAncestor(p, commonAncestor, lastElement) {
  const tn = p.treeAdapter.getTagName(commonAncestor);
  const tid = getTagID(tn);
  if (p._isElementCausesFosterParenting(tid)) {
    p._fosterParentElement(lastElement);
  } else {
    const ns = p.treeAdapter.getNamespaceURI(commonAncestor);
    if (tid === TAG_ID.TEMPLATE && ns === NS.HTML) {
      commonAncestor = p.treeAdapter.getTemplateContent(commonAncestor);
    }
    p.treeAdapter.appendChild(commonAncestor, lastElement);
  }
}
//Steps 15-19 of the algorithm
function aaReplaceFormattingElement(p, furthestBlock, formattingElementEntry) {
  const ns = p.treeAdapter.getNamespaceURI(formattingElementEntry.element);
  const { token } = formattingElementEntry;
  const newElement = p.treeAdapter.createElement(
    token.tagName,
    ns,
    token.attrs,
  );
  p._adoptNodes(furthestBlock, newElement);
  p.treeAdapter.appendChild(furthestBlock, newElement);
  p.activeFormattingElements.insertElementAfterBookmark(newElement, token);
  p.activeFormattingElements.removeEntry(formattingElementEntry);
  p.openElements.remove(formattingElementEntry.element);
  p.openElements.insertAfter(furthestBlock, newElement, token.tagID);
}
//Algorithm entry point
function callAdoptionAgency(p, token) {
  for (let i = 0; i < AA_OUTER_LOOP_ITER; i++) {
    const formattingElementEntry = aaObtainFormattingElementEntry(p, token);
    if (!formattingElementEntry) {
      break;
    }
    const furthestBlock = aaObtainFurthestBlock(p, formattingElementEntry);
    if (!furthestBlock) {
      break;
    }
    p.activeFormattingElements.bookmark = formattingElementEntry;
    const lastElement = aaInnerLoop(
      p,
      furthestBlock,
      formattingElementEntry.element,
    );
    const commonAncestor = p.openElements.getCommonAncestor(
      formattingElementEntry.element,
    );
    p.treeAdapter.detachNode(lastElement);
    if (commonAncestor)
      aaInsertLastNodeInCommonAncestor(p, commonAncestor, lastElement);
    aaReplaceFormattingElement(p, furthestBlock, formattingElementEntry);
  }
}
//Generic token handlers
//------------------------------------------------------------------
function appendComment(p, token) {
  p._appendCommentNode(token, p.openElements.currentTmplContentOrNode);
}
function appendCommentToRootHtmlElement(p, token) {
  p._appendCommentNode(token, p.openElements.items[0]);
}
function appendCommentToDocument(p, token) {
  p._appendCommentNode(token, p.document);
}
function stopParsing(p, token) {
  p.stopped = true;
  // NOTE: Set end locations for elements that remain on the open element stack.
  if (token.location) {
    // NOTE: If we are not in a fragment, `html` and `body` will stay on the stack.
    // This is a problem, as we might overwrite their end position here.
    const target = p.fragmentContext ? 0 : 2;
    for (let i = p.openElements.stackTop; i >= target; i--) {
      p._setEndLocation(p.openElements.items[i], token);
    }
    // Handle `html` and `body`
    if (!p.fragmentContext && p.openElements.stackTop >= 0) {
      const htmlElement = p.openElements.items[0];
      const htmlLocation = p.treeAdapter.getNodeSourceCodeLocation(htmlElement);
      if (htmlLocation && !htmlLocation.endTag) {
        p._setEndLocation(htmlElement, token);
        if (p.openElements.stackTop >= 1) {
          const bodyElement = p.openElements.items[1];
          const bodyLocation =
            p.treeAdapter.getNodeSourceCodeLocation(bodyElement);
          if (bodyLocation && !bodyLocation.endTag) {
            p._setEndLocation(bodyElement, token);
          }
        }
      }
    }
  }
}
// The "initial" insertion mode
//------------------------------------------------------------------
function doctypeInInitialMode(p, token) {
  p._setDocumentType(token);
  const mode = token.forceQuirks
    ? DOCUMENT_MODE.QUIRKS
    : getDocumentMode(token);
  if (!isConforming(token)) {
    p._err(token, ERR.nonConformingDoctype);
  }
  p.treeAdapter.setDocumentMode(p.document, mode);
  p.insertionMode = InsertionMode.BEFORE_HTML;
}
function tokenInInitialMode(p, token) {
  p._err(token, ERR.missingDoctype, true);
  p.treeAdapter.setDocumentMode(p.document, DOCUMENT_MODE.QUIRKS);
  p.insertionMode = InsertionMode.BEFORE_HTML;
  p._processToken(token);
}
// The "before html" insertion mode
//------------------------------------------------------------------
function startTagBeforeHtml(p, token) {
  if (token.tagID === TAG_ID.HTML) {
    p._insertElement(token, NS.HTML);
    p.insertionMode = InsertionMode.BEFORE_HEAD;
  } else {
    tokenBeforeHtml(p, token);
  }
}
function endTagBeforeHtml(p, token) {
  const tn = token.tagID;
  if (
    tn === TAG_ID.HTML ||
    tn === TAG_ID.HEAD ||
    tn === TAG_ID.BODY ||
    tn === TAG_ID.BR
  ) {
    tokenBeforeHtml(p, token);
  }
}
function tokenBeforeHtml(p, token) {
  p._insertFakeRootElement();
  p.insertionMode = InsertionMode.BEFORE_HEAD;
  p._processToken(token);
}
// The "before head" insertion mode
//------------------------------------------------------------------
function startTagBeforeHead(p, token) {
  switch (token.tagID) {
    case TAG_ID.HTML: {
      startTagInBody(p, token);
      break;
    }
    case TAG_ID.HEAD: {
      p._insertElement(token, NS.HTML);
      p.headElement = p.openElements.current;
      p.insertionMode = InsertionMode.IN_HEAD;
      break;
    }
    default: {
      tokenBeforeHead(p, token);
    }
  }
}
function endTagBeforeHead(p, token) {
  const tn = token.tagID;
  if (
    tn === TAG_ID.HEAD ||
    tn === TAG_ID.BODY ||
    tn === TAG_ID.HTML ||
    tn === TAG_ID.BR
  ) {
    tokenBeforeHead(p, token);
  } else {
    p._err(token, ERR.endTagWithoutMatchingOpenElement);
  }
}
function tokenBeforeHead(p, token) {
  p._insertFakeElement(TAG_NAMES.HEAD, TAG_ID.HEAD);
  p.headElement = p.openElements.current;
  p.insertionMode = InsertionMode.IN_HEAD;
  p._processToken(token);
}
// The "in head" insertion mode
//------------------------------------------------------------------
function startTagInHead(p, token) {
  switch (token.tagID) {
    case TAG_ID.HTML: {
      startTagInBody(p, token);
      break;
    }
    case TAG_ID.BASE:
    case TAG_ID.BASEFONT:
    case TAG_ID.BGSOUND:
    case TAG_ID.LINK:
    case TAG_ID.META: {
      p._appendElement(token, NS.HTML);
      token.ackSelfClosing = true;
      break;
    }
    case TAG_ID.TITLE: {
      p._switchToTextParsing(token, TokenizerMode.RCDATA);
      break;
    }
    case TAG_ID.NOSCRIPT: {
      if (p.options.scriptingEnabled) {
        p._switchToTextParsing(token, TokenizerMode.RAWTEXT);
      } else {
        p._insertElement(token, NS.HTML);
        p.insertionMode = InsertionMode.IN_HEAD_NO_SCRIPT;
      }
      break;
    }
    case TAG_ID.NOFRAMES:
    case TAG_ID.STYLE: {
      p._switchToTextParsing(token, TokenizerMode.RAWTEXT);
      break;
    }
    case TAG_ID.SCRIPT: {
      p._switchToTextParsing(token, TokenizerMode.SCRIPT_DATA);
      break;
    }
    case TAG_ID.TEMPLATE: {
      p._insertTemplate(token);
      p.activeFormattingElements.insertMarker();
      p.framesetOk = false;
      p.insertionMode = InsertionMode.IN_TEMPLATE;
      p.tmplInsertionModeStack.unshift(InsertionMode.IN_TEMPLATE);
      break;
    }
    case TAG_ID.HEAD: {
      p._err(token, ERR.misplacedStartTagForHeadElement);
      break;
    }
    default: {
      tokenInHead(p, token);
    }
  }
}
function endTagInHead(p, token) {
  switch (token.tagID) {
    case TAG_ID.HEAD: {
      p.openElements.pop();
      p.insertionMode = InsertionMode.AFTER_HEAD;
      break;
    }
    case TAG_ID.BODY:
    case TAG_ID.BR:
    case TAG_ID.HTML: {
      tokenInHead(p, token);
      break;
    }
    case TAG_ID.TEMPLATE: {
      templateEndTagInHead(p, token);
      break;
    }
    default: {
      p._err(token, ERR.endTagWithoutMatchingOpenElement);
    }
  }
}
function templateEndTagInHead(p, token) {
  if (p.openElements.tmplCount > 0) {
    p.openElements.generateImpliedEndTagsThoroughly();
    if (p.openElements.currentTagId !== TAG_ID.TEMPLATE) {
      p._err(token, ERR.closingOfElementWithOpenChildElements);
    }
    p.openElements.popUntilTagNamePopped(TAG_ID.TEMPLATE);
    p.activeFormattingElements.clearToLastMarker();
    p.tmplInsertionModeStack.shift();
    p._resetInsertionMode();
  } else {
    p._err(token, ERR.endTagWithoutMatchingOpenElement);
  }
}
function tokenInHead(p, token) {
  p.openElements.pop();
  p.insertionMode = InsertionMode.AFTER_HEAD;
  p._processToken(token);
}
// The "in head no script" insertion mode
//------------------------------------------------------------------
function startTagInHeadNoScript(p, token) {
  switch (token.tagID) {
    case TAG_ID.HTML: {
      startTagInBody(p, token);
      break;
    }
    case TAG_ID.BASEFONT:
    case TAG_ID.BGSOUND:
    case TAG_ID.HEAD:
    case TAG_ID.LINK:
    case TAG_ID.META:
    case TAG_ID.NOFRAMES:
    case TAG_ID.STYLE: {
      startTagInHead(p, token);
      break;
    }
    case TAG_ID.NOSCRIPT: {
      p._err(token, ERR.nestedNoscriptInHead);
      break;
    }
    default: {
      tokenInHeadNoScript(p, token);
    }
  }
}
function endTagInHeadNoScript(p, token) {
  switch (token.tagID) {
    case TAG_ID.NOSCRIPT: {
      p.openElements.pop();
      p.insertionMode = InsertionMode.IN_HEAD;
      break;
    }
    case TAG_ID.BR: {
      tokenInHeadNoScript(p, token);
      break;
    }
    default: {
      p._err(token, ERR.endTagWithoutMatchingOpenElement);
    }
  }
}
function tokenInHeadNoScript(p, token) {
  const errCode =
    token.type === TokenType.EOF
      ? ERR.openElementsLeftAfterEof
      : ERR.disallowedContentInNoscriptInHead;
  p._err(token, errCode);
  p.openElements.pop();
  p.insertionMode = InsertionMode.IN_HEAD;
  p._processToken(token);
}
// The "after head" insertion mode
//------------------------------------------------------------------
function startTagAfterHead(p, token) {
  switch (token.tagID) {
    case TAG_ID.HTML: {
      startTagInBody(p, token);
      break;
    }
    case TAG_ID.BODY: {
      p._insertElement(token, NS.HTML);
      p.framesetOk = false;
      p.insertionMode = InsertionMode.IN_BODY;
      break;
    }
    case TAG_ID.FRAMESET: {
      p._insertElement(token, NS.HTML);
      p.insertionMode = InsertionMode.IN_FRAMESET;
      break;
    }
    case TAG_ID.BASE:
    case TAG_ID.BASEFONT:
    case TAG_ID.BGSOUND:
    case TAG_ID.LINK:
    case TAG_ID.META:
    case TAG_ID.NOFRAMES:
    case TAG_ID.SCRIPT:
    case TAG_ID.STYLE:
    case TAG_ID.TEMPLATE:
    case TAG_ID.TITLE: {
      p._err(token, ERR.abandonedHeadElementChild);
      p.openElements.push(p.headElement, TAG_ID.HEAD);
      startTagInHead(p, token);
      p.openElements.remove(p.headElement);
      break;
    }
    case TAG_ID.HEAD: {
      p._err(token, ERR.misplacedStartTagForHeadElement);
      break;
    }
    default: {
      tokenAfterHead(p, token);
    }
  }
}
function endTagAfterHead(p, token) {
  switch (token.tagID) {
    case TAG_ID.BODY:
    case TAG_ID.HTML:
    case TAG_ID.BR: {
      tokenAfterHead(p, token);
      break;
    }
    case TAG_ID.TEMPLATE: {
      templateEndTagInHead(p, token);
      break;
    }
    default: {
      p._err(token, ERR.endTagWithoutMatchingOpenElement);
    }
  }
}
function tokenAfterHead(p, token) {
  p._insertFakeElement(TAG_NAMES.BODY, TAG_ID.BODY);
  p.insertionMode = InsertionMode.IN_BODY;
  modeInBody(p, token);
}
// The "in body" insertion mode
//------------------------------------------------------------------
function modeInBody(p, token) {
  switch (token.type) {
    case TokenType.CHARACTER: {
      characterInBody(p, token);
      break;
    }
    case TokenType.WHITESPACE_CHARACTER: {
      whitespaceCharacterInBody(p, token);
      break;
    }
    case TokenType.COMMENT: {
      appendComment(p, token);
      break;
    }
    case TokenType.START_TAG: {
      startTagInBody(p, token);
      break;
    }
    case TokenType.END_TAG: {
      endTagInBody(p, token);
      break;
    }
    case TokenType.EOF: {
      eofInBody(p, token);
      break;
    }
    // Do nothing
  }
}
function whitespaceCharacterInBody(p, token) {
  p._reconstructActiveFormattingElements();
  p._insertCharacters(token);
}
function characterInBody(p, token) {
  p._reconstructActiveFormattingElements();
  p._insertCharacters(token);
  p.framesetOk = false;
}
function htmlStartTagInBody(p, token) {
  if (p.openElements.tmplCount === 0) {
    p.treeAdapter.adoptAttributes(p.openElements.items[0], token.attrs);
  }
}
function bodyStartTagInBody(p, token) {
  const bodyElement = p.openElements.tryPeekProperlyNestedBodyElement();
  if (bodyElement && p.openElements.tmplCount === 0) {
    p.framesetOk = false;
    p.treeAdapter.adoptAttributes(bodyElement, token.attrs);
  }
}
function framesetStartTagInBody(p, token) {
  const bodyElement = p.openElements.tryPeekProperlyNestedBodyElement();
  if (p.framesetOk && bodyElement) {
    p.treeAdapter.detachNode(bodyElement);
    p.openElements.popAllUpToHtmlElement();
    p._insertElement(token, NS.HTML);
    p.insertionMode = InsertionMode.IN_FRAMESET;
  }
}
function addressStartTagInBody(p, token) {
  if (p.openElements.hasInButtonScope(TAG_ID.P)) {
    p._closePElement();
  }
  p._insertElement(token, NS.HTML);
}
function numberedHeaderStartTagInBody(p, token) {
  if (p.openElements.hasInButtonScope(TAG_ID.P)) {
    p._closePElement();
  }
  if (isNumberedHeader(p.openElements.currentTagId)) {
    p.openElements.pop();
  }
  p._insertElement(token, NS.HTML);
}
function preStartTagInBody(p, token) {
  if (p.openElements.hasInButtonScope(TAG_ID.P)) {
    p._closePElement();
  }
  p._insertElement(token, NS.HTML);
  //NOTE: If the next token is a U+000A LINE FEED (LF) character token, then ignore that token and move
  //on to the next one. (Newlines at the start of pre blocks are ignored as an authoring convenience.)
  p.skipNextNewLine = true;
  p.framesetOk = false;
}
function formStartTagInBody(p, token) {
  const inTemplate = p.openElements.tmplCount > 0;
  if (!p.formElement || inTemplate) {
    if (p.openElements.hasInButtonScope(TAG_ID.P)) {
      p._closePElement();
    }
    p._insertElement(token, NS.HTML);
    if (!inTemplate) {
      p.formElement = p.openElements.current;
    }
  }
}
function listItemStartTagInBody(p, token) {
  p.framesetOk = false;
  const tn = token.tagID;
  for (let i = p.openElements.stackTop; i >= 0; i--) {
    const elementId = p.openElements.tagIDs[i];
    if (
      (tn === TAG_ID.LI && elementId === TAG_ID.LI) ||
      ((tn === TAG_ID.DD || tn === TAG_ID.DT) &&
        (elementId === TAG_ID.DD || elementId === TAG_ID.DT))
    ) {
      p.openElements.generateImpliedEndTagsWithExclusion(elementId);
      p.openElements.popUntilTagNamePopped(elementId);
      break;
    }
    if (
      elementId !== TAG_ID.ADDRESS &&
      elementId !== TAG_ID.DIV &&
      elementId !== TAG_ID.P &&
      p._isSpecialElement(p.openElements.items[i], elementId)
    ) {
      break;
    }
  }
  if (p.openElements.hasInButtonScope(TAG_ID.P)) {
    p._closePElement();
  }
  p._insertElement(token, NS.HTML);
}
function plaintextStartTagInBody(p, token) {
  if (p.openElements.hasInButtonScope(TAG_ID.P)) {
    p._closePElement();
  }
  p._insertElement(token, NS.HTML);
  p.tokenizer.state = TokenizerMode.PLAINTEXT;
}
function buttonStartTagInBody(p, token) {
  if (p.openElements.hasInScope(TAG_ID.BUTTON)) {
    p.openElements.generateImpliedEndTags();
    p.openElements.popUntilTagNamePopped(TAG_ID.BUTTON);
  }
  p._reconstructActiveFormattingElements();
  p._insertElement(token, NS.HTML);
  p.framesetOk = false;
}
function aStartTagInBody(p, token) {
  const activeElementEntry =
    p.activeFormattingElements.getElementEntryInScopeWithTagName(TAG_NAMES.A);
  if (activeElementEntry) {
    callAdoptionAgency(p, token);
    p.openElements.remove(activeElementEntry.element);
    p.activeFormattingElements.removeEntry(activeElementEntry);
  }
  p._reconstructActiveFormattingElements();
  p._insertElement(token, NS.HTML);
  p.activeFormattingElements.pushElement(p.openElements.current, token);
}
function bStartTagInBody(p, token) {
  p._reconstructActiveFormattingElements();
  p._insertElement(token, NS.HTML);
  p.activeFormattingElements.pushElement(p.openElements.current, token);
}
function nobrStartTagInBody(p, token) {
  p._reconstructActiveFormattingElements();
  if (p.openElements.hasInScope(TAG_ID.NOBR)) {
    callAdoptionAgency(p, token);
    p._reconstructActiveFormattingElements();
  }
  p._insertElement(token, NS.HTML);
  p.activeFormattingElements.pushElement(p.openElements.current, token);
}
function appletStartTagInBody(p, token) {
  p._reconstructActiveFormattingElements();
  p._insertElement(token, NS.HTML);
  p.activeFormattingElements.insertMarker();
  p.framesetOk = false;
}
function tableStartTagInBody(p, token) {
  if (
    p.treeAdapter.getDocumentMode(p.document) !== DOCUMENT_MODE.QUIRKS &&
    p.openElements.hasInButtonScope(TAG_ID.P)
  ) {
    p._closePElement();
  }
  p._insertElement(token, NS.HTML);
  p.framesetOk = false;
  p.insertionMode = InsertionMode.IN_TABLE;
}
function areaStartTagInBody(p, token) {
  p._reconstructActiveFormattingElements();
  p._appendElement(token, NS.HTML);
  p.framesetOk = false;
  token.ackSelfClosing = true;
}
function isHiddenInput(token) {
  const inputType = getTokenAttr(token, ATTRS.TYPE);
  return inputType != null && inputType.toLowerCase() === HIDDEN_INPUT_TYPE;
}
function inputStartTagInBody(p, token) {
  p._reconstructActiveFormattingElements();
  p._appendElement(token, NS.HTML);
  if (!isHiddenInput(token)) {
    p.framesetOk = false;
  }
  token.ackSelfClosing = true;
}
function paramStartTagInBody(p, token) {
  p._appendElement(token, NS.HTML);
  token.ackSelfClosing = true;
}
function hrStartTagInBody(p, token) {
  if (p.openElements.hasInButtonScope(TAG_ID.P)) {
    p._closePElement();
  }
  p._appendElement(token, NS.HTML);
  p.framesetOk = false;
  token.ackSelfClosing = true;
}
function imageStartTagInBody(p, token) {
  token.tagName = TAG_NAMES.IMG;
  token.tagID = TAG_ID.IMG;
  areaStartTagInBody(p, token);
}
function textareaStartTagInBody(p, token) {
  p._insertElement(token, NS.HTML);
  //NOTE: If the next token is a U+000A LINE FEED (LF) character token, then ignore that token and move
  //on to the next one. (Newlines at the start of textarea elements are ignored as an authoring convenience.)
  p.skipNextNewLine = true;
  p.tokenizer.state = TokenizerMode.RCDATA;
  p.originalInsertionMode = p.insertionMode;
  p.framesetOk = false;
  p.insertionMode = InsertionMode.TEXT;
}
function xmpStartTagInBody(p, token) {
  if (p.openElements.hasInButtonScope(TAG_ID.P)) {
    p._closePElement();
  }
  p._reconstructActiveFormattingElements();
  p.framesetOk = false;
  p._switchToTextParsing(token, TokenizerMode.RAWTEXT);
}
function iframeStartTagInBody(p, token) {
  p.framesetOk = false;
  p._switchToTextParsing(token, TokenizerMode.RAWTEXT);
}
//NOTE: here we assume that we always act as an user agent with enabled plugins, so we parse
//<noembed> as rawtext.
function noembedStartTagInBody(p, token) {
  p._switchToTextParsing(token, TokenizerMode.RAWTEXT);
}
function selectStartTagInBody(p, token) {
  p._reconstructActiveFormattingElements();
  p._insertElement(token, NS.HTML);
  p.framesetOk = false;
  p.insertionMode =
    p.insertionMode === InsertionMode.IN_TABLE ||
    p.insertionMode === InsertionMode.IN_CAPTION ||
    p.insertionMode === InsertionMode.IN_TABLE_BODY ||
    p.insertionMode === InsertionMode.IN_ROW ||
    p.insertionMode === InsertionMode.IN_CELL
      ? InsertionMode.IN_SELECT_IN_TABLE
      : InsertionMode.IN_SELECT;
}
function optgroupStartTagInBody(p, token) {
  if (p.openElements.currentTagId === TAG_ID.OPTION) {
    p.openElements.pop();
  }
  p._reconstructActiveFormattingElements();
  p._insertElement(token, NS.HTML);
}
function rbStartTagInBody(p, token) {
  if (p.openElements.hasInScope(TAG_ID.RUBY)) {
    p.openElements.generateImpliedEndTags();
  }
  p._insertElement(token, NS.HTML);
}
function rtStartTagInBody(p, token) {
  if (p.openElements.hasInScope(TAG_ID.RUBY)) {
    p.openElements.generateImpliedEndTagsWithExclusion(TAG_ID.RTC);
  }
  p._insertElement(token, NS.HTML);
}
function mathStartTagInBody(p, token) {
  p._reconstructActiveFormattingElements();
  adjustTokenMathMLAttrs(token);
  adjustTokenXMLAttrs(token);
  if (token.selfClosing) {
    p._appendElement(token, NS.MATHML);
  } else {
    p._insertElement(token, NS.MATHML);
  }
  token.ackSelfClosing = true;
}
function svgStartTagInBody(p, token) {
  p._reconstructActiveFormattingElements();
  adjustTokenSVGAttrs(token);
  adjustTokenXMLAttrs(token);
  if (token.selfClosing) {
    p._appendElement(token, NS.SVG);
  } else {
    p._insertElement(token, NS.SVG);
  }
  token.ackSelfClosing = true;
}
function genericStartTagInBody(p, token) {
  p._reconstructActiveFormattingElements();
  p._insertElement(token, NS.HTML);
}
function startTagInBody(p, token) {
  switch (token.tagID) {
    case TAG_ID.I:
    case TAG_ID.S:
    case TAG_ID.B:
    case TAG_ID.U:
    case TAG_ID.EM:
    case TAG_ID.TT:
    case TAG_ID.BIG:
    case TAG_ID.CODE:
    case TAG_ID.FONT:
    case TAG_ID.SMALL:
    case TAG_ID.STRIKE:
    case TAG_ID.STRONG: {
      bStartTagInBody(p, token);
      break;
    }
    case TAG_ID.A: {
      aStartTagInBody(p, token);
      break;
    }
    case TAG_ID.H1:
    case TAG_ID.H2:
    case TAG_ID.H3:
    case TAG_ID.H4:
    case TAG_ID.H5:
    case TAG_ID.H6: {
      numberedHeaderStartTagInBody(p, token);
      break;
    }
    case TAG_ID.P:
    case TAG_ID.DL:
    case TAG_ID.OL:
    case TAG_ID.UL:
    case TAG_ID.DIV:
    case TAG_ID.DIR:
    case TAG_ID.NAV:
    case TAG_ID.MAIN:
    case TAG_ID.MENU:
    case TAG_ID.ASIDE:
    case TAG_ID.CENTER:
    case TAG_ID.FIGURE:
    case TAG_ID.FOOTER:
    case TAG_ID.HEADER:
    case TAG_ID.HGROUP:
    case TAG_ID.DIALOG:
    case TAG_ID.DETAILS:
    case TAG_ID.ADDRESS:
    case TAG_ID.ARTICLE:
    case TAG_ID.SECTION:
    case TAG_ID.SUMMARY:
    case TAG_ID.FIELDSET:
    case TAG_ID.BLOCKQUOTE:
    case TAG_ID.FIGCAPTION: {
      addressStartTagInBody(p, token);
      break;
    }
    case TAG_ID.LI:
    case TAG_ID.DD:
    case TAG_ID.DT: {
      listItemStartTagInBody(p, token);
      break;
    }
    case TAG_ID.BR:
    case TAG_ID.IMG:
    case TAG_ID.WBR:
    case TAG_ID.AREA:
    case TAG_ID.EMBED:
    case TAG_ID.KEYGEN: {
      areaStartTagInBody(p, token);
      break;
    }
    case TAG_ID.HR: {
      hrStartTagInBody(p, token);
      break;
    }
    case TAG_ID.RB:
    case TAG_ID.RTC: {
      rbStartTagInBody(p, token);
      break;
    }
    case TAG_ID.RT:
    case TAG_ID.RP: {
      rtStartTagInBody(p, token);
      break;
    }
    case TAG_ID.PRE:
    case TAG_ID.LISTING: {
      preStartTagInBody(p, token);
      break;
    }
    case TAG_ID.XMP: {
      xmpStartTagInBody(p, token);
      break;
    }
    case TAG_ID.SVG: {
      svgStartTagInBody(p, token);
      break;
    }
    case TAG_ID.HTML: {
      htmlStartTagInBody(p, token);
      break;
    }
    case TAG_ID.BASE:
    case TAG_ID.LINK:
    case TAG_ID.META:
    case TAG_ID.STYLE:
    case TAG_ID.TITLE:
    case TAG_ID.SCRIPT:
    case TAG_ID.BGSOUND:
    case TAG_ID.BASEFONT:
    case TAG_ID.TEMPLATE: {
      startTagInHead(p, token);
      break;
    }
    case TAG_ID.BODY: {
      bodyStartTagInBody(p, token);
      break;
    }
    case TAG_ID.FORM: {
      formStartTagInBody(p, token);
      break;
    }
    case TAG_ID.NOBR: {
      nobrStartTagInBody(p, token);
      break;
    }
    case TAG_ID.MATH: {
      mathStartTagInBody(p, token);
      break;
    }
    case TAG_ID.TABLE: {
      tableStartTagInBody(p, token);
      break;
    }
    case TAG_ID.INPUT: {
      inputStartTagInBody(p, token);
      break;
    }
    case TAG_ID.PARAM:
    case TAG_ID.TRACK:
    case TAG_ID.SOURCE: {
      paramStartTagInBody(p, token);
      break;
    }
    case TAG_ID.IMAGE: {
      imageStartTagInBody(p, token);
      break;
    }
    case TAG_ID.BUTTON: {
      buttonStartTagInBody(p, token);
      break;
    }
    case TAG_ID.APPLET:
    case TAG_ID.OBJECT:
    case TAG_ID.MARQUEE: {
      appletStartTagInBody(p, token);
      break;
    }
    case TAG_ID.IFRAME: {
      iframeStartTagInBody(p, token);
      break;
    }
    case TAG_ID.SELECT: {
      selectStartTagInBody(p, token);
      break;
    }
    case TAG_ID.OPTION:
    case TAG_ID.OPTGROUP: {
      optgroupStartTagInBody(p, token);
      break;
    }
    case TAG_ID.NOEMBED: {
      noembedStartTagInBody(p, token);
      break;
    }
    case TAG_ID.FRAMESET: {
      framesetStartTagInBody(p, token);
      break;
    }
    case TAG_ID.TEXTAREA: {
      textareaStartTagInBody(p, token);
      break;
    }
    case TAG_ID.NOSCRIPT: {
      if (p.options.scriptingEnabled) {
        noembedStartTagInBody(p, token);
      } else {
        genericStartTagInBody(p, token);
      }
      break;
    }
    case TAG_ID.PLAINTEXT: {
      plaintextStartTagInBody(p, token);
      break;
    }
    case TAG_ID.COL:
    case TAG_ID.TH:
    case TAG_ID.TD:
    case TAG_ID.TR:
    case TAG_ID.HEAD:
    case TAG_ID.FRAME:
    case TAG_ID.TBODY:
    case TAG_ID.TFOOT:
    case TAG_ID.THEAD:
    case TAG_ID.CAPTION:
    case TAG_ID.COLGROUP: {
      // Ignore token
      break;
    }
    default: {
      genericStartTagInBody(p, token);
    }
  }
}
function bodyEndTagInBody(p, token) {
  if (p.openElements.hasInScope(TAG_ID.BODY)) {
    p.insertionMode = InsertionMode.AFTER_BODY;
    //NOTE: <body> is never popped from the stack, so we need to updated
    //the end location explicitly.
    if (p.options.sourceCodeLocationInfo) {
      const bodyElement = p.openElements.tryPeekProperlyNestedBodyElement();
      if (bodyElement) {
        p._setEndLocation(bodyElement, token);
      }
    }
  }
}
function htmlEndTagInBody(p, token) {
  if (p.openElements.hasInScope(TAG_ID.BODY)) {
    p.insertionMode = InsertionMode.AFTER_BODY;
    endTagAfterBody(p, token);
  }
}
function addressEndTagInBody(p, token) {
  const tn = token.tagID;
  if (p.openElements.hasInScope(tn)) {
    p.openElements.generateImpliedEndTags();
    p.openElements.popUntilTagNamePopped(tn);
  }
}
function formEndTagInBody(p) {
  const inTemplate = p.openElements.tmplCount > 0;
  const { formElement } = p;
  if (!inTemplate) {
    p.formElement = null;
  }
  if ((formElement || inTemplate) && p.openElements.hasInScope(TAG_ID.FORM)) {
    p.openElements.generateImpliedEndTags();
    if (inTemplate) {
      p.openElements.popUntilTagNamePopped(TAG_ID.FORM);
    } else if (formElement) {
      p.openElements.remove(formElement);
    }
  }
}
function pEndTagInBody(p) {
  if (!p.openElements.hasInButtonScope(TAG_ID.P)) {
    p._insertFakeElement(TAG_NAMES.P, TAG_ID.P);
  }
  p._closePElement();
}
function liEndTagInBody(p) {
  if (p.openElements.hasInListItemScope(TAG_ID.LI)) {
    p.openElements.generateImpliedEndTagsWithExclusion(TAG_ID.LI);
    p.openElements.popUntilTagNamePopped(TAG_ID.LI);
  }
}
function ddEndTagInBody(p, token) {
  const tn = token.tagID;
  if (p.openElements.hasInScope(tn)) {
    p.openElements.generateImpliedEndTagsWithExclusion(tn);
    p.openElements.popUntilTagNamePopped(tn);
  }
}
function numberedHeaderEndTagInBody(p) {
  if (p.openElements.hasNumberedHeaderInScope()) {
    p.openElements.generateImpliedEndTags();
    p.openElements.popUntilNumberedHeaderPopped();
  }
}
function appletEndTagInBody(p, token) {
  const tn = token.tagID;
  if (p.openElements.hasInScope(tn)) {
    p.openElements.generateImpliedEndTags();
    p.openElements.popUntilTagNamePopped(tn);
    p.activeFormattingElements.clearToLastMarker();
  }
}
function brEndTagInBody(p) {
  p._reconstructActiveFormattingElements();
  p._insertFakeElement(TAG_NAMES.BR, TAG_ID.BR);
  p.openElements.pop();
  p.framesetOk = false;
}
function genericEndTagInBody(p, token) {
  const tn = token.tagName;
  const tid = token.tagID;
  for (let i = p.openElements.stackTop; i > 0; i--) {
    const element = p.openElements.items[i];
    const elementId = p.openElements.tagIDs[i];
    // Compare the tag name here, as the tag might not be a known tag with an ID.
    if (
      tid === elementId &&
      (tid !== TAG_ID.UNKNOWN || p.treeAdapter.getTagName(element) === tn)
    ) {
      p.openElements.generateImpliedEndTagsWithExclusion(tid);
      if (p.openElements.stackTop >= i) p.openElements.shortenToLength(i);
      break;
    }
    if (p._isSpecialElement(element, elementId)) {
      break;
    }
  }
}
function endTagInBody(p, token) {
  switch (token.tagID) {
    case TAG_ID.A:
    case TAG_ID.B:
    case TAG_ID.I:
    case TAG_ID.S:
    case TAG_ID.U:
    case TAG_ID.EM:
    case TAG_ID.TT:
    case TAG_ID.BIG:
    case TAG_ID.CODE:
    case TAG_ID.FONT:
    case TAG_ID.NOBR:
    case TAG_ID.SMALL:
    case TAG_ID.STRIKE:
    case TAG_ID.STRONG: {
      callAdoptionAgency(p, token);
      break;
    }
    case TAG_ID.P: {
      pEndTagInBody(p);
      break;
    }
    case TAG_ID.DL:
    case TAG_ID.UL:
    case TAG_ID.OL:
    case TAG_ID.DIR:
    case TAG_ID.DIV:
    case TAG_ID.NAV:
    case TAG_ID.PRE:
    case TAG_ID.MAIN:
    case TAG_ID.MENU:
    case TAG_ID.ASIDE:
    case TAG_ID.BUTTON:
    case TAG_ID.CENTER:
    case TAG_ID.FIGURE:
    case TAG_ID.FOOTER:
    case TAG_ID.HEADER:
    case TAG_ID.HGROUP:
    case TAG_ID.DIALOG:
    case TAG_ID.ADDRESS:
    case TAG_ID.ARTICLE:
    case TAG_ID.DETAILS:
    case TAG_ID.SECTION:
    case TAG_ID.SUMMARY:
    case TAG_ID.LISTING:
    case TAG_ID.FIELDSET:
    case TAG_ID.BLOCKQUOTE:
    case TAG_ID.FIGCAPTION: {
      addressEndTagInBody(p, token);
      break;
    }
    case TAG_ID.LI: {
      liEndTagInBody(p);
      break;
    }
    case TAG_ID.DD:
    case TAG_ID.DT: {
      ddEndTagInBody(p, token);
      break;
    }
    case TAG_ID.H1:
    case TAG_ID.H2:
    case TAG_ID.H3:
    case TAG_ID.H4:
    case TAG_ID.H5:
    case TAG_ID.H6: {
      numberedHeaderEndTagInBody(p);
      break;
    }
    case TAG_ID.BR: {
      brEndTagInBody(p);
      break;
    }
    case TAG_ID.BODY: {
      bodyEndTagInBody(p, token);
      break;
    }
    case TAG_ID.HTML: {
      htmlEndTagInBody(p, token);
      break;
    }
    case TAG_ID.FORM: {
      formEndTagInBody(p);
      break;
    }
    case TAG_ID.APPLET:
    case TAG_ID.OBJECT:
    case TAG_ID.MARQUEE: {
      appletEndTagInBody(p, token);
      break;
    }
    case TAG_ID.TEMPLATE: {
      templateEndTagInHead(p, token);
      break;
    }
    default: {
      genericEndTagInBody(p, token);
    }
  }
}
function eofInBody(p, token) {
  if (p.tmplInsertionModeStack.length > 0) {
    eofInTemplate(p, token);
  } else {
    stopParsing(p, token);
  }
}
// The "text" insertion mode
//------------------------------------------------------------------
function endTagInText(p, token) {
  var _a;
  if (token.tagID === TAG_ID.SCRIPT) {
    (_a = p.scriptHandler) === null || _a === void 0
      ? void 0
      : _a.call(p, p.openElements.current);
  }
  p.openElements.pop();
  p.insertionMode = p.originalInsertionMode;
}
function eofInText(p, token) {
  p._err(token, ERR.eofInElementThatCanContainOnlyText);
  p.openElements.pop();
  p.insertionMode = p.originalInsertionMode;
  p.onEof(token);
}
// The "in table" insertion mode
//------------------------------------------------------------------
function characterInTable(p, token) {
  if (TABLE_STRUCTURE_TAGS.has(p.openElements.currentTagId)) {
    p.pendingCharacterTokens.length = 0;
    p.hasNonWhitespacePendingCharacterToken = false;
    p.originalInsertionMode = p.insertionMode;
    p.insertionMode = InsertionMode.IN_TABLE_TEXT;
    switch (token.type) {
      case TokenType.CHARACTER: {
        characterInTableText(p, token);
        break;
      }
      case TokenType.WHITESPACE_CHARACTER: {
        whitespaceCharacterInTableText(p, token);
        break;
      }
      // Ignore null
    }
  } else {
    tokenInTable(p, token);
  }
}
function captionStartTagInTable(p, token) {
  p.openElements.clearBackToTableContext();
  p.activeFormattingElements.insertMarker();
  p._insertElement(token, NS.HTML);
  p.insertionMode = InsertionMode.IN_CAPTION;
}
function colgroupStartTagInTable(p, token) {
  p.openElements.clearBackToTableContext();
  p._insertElement(token, NS.HTML);
  p.insertionMode = InsertionMode.IN_COLUMN_GROUP;
}
function colStartTagInTable(p, token) {
  p.openElements.clearBackToTableContext();
  p._insertFakeElement(TAG_NAMES.COLGROUP, TAG_ID.COLGROUP);
  p.insertionMode = InsertionMode.IN_COLUMN_GROUP;
  startTagInColumnGroup(p, token);
}
function tbodyStartTagInTable(p, token) {
  p.openElements.clearBackToTableContext();
  p._insertElement(token, NS.HTML);
  p.insertionMode = InsertionMode.IN_TABLE_BODY;
}
function tdStartTagInTable(p, token) {
  p.openElements.clearBackToTableContext();
  p._insertFakeElement(TAG_NAMES.TBODY, TAG_ID.TBODY);
  p.insertionMode = InsertionMode.IN_TABLE_BODY;
  startTagInTableBody(p, token);
}
function tableStartTagInTable(p, token) {
  if (p.openElements.hasInTableScope(TAG_ID.TABLE)) {
    p.openElements.popUntilTagNamePopped(TAG_ID.TABLE);
    p._resetInsertionMode();
    p._processStartTag(token);
  }
}
function inputStartTagInTable(p, token) {
  if (isHiddenInput(token)) {
    p._appendElement(token, NS.HTML);
  } else {
    tokenInTable(p, token);
  }
  token.ackSelfClosing = true;
}
function formStartTagInTable(p, token) {
  if (!p.formElement && p.openElements.tmplCount === 0) {
    p._insertElement(token, NS.HTML);
    p.formElement = p.openElements.current;
    p.openElements.pop();
  }
}
function startTagInTable(p, token) {
  switch (token.tagID) {
    case TAG_ID.TD:
    case TAG_ID.TH:
    case TAG_ID.TR: {
      tdStartTagInTable(p, token);
      break;
    }
    case TAG_ID.STYLE:
    case TAG_ID.SCRIPT:
    case TAG_ID.TEMPLATE: {
      startTagInHead(p, token);
      break;
    }
    case TAG_ID.COL: {
      colStartTagInTable(p, token);
      break;
    }
    case TAG_ID.FORM: {
      formStartTagInTable(p, token);
      break;
    }
    case TAG_ID.TABLE: {
      tableStartTagInTable(p, token);
      break;
    }
    case TAG_ID.TBODY:
    case TAG_ID.TFOOT:
    case TAG_ID.THEAD: {
      tbodyStartTagInTable(p, token);
      break;
    }
    case TAG_ID.INPUT: {
      inputStartTagInTable(p, token);
      break;
    }
    case TAG_ID.CAPTION: {
      captionStartTagInTable(p, token);
      break;
    }
    case TAG_ID.COLGROUP: {
      colgroupStartTagInTable(p, token);
      break;
    }
    default: {
      tokenInTable(p, token);
    }
  }
}
function endTagInTable(p, token) {
  switch (token.tagID) {
    case TAG_ID.TABLE: {
      if (p.openElements.hasInTableScope(TAG_ID.TABLE)) {
        p.openElements.popUntilTagNamePopped(TAG_ID.TABLE);
        p._resetInsertionMode();
      }
      break;
    }
    case TAG_ID.TEMPLATE: {
      templateEndTagInHead(p, token);
      break;
    }
    case TAG_ID.BODY:
    case TAG_ID.CAPTION:
    case TAG_ID.COL:
    case TAG_ID.COLGROUP:
    case TAG_ID.HTML:
    case TAG_ID.TBODY:
    case TAG_ID.TD:
    case TAG_ID.TFOOT:
    case TAG_ID.TH:
    case TAG_ID.THEAD:
    case TAG_ID.TR: {
      // Ignore token
      break;
    }
    default: {
      tokenInTable(p, token);
    }
  }
}
function tokenInTable(p, token) {
  const savedFosterParentingState = p.fosterParentingEnabled;
  p.fosterParentingEnabled = true;
  // Process token in `In Body` mode
  modeInBody(p, token);
  p.fosterParentingEnabled = savedFosterParentingState;
}
// The "in table text" insertion mode
//------------------------------------------------------------------
function whitespaceCharacterInTableText(p, token) {
  p.pendingCharacterTokens.push(token);
}
function characterInTableText(p, token) {
  p.pendingCharacterTokens.push(token);
  p.hasNonWhitespacePendingCharacterToken = true;
}
function tokenInTableText(p, token) {
  let i = 0;
  if (p.hasNonWhitespacePendingCharacterToken) {
    for (; i < p.pendingCharacterTokens.length; i++) {
      tokenInTable(p, p.pendingCharacterTokens[i]);
    }
  } else {
    for (; i < p.pendingCharacterTokens.length; i++) {
      p._insertCharacters(p.pendingCharacterTokens[i]);
    }
  }
  p.insertionMode = p.originalInsertionMode;
  p._processToken(token);
}
// The "in caption" insertion mode
//------------------------------------------------------------------
const TABLE_VOID_ELEMENTS = new Set([
  TAG_ID.CAPTION,
  TAG_ID.COL,
  TAG_ID.COLGROUP,
  TAG_ID.TBODY,
  TAG_ID.TD,
  TAG_ID.TFOOT,
  TAG_ID.TH,
  TAG_ID.THEAD,
  TAG_ID.TR,
]);
function startTagInCaption(p, token) {
  const tn = token.tagID;
  if (TABLE_VOID_ELEMENTS.has(tn)) {
    if (p.openElements.hasInTableScope(TAG_ID.CAPTION)) {
      p.openElements.generateImpliedEndTags();
      p.openElements.popUntilTagNamePopped(TAG_ID.CAPTION);
      p.activeFormattingElements.clearToLastMarker();
      p.insertionMode = InsertionMode.IN_TABLE;
      startTagInTable(p, token);
    }
  } else {
    startTagInBody(p, token);
  }
}
function endTagInCaption(p, token) {
  const tn = token.tagID;
  switch (tn) {
    case TAG_ID.CAPTION:
    case TAG_ID.TABLE: {
      if (p.openElements.hasInTableScope(TAG_ID.CAPTION)) {
        p.openElements.generateImpliedEndTags();
        p.openElements.popUntilTagNamePopped(TAG_ID.CAPTION);
        p.activeFormattingElements.clearToLastMarker();
        p.insertionMode = InsertionMode.IN_TABLE;
        if (tn === TAG_ID.TABLE) {
          endTagInTable(p, token);
        }
      }
      break;
    }
    case TAG_ID.BODY:
    case TAG_ID.COL:
    case TAG_ID.COLGROUP:
    case TAG_ID.HTML:
    case TAG_ID.TBODY:
    case TAG_ID.TD:
    case TAG_ID.TFOOT:
    case TAG_ID.TH:
    case TAG_ID.THEAD:
    case TAG_ID.TR: {
      // Ignore token
      break;
    }
    default: {
      endTagInBody(p, token);
    }
  }
}
// The "in column group" insertion mode
//------------------------------------------------------------------
function startTagInColumnGroup(p, token) {
  switch (token.tagID) {
    case TAG_ID.HTML: {
      startTagInBody(p, token);
      break;
    }
    case TAG_ID.COL: {
      p._appendElement(token, NS.HTML);
      token.ackSelfClosing = true;
      break;
    }
    case TAG_ID.TEMPLATE: {
      startTagInHead(p, token);
      break;
    }
    default: {
      tokenInColumnGroup(p, token);
    }
  }
}
function endTagInColumnGroup(p, token) {
  switch (token.tagID) {
    case TAG_ID.COLGROUP: {
      if (p.openElements.currentTagId === TAG_ID.COLGROUP) {
        p.openElements.pop();
        p.insertionMode = InsertionMode.IN_TABLE;
      }
      break;
    }
    case TAG_ID.TEMPLATE: {
      templateEndTagInHead(p, token);
      break;
    }
    case TAG_ID.COL: {
      // Ignore token
      break;
    }
    default: {
      tokenInColumnGroup(p, token);
    }
  }
}
function tokenInColumnGroup(p, token) {
  if (p.openElements.currentTagId === TAG_ID.COLGROUP) {
    p.openElements.pop();
    p.insertionMode = InsertionMode.IN_TABLE;
    p._processToken(token);
  }
}
// The "in table body" insertion mode
//------------------------------------------------------------------
function startTagInTableBody(p, token) {
  switch (token.tagID) {
    case TAG_ID.TR: {
      p.openElements.clearBackToTableBodyContext();
      p._insertElement(token, NS.HTML);
      p.insertionMode = InsertionMode.IN_ROW;
      break;
    }
    case TAG_ID.TH:
    case TAG_ID.TD: {
      p.openElements.clearBackToTableBodyContext();
      p._insertFakeElement(TAG_NAMES.TR, TAG_ID.TR);
      p.insertionMode = InsertionMode.IN_ROW;
      startTagInRow(p, token);
      break;
    }
    case TAG_ID.CAPTION:
    case TAG_ID.COL:
    case TAG_ID.COLGROUP:
    case TAG_ID.TBODY:
    case TAG_ID.TFOOT:
    case TAG_ID.THEAD: {
      if (p.openElements.hasTableBodyContextInTableScope()) {
        p.openElements.clearBackToTableBodyContext();
        p.openElements.pop();
        p.insertionMode = InsertionMode.IN_TABLE;
        startTagInTable(p, token);
      }
      break;
    }
    default: {
      startTagInTable(p, token);
    }
  }
}
function endTagInTableBody(p, token) {
  const tn = token.tagID;
  switch (token.tagID) {
    case TAG_ID.TBODY:
    case TAG_ID.TFOOT:
    case TAG_ID.THEAD: {
      if (p.openElements.hasInTableScope(tn)) {
        p.openElements.clearBackToTableBodyContext();
        p.openElements.pop();
        p.insertionMode = InsertionMode.IN_TABLE;
      }
      break;
    }
    case TAG_ID.TABLE: {
      if (p.openElements.hasTableBodyContextInTableScope()) {
        p.openElements.clearBackToTableBodyContext();
        p.openElements.pop();
        p.insertionMode = InsertionMode.IN_TABLE;
        endTagInTable(p, token);
      }
      break;
    }
    case TAG_ID.BODY:
    case TAG_ID.CAPTION:
    case TAG_ID.COL:
    case TAG_ID.COLGROUP:
    case TAG_ID.HTML:
    case TAG_ID.TD:
    case TAG_ID.TH:
    case TAG_ID.TR: {
      // Ignore token
      break;
    }
    default: {
      endTagInTable(p, token);
    }
  }
}
// The "in row" insertion mode
//------------------------------------------------------------------
function startTagInRow(p, token) {
  switch (token.tagID) {
    case TAG_ID.TH:
    case TAG_ID.TD: {
      p.openElements.clearBackToTableRowContext();
      p._insertElement(token, NS.HTML);
      p.insertionMode = InsertionMode.IN_CELL;
      p.activeFormattingElements.insertMarker();
      break;
    }
    case TAG_ID.CAPTION:
    case TAG_ID.COL:
    case TAG_ID.COLGROUP:
    case TAG_ID.TBODY:
    case TAG_ID.TFOOT:
    case TAG_ID.THEAD:
    case TAG_ID.TR: {
      if (p.openElements.hasInTableScope(TAG_ID.TR)) {
        p.openElements.clearBackToTableRowContext();
        p.openElements.pop();
        p.insertionMode = InsertionMode.IN_TABLE_BODY;
        startTagInTableBody(p, token);
      }
      break;
    }
    default: {
      startTagInTable(p, token);
    }
  }
}
function endTagInRow(p, token) {
  switch (token.tagID) {
    case TAG_ID.TR: {
      if (p.openElements.hasInTableScope(TAG_ID.TR)) {
        p.openElements.clearBackToTableRowContext();
        p.openElements.pop();
        p.insertionMode = InsertionMode.IN_TABLE_BODY;
      }
      break;
    }
    case TAG_ID.TABLE: {
      if (p.openElements.hasInTableScope(TAG_ID.TR)) {
        p.openElements.clearBackToTableRowContext();
        p.openElements.pop();
        p.insertionMode = InsertionMode.IN_TABLE_BODY;
        endTagInTableBody(p, token);
      }
      break;
    }
    case TAG_ID.TBODY:
    case TAG_ID.TFOOT:
    case TAG_ID.THEAD: {
      if (
        p.openElements.hasInTableScope(token.tagID) ||
        p.openElements.hasInTableScope(TAG_ID.TR)
      ) {
        p.openElements.clearBackToTableRowContext();
        p.openElements.pop();
        p.insertionMode = InsertionMode.IN_TABLE_BODY;
        endTagInTableBody(p, token);
      }
      break;
    }
    case TAG_ID.BODY:
    case TAG_ID.CAPTION:
    case TAG_ID.COL:
    case TAG_ID.COLGROUP:
    case TAG_ID.HTML:
    case TAG_ID.TD:
    case TAG_ID.TH: {
      // Ignore end tag
      break;
    }
    default: {
      endTagInTable(p, token);
    }
  }
}
// The "in cell" insertion mode
//------------------------------------------------------------------
function startTagInCell(p, token) {
  const tn = token.tagID;
  if (TABLE_VOID_ELEMENTS.has(tn)) {
    if (
      p.openElements.hasInTableScope(TAG_ID.TD) ||
      p.openElements.hasInTableScope(TAG_ID.TH)
    ) {
      p._closeTableCell();
      startTagInRow(p, token);
    }
  } else {
    startTagInBody(p, token);
  }
}
function endTagInCell(p, token) {
  const tn = token.tagID;
  switch (tn) {
    case TAG_ID.TD:
    case TAG_ID.TH: {
      if (p.openElements.hasInTableScope(tn)) {
        p.openElements.generateImpliedEndTags();
        p.openElements.popUntilTagNamePopped(tn);
        p.activeFormattingElements.clearToLastMarker();
        p.insertionMode = InsertionMode.IN_ROW;
      }
      break;
    }
    case TAG_ID.TABLE:
    case TAG_ID.TBODY:
    case TAG_ID.TFOOT:
    case TAG_ID.THEAD:
    case TAG_ID.TR: {
      if (p.openElements.hasInTableScope(tn)) {
        p._closeTableCell();
        endTagInRow(p, token);
      }
      break;
    }
    case TAG_ID.BODY:
    case TAG_ID.CAPTION:
    case TAG_ID.COL:
    case TAG_ID.COLGROUP:
    case TAG_ID.HTML: {
      // Ignore token
      break;
    }
    default: {
      endTagInBody(p, token);
    }
  }
}
// The "in select" insertion mode
//------------------------------------------------------------------
function startTagInSelect(p, token) {
  switch (token.tagID) {
    case TAG_ID.HTML: {
      startTagInBody(p, token);
      break;
    }
    case TAG_ID.OPTION: {
      if (p.openElements.currentTagId === TAG_ID.OPTION) {
        p.openElements.pop();
      }
      p._insertElement(token, NS.HTML);
      break;
    }
    case TAG_ID.OPTGROUP: {
      if (p.openElements.currentTagId === TAG_ID.OPTION) {
        p.openElements.pop();
      }
      if (p.openElements.currentTagId === TAG_ID.OPTGROUP) {
        p.openElements.pop();
      }
      p._insertElement(token, NS.HTML);
      break;
    }
    case TAG_ID.INPUT:
    case TAG_ID.KEYGEN:
    case TAG_ID.TEXTAREA:
    case TAG_ID.SELECT: {
      if (p.openElements.hasInSelectScope(TAG_ID.SELECT)) {
        p.openElements.popUntilTagNamePopped(TAG_ID.SELECT);
        p._resetInsertionMode();
        if (token.tagID !== TAG_ID.SELECT) {
          p._processStartTag(token);
        }
      }
      break;
    }
    case TAG_ID.SCRIPT:
    case TAG_ID.TEMPLATE: {
      startTagInHead(p, token);
      break;
    }
    // Do nothing
  }
}
function endTagInSelect(p, token) {
  switch (token.tagID) {
    case TAG_ID.OPTGROUP: {
      if (
        p.openElements.stackTop > 0 &&
        p.openElements.currentTagId === TAG_ID.OPTION &&
        p.openElements.tagIDs[p.openElements.stackTop - 1] === TAG_ID.OPTGROUP
      ) {
        p.openElements.pop();
      }
      if (p.openElements.currentTagId === TAG_ID.OPTGROUP) {
        p.openElements.pop();
      }
      break;
    }
    case TAG_ID.OPTION: {
      if (p.openElements.currentTagId === TAG_ID.OPTION) {
        p.openElements.pop();
      }
      break;
    }
    case TAG_ID.SELECT: {
      if (p.openElements.hasInSelectScope(TAG_ID.SELECT)) {
        p.openElements.popUntilTagNamePopped(TAG_ID.SELECT);
        p._resetInsertionMode();
      }
      break;
    }
    case TAG_ID.TEMPLATE: {
      templateEndTagInHead(p, token);
      break;
    }
    // Do nothing
  }
}
// The "in select in table" insertion mode
//------------------------------------------------------------------
function startTagInSelectInTable(p, token) {
  const tn = token.tagID;
  if (
    tn === TAG_ID.CAPTION ||
    tn === TAG_ID.TABLE ||
    tn === TAG_ID.TBODY ||
    tn === TAG_ID.TFOOT ||
    tn === TAG_ID.THEAD ||
    tn === TAG_ID.TR ||
    tn === TAG_ID.TD ||
    tn === TAG_ID.TH
  ) {
    p.openElements.popUntilTagNamePopped(TAG_ID.SELECT);
    p._resetInsertionMode();
    p._processStartTag(token);
  } else {
    startTagInSelect(p, token);
  }
}
function endTagInSelectInTable(p, token) {
  const tn = token.tagID;
  if (
    tn === TAG_ID.CAPTION ||
    tn === TAG_ID.TABLE ||
    tn === TAG_ID.TBODY ||
    tn === TAG_ID.TFOOT ||
    tn === TAG_ID.THEAD ||
    tn === TAG_ID.TR ||
    tn === TAG_ID.TD ||
    tn === TAG_ID.TH
  ) {
    if (p.openElements.hasInTableScope(tn)) {
      p.openElements.popUntilTagNamePopped(TAG_ID.SELECT);
      p._resetInsertionMode();
      p.onEndTag(token);
    }
  } else {
    endTagInSelect(p, token);
  }
}
// The "in template" insertion mode
//------------------------------------------------------------------
function startTagInTemplate(p, token) {
  switch (token.tagID) {
    // First, handle tags that can start without a mode change
    case TAG_ID.BASE:
    case TAG_ID.BASEFONT:
    case TAG_ID.BGSOUND:
    case TAG_ID.LINK:
    case TAG_ID.META:
    case TAG_ID.NOFRAMES:
    case TAG_ID.SCRIPT:
    case TAG_ID.STYLE:
    case TAG_ID.TEMPLATE:
    case TAG_ID.TITLE: {
      startTagInHead(p, token);
      break;
    }
    // Re-process the token in the appropriate mode
    case TAG_ID.CAPTION:
    case TAG_ID.COLGROUP:
    case TAG_ID.TBODY:
    case TAG_ID.TFOOT:
    case TAG_ID.THEAD: {
      p.tmplInsertionModeStack[0] = InsertionMode.IN_TABLE;
      p.insertionMode = InsertionMode.IN_TABLE;
      startTagInTable(p, token);
      break;
    }
    case TAG_ID.COL: {
      p.tmplInsertionModeStack[0] = InsertionMode.IN_COLUMN_GROUP;
      p.insertionMode = InsertionMode.IN_COLUMN_GROUP;
      startTagInColumnGroup(p, token);
      break;
    }
    case TAG_ID.TR: {
      p.tmplInsertionModeStack[0] = InsertionMode.IN_TABLE_BODY;
      p.insertionMode = InsertionMode.IN_TABLE_BODY;
      startTagInTableBody(p, token);
      break;
    }
    case TAG_ID.TD:
    case TAG_ID.TH: {
      p.tmplInsertionModeStack[0] = InsertionMode.IN_ROW;
      p.insertionMode = InsertionMode.IN_ROW;
      startTagInRow(p, token);
      break;
    }
    default: {
      p.tmplInsertionModeStack[0] = InsertionMode.IN_BODY;
      p.insertionMode = InsertionMode.IN_BODY;
      startTagInBody(p, token);
    }
  }
}
function endTagInTemplate(p, token) {
  if (token.tagID === TAG_ID.TEMPLATE) {
    templateEndTagInHead(p, token);
  }
}
function eofInTemplate(p, token) {
  if (p.openElements.tmplCount > 0) {
    p.openElements.popUntilTagNamePopped(TAG_ID.TEMPLATE);
    p.activeFormattingElements.clearToLastMarker();
    p.tmplInsertionModeStack.shift();
    p._resetInsertionMode();
    p.onEof(token);
  } else {
    stopParsing(p, token);
  }
}
// The "after body" insertion mode
//------------------------------------------------------------------
function startTagAfterBody(p, token) {
  if (token.tagID === TAG_ID.HTML) {
    startTagInBody(p, token);
  } else {
    tokenAfterBody(p, token);
  }
}
function endTagAfterBody(p, token) {
  var _a;
  if (token.tagID === TAG_ID.HTML) {
    if (!p.fragmentContext) {
      p.insertionMode = InsertionMode.AFTER_AFTER_BODY;
    }
    //NOTE: <html> is never popped from the stack, so we need to updated
    //the end location explicitly.
    if (
      p.options.sourceCodeLocationInfo &&
      p.openElements.tagIDs[0] === TAG_ID.HTML
    ) {
      p._setEndLocation(p.openElements.items[0], token);
      // Update the body element, if it doesn't have an end tag
      const bodyElement = p.openElements.items[1];
      if (
        bodyElement &&
        !((_a = p.treeAdapter.getNodeSourceCodeLocation(bodyElement)) ===
          null || _a === void 0
          ? void 0
          : _a.endTag)
      ) {
        p._setEndLocation(bodyElement, token);
      }
    }
  } else {
    tokenAfterBody(p, token);
  }
}
function tokenAfterBody(p, token) {
  p.insertionMode = InsertionMode.IN_BODY;
  modeInBody(p, token);
}
// The "in frameset" insertion mode
//------------------------------------------------------------------
function startTagInFrameset(p, token) {
  switch (token.tagID) {
    case TAG_ID.HTML: {
      startTagInBody(p, token);
      break;
    }
    case TAG_ID.FRAMESET: {
      p._insertElement(token, NS.HTML);
      break;
    }
    case TAG_ID.FRAME: {
      p._appendElement(token, NS.HTML);
      token.ackSelfClosing = true;
      break;
    }
    case TAG_ID.NOFRAMES: {
      startTagInHead(p, token);
      break;
    }
    // Do nothing
  }
}
function endTagInFrameset(p, token) {
  if (
    token.tagID === TAG_ID.FRAMESET &&
    !p.openElements.isRootHtmlElementCurrent()
  ) {
    p.openElements.pop();
    if (!p.fragmentContext && p.openElements.currentTagId !== TAG_ID.FRAMESET) {
      p.insertionMode = InsertionMode.AFTER_FRAMESET;
    }
  }
}
// The "after frameset" insertion mode
//------------------------------------------------------------------
function startTagAfterFrameset(p, token) {
  switch (token.tagID) {
    case TAG_ID.HTML: {
      startTagInBody(p, token);
      break;
    }
    case TAG_ID.NOFRAMES: {
      startTagInHead(p, token);
      break;
    }
    // Do nothing
  }
}
function endTagAfterFrameset(p, token) {
  if (token.tagID === TAG_ID.HTML) {
    p.insertionMode = InsertionMode.AFTER_AFTER_FRAMESET;
  }
}
// The "after after body" insertion mode
//------------------------------------------------------------------
function startTagAfterAfterBody(p, token) {
  if (token.tagID === TAG_ID.HTML) {
    startTagInBody(p, token);
  } else {
    tokenAfterAfterBody(p, token);
  }
}
function tokenAfterAfterBody(p, token) {
  p.insertionMode = InsertionMode.IN_BODY;
  modeInBody(p, token);
}
// The "after after frameset" insertion mode
//------------------------------------------------------------------
function startTagAfterAfterFrameset(p, token) {
  switch (token.tagID) {
    case TAG_ID.HTML: {
      startTagInBody(p, token);
      break;
    }
    case TAG_ID.NOFRAMES: {
      startTagInHead(p, token);
      break;
    }
    // Do nothing
  }
}
// The rules for parsing tokens in foreign content
//------------------------------------------------------------------
function nullCharacterInForeignContent(p, token) {
  token.chars = REPLACEMENT_CHARACTER;
  p._insertCharacters(token);
}
function characterInForeignContent(p, token) {
  p._insertCharacters(token);
  p.framesetOk = false;
}
function popUntilHtmlOrIntegrationPoint(p) {
  while (
    p.treeAdapter.getNamespaceURI(p.openElements.current) !== NS.HTML &&
    !p._isIntegrationPoint(p.openElements.currentTagId, p.openElements.current)
  ) {
    p.openElements.pop();
  }
}
function startTagInForeignContent(p, token) {
  if (causesExit(token)) {
    popUntilHtmlOrIntegrationPoint(p);
    p._startTagOutsideForeignContent(token);
  } else {
    const current = p._getAdjustedCurrentElement();
    const currentNs = p.treeAdapter.getNamespaceURI(current);
    if (currentNs === NS.MATHML) {
      adjustTokenMathMLAttrs(token);
    } else if (currentNs === NS.SVG) {
      adjustTokenSVGTagName(token);
      adjustTokenSVGAttrs(token);
    }
    adjustTokenXMLAttrs(token);
    if (token.selfClosing) {
      p._appendElement(token, currentNs);
    } else {
      p._insertElement(token, currentNs);
    }
    token.ackSelfClosing = true;
  }
}
function endTagInForeignContent(p, token) {
  if (token.tagID === TAG_ID.P || token.tagID === TAG_ID.BR) {
    popUntilHtmlOrIntegrationPoint(p);
    p._endTagOutsideForeignContent(token);
    return;
  }
  for (let i = p.openElements.stackTop; i > 0; i--) {
    const element = p.openElements.items[i];
    if (p.treeAdapter.getNamespaceURI(element) === NS.HTML) {
      p._endTagOutsideForeignContent(token);
      break;
    }
    const tagName = p.treeAdapter.getTagName(element);
    if (tagName.toLowerCase() === token.tagName) {
      //NOTE: update the token tag name for `_setEndLocation`.
      token.tagName = tagName;
      p.openElements.shortenToLength(i);
      break;
    }
  }
}

// Sets
const VOID_ELEMENTS = new Set([
  TAG_NAMES.AREA,
  TAG_NAMES.BASE,
  TAG_NAMES.BASEFONT,
  TAG_NAMES.BGSOUND,
  TAG_NAMES.BR,
  TAG_NAMES.COL,
  TAG_NAMES.EMBED,
  TAG_NAMES.FRAME,
  TAG_NAMES.HR,
  TAG_NAMES.IMG,
  TAG_NAMES.INPUT,
  TAG_NAMES.KEYGEN,
  TAG_NAMES.LINK,
  TAG_NAMES.META,
  TAG_NAMES.PARAM,
  TAG_NAMES.SOURCE,
  TAG_NAMES.TRACK,
  TAG_NAMES.WBR,
]);
function isVoidElement(node, options) {
  return (
    options.treeAdapter.isElementNode(node) &&
    options.treeAdapter.getNamespaceURI(node) === NS.HTML &&
    VOID_ELEMENTS.has(options.treeAdapter.getTagName(node))
  );
}
const defaultOpts = { treeAdapter: defaultTreeAdapter, scriptingEnabled: true };
/**
 * Serializes an AST element node to an HTML string, including the element node.
 *
 * @example
 *
 * ```js
 * const parse5 = require('parse5');
 *
 * const document = parse5.parseFragment('<div>Hello, <b>world</b>!</div>');
 *
 * // Serializes the <div> element.
 * const html = parse5.serializeOuter(document.childNodes[0]);
 *
 * console.log(str); //> '<div>Hello, <b>world</b>!</div>'
 * ```
 *
 * @param node Node to serialize.
 * @param options Serialization options.
 */
function serializeOuter(node, options) {
  const opts = { ...defaultOpts, ...options };
  return serializeNode(node, opts);
}
function serializeChildNodes(parentNode, options) {
  let html = "";
  // Get container of the child nodes
  const container =
    options.treeAdapter.isElementNode(parentNode) &&
    options.treeAdapter.getTagName(parentNode) === TAG_NAMES.TEMPLATE &&
    options.treeAdapter.getNamespaceURI(parentNode) === NS.HTML
      ? options.treeAdapter.getTemplateContent(parentNode)
      : parentNode;
  const childNodes = options.treeAdapter.getChildNodes(container);
  if (childNodes) {
    for (const currentNode of childNodes) {
      html += serializeNode(currentNode, options);
    }
  }
  return html;
}
function serializeNode(node, options) {
  if (options.treeAdapter.isElementNode(node)) {
    return serializeElement(node, options);
  }
  if (options.treeAdapter.isTextNode(node)) {
    return serializeTextNode(node, options);
  }
  if (options.treeAdapter.isCommentNode(node)) {
    return serializeCommentNode(node, options);
  }
  if (options.treeAdapter.isDocumentTypeNode(node)) {
    return serializeDocumentTypeNode(node, options);
  }
  // Return an empty string for unknown nodes
  return "";
}
function serializeElement(node, options) {
  const tn = options.treeAdapter.getTagName(node);
  return `<${tn}${serializeAttributes(node, options)}>${
    isVoidElement(node, options)
      ? ""
      : `${serializeChildNodes(node, options)}</${tn}>`
  }`;
}
function serializeAttributes(node, { treeAdapter }) {
  let html = "";
  for (const attr of treeAdapter.getAttrList(node)) {
    html += " ";
    if (!attr.namespace) {
      html += attr.name;
    } else
      switch (attr.namespace) {
        case NS.XML: {
          html += `xml:${attr.name}`;
          break;
        }
        case NS.XMLNS: {
          if (attr.name !== "xmlns") {
            html += "xmlns:";
          }
          html += attr.name;
          break;
        }
        case NS.XLINK: {
          html += `xlink:${attr.name}`;
          break;
        }
        default: {
          html += `${attr.prefix}:${attr.name}`;
        }
      }
    html += `="${escapeAttribute(attr.value)}"`;
  }
  return html;
}
function serializeTextNode(node, options) {
  const { treeAdapter } = options;
  const content = treeAdapter.getTextNodeContent(node);
  const parent = treeAdapter.getParentNode(node);
  const parentTn =
    parent &&
    treeAdapter.isElementNode(parent) &&
    treeAdapter.getTagName(parent);
  return parentTn &&
    treeAdapter.getNamespaceURI(parent) === NS.HTML &&
    hasUnescapedText(parentTn, options.scriptingEnabled)
    ? content
    : escapeText(content);
}
function serializeCommentNode(node, { treeAdapter }) {
  return `<!--${treeAdapter.getCommentNodeContent(node)}-->`;
}
function serializeDocumentTypeNode(node, { treeAdapter }) {
  return `<!DOCTYPE ${treeAdapter.getDocumentTypeNodeName(node)}>`;
}

// Shorthands
/**
 * Parses an HTML string.
 *
 * @param html Input HTML string.
 * @param options Parsing options.
 * @returns Document
 *
 * @example
 *
 * ```js
 * const parse5 = require('parse5');
 *
 * const document = parse5.parse('<!DOCTYPE html><html><head></head><body>Hi there!</body></html>');
 *
 * console.log(document.childNodes[1].tagName); //> 'html'
 *```
 */
function parse$1A(html, options) {
  return Parser$2.parse(html, options);
}
function parseFragment(fragmentContext, html, options) {
  if (typeof fragmentContext === "string") {
    options = html;
    html = fragmentContext;
    fragmentContext = null;
  }
  const parser = Parser$2.getFragmentParser(fragmentContext, options);
  parser.tokenizer.write(html, true);
  return parser.getFragment();
}

function createTextNode(value) {
  return new Text(value);
}
function enquoteDoctypeId(id) {
  const quote = id.includes('"') ? "'" : '"';
  return quote + id + quote;
}
/** @internal */
function serializeDoctypeContent(name, publicId, systemId) {
  let str = "!DOCTYPE ";
  if (name) {
    str += name;
  }
  if (publicId) {
    str += ` PUBLIC ${enquoteDoctypeId(publicId)}`;
  } else if (systemId) {
    str += " SYSTEM";
  }
  if (systemId) {
    str += ` ${enquoteDoctypeId(systemId)}`;
  }
  return str;
}
const adapter = {
  // Re-exports from domhandler
  isCommentNode: isComment,
  isElementNode: isTag$1,
  isTextNode: isText,
  //Node construction
  createDocument() {
    const node = new Document([]);
    node["x-mode"] = DOCUMENT_MODE.NO_QUIRKS;
    return node;
  },
  createDocumentFragment() {
    return new Document([]);
  },
  createElement(tagName, namespaceURI, attrs) {
    const attribs = Object.create(null);
    const attribsNamespace = Object.create(null);
    const attribsPrefix = Object.create(null);
    for (let i = 0; i < attrs.length; i++) {
      const attrName = attrs[i].name;
      attribs[attrName] = attrs[i].value;
      attribsNamespace[attrName] = attrs[i].namespace;
      attribsPrefix[attrName] = attrs[i].prefix;
    }
    const node = new Element(tagName, attribs, []);
    node.namespace = namespaceURI;
    node["x-attribsNamespace"] = attribsNamespace;
    node["x-attribsPrefix"] = attribsPrefix;
    return node;
  },
  createCommentNode(data) {
    return new Comment$a(data);
  },
  //Tree mutation
  appendChild(parentNode, newNode) {
    const prev = parentNode.children[parentNode.children.length - 1];
    if (prev) {
      prev.next = newNode;
      newNode.prev = prev;
    }
    parentNode.children.push(newNode);
    newNode.parent = parentNode;
  },
  insertBefore(parentNode, newNode, referenceNode) {
    const insertionIdx = parentNode.children.indexOf(referenceNode);
    const { prev } = referenceNode;
    if (prev) {
      prev.next = newNode;
      newNode.prev = prev;
    }
    referenceNode.prev = newNode;
    newNode.next = referenceNode;
    parentNode.children.splice(insertionIdx, 0, newNode);
    newNode.parent = parentNode;
  },
  setTemplateContent(templateElement, contentElement) {
    adapter.appendChild(templateElement, contentElement);
  },
  getTemplateContent(templateElement) {
    return templateElement.children[0];
  },
  setDocumentType(document, name, publicId, systemId) {
    const data = serializeDoctypeContent(name, publicId, systemId);
    let doctypeNode = document.children.find(
      (node) => isDirective(node) && node.name === "!doctype",
    );
    if (doctypeNode) {
      doctypeNode.data = data !== null && data !== void 0 ? data : null;
    } else {
      doctypeNode = new ProcessingInstruction("!doctype", data);
      adapter.appendChild(document, doctypeNode);
    }
    doctypeNode["x-name"] = name !== null && name !== void 0 ? name : undefined;
    doctypeNode["x-publicId"] =
      publicId !== null && publicId !== void 0 ? publicId : undefined;
    doctypeNode["x-systemId"] =
      systemId !== null && systemId !== void 0 ? systemId : undefined;
  },
  setDocumentMode(document, mode) {
    document["x-mode"] = mode;
  },
  getDocumentMode(document) {
    return document["x-mode"];
  },
  detachNode(node) {
    if (node.parent) {
      const idx = node.parent.children.indexOf(node);
      const { prev, next } = node;
      node.prev = null;
      node.next = null;
      if (prev) {
        prev.next = next;
      }
      if (next) {
        next.prev = prev;
      }
      node.parent.children.splice(idx, 1);
      node.parent = null;
    }
  },
  insertText(parentNode, text) {
    const lastChild = parentNode.children[parentNode.children.length - 1];
    if (lastChild && isText(lastChild)) {
      lastChild.data += text;
    } else {
      adapter.appendChild(parentNode, createTextNode(text));
    }
  },
  insertTextBefore(parentNode, text, referenceNode) {
    const prevNode =
      parentNode.children[parentNode.children.indexOf(referenceNode) - 1];
    if (prevNode && isText(prevNode)) {
      prevNode.data += text;
    } else {
      adapter.insertBefore(parentNode, createTextNode(text), referenceNode);
    }
  },
  adoptAttributes(recipient, attrs) {
    for (let i = 0; i < attrs.length; i++) {
      const attrName = attrs[i].name;
      if (typeof recipient.attribs[attrName] === "undefined") {
        recipient.attribs[attrName] = attrs[i].value;
        recipient["x-attribsNamespace"][attrName] = attrs[i].namespace;
        recipient["x-attribsPrefix"][attrName] = attrs[i].prefix;
      }
    }
  },
  //Tree traversing
  getFirstChild(node) {
    return node.children[0];
  },
  getChildNodes(node) {
    return node.children;
  },
  getParentNode(node) {
    return node.parent;
  },
  getAttrList(element) {
    return element.attributes;
  },
  //Node data
  getTagName(element) {
    return element.name;
  },
  getNamespaceURI(element) {
    return element.namespace;
  },
  getTextNodeContent(textNode) {
    return textNode.data;
  },
  getCommentNodeContent(commentNode) {
    return commentNode.data;
  },
  getDocumentTypeNodeName(doctypeNode) {
    var _a;
    return (_a = doctypeNode["x-name"]) !== null && _a !== void 0 ? _a : "";
  },
  getDocumentTypeNodePublicId(doctypeNode) {
    var _a;
    return (_a = doctypeNode["x-publicId"]) !== null && _a !== void 0 ? _a : "";
  },
  getDocumentTypeNodeSystemId(doctypeNode) {
    var _a;
    return (_a = doctypeNode["x-systemId"]) !== null && _a !== void 0 ? _a : "";
  },
  //Node types
  isDocumentTypeNode(node) {
    return isDirective(node) && node.name === "!doctype";
  },
  // Source code location
  setNodeSourceCodeLocation(node, location) {
    if (location) {
      node.startIndex = location.startOffset;
      node.endIndex = location.endOffset;
    }
    node.sourceCodeLocation = location;
  },
  getNodeSourceCodeLocation(node) {
    return node.sourceCodeLocation;
  },
  updateNodeSourceCodeLocation(node, endLocation) {
    if (endLocation.endOffset != null) node.endIndex = endLocation.endOffset;
    node.sourceCodeLocation = {
      ...node.sourceCodeLocation,
      ...endLocation,
    };
  },
};

/**
 * Parse the content with `parse5` in the context of the given `ParentNode`.
 *
 * @param content - The content to parse.
 * @param options - A set of options to use to parse.
 * @param isDocument - Whether to parse the content as a full HTML document.
 * @param context - The context in which to parse the content.
 * @returns The parsed content.
 */
function parseWithParse5(content, options, isDocument, context) {
  const opts = {
    scriptingEnabled:
      typeof options.scriptingEnabled === "boolean"
        ? options.scriptingEnabled
        : true,
    treeAdapter: adapter,
    sourceCodeLocationInfo: options.sourceCodeLocationInfo,
  };
  return isDocument
    ? parse$1A(content, opts)
    : parseFragment(context, content, opts);
}
const renderOpts = { treeAdapter: adapter };
/**
 * Renders the given DOM tree with `parse5` and returns the result as a string.
 *
 * @param dom - The DOM tree to render.
 * @returns The rendered document.
 */
function renderWithParse5(dom) {
  /*
   * `dom-serializer` passes over the special "root" node and renders the
   * node's children in its place. To mimic this behavior with `parse5`, an
   * equivalent operation must be applied to the input array.
   */
  const nodes = "length" in dom ? dom : [dom];
  for (let index = 0; index < nodes.length; index += 1) {
    const node = nodes[index];
    if (isDocument(node)) {
      Array.prototype.splice.call(nodes, index, 1, ...node.children);
    }
  }
  let result = "";
  for (let index = 0; index < nodes.length; index += 1) {
    const node = nodes[index];
    result += serializeOuter(node, renderOpts);
  }
  return result;
}

const elementNames = new Map(
  [
    "altGlyph",
    "altGlyphDef",
    "altGlyphItem",
    "animateColor",
    "animateMotion",
    "animateTransform",
    "clipPath",
    "feBlend",
    "feColorMatrix",
    "feComponentTransfer",
    "feComposite",
    "feConvolveMatrix",
    "feDiffuseLighting",
    "feDisplacementMap",
    "feDistantLight",
    "feDropShadow",
    "feFlood",
    "feFuncA",
    "feFuncB",
    "feFuncG",
    "feFuncR",
    "feGaussianBlur",
    "feImage",
    "feMerge",
    "feMergeNode",
    "feMorphology",
    "feOffset",
    "fePointLight",
    "feSpecularLighting",
    "feSpotLight",
    "feTile",
    "feTurbulence",
    "foreignObject",
    "glyphRef",
    "linearGradient",
    "radialGradient",
    "textPath",
  ].map((val) => [val.toLowerCase(), val]),
);
const attributeNames = new Map(
  [
    "definitionURL",
    "attributeName",
    "attributeType",
    "baseFrequency",
    "baseProfile",
    "calcMode",
    "clipPathUnits",
    "diffuseConstant",
    "edgeMode",
    "filterUnits",
    "glyphRef",
    "gradientTransform",
    "gradientUnits",
    "kernelMatrix",
    "kernelUnitLength",
    "keyPoints",
    "keySplines",
    "keyTimes",
    "lengthAdjust",
    "limitingConeAngle",
    "markerHeight",
    "markerUnits",
    "markerWidth",
    "maskContentUnits",
    "maskUnits",
    "numOctaves",
    "pathLength",
    "patternContentUnits",
    "patternTransform",
    "patternUnits",
    "pointsAtX",
    "pointsAtY",
    "pointsAtZ",
    "preserveAlpha",
    "preserveAspectRatio",
    "primitiveUnits",
    "refX",
    "refY",
    "repeatCount",
    "repeatDur",
    "requiredExtensions",
    "requiredFeatures",
    "specularConstant",
    "specularExponent",
    "spreadMethod",
    "startOffset",
    "stdDeviation",
    "stitchTiles",
    "surfaceScale",
    "systemLanguage",
    "tableValues",
    "targetX",
    "targetY",
    "textLength",
    "viewBox",
    "viewTarget",
    "xChannelSelector",
    "yChannelSelector",
    "zoomAndPan",
  ].map((val) => [val.toLowerCase(), val]),
);

/*
 * Module dependencies
 */
const unencodedElements = new Set([
  "style",
  "script",
  "xmp",
  "iframe",
  "noembed",
  "noframes",
  "plaintext",
  "noscript",
]);
function replaceQuotes(value) {
  return value.replace(/"/g, "&quot;");
}
/**
 * Format attributes
 */
function formatAttributes(attributes, opts) {
  var _a;
  if (!attributes) return;
  const encode =
    ((_a = opts.encodeEntities) !== null && _a !== void 0
      ? _a
      : opts.decodeEntities) === false
      ? replaceQuotes
      : opts.xmlMode || opts.encodeEntities !== "utf8"
        ? encodeXML
        : escapeAttribute;
  return Object.keys(attributes)
    .map((key) => {
      var _a, _b;
      const value = (_a = attributes[key]) !== null && _a !== void 0 ? _a : "";
      if (opts.xmlMode === "foreign") {
        /* Fix up mixed-case attribute names */
        key =
          (_b = attributeNames.get(key)) !== null && _b !== void 0 ? _b : key;
      }
      if (!opts.emptyAttrs && !opts.xmlMode && value === "") {
        return key;
      }
      return `${key}="${encode(value)}"`;
    })
    .join(" ");
}
/**
 * Self-enclosing tags
 */
const singleTag = new Set([
  "area",
  "base",
  "basefont",
  "br",
  "col",
  "command",
  "embed",
  "frame",
  "hr",
  "img",
  "input",
  "isindex",
  "keygen",
  "link",
  "meta",
  "param",
  "source",
  "track",
  "wbr",
]);
/**
 * Renders a DOM node or an array of DOM nodes to a string.
 *
 * Can be thought of as the equivalent of the `outerHTML` of the passed node(s).
 *
 * @param node Node to be rendered.
 * @param options Changes serialization behavior
 */
function render(node, options = {}) {
  const nodes = "length" in node ? node : [node];
  let output = "";
  for (let i = 0; i < nodes.length; i++) {
    output += renderNode(nodes[i], options);
  }
  return output;
}
function renderNode(node, options) {
  switch (node.type) {
    case Root:
      return render(node.children, options);
    // @ts-expect-error We don't use `Doctype` yet
    case Doctype:
    case Directive:
      return renderDirective(node);
    case Comment$c:
      return renderComment(node);
    case CDATA$2:
      return renderCdata(node);
    case Script:
    case Style:
    case Tag:
      return renderTag(node, options);
    case Text$2:
      return renderText(node, options);
  }
}
const foreignModeIntegrationPoints = new Set([
  "mi",
  "mo",
  "mn",
  "ms",
  "mtext",
  "annotation-xml",
  "foreignObject",
  "desc",
  "title",
]);
const foreignElements = new Set(["svg", "math"]);
function renderTag(elem, opts) {
  var _a;
  // Handle SVG / MathML in HTML
  if (opts.xmlMode === "foreign") {
    /* Fix up mixed-case element names */
    elem.name =
      (_a = elementNames.get(elem.name)) !== null && _a !== void 0
        ? _a
        : elem.name;
    /* Exit foreign mode at integration points */
    if (elem.parent && foreignModeIntegrationPoints.has(elem.parent.name)) {
      opts = { ...opts, xmlMode: false };
    }
  }
  if (!opts.xmlMode && foreignElements.has(elem.name)) {
    opts = { ...opts, xmlMode: "foreign" };
  }
  let tag = `<${elem.name}`;
  const attribs = formatAttributes(elem.attribs, opts);
  if (attribs) {
    tag += ` ${attribs}`;
  }
  if (
    elem.children.length === 0 &&
    (opts.xmlMode
      ? // In XML mode or foreign mode, and user hasn't explicitly turned off self-closing tags
        opts.selfClosingTags !== false
      : // User explicitly asked for self-closing tags, even in HTML mode
        opts.selfClosingTags && singleTag.has(elem.name))
  ) {
    if (!opts.xmlMode) tag += " ";
    tag += "/>";
  } else {
    tag += ">";
    if (elem.children.length > 0) {
      tag += render(elem.children, opts);
    }
    if (opts.xmlMode || !singleTag.has(elem.name)) {
      tag += `</${elem.name}>`;
    }
  }
  return tag;
}
function renderDirective(elem) {
  return `<${elem.data}>`;
}
function renderText(elem, opts) {
  var _a;
  let data = elem.data || "";
  // If entities weren't decoded, no need to encode them back
  if (
    ((_a = opts.encodeEntities) !== null && _a !== void 0
      ? _a
      : opts.decodeEntities) !== false &&
    !(!opts.xmlMode && elem.parent && unencodedElements.has(elem.parent.name))
  ) {
    data =
      opts.xmlMode || opts.encodeEntities !== "utf8"
        ? encodeXML(data)
        : escapeText(data);
  }
  return data;
}
function renderCdata(elem) {
  return `<![CDATA[${elem.children[0].data}]]>`;
}
function renderComment(elem) {
  return `<!--${elem.data}-->`;
}

var CharCodes;
(function (CharCodes) {
  CharCodes[(CharCodes["Tab"] = 9)] = "Tab";
  CharCodes[(CharCodes["NewLine"] = 10)] = "NewLine";
  CharCodes[(CharCodes["FormFeed"] = 12)] = "FormFeed";
  CharCodes[(CharCodes["CarriageReturn"] = 13)] = "CarriageReturn";
  CharCodes[(CharCodes["Space"] = 32)] = "Space";
  CharCodes[(CharCodes["ExclamationMark"] = 33)] = "ExclamationMark";
  CharCodes[(CharCodes["Number"] = 35)] = "Number";
  CharCodes[(CharCodes["Amp"] = 38)] = "Amp";
  CharCodes[(CharCodes["SingleQuote"] = 39)] = "SingleQuote";
  CharCodes[(CharCodes["DoubleQuote"] = 34)] = "DoubleQuote";
  CharCodes[(CharCodes["Dash"] = 45)] = "Dash";
  CharCodes[(CharCodes["Slash"] = 47)] = "Slash";
  CharCodes[(CharCodes["Zero"] = 48)] = "Zero";
  CharCodes[(CharCodes["Nine"] = 57)] = "Nine";
  CharCodes[(CharCodes["Semi"] = 59)] = "Semi";
  CharCodes[(CharCodes["Lt"] = 60)] = "Lt";
  CharCodes[(CharCodes["Eq"] = 61)] = "Eq";
  CharCodes[(CharCodes["Gt"] = 62)] = "Gt";
  CharCodes[(CharCodes["Questionmark"] = 63)] = "Questionmark";
  CharCodes[(CharCodes["UpperA"] = 65)] = "UpperA";
  CharCodes[(CharCodes["LowerA"] = 97)] = "LowerA";
  CharCodes[(CharCodes["UpperF"] = 70)] = "UpperF";
  CharCodes[(CharCodes["LowerF"] = 102)] = "LowerF";
  CharCodes[(CharCodes["UpperZ"] = 90)] = "UpperZ";
  CharCodes[(CharCodes["LowerZ"] = 122)] = "LowerZ";
  CharCodes[(CharCodes["LowerX"] = 120)] = "LowerX";
  CharCodes[(CharCodes["OpeningSquareBracket"] = 91)] = "OpeningSquareBracket";
})(CharCodes || (CharCodes = {}));
/** All the states the tokenizer can be in. */
var State;
(function (State) {
  State[(State["Text"] = 1)] = "Text";
  State[(State["BeforeTagName"] = 2)] = "BeforeTagName";
  State[(State["InTagName"] = 3)] = "InTagName";
  State[(State["InSelfClosingTag"] = 4)] = "InSelfClosingTag";
  State[(State["BeforeClosingTagName"] = 5)] = "BeforeClosingTagName";
  State[(State["InClosingTagName"] = 6)] = "InClosingTagName";
  State[(State["AfterClosingTagName"] = 7)] = "AfterClosingTagName";
  // Attributes
  State[(State["BeforeAttributeName"] = 8)] = "BeforeAttributeName";
  State[(State["InAttributeName"] = 9)] = "InAttributeName";
  State[(State["AfterAttributeName"] = 10)] = "AfterAttributeName";
  State[(State["BeforeAttributeValue"] = 11)] = "BeforeAttributeValue";
  State[(State["InAttributeValueDq"] = 12)] = "InAttributeValueDq";
  State[(State["InAttributeValueSq"] = 13)] = "InAttributeValueSq";
  State[(State["InAttributeValueNq"] = 14)] = "InAttributeValueNq";
  // Declarations
  State[(State["BeforeDeclaration"] = 15)] = "BeforeDeclaration";
  State[(State["InDeclaration"] = 16)] = "InDeclaration";
  // Processing instructions
  State[(State["InProcessingInstruction"] = 17)] = "InProcessingInstruction";
  // Comments & CDATA
  State[(State["BeforeComment"] = 18)] = "BeforeComment";
  State[(State["CDATASequence"] = 19)] = "CDATASequence";
  State[(State["InSpecialComment"] = 20)] = "InSpecialComment";
  State[(State["InCommentLike"] = 21)] = "InCommentLike";
  // Special tags
  State[(State["BeforeSpecialS"] = 22)] = "BeforeSpecialS";
  State[(State["SpecialStartSequence"] = 23)] = "SpecialStartSequence";
  State[(State["InSpecialTag"] = 24)] = "InSpecialTag";
  State[(State["BeforeEntity"] = 25)] = "BeforeEntity";
  State[(State["BeforeNumericEntity"] = 26)] = "BeforeNumericEntity";
  State[(State["InNamedEntity"] = 27)] = "InNamedEntity";
  State[(State["InNumericEntity"] = 28)] = "InNumericEntity";
  State[(State["InHexEntity"] = 29)] = "InHexEntity";
})(State || (State = {}));
function isWhitespace(c) {
  return (
    c === CharCodes.Space ||
    c === CharCodes.NewLine ||
    c === CharCodes.Tab ||
    c === CharCodes.FormFeed ||
    c === CharCodes.CarriageReturn
  );
}
function isEndOfTagSection(c) {
  return c === CharCodes.Slash || c === CharCodes.Gt || isWhitespace(c);
}
function isNumber(c) {
  return c >= CharCodes.Zero && c <= CharCodes.Nine;
}
function isASCIIAlpha(c) {
  return (
    (c >= CharCodes.LowerA && c <= CharCodes.LowerZ) ||
    (c >= CharCodes.UpperA && c <= CharCodes.UpperZ)
  );
}
function isHexDigit$2(c) {
  return (
    (c >= CharCodes.UpperA && c <= CharCodes.UpperF) ||
    (c >= CharCodes.LowerA && c <= CharCodes.LowerF)
  );
}
var QuoteType;
(function (QuoteType) {
  QuoteType[(QuoteType["NoValue"] = 0)] = "NoValue";
  QuoteType[(QuoteType["Unquoted"] = 1)] = "Unquoted";
  QuoteType[(QuoteType["Single"] = 2)] = "Single";
  QuoteType[(QuoteType["Double"] = 3)] = "Double";
})(QuoteType || (QuoteType = {}));
/**
 * Sequences used to match longer strings.
 *
 * We don't have `Script`, `Style`, or `Title` here. Instead, we re-use the *End
 * sequences with an increased offset.
 */
const Sequences = {
  Cdata: new Uint8Array([0x43, 0x44, 0x41, 0x54, 0x41, 0x5b]),
  CdataEnd: new Uint8Array([0x5d, 0x5d, 0x3e]),
  CommentEnd: new Uint8Array([0x2d, 0x2d, 0x3e]),
  ScriptEnd: new Uint8Array([0x3c, 0x2f, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74]),
  StyleEnd: new Uint8Array([0x3c, 0x2f, 0x73, 0x74, 0x79, 0x6c, 0x65]),
  TitleEnd: new Uint8Array([0x3c, 0x2f, 0x74, 0x69, 0x74, 0x6c, 0x65]), // `</title`
};
let Tokenizer$2 = class Tokenizer {
  constructor({ xmlMode = false, decodeEntities = true }, cbs) {
    this.cbs = cbs;
    /** The current state the tokenizer is in. */
    this.state = State.Text;
    /** The read buffer. */
    this.buffer = "";
    /** The beginning of the section that is currently being read. */
    this.sectionStart = 0;
    /** The index within the buffer that we are currently looking at. */
    this.index = 0;
    /** Some behavior, eg. when decoding entities, is done while we are in another state. This keeps track of the other state type. */
    this.baseState = State.Text;
    /** For special parsing behavior inside of script and style tags. */
    this.isSpecial = false;
    /** Indicates whether the tokenizer has been paused. */
    this.running = true;
    /** The offset of the current buffer. */
    this.offset = 0;
    this.currentSequence = undefined;
    this.sequenceIndex = 0;
    this.trieIndex = 0;
    this.trieCurrent = 0;
    /** For named entities, the index of the value. For numeric entities, the code point. */
    this.entityResult = 0;
    this.entityExcess = 0;
    this.xmlMode = xmlMode;
    this.decodeEntities = decodeEntities;
    this.entityTrie = xmlMode ? xmlDecodeTree : htmlDecodeTree;
  }
  reset() {
    this.state = State.Text;
    this.buffer = "";
    this.sectionStart = 0;
    this.index = 0;
    this.baseState = State.Text;
    this.currentSequence = undefined;
    this.running = true;
    this.offset = 0;
  }
  write(chunk) {
    this.offset += this.buffer.length;
    this.buffer = chunk;
    this.parse();
  }
  end() {
    if (this.running) this.finish();
  }
  pause() {
    this.running = false;
  }
  resume() {
    this.running = true;
    if (this.index < this.buffer.length + this.offset) {
      this.parse();
    }
  }
  /**
   * The current index within all of the written data.
   */
  getIndex() {
    return this.index;
  }
  /**
   * The start of the current section.
   */
  getSectionStart() {
    return this.sectionStart;
  }
  stateText(c) {
    if (
      c === CharCodes.Lt ||
      (!this.decodeEntities && this.fastForwardTo(CharCodes.Lt))
    ) {
      if (this.index > this.sectionStart) {
        this.cbs.ontext(this.sectionStart, this.index);
      }
      this.state = State.BeforeTagName;
      this.sectionStart = this.index;
    } else if (this.decodeEntities && c === CharCodes.Amp) {
      this.state = State.BeforeEntity;
    }
  }
  stateSpecialStartSequence(c) {
    const isEnd = this.sequenceIndex === this.currentSequence.length;
    const isMatch = isEnd
      ? // If we are at the end of the sequence, make sure the tag name has ended
        isEndOfTagSection(c)
      : // Otherwise, do a case-insensitive comparison
        (c | 0x20) === this.currentSequence[this.sequenceIndex];
    if (!isMatch) {
      this.isSpecial = false;
    } else if (!isEnd) {
      this.sequenceIndex++;
      return;
    }
    this.sequenceIndex = 0;
    this.state = State.InTagName;
    this.stateInTagName(c);
  }
  /** Look for an end tag. For <title> tags, also decode entities. */
  stateInSpecialTag(c) {
    if (this.sequenceIndex === this.currentSequence.length) {
      if (c === CharCodes.Gt || isWhitespace(c)) {
        const endOfText = this.index - this.currentSequence.length;
        if (this.sectionStart < endOfText) {
          // Spoof the index so that reported locations match up.
          const actualIndex = this.index;
          this.index = endOfText;
          this.cbs.ontext(this.sectionStart, endOfText);
          this.index = actualIndex;
        }
        this.isSpecial = false;
        this.sectionStart = endOfText + 2; // Skip over the `</`
        this.stateInClosingTagName(c);
        return; // We are done; skip the rest of the function.
      }
      this.sequenceIndex = 0;
    }
    if ((c | 0x20) === this.currentSequence[this.sequenceIndex]) {
      this.sequenceIndex += 1;
    } else if (this.sequenceIndex === 0) {
      if (this.currentSequence === Sequences.TitleEnd) {
        // We have to parse entities in <title> tags.
        if (this.decodeEntities && c === CharCodes.Amp) {
          this.state = State.BeforeEntity;
        }
      } else if (this.fastForwardTo(CharCodes.Lt)) {
        // Outside of <title> tags, we can fast-forward.
        this.sequenceIndex = 1;
      }
    } else {
      // If we see a `<`, set the sequence index to 1; useful for eg. `<</script>`.
      this.sequenceIndex = Number(c === CharCodes.Lt);
    }
  }
  stateCDATASequence(c) {
    if (c === Sequences.Cdata[this.sequenceIndex]) {
      if (++this.sequenceIndex === Sequences.Cdata.length) {
        this.state = State.InCommentLike;
        this.currentSequence = Sequences.CdataEnd;
        this.sequenceIndex = 0;
        this.sectionStart = this.index + 1;
      }
    } else {
      this.sequenceIndex = 0;
      this.state = State.InDeclaration;
      this.stateInDeclaration(c); // Reconsume the character
    }
  }
  /**
   * When we wait for one specific character, we can speed things up
   * by skipping through the buffer until we find it.
   *
   * @returns Whether the character was found.
   */
  fastForwardTo(c) {
    while (++this.index < this.buffer.length + this.offset) {
      if (this.buffer.charCodeAt(this.index - this.offset) === c) {
        return true;
      }
    }
    /*
     * We increment the index at the end of the `parse` loop,
     * so set it to `buffer.length - 1` here.
     *
     * TODO: Refactor `parse` to increment index before calling states.
     */
    this.index = this.buffer.length + this.offset - 1;
    return false;
  }
  /**
   * Comments and CDATA end with `-->` and `]]>`.
   *
   * Their common qualities are:
   * - Their end sequences have a distinct character they start with.
   * - That character is then repeated, so we have to check multiple repeats.
   * - All characters but the start character of the sequence can be skipped.
   */
  stateInCommentLike(c) {
    if (c === this.currentSequence[this.sequenceIndex]) {
      if (++this.sequenceIndex === this.currentSequence.length) {
        if (this.currentSequence === Sequences.CdataEnd) {
          this.cbs.oncdata(this.sectionStart, this.index, 2);
        } else {
          this.cbs.oncomment(this.sectionStart, this.index, 2);
        }
        this.sequenceIndex = 0;
        this.sectionStart = this.index + 1;
        this.state = State.Text;
      }
    } else if (this.sequenceIndex === 0) {
      // Fast-forward to the first character of the sequence
      if (this.fastForwardTo(this.currentSequence[0])) {
        this.sequenceIndex = 1;
      }
    } else if (c !== this.currentSequence[this.sequenceIndex - 1]) {
      // Allow long sequences, eg. --->, ]]]>
      this.sequenceIndex = 0;
    }
  }
  /**
   * HTML only allows ASCII alpha characters (a-z and A-Z) at the beginning of a tag name.
   *
   * XML allows a lot more characters here (@see https://www.w3.org/TR/REC-xml/#NT-NameStartChar).
   * We allow anything that wouldn't end the tag.
   */
  isTagStartChar(c) {
    return this.xmlMode ? !isEndOfTagSection(c) : isASCIIAlpha(c);
  }
  startSpecial(sequence, offset) {
    this.isSpecial = true;
    this.currentSequence = sequence;
    this.sequenceIndex = offset;
    this.state = State.SpecialStartSequence;
  }
  stateBeforeTagName(c) {
    if (c === CharCodes.ExclamationMark) {
      this.state = State.BeforeDeclaration;
      this.sectionStart = this.index + 1;
    } else if (c === CharCodes.Questionmark) {
      this.state = State.InProcessingInstruction;
      this.sectionStart = this.index + 1;
    } else if (this.isTagStartChar(c)) {
      const lower = c | 0x20;
      this.sectionStart = this.index;
      if (!this.xmlMode && lower === Sequences.TitleEnd[2]) {
        this.startSpecial(Sequences.TitleEnd, 3);
      } else {
        this.state =
          !this.xmlMode && lower === Sequences.ScriptEnd[2]
            ? State.BeforeSpecialS
            : State.InTagName;
      }
    } else if (c === CharCodes.Slash) {
      this.state = State.BeforeClosingTagName;
    } else {
      this.state = State.Text;
      this.stateText(c);
    }
  }
  stateInTagName(c) {
    if (isEndOfTagSection(c)) {
      this.cbs.onopentagname(this.sectionStart, this.index);
      this.sectionStart = -1;
      this.state = State.BeforeAttributeName;
      this.stateBeforeAttributeName(c);
    }
  }
  stateBeforeClosingTagName(c) {
    if (isWhitespace(c));
    else if (c === CharCodes.Gt) {
      this.state = State.Text;
    } else {
      this.state = this.isTagStartChar(c)
        ? State.InClosingTagName
        : State.InSpecialComment;
      this.sectionStart = this.index;
    }
  }
  stateInClosingTagName(c) {
    if (c === CharCodes.Gt || isWhitespace(c)) {
      this.cbs.onclosetag(this.sectionStart, this.index);
      this.sectionStart = -1;
      this.state = State.AfterClosingTagName;
      this.stateAfterClosingTagName(c);
    }
  }
  stateAfterClosingTagName(c) {
    // Skip everything until ">"
    if (c === CharCodes.Gt || this.fastForwardTo(CharCodes.Gt)) {
      this.state = State.Text;
      this.baseState = State.Text;
      this.sectionStart = this.index + 1;
    }
  }
  stateBeforeAttributeName(c) {
    if (c === CharCodes.Gt) {
      this.cbs.onopentagend(this.index);
      if (this.isSpecial) {
        this.state = State.InSpecialTag;
        this.sequenceIndex = 0;
      } else {
        this.state = State.Text;
      }
      this.baseState = this.state;
      this.sectionStart = this.index + 1;
    } else if (c === CharCodes.Slash) {
      this.state = State.InSelfClosingTag;
    } else if (!isWhitespace(c)) {
      this.state = State.InAttributeName;
      this.sectionStart = this.index;
    }
  }
  stateInSelfClosingTag(c) {
    if (c === CharCodes.Gt) {
      this.cbs.onselfclosingtag(this.index);
      this.state = State.Text;
      this.baseState = State.Text;
      this.sectionStart = this.index + 1;
      this.isSpecial = false; // Reset special state, in case of self-closing special tags
    } else if (!isWhitespace(c)) {
      this.state = State.BeforeAttributeName;
      this.stateBeforeAttributeName(c);
    }
  }
  stateInAttributeName(c) {
    if (c === CharCodes.Eq || isEndOfTagSection(c)) {
      this.cbs.onattribname(this.sectionStart, this.index);
      this.sectionStart = -1;
      this.state = State.AfterAttributeName;
      this.stateAfterAttributeName(c);
    }
  }
  stateAfterAttributeName(c) {
    if (c === CharCodes.Eq) {
      this.state = State.BeforeAttributeValue;
    } else if (c === CharCodes.Slash || c === CharCodes.Gt) {
      this.cbs.onattribend(QuoteType.NoValue, this.index);
      this.state = State.BeforeAttributeName;
      this.stateBeforeAttributeName(c);
    } else if (!isWhitespace(c)) {
      this.cbs.onattribend(QuoteType.NoValue, this.index);
      this.state = State.InAttributeName;
      this.sectionStart = this.index;
    }
  }
  stateBeforeAttributeValue(c) {
    if (c === CharCodes.DoubleQuote) {
      this.state = State.InAttributeValueDq;
      this.sectionStart = this.index + 1;
    } else if (c === CharCodes.SingleQuote) {
      this.state = State.InAttributeValueSq;
      this.sectionStart = this.index + 1;
    } else if (!isWhitespace(c)) {
      this.sectionStart = this.index;
      this.state = State.InAttributeValueNq;
      this.stateInAttributeValueNoQuotes(c); // Reconsume token
    }
  }
  handleInAttributeValue(c, quote) {
    if (c === quote || (!this.decodeEntities && this.fastForwardTo(quote))) {
      this.cbs.onattribdata(this.sectionStart, this.index);
      this.sectionStart = -1;
      this.cbs.onattribend(
        quote === CharCodes.DoubleQuote ? QuoteType.Double : QuoteType.Single,
        this.index,
      );
      this.state = State.BeforeAttributeName;
    } else if (this.decodeEntities && c === CharCodes.Amp) {
      this.baseState = this.state;
      this.state = State.BeforeEntity;
    }
  }
  stateInAttributeValueDoubleQuotes(c) {
    this.handleInAttributeValue(c, CharCodes.DoubleQuote);
  }
  stateInAttributeValueSingleQuotes(c) {
    this.handleInAttributeValue(c, CharCodes.SingleQuote);
  }
  stateInAttributeValueNoQuotes(c) {
    if (isWhitespace(c) || c === CharCodes.Gt) {
      this.cbs.onattribdata(this.sectionStart, this.index);
      this.sectionStart = -1;
      this.cbs.onattribend(QuoteType.Unquoted, this.index);
      this.state = State.BeforeAttributeName;
      this.stateBeforeAttributeName(c);
    } else if (this.decodeEntities && c === CharCodes.Amp) {
      this.baseState = this.state;
      this.state = State.BeforeEntity;
    }
  }
  stateBeforeDeclaration(c) {
    if (c === CharCodes.OpeningSquareBracket) {
      this.state = State.CDATASequence;
      this.sequenceIndex = 0;
    } else {
      this.state =
        c === CharCodes.Dash ? State.BeforeComment : State.InDeclaration;
    }
  }
  stateInDeclaration(c) {
    if (c === CharCodes.Gt || this.fastForwardTo(CharCodes.Gt)) {
      this.cbs.ondeclaration(this.sectionStart, this.index);
      this.state = State.Text;
      this.sectionStart = this.index + 1;
    }
  }
  stateInProcessingInstruction(c) {
    if (c === CharCodes.Gt || this.fastForwardTo(CharCodes.Gt)) {
      this.cbs.onprocessinginstruction(this.sectionStart, this.index);
      this.state = State.Text;
      this.sectionStart = this.index + 1;
    }
  }
  stateBeforeComment(c) {
    if (c === CharCodes.Dash) {
      this.state = State.InCommentLike;
      this.currentSequence = Sequences.CommentEnd;
      // Allow short comments (eg. <!-->)
      this.sequenceIndex = 2;
      this.sectionStart = this.index + 1;
    } else {
      this.state = State.InDeclaration;
    }
  }
  stateInSpecialComment(c) {
    if (c === CharCodes.Gt || this.fastForwardTo(CharCodes.Gt)) {
      this.cbs.oncomment(this.sectionStart, this.index, 0);
      this.state = State.Text;
      this.sectionStart = this.index + 1;
    }
  }
  stateBeforeSpecialS(c) {
    const lower = c | 0x20;
    if (lower === Sequences.ScriptEnd[3]) {
      this.startSpecial(Sequences.ScriptEnd, 4);
    } else if (lower === Sequences.StyleEnd[3]) {
      this.startSpecial(Sequences.StyleEnd, 4);
    } else {
      this.state = State.InTagName;
      this.stateInTagName(c); // Consume the token again
    }
  }
  stateBeforeEntity(c) {
    // Start excess with 1 to include the '&'
    this.entityExcess = 1;
    this.entityResult = 0;
    if (c === CharCodes.Number) {
      this.state = State.BeforeNumericEntity;
    } else if (c === CharCodes.Amp);
    else {
      this.trieIndex = 0;
      this.trieCurrent = this.entityTrie[0];
      this.state = State.InNamedEntity;
      this.stateInNamedEntity(c);
    }
  }
  stateInNamedEntity(c) {
    this.entityExcess += 1;
    this.trieIndex = determineBranch(
      this.entityTrie,
      this.trieCurrent,
      this.trieIndex + 1,
      c,
    );
    if (this.trieIndex < 0) {
      this.emitNamedEntity();
      this.index--;
      return;
    }
    this.trieCurrent = this.entityTrie[this.trieIndex];
    const masked = this.trieCurrent & BinTrieFlags.VALUE_LENGTH;
    // If the branch is a value, store it and continue
    if (masked) {
      // The mask is the number of bytes of the value, including the current byte.
      const valueLength = (masked >> 14) - 1;
      // If we have a legacy entity while parsing strictly, just skip the number of bytes
      if (!this.allowLegacyEntity() && c !== CharCodes.Semi) {
        this.trieIndex += valueLength;
      } else {
        // Add 1 as we have already incremented the excess
        const entityStart = this.index - this.entityExcess + 1;
        if (entityStart > this.sectionStart) {
          this.emitPartial(this.sectionStart, entityStart);
        }
        // If this is a surrogate pair, consume the next two bytes
        this.entityResult = this.trieIndex;
        this.trieIndex += valueLength;
        this.entityExcess = 0;
        this.sectionStart = this.index + 1;
        if (valueLength === 0) {
          this.emitNamedEntity();
        }
      }
    }
  }
  emitNamedEntity() {
    this.state = this.baseState;
    if (this.entityResult === 0) {
      return;
    }
    const valueLength =
      (this.entityTrie[this.entityResult] & BinTrieFlags.VALUE_LENGTH) >> 14;
    switch (valueLength) {
      case 1: {
        this.emitCodePoint(
          this.entityTrie[this.entityResult] & ~BinTrieFlags.VALUE_LENGTH,
        );
        break;
      }
      case 2: {
        this.emitCodePoint(this.entityTrie[this.entityResult + 1]);
        break;
      }
      case 3: {
        this.emitCodePoint(this.entityTrie[this.entityResult + 1]);
        this.emitCodePoint(this.entityTrie[this.entityResult + 2]);
      }
    }
  }
  stateBeforeNumericEntity(c) {
    if ((c | 0x20) === CharCodes.LowerX) {
      this.entityExcess++;
      this.state = State.InHexEntity;
    } else {
      this.state = State.InNumericEntity;
      this.stateInNumericEntity(c);
    }
  }
  emitNumericEntity(strict) {
    const entityStart = this.index - this.entityExcess - 1;
    const numberStart =
      entityStart + 2 + Number(this.state === State.InHexEntity);
    if (numberStart !== this.index) {
      // Emit leading data if any
      if (entityStart > this.sectionStart) {
        this.emitPartial(this.sectionStart, entityStart);
      }
      this.sectionStart = this.index + Number(strict);
      this.emitCodePoint(replaceCodePoint(this.entityResult));
    }
    this.state = this.baseState;
  }
  stateInNumericEntity(c) {
    if (c === CharCodes.Semi) {
      this.emitNumericEntity(true);
    } else if (isNumber(c)) {
      this.entityResult = this.entityResult * 10 + (c - CharCodes.Zero);
      this.entityExcess++;
    } else {
      if (this.allowLegacyEntity()) {
        this.emitNumericEntity(false);
      } else {
        this.state = this.baseState;
      }
      this.index--;
    }
  }
  stateInHexEntity(c) {
    if (c === CharCodes.Semi) {
      this.emitNumericEntity(true);
    } else if (isNumber(c)) {
      this.entityResult = this.entityResult * 16 + (c - CharCodes.Zero);
      this.entityExcess++;
    } else if (isHexDigit$2(c)) {
      this.entityResult =
        this.entityResult * 16 + ((c | 0x20) - CharCodes.LowerA + 10);
      this.entityExcess++;
    } else {
      if (this.allowLegacyEntity()) {
        this.emitNumericEntity(false);
      } else {
        this.state = this.baseState;
      }
      this.index--;
    }
  }
  allowLegacyEntity() {
    return (
      !this.xmlMode &&
      (this.baseState === State.Text || this.baseState === State.InSpecialTag)
    );
  }
  /**
   * Remove data that has already been consumed from the buffer.
   */
  cleanup() {
    // If we are inside of text or attributes, emit what we already have.
    if (this.running && this.sectionStart !== this.index) {
      if (
        this.state === State.Text ||
        (this.state === State.InSpecialTag && this.sequenceIndex === 0)
      ) {
        this.cbs.ontext(this.sectionStart, this.index);
        this.sectionStart = this.index;
      } else if (
        this.state === State.InAttributeValueDq ||
        this.state === State.InAttributeValueSq ||
        this.state === State.InAttributeValueNq
      ) {
        this.cbs.onattribdata(this.sectionStart, this.index);
        this.sectionStart = this.index;
      }
    }
  }
  shouldContinue() {
    return this.index < this.buffer.length + this.offset && this.running;
  }
  /**
   * Iterates through the buffer, calling the function corresponding to the current state.
   *
   * States that are more likely to be hit are higher up, as a performance improvement.
   */
  parse() {
    while (this.shouldContinue()) {
      const c = this.buffer.charCodeAt(this.index - this.offset);
      switch (this.state) {
        case State.Text: {
          this.stateText(c);
          break;
        }
        case State.SpecialStartSequence: {
          this.stateSpecialStartSequence(c);
          break;
        }
        case State.InSpecialTag: {
          this.stateInSpecialTag(c);
          break;
        }
        case State.CDATASequence: {
          this.stateCDATASequence(c);
          break;
        }
        case State.InAttributeValueDq: {
          this.stateInAttributeValueDoubleQuotes(c);
          break;
        }
        case State.InAttributeName: {
          this.stateInAttributeName(c);
          break;
        }
        case State.InCommentLike: {
          this.stateInCommentLike(c);
          break;
        }
        case State.InSpecialComment: {
          this.stateInSpecialComment(c);
          break;
        }
        case State.BeforeAttributeName: {
          this.stateBeforeAttributeName(c);
          break;
        }
        case State.InTagName: {
          this.stateInTagName(c);
          break;
        }
        case State.InClosingTagName: {
          this.stateInClosingTagName(c);
          break;
        }
        case State.BeforeTagName: {
          this.stateBeforeTagName(c);
          break;
        }
        case State.AfterAttributeName: {
          this.stateAfterAttributeName(c);
          break;
        }
        case State.InAttributeValueSq: {
          this.stateInAttributeValueSingleQuotes(c);
          break;
        }
        case State.BeforeAttributeValue: {
          this.stateBeforeAttributeValue(c);
          break;
        }
        case State.BeforeClosingTagName: {
          this.stateBeforeClosingTagName(c);
          break;
        }
        case State.AfterClosingTagName: {
          this.stateAfterClosingTagName(c);
          break;
        }
        case State.BeforeSpecialS: {
          this.stateBeforeSpecialS(c);
          break;
        }
        case State.InAttributeValueNq: {
          this.stateInAttributeValueNoQuotes(c);
          break;
        }
        case State.InSelfClosingTag: {
          this.stateInSelfClosingTag(c);
          break;
        }
        case State.InDeclaration: {
          this.stateInDeclaration(c);
          break;
        }
        case State.BeforeDeclaration: {
          this.stateBeforeDeclaration(c);
          break;
        }
        case State.BeforeComment: {
          this.stateBeforeComment(c);
          break;
        }
        case State.InProcessingInstruction: {
          this.stateInProcessingInstruction(c);
          break;
        }
        case State.InNamedEntity: {
          this.stateInNamedEntity(c);
          break;
        }
        case State.BeforeEntity: {
          this.stateBeforeEntity(c);
          break;
        }
        case State.InHexEntity: {
          this.stateInHexEntity(c);
          break;
        }
        case State.InNumericEntity: {
          this.stateInNumericEntity(c);
          break;
        }
        default: {
          // `this._state === State.BeforeNumericEntity`
          this.stateBeforeNumericEntity(c);
        }
      }
      this.index++;
    }
    this.cleanup();
  }
  finish() {
    if (this.state === State.InNamedEntity) {
      this.emitNamedEntity();
    }
    // If there is remaining data, emit it in a reasonable way
    if (this.sectionStart < this.index) {
      this.handleTrailingData();
    }
    this.cbs.onend();
  }
  /** Handle any trailing data. */
  handleTrailingData() {
    const endIndex = this.buffer.length + this.offset;
    if (this.state === State.InCommentLike) {
      if (this.currentSequence === Sequences.CdataEnd) {
        this.cbs.oncdata(this.sectionStart, endIndex, 0);
      } else {
        this.cbs.oncomment(this.sectionStart, endIndex, 0);
      }
    } else if (
      this.state === State.InNumericEntity &&
      this.allowLegacyEntity()
    ) {
      this.emitNumericEntity(false);
      // All trailing data will have been consumed
    } else if (this.state === State.InHexEntity && this.allowLegacyEntity()) {
      this.emitNumericEntity(false);
      // All trailing data will have been consumed
    } else if (
      this.state === State.InTagName ||
      this.state === State.BeforeAttributeName ||
      this.state === State.BeforeAttributeValue ||
      this.state === State.AfterAttributeName ||
      this.state === State.InAttributeName ||
      this.state === State.InAttributeValueSq ||
      this.state === State.InAttributeValueDq ||
      this.state === State.InAttributeValueNq ||
      this.state === State.InClosingTagName
    );
    else {
      this.cbs.ontext(this.sectionStart, endIndex);
    }
  }
  emitPartial(start, endIndex) {
    if (
      this.baseState !== State.Text &&
      this.baseState !== State.InSpecialTag
    ) {
      this.cbs.onattribdata(start, endIndex);
    } else {
      this.cbs.ontext(start, endIndex);
    }
  }
  emitCodePoint(cp) {
    if (
      this.baseState !== State.Text &&
      this.baseState !== State.InSpecialTag
    ) {
      this.cbs.onattribentity(cp);
    } else {
      this.cbs.ontextentity(cp);
    }
  }
};

const formTags = new Set([
  "input",
  "option",
  "optgroup",
  "select",
  "button",
  "datalist",
  "textarea",
]);
const pTag = new Set(["p"]);
const tableSectionTags = new Set(["thead", "tbody"]);
const ddtTags = new Set(["dd", "dt"]);
const rtpTags = new Set(["rt", "rp"]);
const openImpliesClose = new Map([
  ["tr", new Set(["tr", "th", "td"])],
  ["th", new Set(["th"])],
  ["td", new Set(["thead", "th", "td"])],
  ["body", new Set(["head", "link", "script"])],
  ["li", new Set(["li"])],
  ["p", pTag],
  ["h1", pTag],
  ["h2", pTag],
  ["h3", pTag],
  ["h4", pTag],
  ["h5", pTag],
  ["h6", pTag],
  ["select", formTags],
  ["input", formTags],
  ["output", formTags],
  ["button", formTags],
  ["datalist", formTags],
  ["textarea", formTags],
  ["option", new Set(["option"])],
  ["optgroup", new Set(["optgroup", "option"])],
  ["dd", ddtTags],
  ["dt", ddtTags],
  ["address", pTag],
  ["article", pTag],
  ["aside", pTag],
  ["blockquote", pTag],
  ["details", pTag],
  ["div", pTag],
  ["dl", pTag],
  ["fieldset", pTag],
  ["figcaption", pTag],
  ["figure", pTag],
  ["footer", pTag],
  ["form", pTag],
  ["header", pTag],
  ["hr", pTag],
  ["main", pTag],
  ["nav", pTag],
  ["ol", pTag],
  ["pre", pTag],
  ["section", pTag],
  ["table", pTag],
  ["ul", pTag],
  ["rt", rtpTags],
  ["rp", rtpTags],
  ["tbody", tableSectionTags],
  ["tfoot", tableSectionTags],
]);
const voidElements = new Set([
  "area",
  "base",
  "basefont",
  "br",
  "col",
  "command",
  "embed",
  "frame",
  "hr",
  "img",
  "input",
  "isindex",
  "keygen",
  "link",
  "meta",
  "param",
  "source",
  "track",
  "wbr",
]);
const foreignContextElements = new Set(["math", "svg"]);
const htmlIntegrationElements = new Set([
  "mi",
  "mo",
  "mn",
  "ms",
  "mtext",
  "annotation-xml",
  "foreignobject",
  "desc",
  "title",
]);
const reNameEnd = /\s|\//;
let Parser$1 = class Parser {
  constructor(cbs, options = {}) {
    var _a, _b, _c, _d, _e;
    this.options = options;
    /** The start index of the last event. */
    this.startIndex = 0;
    /** The end index of the last event. */
    this.endIndex = 0;
    /**
     * Store the start index of the current open tag,
     * so we can update the start index for attributes.
     */
    this.openTagStart = 0;
    this.tagname = "";
    this.attribname = "";
    this.attribvalue = "";
    this.attribs = null;
    this.stack = [];
    this.foreignContext = [];
    this.buffers = [];
    this.bufferOffset = 0;
    /** The index of the last written buffer. Used when resuming after a `pause()`. */
    this.writeIndex = 0;
    /** Indicates whether the parser has finished running / `.end` has been called. */
    this.ended = false;
    this.cbs = cbs !== null && cbs !== void 0 ? cbs : {};
    this.lowerCaseTagNames =
      (_a = options.lowerCaseTags) !== null && _a !== void 0
        ? _a
        : !options.xmlMode;
    this.lowerCaseAttributeNames =
      (_b = options.lowerCaseAttributeNames) !== null && _b !== void 0
        ? _b
        : !options.xmlMode;
    this.tokenizer = new (
      (_c = options.Tokenizer) !== null && _c !== void 0 ? _c : Tokenizer$2
    )(this.options, this);
    (_e = (_d = this.cbs).onparserinit) === null || _e === void 0
      ? void 0
      : _e.call(_d, this);
  }
  // Tokenizer event handlers
  /** @internal */
  ontext(start, endIndex) {
    var _a, _b;
    const data = this.getSlice(start, endIndex);
    this.endIndex = endIndex - 1;
    (_b = (_a = this.cbs).ontext) === null || _b === void 0
      ? void 0
      : _b.call(_a, data);
    this.startIndex = endIndex;
  }
  /** @internal */
  ontextentity(cp) {
    var _a, _b;
    /*
     * Entities can be emitted on the character, or directly after.
     * We use the section start here to get accurate indices.
     */
    const index = this.tokenizer.getSectionStart();
    this.endIndex = index - 1;
    (_b = (_a = this.cbs).ontext) === null || _b === void 0
      ? void 0
      : _b.call(_a, fromCodePoint(cp));
    this.startIndex = index;
  }
  isVoidElement(name) {
    return !this.options.xmlMode && voidElements.has(name);
  }
  /** @internal */
  onopentagname(start, endIndex) {
    this.endIndex = endIndex;
    let name = this.getSlice(start, endIndex);
    if (this.lowerCaseTagNames) {
      name = name.toLowerCase();
    }
    this.emitOpenTag(name);
  }
  emitOpenTag(name) {
    var _a, _b, _c, _d;
    this.openTagStart = this.startIndex;
    this.tagname = name;
    const impliesClose = !this.options.xmlMode && openImpliesClose.get(name);
    if (impliesClose) {
      while (
        this.stack.length > 0 &&
        impliesClose.has(this.stack[this.stack.length - 1])
      ) {
        const element = this.stack.pop();
        (_b = (_a = this.cbs).onclosetag) === null || _b === void 0
          ? void 0
          : _b.call(_a, element, true);
      }
    }
    if (!this.isVoidElement(name)) {
      this.stack.push(name);
      if (foreignContextElements.has(name)) {
        this.foreignContext.push(true);
      } else if (htmlIntegrationElements.has(name)) {
        this.foreignContext.push(false);
      }
    }
    (_d = (_c = this.cbs).onopentagname) === null || _d === void 0
      ? void 0
      : _d.call(_c, name);
    if (this.cbs.onopentag) this.attribs = {};
  }
  endOpenTag(isImplied) {
    var _a, _b;
    this.startIndex = this.openTagStart;
    if (this.attribs) {
      (_b = (_a = this.cbs).onopentag) === null || _b === void 0
        ? void 0
        : _b.call(_a, this.tagname, this.attribs, isImplied);
      this.attribs = null;
    }
    if (this.cbs.onclosetag && this.isVoidElement(this.tagname)) {
      this.cbs.onclosetag(this.tagname, true);
    }
    this.tagname = "";
  }
  /** @internal */
  onopentagend(endIndex) {
    this.endIndex = endIndex;
    this.endOpenTag(false);
    // Set `startIndex` for next node
    this.startIndex = endIndex + 1;
  }
  /** @internal */
  onclosetag(start, endIndex) {
    var _a, _b, _c, _d, _e, _f;
    this.endIndex = endIndex;
    let name = this.getSlice(start, endIndex);
    if (this.lowerCaseTagNames) {
      name = name.toLowerCase();
    }
    if (foreignContextElements.has(name) || htmlIntegrationElements.has(name)) {
      this.foreignContext.pop();
    }
    if (!this.isVoidElement(name)) {
      const pos = this.stack.lastIndexOf(name);
      if (pos !== -1) {
        if (this.cbs.onclosetag) {
          let count = this.stack.length - pos;
          while (count--) {
            // We know the stack has sufficient elements.
            this.cbs.onclosetag(this.stack.pop(), count !== 0);
          }
        } else this.stack.length = pos;
      } else if (!this.options.xmlMode && name === "p") {
        // Implicit open before close
        this.emitOpenTag("p");
        this.closeCurrentTag(true);
      }
    } else if (!this.options.xmlMode && name === "br") {
      // We can't use `emitOpenTag` for implicit open, as `br` would be implicitly closed.
      (_b = (_a = this.cbs).onopentagname) === null || _b === void 0
        ? void 0
        : _b.call(_a, "br");
      (_d = (_c = this.cbs).onopentag) === null || _d === void 0
        ? void 0
        : _d.call(_c, "br", {}, true);
      (_f = (_e = this.cbs).onclosetag) === null || _f === void 0
        ? void 0
        : _f.call(_e, "br", false);
    }
    // Set `startIndex` for next node
    this.startIndex = endIndex + 1;
  }
  /** @internal */
  onselfclosingtag(endIndex) {
    this.endIndex = endIndex;
    if (
      this.options.xmlMode ||
      this.options.recognizeSelfClosing ||
      this.foreignContext[this.foreignContext.length - 1]
    ) {
      this.closeCurrentTag(false);
      // Set `startIndex` for next node
      this.startIndex = endIndex + 1;
    } else {
      // Ignore the fact that the tag is self-closing.
      this.onopentagend(endIndex);
    }
  }
  closeCurrentTag(isOpenImplied) {
    var _a, _b;
    const name = this.tagname;
    this.endOpenTag(isOpenImplied);
    // Self-closing tags will be on the top of the stack
    if (this.stack[this.stack.length - 1] === name) {
      // If the opening tag isn't implied, the closing tag has to be implied.
      (_b = (_a = this.cbs).onclosetag) === null || _b === void 0
        ? void 0
        : _b.call(_a, name, !isOpenImplied);
      this.stack.pop();
    }
  }
  /** @internal */
  onattribname(start, endIndex) {
    this.startIndex = start;
    const name = this.getSlice(start, endIndex);
    this.attribname = this.lowerCaseAttributeNames ? name.toLowerCase() : name;
  }
  /** @internal */
  onattribdata(start, endIndex) {
    this.attribvalue += this.getSlice(start, endIndex);
  }
  /** @internal */
  onattribentity(cp) {
    this.attribvalue += fromCodePoint(cp);
  }
  /** @internal */
  onattribend(quote, endIndex) {
    var _a, _b;
    this.endIndex = endIndex;
    (_b = (_a = this.cbs).onattribute) === null || _b === void 0
      ? void 0
      : _b.call(
          _a,
          this.attribname,
          this.attribvalue,
          quote === QuoteType.Double
            ? '"'
            : quote === QuoteType.Single
              ? "'"
              : quote === QuoteType.NoValue
                ? undefined
                : null,
        );
    if (
      this.attribs &&
      !Object.prototype.hasOwnProperty.call(this.attribs, this.attribname)
    ) {
      this.attribs[this.attribname] = this.attribvalue;
    }
    this.attribvalue = "";
  }
  getInstructionName(value) {
    const index = value.search(reNameEnd);
    let name = index < 0 ? value : value.substr(0, index);
    if (this.lowerCaseTagNames) {
      name = name.toLowerCase();
    }
    return name;
  }
  /** @internal */
  ondeclaration(start, endIndex) {
    this.endIndex = endIndex;
    const value = this.getSlice(start, endIndex);
    if (this.cbs.onprocessinginstruction) {
      const name = this.getInstructionName(value);
      this.cbs.onprocessinginstruction(`!${name}`, `!${value}`);
    }
    // Set `startIndex` for next node
    this.startIndex = endIndex + 1;
  }
  /** @internal */
  onprocessinginstruction(start, endIndex) {
    this.endIndex = endIndex;
    const value = this.getSlice(start, endIndex);
    if (this.cbs.onprocessinginstruction) {
      const name = this.getInstructionName(value);
      this.cbs.onprocessinginstruction(`?${name}`, `?${value}`);
    }
    // Set `startIndex` for next node
    this.startIndex = endIndex + 1;
  }
  /** @internal */
  oncomment(start, endIndex, offset) {
    var _a, _b, _c, _d;
    this.endIndex = endIndex;
    (_b = (_a = this.cbs).oncomment) === null || _b === void 0
      ? void 0
      : _b.call(_a, this.getSlice(start, endIndex - offset));
    (_d = (_c = this.cbs).oncommentend) === null || _d === void 0
      ? void 0
      : _d.call(_c);
    // Set `startIndex` for next node
    this.startIndex = endIndex + 1;
  }
  /** @internal */
  oncdata(start, endIndex, offset) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
    this.endIndex = endIndex;
    const value = this.getSlice(start, endIndex - offset);
    if (this.options.xmlMode || this.options.recognizeCDATA) {
      (_b = (_a = this.cbs).oncdatastart) === null || _b === void 0
        ? void 0
        : _b.call(_a);
      (_d = (_c = this.cbs).ontext) === null || _d === void 0
        ? void 0
        : _d.call(_c, value);
      (_f = (_e = this.cbs).oncdataend) === null || _f === void 0
        ? void 0
        : _f.call(_e);
    } else {
      (_h = (_g = this.cbs).oncomment) === null || _h === void 0
        ? void 0
        : _h.call(_g, `[CDATA[${value}]]`);
      (_k = (_j = this.cbs).oncommentend) === null || _k === void 0
        ? void 0
        : _k.call(_j);
    }
    // Set `startIndex` for next node
    this.startIndex = endIndex + 1;
  }
  /** @internal */
  onend() {
    var _a, _b;
    if (this.cbs.onclosetag) {
      // Set the end index for all remaining tags
      this.endIndex = this.startIndex;
      for (
        let index = this.stack.length;
        index > 0;
        this.cbs.onclosetag(this.stack[--index], true)
      );
    }
    (_b = (_a = this.cbs).onend) === null || _b === void 0
      ? void 0
      : _b.call(_a);
  }
  /**
   * Resets the parser to a blank state, ready to parse a new HTML document
   */
  reset() {
    var _a, _b, _c, _d;
    (_b = (_a = this.cbs).onreset) === null || _b === void 0
      ? void 0
      : _b.call(_a);
    this.tokenizer.reset();
    this.tagname = "";
    this.attribname = "";
    this.attribs = null;
    this.stack.length = 0;
    this.startIndex = 0;
    this.endIndex = 0;
    (_d = (_c = this.cbs).onparserinit) === null || _d === void 0
      ? void 0
      : _d.call(_c, this);
    this.buffers.length = 0;
    this.bufferOffset = 0;
    this.writeIndex = 0;
    this.ended = false;
  }
  /**
   * Resets the parser, then parses a complete document and
   * pushes it to the handler.
   *
   * @param data Document to parse.
   */
  parseComplete(data) {
    this.reset();
    this.end(data);
  }
  getSlice(start, end) {
    while (start - this.bufferOffset >= this.buffers[0].length) {
      this.shiftBuffer();
    }
    let slice = this.buffers[0].slice(
      start - this.bufferOffset,
      end - this.bufferOffset,
    );
    while (end - this.bufferOffset > this.buffers[0].length) {
      this.shiftBuffer();
      slice += this.buffers[0].slice(0, end - this.bufferOffset);
    }
    return slice;
  }
  shiftBuffer() {
    this.bufferOffset += this.buffers[0].length;
    this.writeIndex--;
    this.buffers.shift();
  }
  /**
   * Parses a chunk of data and calls the corresponding callbacks.
   *
   * @param chunk Chunk to parse.
   */
  write(chunk) {
    var _a, _b;
    if (this.ended) {
      (_b = (_a = this.cbs).onerror) === null || _b === void 0
        ? void 0
        : _b.call(_a, new Error(".write() after done!"));
      return;
    }
    this.buffers.push(chunk);
    if (this.tokenizer.running) {
      this.tokenizer.write(chunk);
      this.writeIndex++;
    }
  }
  /**
   * Parses the end of the buffer and clears the stack, calls onend.
   *
   * @param chunk Optional final chunk to parse.
   */
  end(chunk) {
    var _a, _b;
    if (this.ended) {
      (_b = (_a = this.cbs).onerror) === null || _b === void 0
        ? void 0
        : _b.call(_a, new Error(".end() after done!"));
      return;
    }
    if (chunk) this.write(chunk);
    this.ended = true;
    this.tokenizer.end();
  }
  /**
   * Pauses parsing. The parser won't emit events until `resume` is called.
   */
  pause() {
    this.tokenizer.pause();
  }
  /**
   * Resumes parsing after `pause` was called.
   */
  resume() {
    this.tokenizer.resume();
    while (this.tokenizer.running && this.writeIndex < this.buffers.length) {
      this.tokenizer.write(this.buffers[this.writeIndex++]);
    }
    if (this.ended) this.tokenizer.end();
  }
  /**
   * Alias of `write`, for backwards compatibility.
   *
   * @param chunk Chunk to parse.
   * @deprecated
   */
  parseChunk(chunk) {
    this.write(chunk);
  }
  /**
   * Alias of `end`, for backwards compatibility.
   *
   * @param chunk Optional final chunk to parse.
   * @deprecated
   */
  done(chunk) {
    this.end(chunk);
  }
};

// Helper methods
/**
 * Parses the data, returns the resulting document.
 *
 * @param data The data that should be parsed.
 * @param options Optional options for the parser and DOM builder.
 */
function parseDocument(data, options) {
  const handler = new DomHandler(undefined, options);
  new Parser$1(handler, options).end(data);
  return handler.root;
}

/**
 * Types used in signatures of Cheerio methods.
 *
 * @category Cheerio
 */
const parse$1z = getParse((content, options, isDocument, context) =>
  options.xmlMode || options._useHtmlParser2
    ? parseDocument(content, options)
    : parseWithParse5(content, options, isDocument, context),
);
// Duplicate docs due to https://github.com/TypeStrong/typedoc/issues/1616
/**
 * Create a querying function, bound to a document created from the provided markup.
 *
 * Note that similar to web browser contexts, this operation may introduce
 * `<html>`, `<head>`, and `<body>` elements; set `isDocument` to `false` to
 * switch to fragment mode and disable this.
 *
 * @param content - Markup to be loaded.
 * @param options - Options for the created instance.
 * @param isDocument - Allows parser to be switched to fragment mode.
 * @returns The loaded document.
 * @see {@link https://cheerio.js.org#loading} for additional usage information.
 */
const load$1 = getLoad(parse$1z, (dom, options) =>
  options.xmlMode || options._useHtmlParser2
    ? render(dom, options)
    : renderWithParse5(dom),
);
/**
 * The default cheerio instance.
 *
 * @deprecated Use the function returned by `load` instead.
 */
load$1([]);

const defaultIconDimensions = Object.freeze({
  left: 0,
  top: 0,
  width: 16,
  height: 16,
});
const defaultIconTransformations = Object.freeze({
  rotate: 0,
  vFlip: false,
  hFlip: false,
});
const defaultIconProps = Object.freeze({
  ...defaultIconDimensions,
  ...defaultIconTransformations,
});
const defaultExtendedIconProps = Object.freeze({
  ...defaultIconProps,
  body: "",
  hidden: false,
});

const defaultIconSizeCustomisations = Object.freeze({
  width: null,
  height: null,
});
const defaultIconCustomisations = Object.freeze({
  // Dimensions
  ...defaultIconSizeCustomisations,
  // Transformations
  ...defaultIconTransformations,
});

function mergeIconTransformations(obj1, obj2) {
  const result = {};
  if (!obj1.hFlip !== !obj2.hFlip) {
    result.hFlip = true;
  }
  if (!obj1.vFlip !== !obj2.vFlip) {
    result.vFlip = true;
  }
  const rotate = ((obj1.rotate || 0) + (obj2.rotate || 0)) % 4;
  if (rotate) {
    result.rotate = rotate;
  }
  return result;
}

function mergeIconData(parent, child) {
  const result = mergeIconTransformations(parent, child);
  for (const key in defaultExtendedIconProps) {
    if (key in defaultIconTransformations) {
      if (key in parent && !(key in result)) {
        result[key] = defaultIconTransformations[key];
      }
    } else if (key in child) {
      result[key] = child[key];
    } else if (key in parent) {
      result[key] = parent[key];
    }
  }
  return result;
}

function minifyIconSet(data) {
  const icons = Object.keys(data.icons);
  Object.keys(defaultIconDimensions).forEach((prop) => {
    if (data[prop] === defaultIconDimensions[prop]) {
      delete data[prop];
    }
    const defaultValue = defaultIconDimensions[prop];
    const propType = typeof defaultValue;
    const hasMinifiedDefault =
      typeof data[prop] === propType && data[prop] !== defaultValue;
    let maxCount = 0;
    let maxValue = null;
    const counters = /* @__PURE__ */ new Map();
    for (let i = 0; i < icons.length; i++) {
      const item = data.icons[icons[i]];
      let value;
      if (typeof item[prop] === propType) {
        value = item[prop];
      } else if (hasMinifiedDefault) {
        value = data[prop];
      } else {
        value = defaultIconDimensions[prop];
      }
      if (i === 0) {
        maxCount = 1;
        maxValue = value;
        counters.set(value, 1);
        continue;
      }
      if (!counters.has(value)) {
        counters.set(value, 1);
        continue;
      }
      const count = counters.get(value) + 1;
      counters.set(value, count);
      if (count > maxCount) {
        maxCount = count;
        maxValue = value;
      }
    }
    const canMinify = maxValue !== null && maxCount > 1;
    const oldDefault = hasMinifiedDefault ? data[prop] : null;
    const newDefault = canMinify ? maxValue : oldDefault;
    if (newDefault === defaultValue) {
      delete data[prop];
    } else if (canMinify) {
      data[prop] = newDefault;
    }
    icons.forEach((key) => {
      const item = data.icons[key];
      const value =
        prop in item
          ? item[prop]
          : hasMinifiedDefault
            ? oldDefault
            : defaultValue;
      if (
        value === newDefault ||
        (newDefault === null && value === defaultValue)
      ) {
        delete item[prop];
        return;
      }
      if (canMinify && !(prop in item)) {
        item[prop] = value;
      }
    });
  });
}

const minDisplayHeight = 16;
const maxDisplayHeight = 24;
const maxSamplesCount = 3;
function validateDisplayHeight(value) {
  while (value < minDisplayHeight) {
    value *= 2;
  }
  while (value > maxDisplayHeight) {
    value /= 2;
  }
  return value === Math.round(value) &&
    value >= minDisplayHeight &&
    value <= maxDisplayHeight
    ? value
    : 0;
}
function convertIconSetInfo(data, expectedPrefix = "") {
  if (typeof data !== "object" || data === null) {
    return null;
  }
  const source = data;
  const getSourceNestedString = (field, key, defaultValue = "") => {
    if (typeof source[field] !== "object") {
      return defaultValue;
    }
    const obj = source[field];
    return typeof obj[key] === "string" ? obj[key] : defaultValue;
  };
  let name;
  if (typeof source.name === "string") {
    name = source.name;
  } else if (typeof source.title === "string") {
    name = source.title;
  } else {
    return null;
  }
  if (
    expectedPrefix !== "" &&
    typeof source.prefix === "string" &&
    source.prefix !== expectedPrefix
  ) {
    return null;
  }
  const info = {
    name,
  };
  switch (typeof source.total) {
    case "number":
      info.total = source.total;
      break;
    case "string": {
      const num = parseInt(source.total);
      if (num > 0) {
        info.total = num;
      }
      break;
    }
  }
  if (typeof source.version === "string") {
    info.version = source.version;
  }
  info.author = {
    name: getSourceNestedString(
      "author",
      "name",
      typeof source.author === "string" ? source.author : "",
    ),
  };
  if (typeof source.author === "object") {
    const sourceAuthor = source.author;
    if (typeof sourceAuthor.url === "string") {
      info.author.url = sourceAuthor.url;
    }
  }
  info.license = {
    title: getSourceNestedString(
      "license",
      "title",
      typeof source.license === "string" ? source.license : "",
    ),
  };
  if (typeof source.license === "object") {
    const sourceLicense = source.license;
    if (typeof sourceLicense.spdx === "string") {
      info.license.spdx = sourceLicense.spdx;
    }
    if (typeof sourceLicense.url === "string") {
      info.license.url = sourceLicense.url;
    }
  }
  if (source.samples instanceof Array) {
    const samples = [];
    source.samples.forEach((item) => {
      if (typeof item === "string" && samples.length < maxSamplesCount) {
        samples.push(item);
      }
    });
    if (samples.length) {
      info.samples = samples;
    }
  }
  if (typeof source.height === "number" || typeof source.height === "string") {
    const num = parseInt(source.height);
    if (num > 0) {
      info.height = num;
    }
  }
  if (source.height instanceof Array) {
    source.height.forEach((item) => {
      const num = parseInt(item);
      if (num > 0) {
        if (!(info.height instanceof Array)) {
          info.height = [];
        }
        info.height.push(num);
      }
    });
    switch (info.height.length) {
      case 0:
        delete info.height;
        break;
      case 1:
        info.height = info.height[0];
    }
  }
  if (typeof info.height === "number") {
    const displayHeight = validateDisplayHeight(info.height);
    if (displayHeight && displayHeight !== info.height) {
      info.displayHeight = displayHeight;
    }
  }
  ["samplesHeight", "displayHeight"].forEach((prop) => {
    const value = source[prop];
    if (typeof value === "number" || typeof value === "string") {
      const displayHeight = validateDisplayHeight(parseInt(value));
      if (displayHeight) {
        info.displayHeight = displayHeight;
      }
    }
  });
  if (typeof source.category === "string") {
    info.category = source.category;
  }
  switch (typeof source.palette) {
    case "boolean":
      info.palette = source.palette;
      break;
    case "string":
      switch (source.palette.toLowerCase()) {
        case "colorless":
        case "false":
          info.palette = false;
          break;
        case "colorful":
        case "true":
          info.palette = true;
      }
      break;
  }
  if (source.hidden === true) {
    info.hidden = true;
  }
  Object.keys(source).forEach((key) => {
    const value = source[key];
    if (typeof value !== "string") {
      return;
    }
    switch (key) {
      case "url":
      case "uri":
        info.author.url = value;
        break;
      case "licenseURL":
      case "licenseURI":
        info.license.url = value;
        break;
      case "licenseID":
      case "licenseSPDX":
        info.license.spdx = value;
        break;
    }
  });
  return info;
}

const unitsSplit = /(-?[0-9.]*[0-9]+[0-9.]*)/g;
const unitsTest = /^-?[0-9.]*[0-9]+[0-9.]*$/g;
function calculateSize(size, ratio, precision) {
  if (ratio === 1) {
    return size;
  }
  precision = precision || 100;
  if (typeof size === "number") {
    return Math.ceil(size * ratio * precision) / precision;
  }
  if (typeof size !== "string") {
    return size;
  }
  const oldParts = size.split(unitsSplit);
  if (oldParts === null || !oldParts.length) {
    return size;
  }
  const newParts = [];
  let code = oldParts.shift();
  let isNumber = unitsTest.test(code);
  while (true) {
    if (isNumber) {
      const num = parseFloat(code);
      if (isNaN(num)) {
        newParts.push(code);
      } else {
        newParts.push(Math.ceil(num * ratio * precision) / precision);
      }
    } else {
      newParts.push(code);
    }
    code = oldParts.shift();
    if (code === void 0) {
      return newParts.join("");
    }
    isNumber = !isNumber;
  }
}

function splitSVGDefs(content, tag = "defs") {
  let defs = "";
  const index = content.indexOf("<" + tag);
  while (index >= 0) {
    const start = content.indexOf(">", index);
    const end = content.indexOf("</" + tag);
    if (start === -1 || end === -1) {
      break;
    }
    const endEnd = content.indexOf(">", end);
    if (endEnd === -1) {
      break;
    }
    defs += content.slice(start + 1, end).trim();
    content = content.slice(0, index).trim() + content.slice(endEnd + 1);
  }
  return {
    defs,
    content,
  };
}
function mergeDefsAndContent(defs, content) {
  return defs ? "<defs>" + defs + "</defs>" + content : content;
}
function wrapSVGContent(body, start, end) {
  const split = splitSVGDefs(body);
  return mergeDefsAndContent(split.defs, start + split.content + end);
}

const isUnsetKeyword = (value) =>
  value === "unset" || value === "undefined" || value === "none";
function iconToSVG(icon, customisations) {
  const fullIcon = {
    ...defaultIconProps,
    ...icon,
  };
  const fullCustomisations = {
    ...defaultIconCustomisations,
    ...customisations,
  };
  const box = {
    left: fullIcon.left,
    top: fullIcon.top,
    width: fullIcon.width,
    height: fullIcon.height,
  };
  let body = fullIcon.body;
  [fullIcon, fullCustomisations].forEach((props) => {
    const transformations = [];
    const hFlip = props.hFlip;
    const vFlip = props.vFlip;
    let rotation = props.rotate;
    if (hFlip) {
      if (vFlip) {
        rotation += 2;
      } else {
        transformations.push(
          "translate(" +
            (box.width + box.left).toString() +
            " " +
            (0 - box.top).toString() +
            ")",
        );
        transformations.push("scale(-1 1)");
        box.top = box.left = 0;
      }
    } else if (vFlip) {
      transformations.push(
        "translate(" +
          (0 - box.left).toString() +
          " " +
          (box.height + box.top).toString() +
          ")",
      );
      transformations.push("scale(1 -1)");
      box.top = box.left = 0;
    }
    let tempValue;
    if (rotation < 0) {
      rotation -= Math.floor(rotation / 4) * 4;
    }
    rotation = rotation % 4;
    switch (rotation) {
      case 1:
        tempValue = box.height / 2 + box.top;
        transformations.unshift(
          "rotate(90 " +
            tempValue.toString() +
            " " +
            tempValue.toString() +
            ")",
        );
        break;
      case 2:
        transformations.unshift(
          "rotate(180 " +
            (box.width / 2 + box.left).toString() +
            " " +
            (box.height / 2 + box.top).toString() +
            ")",
        );
        break;
      case 3:
        tempValue = box.width / 2 + box.left;
        transformations.unshift(
          "rotate(-90 " +
            tempValue.toString() +
            " " +
            tempValue.toString() +
            ")",
        );
        break;
    }
    if (rotation % 2 === 1) {
      if (box.left !== box.top) {
        tempValue = box.left;
        box.left = box.top;
        box.top = tempValue;
      }
      if (box.width !== box.height) {
        tempValue = box.width;
        box.width = box.height;
        box.height = tempValue;
      }
    }
    if (transformations.length) {
      body = wrapSVGContent(
        body,
        '<g transform="' + transformations.join(" ") + '">',
        "</g>",
      );
    }
  });
  const customisationsWidth = fullCustomisations.width;
  const customisationsHeight = fullCustomisations.height;
  const boxWidth = box.width;
  const boxHeight = box.height;
  let width;
  let height;
  if (customisationsWidth === null) {
    height =
      customisationsHeight === null
        ? "1em"
        : customisationsHeight === "auto"
          ? boxHeight
          : customisationsHeight;
    width = calculateSize(height, boxWidth / boxHeight);
  } else {
    width = customisationsWidth === "auto" ? boxWidth : customisationsWidth;
    height =
      customisationsHeight === null
        ? calculateSize(width, boxHeight / boxWidth)
        : customisationsHeight === "auto"
          ? boxHeight
          : customisationsHeight;
  }
  const attributes = {};
  const setAttr = (prop, value) => {
    if (!isUnsetKeyword(value)) {
      attributes[prop] = value.toString();
    }
  };
  setAttr("width", width);
  setAttr("height", height);
  const viewBox = [box.left, box.top, boxWidth, boxHeight];
  attributes.viewBox = viewBox.join(" ");
  return {
    attributes,
    viewBox,
    body,
  };
}

function trimSVG(str) {
  return str
    .replace(/(['"])\s*\n\s*([^>\\/\s])/g, "$1 $2")
    .replace(/(["';{}><])\s*\n\s*/g, "$1")
    .replace(/\s*\n\s*/g, " ")
    .replace(/\s+"/g, '"')
    .replace(/="\s+/g, '="')
    .replace(/(\s)+\/>/g, "/>")
    .trim();
}

const skipTags = ["script", "style"];
function prettifySVG(content, tab = "	", depth = 0) {
  let result = "";
  let level = 0;
  content = content.replace(/(\s)*\/>/g, " />");
  while (content.length > 0) {
    const openIndex = content.indexOf("<");
    let closeIndex = content.indexOf(">");
    if (openIndex === -1 && closeIndex === -1) {
      return result;
    }
    if (openIndex === -1 || closeIndex === -1 || closeIndex < openIndex) {
      return null;
    }
    const text = content.slice(0, openIndex);
    const trimmedText = text.trim();
    if (trimmedText.length) {
      if (text.trimStart() !== text && text.trimEnd() !== text) {
        result += trimmedText + "\n" + tab.repeat(level + depth);
      } else {
        result = result.trim() + text;
      }
    }
    content = content.slice(openIndex);
    closeIndex -= openIndex;
    const lastChar = content.slice(closeIndex - 1, closeIndex);
    const isClosing = content.slice(0, 2) === "</";
    let isSelfClosing = lastChar === "/" || lastChar === "?";
    if (isClosing && isSelfClosing) {
      return null;
    }
    const tagName = content
      .slice(isClosing ? 2 : 1)
      .split(/[\s>]/)
      .shift();
    const ignoreTagContent =
      !isSelfClosing && !isClosing && skipTags.includes(tagName);
    if (!ignoreTagContent) {
      const nextOpenIndex = content.indexOf("<", 1);
      if (nextOpenIndex !== -1 && nextOpenIndex < closeIndex) {
        return null;
      }
    }
    if (isClosing && tab.length) {
      if (result.slice(0 - tab.length) === tab) {
        result = result.slice(0, result.length - tab.length);
      }
    }
    result += content.slice(0, closeIndex + 1);
    content = content.slice(closeIndex + 1);
    if (ignoreTagContent) {
      const closingIndex = content.indexOf("</" + tagName);
      const closingEnd = content.indexOf(">", closingIndex);
      if (closingIndex < 0 || closingEnd < 0) {
        return null;
      }
      result += content.slice(0, closingEnd + 1);
      content = content.slice(closingEnd + 1);
      isSelfClosing = true;
    }
    if (isClosing) {
      level--;
      if (level < 0) {
        return null;
      }
    } else if (!isSelfClosing) {
      level++;
    }
    result += "\n" + tab.repeat(level + depth);
  }
  return level === 0 ? result : null;
}

var src = { exports: {} };

var browser$3 = { exports: {} };

/**
 * Helpers.
 */

var ms;
var hasRequiredMs;

function requireMs() {
  if (hasRequiredMs) return ms;
  hasRequiredMs = 1;
  var s = 1000;
  var m = s * 60;
  var h = m * 60;
  var d = h * 24;
  var w = d * 7;
  var y = d * 365.25;

  /**
   * Parse or format the given `val`.
   *
   * Options:
   *
   *  - `long` verbose formatting [false]
   *
   * @param {String|Number} val
   * @param {Object} [options]
   * @throws {Error} throw an error if val is not a non-empty string or a number
   * @return {String|Number}
   * @api public
   */

  ms = function (val, options) {
    options = options || {};
    var type = typeof val;
    if (type === "string" && val.length > 0) {
      return parse(val);
    } else if (type === "number" && isFinite(val)) {
      return options.long ? fmtLong(val) : fmtShort(val);
    }
    throw new Error(
      "val is not a non-empty string or a valid number. val=" +
        JSON.stringify(val),
    );
  };

  /**
   * Parse the given `str` and return milliseconds.
   *
   * @param {String} str
   * @return {Number}
   * @api private
   */

  function parse(str) {
    str = String(str);
    if (str.length > 100) {
      return;
    }
    var match =
      /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
        str,
      );
    if (!match) {
      return;
    }
    var n = parseFloat(match[1]);
    var type = (match[2] || "ms").toLowerCase();
    switch (type) {
      case "years":
      case "year":
      case "yrs":
      case "yr":
      case "y":
        return n * y;
      case "weeks":
      case "week":
      case "w":
        return n * w;
      case "days":
      case "day":
      case "d":
        return n * d;
      case "hours":
      case "hour":
      case "hrs":
      case "hr":
      case "h":
        return n * h;
      case "minutes":
      case "minute":
      case "mins":
      case "min":
      case "m":
        return n * m;
      case "seconds":
      case "second":
      case "secs":
      case "sec":
      case "s":
        return n * s;
      case "milliseconds":
      case "millisecond":
      case "msecs":
      case "msec":
      case "ms":
        return n;
      default:
        return undefined;
    }
  }

  /**
   * Short format for `ms`.
   *
   * @param {Number} ms
   * @return {String}
   * @api private
   */

  function fmtShort(ms) {
    var msAbs = Math.abs(ms);
    if (msAbs >= d) {
      return Math.round(ms / d) + "d";
    }
    if (msAbs >= h) {
      return Math.round(ms / h) + "h";
    }
    if (msAbs >= m) {
      return Math.round(ms / m) + "m";
    }
    if (msAbs >= s) {
      return Math.round(ms / s) + "s";
    }
    return ms + "ms";
  }

  /**
   * Long format for `ms`.
   *
   * @param {Number} ms
   * @return {String}
   * @api private
   */

  function fmtLong(ms) {
    var msAbs = Math.abs(ms);
    if (msAbs >= d) {
      return plural(ms, msAbs, d, "day");
    }
    if (msAbs >= h) {
      return plural(ms, msAbs, h, "hour");
    }
    if (msAbs >= m) {
      return plural(ms, msAbs, m, "minute");
    }
    if (msAbs >= s) {
      return plural(ms, msAbs, s, "second");
    }
    return ms + " ms";
  }

  /**
   * Pluralization helper.
   */

  function plural(ms, msAbs, n, name) {
    var isPlural = msAbs >= n * 1.5;
    return Math.round(ms / n) + " " + name + (isPlural ? "s" : "");
  }
  return ms;
}

var common;
var hasRequiredCommon;

function requireCommon() {
  if (hasRequiredCommon) return common;
  hasRequiredCommon = 1;
  /**
   * This is the common logic for both the Node.js and web browser
   * implementations of `debug()`.
   */

  function setup(env) {
    createDebug.debug = createDebug;
    createDebug.default = createDebug;
    createDebug.coerce = coerce;
    createDebug.disable = disable;
    createDebug.enable = enable;
    createDebug.enabled = enabled;
    createDebug.humanize = requireMs();
    createDebug.destroy = destroy;

    Object.keys(env).forEach((key) => {
      createDebug[key] = env[key];
    });

    /**
     * The currently active debug mode names, and names to skip.
     */

    createDebug.names = [];
    createDebug.skips = [];

    /**
     * Map of special "%n" handling functions, for the debug "format" argument.
     *
     * Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
     */
    createDebug.formatters = {};

    /**
     * Selects a color for a debug namespace
     * @param {String} namespace The namespace string for the debug instance to be colored
     * @return {Number|String} An ANSI color code for the given namespace
     * @api private
     */
    function selectColor(namespace) {
      let hash = 0;

      for (let i = 0; i < namespace.length; i++) {
        hash = (hash << 5) - hash + namespace.charCodeAt(i);
        hash |= 0; // Convert to 32bit integer
      }

      return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
    }
    createDebug.selectColor = selectColor;

    /**
     * Create a debugger with the given `namespace`.
     *
     * @param {String} namespace
     * @return {Function}
     * @api public
     */
    function createDebug(namespace) {
      let prevTime;
      let enableOverride = null;
      let namespacesCache;
      let enabledCache;

      function debug(...args) {
        // Disabled?
        if (!debug.enabled) {
          return;
        }

        const self = debug;

        // Set `diff` timestamp
        const curr = Number(new Date());
        const ms = curr - (prevTime || curr);
        self.diff = ms;
        self.prev = prevTime;
        self.curr = curr;
        prevTime = curr;

        args[0] = createDebug.coerce(args[0]);

        if (typeof args[0] !== "string") {
          // Anything else let's inspect with %O
          args.unshift("%O");
        }

        // Apply any `formatters` transformations
        let index = 0;
        args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
          // If we encounter an escaped % then don't increase the array index
          if (match === "%%") {
            return "%";
          }
          index++;
          const formatter = createDebug.formatters[format];
          if (typeof formatter === "function") {
            const val = args[index];
            match = formatter.call(self, val);

            // Now we need to remove `args[index]` since it's inlined in the `format`
            args.splice(index, 1);
            index--;
          }
          return match;
        });

        // Apply env-specific formatting (colors, etc.)
        createDebug.formatArgs.call(self, args);

        const logFn = self.log || createDebug.log;
        logFn.apply(self, args);
      }

      debug.namespace = namespace;
      debug.useColors = createDebug.useColors();
      debug.color = createDebug.selectColor(namespace);
      debug.extend = extend;
      debug.destroy = createDebug.destroy; // XXX Temporary. Will be removed in the next major release.

      Object.defineProperty(debug, "enabled", {
        enumerable: true,
        configurable: false,
        get: () => {
          if (enableOverride !== null) {
            return enableOverride;
          }
          if (namespacesCache !== createDebug.namespaces) {
            namespacesCache = createDebug.namespaces;
            enabledCache = createDebug.enabled(namespace);
          }

          return enabledCache;
        },
        set: (v) => {
          enableOverride = v;
        },
      });

      // Env-specific initialization logic for debug instances
      if (typeof createDebug.init === "function") {
        createDebug.init(debug);
      }

      return debug;
    }

    function extend(namespace, delimiter) {
      const newDebug = createDebug(
        this.namespace +
          (typeof delimiter === "undefined" ? ":" : delimiter) +
          namespace,
      );
      newDebug.log = this.log;
      return newDebug;
    }

    /**
     * Enables a debug mode by namespaces. This can include modes
     * separated by a colon and wildcards.
     *
     * @param {String} namespaces
     * @api public
     */
    function enable(namespaces) {
      createDebug.save(namespaces);
      createDebug.namespaces = namespaces;

      createDebug.names = [];
      createDebug.skips = [];

      let i;
      const split = (typeof namespaces === "string" ? namespaces : "").split(
        /[\s,]+/,
      );
      const len = split.length;

      for (i = 0; i < len; i++) {
        if (!split[i]) {
          // ignore empty strings
          continue;
        }

        namespaces = split[i].replace(/\*/g, ".*?");

        if (namespaces[0] === "-") {
          createDebug.skips.push(new RegExp("^" + namespaces.slice(1) + "$"));
        } else {
          createDebug.names.push(new RegExp("^" + namespaces + "$"));
        }
      }
    }

    /**
     * Disable debug output.
     *
     * @return {String} namespaces
     * @api public
     */
    function disable() {
      const namespaces = [
        ...createDebug.names.map(toNamespace),
        ...createDebug.skips
          .map(toNamespace)
          .map((namespace) => "-" + namespace),
      ].join(",");
      createDebug.enable("");
      return namespaces;
    }

    /**
     * Returns true if the given mode name is enabled, false otherwise.
     *
     * @param {String} name
     * @return {Boolean}
     * @api public
     */
    function enabled(name) {
      if (name[name.length - 1] === "*") {
        return true;
      }

      let i;
      let len;

      for (i = 0, len = createDebug.skips.length; i < len; i++) {
        if (createDebug.skips[i].test(name)) {
          return false;
        }
      }

      for (i = 0, len = createDebug.names.length; i < len; i++) {
        if (createDebug.names[i].test(name)) {
          return true;
        }
      }

      return false;
    }

    /**
     * Convert regexp to namespace
     *
     * @param {RegExp} regxep
     * @return {String} namespace
     * @api private
     */
    function toNamespace(regexp) {
      return regexp
        .toString()
        .substring(2, regexp.toString().length - 2)
        .replace(/\.\*\?$/, "*");
    }

    /**
     * Coerce `val`.
     *
     * @param {Mixed} val
     * @return {Mixed}
     * @api private
     */
    function coerce(val) {
      if (val instanceof Error) {
        return val.stack || val.message;
      }
      return val;
    }

    /**
     * XXX DO NOT USE. This is a temporary stub function.
     * XXX It WILL be removed in the next major release.
     */
    function destroy() {
      console.warn(
        "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.",
      );
    }

    createDebug.enable(createDebug.load());

    return createDebug;
  }

  common = setup;
  return common;
}

/* eslint-env browser */

var hasRequiredBrowser;

function requireBrowser() {
  if (hasRequiredBrowser) return browser$3.exports;
  hasRequiredBrowser = 1;
  (function (module, exports) {
    /**
     * This is the web browser implementation of `debug()`.
     */

    exports.formatArgs = formatArgs;
    exports.save = save;
    exports.load = load;
    exports.useColors = useColors;
    exports.storage = localstorage();
    exports.destroy = (() => {
      let warned = false;

      return () => {
        if (!warned) {
          warned = true;
          console.warn(
            "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.",
          );
        }
      };
    })();

    /**
     * Colors.
     */

    exports.colors = [
      "#0000CC",
      "#0000FF",
      "#0033CC",
      "#0033FF",
      "#0066CC",
      "#0066FF",
      "#0099CC",
      "#0099FF",
      "#00CC00",
      "#00CC33",
      "#00CC66",
      "#00CC99",
      "#00CCCC",
      "#00CCFF",
      "#3300CC",
      "#3300FF",
      "#3333CC",
      "#3333FF",
      "#3366CC",
      "#3366FF",
      "#3399CC",
      "#3399FF",
      "#33CC00",
      "#33CC33",
      "#33CC66",
      "#33CC99",
      "#33CCCC",
      "#33CCFF",
      "#6600CC",
      "#6600FF",
      "#6633CC",
      "#6633FF",
      "#66CC00",
      "#66CC33",
      "#9900CC",
      "#9900FF",
      "#9933CC",
      "#9933FF",
      "#99CC00",
      "#99CC33",
      "#CC0000",
      "#CC0033",
      "#CC0066",
      "#CC0099",
      "#CC00CC",
      "#CC00FF",
      "#CC3300",
      "#CC3333",
      "#CC3366",
      "#CC3399",
      "#CC33CC",
      "#CC33FF",
      "#CC6600",
      "#CC6633",
      "#CC9900",
      "#CC9933",
      "#CCCC00",
      "#CCCC33",
      "#FF0000",
      "#FF0033",
      "#FF0066",
      "#FF0099",
      "#FF00CC",
      "#FF00FF",
      "#FF3300",
      "#FF3333",
      "#FF3366",
      "#FF3399",
      "#FF33CC",
      "#FF33FF",
      "#FF6600",
      "#FF6633",
      "#FF9900",
      "#FF9933",
      "#FFCC00",
      "#FFCC33",
    ];

    /**
     * Currently only WebKit-based Web Inspectors, Firefox >= v31,
     * and the Firebug extension (any Firefox version) are known
     * to support "%c" CSS customizations.
     *
     * TODO: add a `localStorage` variable to explicitly enable/disable colors
     */

    // eslint-disable-next-line complexity
    function useColors() {
      // NB: In an Electron preload script, document will be defined but not fully
      // initialized. Since we know we're in Chrome, we'll just detect this case
      // explicitly
      if (
        typeof window !== "undefined" &&
        window.process &&
        (window.process.type === "renderer" || window.process.__nwjs)
      ) {
        return true;
      }

      // Internet Explorer and Edge do not support colors.
      if (
        typeof navigator !== "undefined" &&
        navigator.userAgent &&
        navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)
      ) {
        return false;
      }

      // Is webkit? http://stackoverflow.com/a/16459606/376773
      // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
      return (
        (typeof document !== "undefined" &&
          document.documentElement &&
          document.documentElement.style &&
          document.documentElement.style.WebkitAppearance) ||
        // Is firebug? http://stackoverflow.com/a/398120/376773
        (typeof window !== "undefined" &&
          window.console &&
          (window.console.firebug ||
            (window.console.exception && window.console.table))) ||
        // Is firefox >= v31?
        // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
        (typeof navigator !== "undefined" &&
          navigator.userAgent &&
          navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) &&
          parseInt(RegExp.$1, 10) >= 31) ||
        // Double check webkit in userAgent just in case we are in a worker
        (typeof navigator !== "undefined" &&
          navigator.userAgent &&
          navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/))
      );
    }

    /**
     * Colorize log arguments if enabled.
     *
     * @api public
     */

    function formatArgs(args) {
      args[0] =
        (this.useColors ? "%c" : "") +
        this.namespace +
        (this.useColors ? " %c" : " ") +
        args[0] +
        (this.useColors ? "%c " : " ") +
        "+" +
        module.exports.humanize(this.diff);

      if (!this.useColors) {
        return;
      }

      const c = "color: " + this.color;
      args.splice(1, 0, c, "color: inherit");

      // The final "%c" is somewhat tricky, because there could be other
      // arguments passed either before or after the %c, so we need to
      // figure out the correct index to insert the CSS into
      let index = 0;
      let lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, (match) => {
        if (match === "%%") {
          return;
        }
        index++;
        if (match === "%c") {
          // We only are interested in the *last* %c
          // (the user may have provided their own)
          lastC = index;
        }
      });

      args.splice(lastC, 0, c);
    }

    /**
     * Invokes `console.debug()` when available.
     * No-op when `console.debug` is not a "function".
     * If `console.debug` is not available, falls back
     * to `console.log`.
     *
     * @api public
     */
    exports.log = console.debug || console.log || (() => {});

    /**
     * Save `namespaces`.
     *
     * @param {String} namespaces
     * @api private
     */
    function save(namespaces) {
      try {
        if (namespaces) {
          exports.storage.setItem("debug", namespaces);
        } else {
          exports.storage.removeItem("debug");
        }
      } catch (error) {
        // Swallow
        // XXX (@Qix-) should we be logging these?
      }
    }

    /**
     * Load `namespaces`.
     *
     * @return {String} returns the previously persisted debug modes
     * @api private
     */
    function load() {
      let r;
      try {
        r = exports.storage.getItem("debug");
      } catch (error) {
        // Swallow
        // XXX (@Qix-) should we be logging these?
      }

      // If debug isn't set in LS, and we're in Electron, try to load $DEBUG
      if (!r && typeof process !== "undefined" && "env" in process) {
        r = process.env.DEBUG;
      }

      return r;
    }

    /**
     * Localstorage attempts to return the localstorage.
     *
     * This is necessary because safari throws
     * when a user disables cookies/localstorage
     * and you attempt to access it.
     *
     * @return {LocalStorage}
     * @api private
     */

    function localstorage() {
      try {
        // TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context
        // The Browser also has localStorage in the global context.
        return localStorage;
      } catch (error) {
        // Swallow
        // XXX (@Qix-) should we be logging these?
      }
    }

    module.exports = requireCommon()(exports);

    const { formatters } = module.exports;

    /**
     * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
     */

    formatters.j = function (v) {
      try {
        return JSON.stringify(v);
      } catch (error) {
        return "[UnexpectedJSONParseError]: " + error.message;
      }
    };
  })(browser$3, browser$3.exports);
  return browser$3.exports;
}

var node$2 = { exports: {} };

var hasFlag;
var hasRequiredHasFlag;

function requireHasFlag() {
  if (hasRequiredHasFlag) return hasFlag;
  hasRequiredHasFlag = 1;
  hasFlag = (flag, argv) => {
    argv = argv || process.argv;
    const prefix = flag.startsWith("-") ? "" : flag.length === 1 ? "-" : "--";
    const pos = argv.indexOf(prefix + flag);
    const terminatorPos = argv.indexOf("--");
    return pos !== -1 && (terminatorPos === -1 ? true : pos < terminatorPos);
  };
  return hasFlag;
}

var supportsColor_1;
var hasRequiredSupportsColor;

function requireSupportsColor() {
  if (hasRequiredSupportsColor) return supportsColor_1;
  hasRequiredSupportsColor = 1;
  const os = require$$1$4;
  const hasFlag = requireHasFlag();

  const env = process.env;

  let forceColor;
  if (hasFlag("no-color") || hasFlag("no-colors") || hasFlag("color=false")) {
    forceColor = false;
  } else if (
    hasFlag("color") ||
    hasFlag("colors") ||
    hasFlag("color=true") ||
    hasFlag("color=always")
  ) {
    forceColor = true;
  }
  if ("FORCE_COLOR" in env) {
    forceColor =
      env.FORCE_COLOR.length === 0 || parseInt(env.FORCE_COLOR, 10) !== 0;
  }

  function translateLevel(level) {
    if (level === 0) {
      return false;
    }

    return {
      level,
      hasBasic: true,
      has256: level >= 2,
      has16m: level >= 3,
    };
  }

  function supportsColor(stream) {
    if (forceColor === false) {
      return 0;
    }

    if (
      hasFlag("color=16m") ||
      hasFlag("color=full") ||
      hasFlag("color=truecolor")
    ) {
      return 3;
    }

    if (hasFlag("color=256")) {
      return 2;
    }

    if (stream && !stream.isTTY && forceColor !== true) {
      return 0;
    }

    const min = forceColor ? 1 : 0;

    if (process.platform === "win32") {
      // Node.js 7.5.0 is the first version of Node.js to include a patch to
      // libuv that enables 256 color output on Windows. Anything earlier and it
      // won't work. However, here we target Node.js 8 at minimum as it is an LTS
      // release, and Node.js 7 is not. Windows 10 build 10586 is the first Windows
      // release that supports 256 colors. Windows 10 build 14931 is the first release
      // that supports 16m/TrueColor.
      const osRelease = os.release().split(".");
      if (
        Number(process.versions.node.split(".")[0]) >= 8 &&
        Number(osRelease[0]) >= 10 &&
        Number(osRelease[2]) >= 10586
      ) {
        return Number(osRelease[2]) >= 14931 ? 3 : 2;
      }

      return 1;
    }

    if ("CI" in env) {
      if (
        ["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI"].some(
          (sign) => sign in env,
        ) ||
        env.CI_NAME === "codeship"
      ) {
        return 1;
      }

      return min;
    }

    if ("TEAMCITY_VERSION" in env) {
      return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
    }

    if (env.COLORTERM === "truecolor") {
      return 3;
    }

    if ("TERM_PROGRAM" in env) {
      const version = parseInt(
        (env.TERM_PROGRAM_VERSION || "").split(".")[0],
        10,
      );

      switch (env.TERM_PROGRAM) {
        case "iTerm.app":
          return version >= 3 ? 3 : 2;
        case "Apple_Terminal":
          return 2;
        // No default
      }
    }

    if (/-256(color)?$/i.test(env.TERM)) {
      return 2;
    }

    if (
      /^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(
        env.TERM,
      )
    ) {
      return 1;
    }

    if ("COLORTERM" in env) {
      return 1;
    }

    if (env.TERM === "dumb") {
      return min;
    }

    return min;
  }

  function getSupportLevel(stream) {
    const level = supportsColor(stream);
    return translateLevel(level);
  }

  supportsColor_1 = {
    supportsColor: getSupportLevel,
    stdout: getSupportLevel(process.stdout),
    stderr: getSupportLevel(process.stderr),
  };
  return supportsColor_1;
}

/**
 * Module dependencies.
 */

var hasRequiredNode;

function requireNode() {
  if (hasRequiredNode) return node$2.exports;
  hasRequiredNode = 1;
  (function (module, exports) {
    const tty = require$$6;
    const util = require$$1$5;

    /**
     * This is the Node.js implementation of `debug()`.
     */

    exports.init = init;
    exports.log = log;
    exports.formatArgs = formatArgs;
    exports.save = save;
    exports.load = load;
    exports.useColors = useColors;
    exports.destroy = util.deprecate(
      () => {},
      "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.",
    );

    /**
     * Colors.
     */

    exports.colors = [6, 2, 3, 4, 5, 1];

    try {
      // Optional dependency (as in, doesn't need to be installed, NOT like optionalDependencies in package.json)
      // eslint-disable-next-line import/no-extraneous-dependencies
      const supportsColor = requireSupportsColor();

      if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
        exports.colors = [
          20, 21, 26, 27, 32, 33, 38, 39, 40, 41, 42, 43, 44, 45, 56, 57, 62,
          63, 68, 69, 74, 75, 76, 77, 78, 79, 80, 81, 92, 93, 98, 99, 112, 113,
          128, 129, 134, 135, 148, 149, 160, 161, 162, 163, 164, 165, 166, 167,
          168, 169, 170, 171, 172, 173, 178, 179, 184, 185, 196, 197, 198, 199,
          200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 214, 215, 220, 221,
        ];
      }
    } catch (error) {
      // Swallow - we only care if `supports-color` is available; it doesn't have to be.
    }

    /**
     * Build up the default `inspectOpts` object from the environment variables.
     *
     *   $ DEBUG_COLORS=no DEBUG_DEPTH=10 DEBUG_SHOW_HIDDEN=enabled node script.js
     */

    exports.inspectOpts = Object.keys(process.env)
      .filter((key) => {
        return /^debug_/i.test(key);
      })
      .reduce((obj, key) => {
        // Camel-case
        const prop = key
          .substring(6)
          .toLowerCase()
          .replace(/_([a-z])/g, (_, k) => {
            return k.toUpperCase();
          });

        // Coerce string value into JS value
        let val = process.env[key];
        if (/^(yes|on|true|enabled)$/i.test(val)) {
          val = true;
        } else if (/^(no|off|false|disabled)$/i.test(val)) {
          val = false;
        } else if (val === "null") {
          val = null;
        } else {
          val = Number(val);
        }

        obj[prop] = val;
        return obj;
      }, {});

    /**
     * Is stdout a TTY? Colored output is enabled when `true`.
     */

    function useColors() {
      return "colors" in exports.inspectOpts
        ? Boolean(exports.inspectOpts.colors)
        : tty.isatty(process.stderr.fd);
    }

    /**
     * Adds ANSI color escape codes if enabled.
     *
     * @api public
     */

    function formatArgs(args) {
      const { namespace: name, useColors } = this;

      if (useColors) {
        const c = this.color;
        const colorCode = "\u001B[3" + (c < 8 ? c : "8;5;" + c);
        const prefix = `  ${colorCode};1m${name} \u001B[0m`;

        args[0] = prefix + args[0].split("\n").join("\n" + prefix);
        args.push(
          colorCode + "m+" + module.exports.humanize(this.diff) + "\u001B[0m",
        );
      } else {
        args[0] = getDate() + name + " " + args[0];
      }
    }

    function getDate() {
      if (exports.inspectOpts.hideDate) {
        return "";
      }
      return new Date().toISOString() + " ";
    }

    /**
     * Invokes `util.format()` with the specified arguments and writes to stderr.
     */

    function log(...args) {
      return process.stderr.write(util.format(...args) + "\n");
    }

    /**
     * Save `namespaces`.
     *
     * @param {String} namespaces
     * @api private
     */
    function save(namespaces) {
      if (namespaces) {
        process.env.DEBUG = namespaces;
      } else {
        // If you set a process.env field to null or undefined, it gets cast to the
        // string 'null' or 'undefined'. Just delete instead.
        delete process.env.DEBUG;
      }
    }

    /**
     * Load `namespaces`.
     *
     * @return {String} returns the previously persisted debug modes
     * @api private
     */

    function load() {
      return process.env.DEBUG;
    }

    /**
     * Init logic for `debug` instances.
     *
     * Create a new `inspectOpts` object in case `useColors` is set
     * differently for a particular `debug` instance.
     */

    function init(debug) {
      debug.inspectOpts = {};

      const keys = Object.keys(exports.inspectOpts);
      for (let i = 0; i < keys.length; i++) {
        debug.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];
      }
    }

    module.exports = requireCommon()(exports);

    const { formatters } = module.exports;

    /**
     * Map %o to `util.inspect()`, all on a single line.
     */

    formatters.o = function (v) {
      this.inspectOpts.colors = this.useColors;
      return util
        .inspect(v, this.inspectOpts)
        .split("\n")
        .map((str) => str.trim())
        .join(" ");
    };

    /**
     * Map %O to `util.inspect()`, allowing multiple lines if needed.
     */

    formatters.O = function (v) {
      this.inspectOpts.colors = this.useColors;
      return util.inspect(v, this.inspectOpts);
    };
  })(node$2, node$2.exports);
  return node$2.exports;
}

/**
 * Detect Electron renderer / nwjs process, which is node, but we should
 * treat as a browser.
 */

if (
  typeof process === "undefined" ||
  process.type === "renderer" ||
  process.browser === true ||
  process.__nwjs
) {
  src.exports = requireBrowser();
} else {
  src.exports = requireNode();
}

var srcExports = src.exports;

function unmergeObjects(obj1, obj2) {
  const result = {
    ...obj1,
  };
  for (const key in obj2) {
    if (result[key] === obj2[key]) {
      delete result[key];
    }
  }
  return result;
}
function commonObjectProps(item, reference) {
  const result = /* @__PURE__ */ Object.create(null);
  for (const key in reference) {
    if (key in item) {
      result[key] = item[key];
    }
  }
  return result;
}

var __defProp$1 = Object.defineProperty;
var __defNormalProp$1 = (obj, key, value) =>
  key in obj
    ? __defProp$1(obj, key, {
        enumerable: true,
        configurable: true,
        writable: true,
        value,
      })
    : (obj[key] = value);
var __publicField$1 = (obj, key, value) => {
  __defNormalProp$1(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
class SVG {
  /**
   * Constructor
   */
  constructor(content) {
    // Cheerio tree, initialized in load()
    __publicField$1(this, "$svg");
    // Dimensions, initialized in load()
    __publicField$1(this, "viewBox");
    this.load(content);
  }
  /**
   * Get SVG as string
   */
  toString(customisations) {
    if (customisations) {
      const data = iconToSVG(this.getIcon(), customisations);
      let svgAttributes = ' xmlns="http://www.w3.org/2000/svg"';
      if (data.body.includes("xlink:")) {
        svgAttributes += ' xmlns:xlink="http://www.w3.org/1999/xlink"';
      }
      for (const key in data.attributes) {
        const value = data.attributes[key];
        svgAttributes += " " + key + '="' + value + '"';
      }
      return "<svg" + svgAttributes + ">" + data.body + "</svg>";
    }
    const $root = this.$svg(":root");
    const box = this.viewBox;
    if ($root.attr("viewBox") === void 0) {
      $root.attr(
        "viewBox",
        `${box.left} ${box.top} ${box.width} ${box.height}`,
      );
    }
    if ($root.attr("width") === void 0) {
      $root.attr("width", box.width.toString());
    }
    if ($root.attr("height") === void 0) {
      $root.attr("height", box.height.toString());
    }
    return this.$svg.html();
  }
  /**
   * Get SVG as string without whitespaces
   */
  toMinifiedString(customisations) {
    return trimSVG(this.toString(customisations));
  }
  /**
   * Get SVG as string with whitespaces
   */
  toPrettyString(customisations) {
    const str = this.toMinifiedString(customisations);
    return prettifySVG(str) ?? str;
  }
  /**
   * Get body
   */
  getBody() {
    const $root = this.$svg(":root");
    const attribs = $root.get(0).attribs;
    for (const key in attribs) {
      switch (key.split("-").shift()) {
        case "fill":
        case "stroke":
        case "opacity":
          throw new Error(
            `Cannot use getBody() on icon that was not cleaned up with cleanupSVGRoot(). Icon has attribute ${key}="${attribs[key]}"`,
          );
      }
    }
    return trimSVG(this.$svg("svg").html());
  }
  /**
   * Get icon as IconifyIcon
   */
  getIcon() {
    const props = this.viewBox;
    const body = this.getBody();
    return {
      ...props,
      body,
    };
  }
  /**
   * Load SVG
   *
   * @param {string} content
   */
  load(content) {
    function remove(str1, str2, append) {
      let start = 0;
      while ((start = content.indexOf(str1, start)) !== -1) {
        const end = content.indexOf(str2, start + str1.length);
        if (end === -1) {
          return;
        }
        content =
          content.slice(0, start) + append + content.slice(end + str2.length);
        start = start + append.length;
      }
    }
    remove("<!--", "-->", "");
    remove("<?xml", "?>", "");
    remove("<!DOCTYPE svg", "<svg", "<svg");
    remove(
      'xmlns:x="&ns_extend;" xmlns:i="&ns_ai;" xmlns:graph="&ns_graphs;"',
      "",
      "",
    );
    remove('xml:space="preserve"', "", "");
    content = content.replace(/<g>\s*<\/g>/g, "");
    this.$svg = load$1(content.trim(), {
      lowerCaseAttributeNames: false,
      xmlMode: true,
    });
    const $root = this.$svg(":root");
    if ($root.length > 1 || $root.get(0).tagName !== "svg") {
      throw new Error("Invalid SVG file: bad root tag");
    }
    const viewBox = $root.attr("viewBox");
    if (viewBox !== void 0) {
      const list = viewBox.split(" ");
      this.viewBox = {
        left: parseFloat(list[0]),
        top: parseFloat(list[1]),
        width: parseFloat(list[2]),
        height: parseFloat(list[3]),
      };
    } else {
      const width = $root.attr("width");
      const height = $root.attr("height");
      if (!width || !height) {
        throw new Error("Invalid SVG file: missing dimensions");
      }
      this.viewBox = {
        left: 0,
        top: 0,
        width: parseFloat(width),
        height: parseFloat(height),
      };
    }
    Object.keys(this.viewBox).forEach((key) => {
      const attr = key;
      if (isNaN(this.viewBox[attr])) {
        throw new Error(`Invalid SVG file: invalid ${attr}`);
      }
    });
  }
}

const styleTag = /* @__PURE__ */ new Set(["style"]);
const defsTag = /* @__PURE__ */ new Set(["defs"]);
const maskTags = /* @__PURE__ */ new Set(["clipPath", "mask"]);
const symbolTag = /* @__PURE__ */ new Set(["symbol"]);
const shapeTags = /* @__PURE__ */ new Set([
  "circle",
  "ellipse",
  "line",
  "path",
  "polygon",
  "polyline",
  "rect",
]);
const useTag = /* @__PURE__ */ new Set(["use"]);
const groupTag = /* @__PURE__ */ new Set(["g"]);
const markerTag = /* @__PURE__ */ new Set(["marker"]);
const animateTags = /* @__PURE__ */ new Set([
  "animate",
  "animateMotion",
  "animateTransform",
  "discard",
  "set",
]);
const animateMotionChildTags = /* @__PURE__ */ new Set(["mpath"]);
const gradientTags = /* @__PURE__ */ new Set([
  "linearGradient",
  "radialGradient",
]);
const gradientChildTags = /* @__PURE__ */ new Set(["stop"]);
const patternTag = /* @__PURE__ */ new Set(["pattern"]);
const filterTag = /* @__PURE__ */ new Set(["filter"]);
const feLightningTags = /* @__PURE__ */ new Set([
  "feDiffuseLighting",
  "feSpecularLighting",
]);
const filterChildTags = /* @__PURE__ */ new Set([
  "feBlend",
  "feColorMatrix",
  "feComponentTransfer",
  "feComposite",
  "feConvolveMatrix",
  "feDisplacementMap",
  "feDropShadow",
  "feFlood",
  "feGaussianBlur",
  "feMerge",
  "feMorphology",
  "feOffset",
  "feTile",
  "feTurbulence",
  ...feLightningTags,
]);
const feComponentTransferChildTag = /* @__PURE__ */ new Set([
  "feFuncR",
  "feFuncG",
  "feFuncB",
  "feFuncA",
]);
const feLightningChildTags = /* @__PURE__ */ new Set([
  "feSpotLight",
  "fePointLight",
  "feDistantLight",
]);
const feMergeChildTags = /* @__PURE__ */ new Set(["feMergeNode"]);
/* @__PURE__ */ new Set([
  ...gradientTags,
  ...patternTag,
  ...markerTag,
  ...symbolTag,
  ...filterTag,
]);
/* @__PURE__ */ new Set([
  ...styleTag,
  ...defsTag,
  ...maskTags,
  ...symbolTag,
  ...shapeTags,
  ...useTag,
  ...groupTag,
  ...markerTag,
  ...animateTags,
  ...animateMotionChildTags,
  ...gradientTags,
  ...gradientChildTags,
  ...patternTag,
  ...filterTag,
  ...filterChildTags,
  ...feComponentTransferChildTag,
  ...feLightningChildTags,
  ...feMergeChildTags,
]);

const fillPresentationalAttributes = /* @__PURE__ */ new Set([
  "fill-opacity",
  "fill-rule",
]);
const strokePresentationalAttributes = /* @__PURE__ */ new Set([
  "stroke-dasharray",
  "stroke-dashoffset",
  "stroke-linecap",
  "stroke-linejoin",
  "stroke-miterlimit",
  "stroke-opacity",
  "stroke-width",
]);
const urlPresentationalAttributes = /* @__PURE__ */ new Set([
  "clip-path",
  "filter",
  "mask",
]);
const visibilityPresentationalAttributes = /* @__PURE__ */ new Set([
  "display",
  "opacity",
  "visibility",
]);
const commonColorPresentationalAttributes = /* @__PURE__ */ new Set([
  "color",
  "fill",
  "stroke",
]);
const otherPresentationalAttributes = /* @__PURE__ */ new Set([
  "color-interpolation",
  "color-rendering",
  "transform",
  "vector-effect",
]);
const presentationalAttributes = /* @__PURE__ */ new Set([
  ...fillPresentationalAttributes,
  ...strokePresentationalAttributes,
  ...urlPresentationalAttributes,
  ...visibilityPresentationalAttributes,
  ...commonColorPresentationalAttributes,
  ...otherPresentationalAttributes,
]);
const markerAttributes = /* @__PURE__ */ new Set([
  "marker-start",
  "marker-mid",
  "marker-end",
]);
const otherShapeAttributes = /* @__PURE__ */ new Set(["pathLength"]);
const animationTimingAttributes = /* @__PURE__ */ new Set([
  "begin",
  "dur",
  "end",
  "min",
  "max",
  "restart",
  "repeatCount",
  "repeatDur",
  "fill",
]);
const animationValueAttributes = /* @__PURE__ */ new Set([
  "calcMode",
  "values",
  "keyTimes",
  "keySplines",
  "from",
  "to",
  "by",
]);
const otherAnimationAttributes = /* @__PURE__ */ new Set([
  "attributeName",
  "additive",
  "accumulate",
]);
const commonGradientAttributes = /* @__PURE__ */ new Set([
  "gradientUnits",
  "gradientTransform",
  "href",
  "spreadMethod",
]);
const commonFeAttributes = /* @__PURE__ */ new Set([
  "x",
  "y",
  "width",
  "height",
  "color-interpolation-filters",
]);
const feFuncAttributes = /* @__PURE__ */ new Set([
  "type",
  "tableValues",
  "slope",
  "intercept",
  "amplitude",
  "exponent",
  "offset",
  ...commonFeAttributes,
]);
const tagSpecificPresentationalAttributes = {
  // SVG
  svg: /* @__PURE__ */ new Set([
    "width",
    "height",
    ...presentationalAttributes,
  ]),
  // Defnitions, containers and masks
  clipPath: /* @__PURE__ */ new Set([...presentationalAttributes]),
  defs: /* @__PURE__ */ new Set([]),
  g: /* @__PURE__ */ new Set([...presentationalAttributes]),
  mask: /* @__PURE__ */ new Set([
    "x",
    "y",
    "width",
    "height",
    ...presentationalAttributes,
  ]),
  symbol: /* @__PURE__ */ new Set([
    "x",
    "y",
    "width",
    "height",
    ...presentationalAttributes,
  ]),
  // Use
  use: /* @__PURE__ */ new Set([
    "x",
    "y",
    "width",
    "height",
    "refX",
    "refY",
    ...presentationalAttributes,
  ]),
  // Marker
  marker: /* @__PURE__ */ new Set([...presentationalAttributes]),
  // Gradients
  linearGradient: /* @__PURE__ */ new Set([
    "x1",
    "x2",
    "y1",
    "y2",
    ...presentationalAttributes,
  ]),
  radialGradient: /* @__PURE__ */ new Set([
    "cx",
    "cy",
    "fr",
    "fx",
    "fy",
    "r",
    ...presentationalAttributes,
  ]),
  stop: /* @__PURE__ */ new Set(["offset", "stop-color", "stop-opacity"]),
  // Filters
  feFlood: /* @__PURE__ */ new Set(["flood-color", "flood-opacity"]),
  feDropShadow: /* @__PURE__ */ new Set(["flood-color", "flood-opacity"]),
};
shapeTags.forEach((tag) => {
  tagSpecificPresentationalAttributes[tag] = /* @__PURE__ */ new Set([
    ...presentationalAttributes,
    ...markerAttributes,
    ...(tagSpecificPresentationalAttributes[tag] || []),
  ]);
});
filterChildTags.forEach((tag) => {
  tagSpecificPresentationalAttributes[tag] = /* @__PURE__ */ new Set([
    ...commonFeAttributes,
    ...(tagSpecificPresentationalAttributes[tag] || []),
  ]);
});
({
  // SVG
  svg: /* @__PURE__ */ new Set(["xmlns", "viewBox", "preserveAspectRatio"]),
  // Defnitions, containers and masks
  clipPath: /* @__PURE__ */ new Set(["clipPathUnits"]),
  mask: /* @__PURE__ */ new Set(["maskContentUnits", "maskUnits"]),
  symbol: /* @__PURE__ */ new Set(["viewBox", "preserveAspectRatio"]),
  // Shapes
  circle: /* @__PURE__ */ new Set([...otherShapeAttributes]),
  ellipse: /* @__PURE__ */ new Set([...otherShapeAttributes]),
  line: /* @__PURE__ */ new Set([...otherShapeAttributes]),
  path: /* @__PURE__ */ new Set([...otherShapeAttributes]),
  polygon: /* @__PURE__ */ new Set([...otherShapeAttributes]),
  polyline: /* @__PURE__ */ new Set([...otherShapeAttributes]),
  rect: /* @__PURE__ */ new Set([...otherShapeAttributes]),
  // Use
  use: /* @__PURE__ */ new Set(["href"]),
  // Marker
  marker: /* @__PURE__ */ new Set([
    "markerHeight",
    "markerUnits",
    "markerWidth",
    "orient",
    "preserveAspectRatio",
    "refX",
    "refY",
    "viewBox",
  ]),
  // Animations
  animate: /* @__PURE__ */ new Set([
    ...animationTimingAttributes,
    ...animationValueAttributes,
    ...otherAnimationAttributes,
  ]),
  animateMotion: /* @__PURE__ */ new Set([
    "keyPoints",
    "path",
    "rotate",
    ...animationTimingAttributes,
    ...animationValueAttributes,
    ...otherAnimationAttributes,
  ]),
  animateTransform: /* @__PURE__ */ new Set([
    "by",
    "from",
    "to",
    "type",
    ...animationTimingAttributes,
    ...animationValueAttributes,
    ...otherAnimationAttributes,
  ]),
  discard: /* @__PURE__ */ new Set(["begin", "href"]),
  set: /* @__PURE__ */ new Set([
    "to",
    ...animationTimingAttributes,
    ...otherAnimationAttributes,
  ]),
  mpath: /* @__PURE__ */ new Set(["href"]),
  // Gradients
  linearGradient: /* @__PURE__ */ new Set([...commonGradientAttributes]),
  radialGradient: /* @__PURE__ */ new Set([...commonGradientAttributes]),
  // Filters
  feSpotLight: /* @__PURE__ */ new Set([
    "x",
    "y",
    "z",
    "pointsAtX",
    "pointsAtY",
    "pointsAtZ",
    "specularExponent",
    "limitingConeAngle",
  ]),
  feBlend: /* @__PURE__ */ new Set(["in", "in2", "mode"]),
  feColorMatrix: /* @__PURE__ */ new Set(["in", "type", "values"]),
  feComponentTransfer: /* @__PURE__ */ new Set(["in"]),
  feComposite: /* @__PURE__ */ new Set([
    "in",
    "in2",
    "operator",
    "k1",
    "k2",
    "k3",
    "k4",
  ]),
  feConvolveMatrix: /* @__PURE__ */ new Set([
    "in",
    "order",
    "kernelMatrix",
    "divisor",
    "bias",
    "targetX",
    "targetY",
    "edgeMode",
    "kernelUnitLength",
    "preserveAlpha",
  ]),
  feDiffuseLighting: /* @__PURE__ */ new Set([
    "in",
    "surfaceScale",
    "diffuseConstant",
    "kernelUnitLength",
  ]),
  feDisplacementMap: /* @__PURE__ */ new Set([
    "in",
    "in2",
    "scale",
    "xChannelSelector",
    "yChannelSelector",
  ]),
  feDistantLight: /* @__PURE__ */ new Set(["azimuth", "elevation"]),
  feDropShadow: /* @__PURE__ */ new Set(["dx", "dy", "stdDeviation"]),
  feGaussianBlur: /* @__PURE__ */ new Set(["in", "stdDeviation", "edgeMode"]),
  feFuncA: feFuncAttributes,
  feFuncR: feFuncAttributes,
  feFuncG: feFuncAttributes,
  feFuncB: feFuncAttributes,
  feMergeNode: /* @__PURE__ */ new Set(["in"]),
  feMorphology: /* @__PURE__ */ new Set(["in", "operator", "radius"]),
  feOffset: /* @__PURE__ */ new Set(["in", "dx", "dy"]),
  fePointLight: /* @__PURE__ */ new Set(["x", "y", "z"]),
  feSpecularLighting: /* @__PURE__ */ new Set([
    "in",
    "surfaceScale",
    "specularConstant",
    "specularExponent",
    "kernelUnitLength",
  ]),
  feTile: /* @__PURE__ */ new Set(["in"]),
  feTurbulence: /* @__PURE__ */ new Set([
    "baseFrequency",
    "numOctaves",
    "seed",
    "stitchTiles",
    "type",
  ]),
});

const requiredParentTags = /* @__PURE__ */ new Map();
requiredParentTags.set(
  /* @__PURE__ */ new Set(["feComponentTransfer"]),
  feComponentTransferChildTag,
);
requiredParentTags.set(/* @__PURE__ */ new Set(["feMerge"]), feMergeChildTags);
requiredParentTags.set(feLightningTags, feLightningChildTags);
requiredParentTags.set(filterTag, filterChildTags);
requiredParentTags.set(gradientTags, gradientChildTags);
requiredParentTags.set(
  /* @__PURE__ */ new Set(["animateMotion"]),
  animateMotionChildTags,
);

var svgo = {};

var parser$4 = {};

var sax = {};

(function (exports) {
  (function (sax) {
    // wrapper for non-node envs
    sax.parser = function (strict, opt) {
      return new SAXParser(strict, opt);
    };
    sax.SAXParser = SAXParser;

    // When we pass the MAX_BUFFER_LENGTH position, start checking for buffer overruns.
    // When we check, schedule the next check for MAX_BUFFER_LENGTH - (max(buffer lengths)),
    // since that's the earliest that a buffer overrun could occur.  This way, checks are
    // as rare as required, but as often as necessary to ensure never crossing this bound.
    // Furthermore, buffers are only tested at most once per write(), so passing a very
    // large string into write() might have undesirable effects, but this is manageable by
    // the caller, so it is assumed to be safe.  Thus, a call to write() may, in the extreme
    // edge case, result in creating at most one complete copy of the string passed in.
    // Set to Infinity to have unlimited buffers.
    sax.MAX_BUFFER_LENGTH = 64 * 1024;

    var buffers = [
      "comment",
      "sgmlDecl",
      "textNode",
      "tagName",
      "doctype",
      "procInstName",
      "procInstBody",
      "entity",
      "attribName",
      "attribValue",
      "cdata",
      "script",
    ];

    sax.EVENTS = [
      "text",
      "processinginstruction",
      "sgmldeclaration",
      "doctype",
      "comment",
      "opentagstart",
      "attribute",
      "opentag",
      "closetag",
      "opencdata",
      "cdata",
      "closecdata",
      "error",
      "end",
      "ready",
      "script",
      "opennamespace",
      "closenamespace",
    ];

    function SAXParser(strict, opt) {
      if (!(this instanceof SAXParser)) {
        return new SAXParser(strict, opt);
      }

      var parser = this;
      clearBuffers(parser);
      parser.q = parser.c = "";
      parser.bufferCheckPosition = sax.MAX_BUFFER_LENGTH;
      parser.opt = opt || {};
      parser.opt.lowercase = parser.opt.lowercase || parser.opt.lowercasetags;
      parser.looseCase = parser.opt.lowercase ? "toLowerCase" : "toUpperCase";
      parser.tags = [];
      parser.closed = parser.closedRoot = parser.sawRoot = false;
      parser.tag = parser.error = null;
      parser.strict = !!strict;
      parser.noscript = !!(strict || parser.opt.noscript);
      parser.state = S.BEGIN;
      parser.strictEntities = parser.opt.strictEntities;
      parser.ENTITIES = parser.strictEntities
        ? Object.create(sax.XML_ENTITIES)
        : Object.create(sax.ENTITIES);
      parser.attribList = [];

      // namespaces form a prototype chain.
      // it always points at the current tag,
      // which protos to its parent tag.
      if (parser.opt.xmlns) {
        parser.ns = Object.create(rootNS);
      }

      // mostly just for error reporting
      parser.trackPosition = parser.opt.position !== false;
      if (parser.trackPosition) {
        parser.position = parser.line = parser.column = 0;
      }
      emit(parser, "onready");
    }

    if (!Object.create) {
      Object.create = function (o) {
        function F() {}
        F.prototype = o;
        var newf = new F();
        return newf;
      };
    }

    if (!Object.keys) {
      Object.keys = function (o) {
        var a = [];
        for (var i in o) if (o.hasOwnProperty(i)) a.push(i);
        return a;
      };
    }

    function checkBufferLength(parser) {
      var maxAllowed = Math.max(sax.MAX_BUFFER_LENGTH, 10);
      var maxActual = 0;
      for (var i = 0, l = buffers.length; i < l; i++) {
        var len = parser[buffers[i]].length;
        if (len > maxAllowed) {
          // Text/cdata nodes can get big, and since they're buffered,
          // we can get here under normal conditions.
          // Avoid issues by emitting the text node now,
          // so at least it won't get any bigger.
          switch (buffers[i]) {
            case "textNode":
              closeText(parser);
              break;

            case "cdata":
              emitNode(parser, "oncdata", parser.cdata);
              parser.cdata = "";
              break;

            case "script":
              emitNode(parser, "onscript", parser.script);
              parser.script = "";
              break;

            default:
              error(parser, "Max buffer length exceeded: " + buffers[i]);
          }
        }
        maxActual = Math.max(maxActual, len);
      }
      // schedule the next check for the earliest possible buffer overrun.
      var m = sax.MAX_BUFFER_LENGTH - maxActual;
      parser.bufferCheckPosition = m + parser.position;
    }

    function clearBuffers(parser) {
      for (var i = 0, l = buffers.length; i < l; i++) {
        parser[buffers[i]] = "";
      }
    }

    function flushBuffers(parser) {
      closeText(parser);
      if (parser.cdata !== "") {
        emitNode(parser, "oncdata", parser.cdata);
        parser.cdata = "";
      }
      if (parser.script !== "") {
        emitNode(parser, "onscript", parser.script);
        parser.script = "";
      }
    }

    SAXParser.prototype = {
      end: function () {
        end(this);
      },
      write: write,
      resume: function () {
        this.error = null;
        return this;
      },
      close: function () {
        return this.write(null);
      },
      flush: function () {
        flushBuffers(this);
      },
    };

    // this really needs to be replaced with character classes.
    // XML allows all manner of ridiculous numbers and digits.
    var CDATA = "[CDATA[";
    var DOCTYPE = "DOCTYPE";
    var XML_NAMESPACE = "http://www.w3.org/XML/1998/namespace";
    var XMLNS_NAMESPACE = "http://www.w3.org/2000/xmlns/";
    var rootNS = { xml: XML_NAMESPACE, xmlns: XMLNS_NAMESPACE };

    // http://www.w3.org/TR/REC-xml/#NT-NameStartChar
    // This implementation works on strings, a single character at a time
    // as such, it cannot ever support astral-plane characters (10000-EFFFF)
    // without a significant breaking change to either this  parser, or the
    // JavaScript language.  Implementation of an emoji-capable xml parser
    // is left as an exercise for the reader.
    var nameStart =
      /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/;

    var nameBody =
      /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/;

    var entityStart =
      /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/;
    var entityBody =
      /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/;

    function isWhitespace(c) {
      return c === " " || c === "\n" || c === "\r" || c === "\t";
    }

    function isQuote(c) {
      return c === '"' || c === "'";
    }

    function isAttribEnd(c) {
      return c === ">" || isWhitespace(c);
    }

    function isMatch(regex, c) {
      return regex.test(c);
    }

    function notMatch(regex, c) {
      return !isMatch(regex, c);
    }

    var S = 0;
    sax.STATE = {
      BEGIN: S++, // leading byte order mark or whitespace
      BEGIN_WHITESPACE: S++, // leading whitespace
      TEXT: S++, // general stuff
      TEXT_ENTITY: S++, // &amp and such.
      OPEN_WAKA: S++, // <
      SGML_DECL: S++, // <!BLARG
      SGML_DECL_QUOTED: S++, // <!BLARG foo "bar
      DOCTYPE: S++, // <!DOCTYPE
      DOCTYPE_QUOTED: S++, // <!DOCTYPE "//blah
      DOCTYPE_DTD: S++, // <!DOCTYPE "//blah" [ ...
      DOCTYPE_DTD_QUOTED: S++, // <!DOCTYPE "//blah" [ "foo
      COMMENT_STARTING: S++, // <!-
      COMMENT: S++, // <!--
      COMMENT_ENDING: S++, // <!-- blah -
      COMMENT_ENDED: S++, // <!-- blah --
      CDATA: S++, // <![CDATA[ something
      CDATA_ENDING: S++, // ]
      CDATA_ENDING_2: S++, // ]]
      PROC_INST: S++, // <?hi
      PROC_INST_BODY: S++, // <?hi there
      PROC_INST_ENDING: S++, // <?hi "there" ?
      OPEN_TAG: S++, // <strong
      OPEN_TAG_SLASH: S++, // <strong /
      ATTRIB: S++, // <a
      ATTRIB_NAME: S++, // <a foo
      ATTRIB_NAME_SAW_WHITE: S++, // <a foo _
      ATTRIB_VALUE: S++, // <a foo=
      ATTRIB_VALUE_QUOTED: S++, // <a foo="bar
      ATTRIB_VALUE_CLOSED: S++, // <a foo="bar"
      ATTRIB_VALUE_UNQUOTED: S++, // <a foo=bar
      ATTRIB_VALUE_ENTITY_Q: S++, // <foo bar="&quot;"
      ATTRIB_VALUE_ENTITY_U: S++, // <foo bar=&quot
      CLOSE_TAG: S++, // </a
      CLOSE_TAG_SAW_WHITE: S++, // </a   >
      SCRIPT: S++, // <script> ...
      SCRIPT_ENDING: S++, // <script> ... <
    };

    sax.XML_ENTITIES = {
      amp: "&",
      gt: ">",
      lt: "<",
      quot: '"',
      apos: "'",
    };

    sax.ENTITIES = {
      amp: "&",
      gt: ">",
      lt: "<",
      quot: '"',
      apos: "'",
      AElig: 198,
      Aacute: 193,
      Acirc: 194,
      Agrave: 192,
      Aring: 197,
      Atilde: 195,
      Auml: 196,
      Ccedil: 199,
      ETH: 208,
      Eacute: 201,
      Ecirc: 202,
      Egrave: 200,
      Euml: 203,
      Iacute: 205,
      Icirc: 206,
      Igrave: 204,
      Iuml: 207,
      Ntilde: 209,
      Oacute: 211,
      Ocirc: 212,
      Ograve: 210,
      Oslash: 216,
      Otilde: 213,
      Ouml: 214,
      THORN: 222,
      Uacute: 218,
      Ucirc: 219,
      Ugrave: 217,
      Uuml: 220,
      Yacute: 221,
      aacute: 225,
      acirc: 226,
      aelig: 230,
      agrave: 224,
      aring: 229,
      atilde: 227,
      auml: 228,
      ccedil: 231,
      eacute: 233,
      ecirc: 234,
      egrave: 232,
      eth: 240,
      euml: 235,
      iacute: 237,
      icirc: 238,
      igrave: 236,
      iuml: 239,
      ntilde: 241,
      oacute: 243,
      ocirc: 244,
      ograve: 242,
      oslash: 248,
      otilde: 245,
      ouml: 246,
      szlig: 223,
      thorn: 254,
      uacute: 250,
      ucirc: 251,
      ugrave: 249,
      uuml: 252,
      yacute: 253,
      yuml: 255,
      copy: 169,
      reg: 174,
      nbsp: 160,
      iexcl: 161,
      cent: 162,
      pound: 163,
      curren: 164,
      yen: 165,
      brvbar: 166,
      sect: 167,
      uml: 168,
      ordf: 170,
      laquo: 171,
      not: 172,
      shy: 173,
      macr: 175,
      deg: 176,
      plusmn: 177,
      sup1: 185,
      sup2: 178,
      sup3: 179,
      acute: 180,
      micro: 181,
      para: 182,
      middot: 183,
      cedil: 184,
      ordm: 186,
      raquo: 187,
      frac14: 188,
      frac12: 189,
      frac34: 190,
      iquest: 191,
      times: 215,
      divide: 247,
      OElig: 338,
      oelig: 339,
      Scaron: 352,
      scaron: 353,
      Yuml: 376,
      fnof: 402,
      circ: 710,
      tilde: 732,
      Alpha: 913,
      Beta: 914,
      Gamma: 915,
      Delta: 916,
      Epsilon: 917,
      Zeta: 918,
      Eta: 919,
      Theta: 920,
      Iota: 921,
      Kappa: 922,
      Lambda: 923,
      Mu: 924,
      Nu: 925,
      Xi: 926,
      Omicron: 927,
      Pi: 928,
      Rho: 929,
      Sigma: 931,
      Tau: 932,
      Upsilon: 933,
      Phi: 934,
      Chi: 935,
      Psi: 936,
      Omega: 937,
      alpha: 945,
      beta: 946,
      gamma: 947,
      delta: 948,
      epsilon: 949,
      zeta: 950,
      eta: 951,
      theta: 952,
      iota: 953,
      kappa: 954,
      lambda: 955,
      mu: 956,
      nu: 957,
      xi: 958,
      omicron: 959,
      pi: 960,
      rho: 961,
      sigmaf: 962,
      sigma: 963,
      tau: 964,
      upsilon: 965,
      phi: 966,
      chi: 967,
      psi: 968,
      omega: 969,
      thetasym: 977,
      upsih: 978,
      piv: 982,
      ensp: 8194,
      emsp: 8195,
      thinsp: 8201,
      zwnj: 8204,
      zwj: 8205,
      lrm: 8206,
      rlm: 8207,
      ndash: 8211,
      mdash: 8212,
      lsquo: 8216,
      rsquo: 8217,
      sbquo: 8218,
      ldquo: 8220,
      rdquo: 8221,
      bdquo: 8222,
      dagger: 8224,
      Dagger: 8225,
      bull: 8226,
      hellip: 8230,
      permil: 8240,
      prime: 8242,
      Prime: 8243,
      lsaquo: 8249,
      rsaquo: 8250,
      oline: 8254,
      frasl: 8260,
      euro: 8364,
      image: 8465,
      weierp: 8472,
      real: 8476,
      trade: 8482,
      alefsym: 8501,
      larr: 8592,
      uarr: 8593,
      rarr: 8594,
      darr: 8595,
      harr: 8596,
      crarr: 8629,
      lArr: 8656,
      uArr: 8657,
      rArr: 8658,
      dArr: 8659,
      hArr: 8660,
      forall: 8704,
      part: 8706,
      exist: 8707,
      empty: 8709,
      nabla: 8711,
      isin: 8712,
      notin: 8713,
      ni: 8715,
      prod: 8719,
      sum: 8721,
      minus: 8722,
      lowast: 8727,
      radic: 8730,
      prop: 8733,
      infin: 8734,
      ang: 8736,
      and: 8743,
      or: 8744,
      cap: 8745,
      cup: 8746,
      int: 8747,
      there4: 8756,
      sim: 8764,
      cong: 8773,
      asymp: 8776,
      ne: 8800,
      equiv: 8801,
      le: 8804,
      ge: 8805,
      sub: 8834,
      sup: 8835,
      nsub: 8836,
      sube: 8838,
      supe: 8839,
      oplus: 8853,
      otimes: 8855,
      perp: 8869,
      sdot: 8901,
      lceil: 8968,
      rceil: 8969,
      lfloor: 8970,
      rfloor: 8971,
      lang: 9001,
      rang: 9002,
      loz: 9674,
      spades: 9824,
      clubs: 9827,
      hearts: 9829,
      diams: 9830,
    };

    Object.keys(sax.ENTITIES).forEach(function (key) {
      var e = sax.ENTITIES[key];
      var s = typeof e === "number" ? String.fromCharCode(e) : e;
      sax.ENTITIES[key] = s;
    });

    for (var s in sax.STATE) {
      sax.STATE[sax.STATE[s]] = s;
    }

    // shorthand
    S = sax.STATE;

    function emit(parser, event, data) {
      parser[event] && parser[event](data);
    }

    function emitNode(parser, nodeType, data) {
      if (parser.textNode) closeText(parser);
      emit(parser, nodeType, data);
    }

    function closeText(parser) {
      parser.textNode = textopts(parser.opt, parser.textNode);
      if (parser.textNode) emit(parser, "ontext", parser.textNode);
      parser.textNode = "";
    }

    function textopts(opt, text) {
      if (opt.trim) text = text.trim();
      if (opt.normalize) text = text.replace(/\s+/g, " ");
      return text;
    }

    function error(parser, reason) {
      closeText(parser);
      const message =
        reason +
        "\nLine: " +
        parser.line +
        "\nColumn: " +
        parser.column +
        "\nChar: " +
        parser.c;
      const error = new Error(message);
      error.reason = reason;
      error.line = parser.line;
      error.column = parser.column;
      parser.error = error;
      emit(parser, "onerror", error);
      return parser;
    }

    function end(parser) {
      if (parser.sawRoot && !parser.closedRoot)
        strictFail(parser, "Unclosed root tag");
      if (
        parser.state !== S.BEGIN &&
        parser.state !== S.BEGIN_WHITESPACE &&
        parser.state !== S.TEXT
      ) {
        error(parser, "Unexpected end");
      }
      closeText(parser);
      parser.c = "";
      parser.closed = true;
      emit(parser, "onend");
      SAXParser.call(parser, parser.strict, parser.opt);
      return parser;
    }

    function strictFail(parser, message) {
      if (typeof parser !== "object" || !(parser instanceof SAXParser)) {
        throw new Error("bad call to strictFail");
      }
      if (parser.strict) {
        error(parser, message);
      }
    }

    function newTag(parser) {
      if (!parser.strict) parser.tagName = parser.tagName[parser.looseCase]();
      var parent = parser.tags[parser.tags.length - 1] || parser;
      var tag = (parser.tag = { name: parser.tagName, attributes: {} });

      // will be overridden if tag contails an xmlns="foo" or xmlns:foo="bar"
      if (parser.opt.xmlns) {
        tag.ns = parent.ns;
      }
      parser.attribList.length = 0;
      emitNode(parser, "onopentagstart", tag);
    }

    function qname(name, attribute) {
      var i = name.indexOf(":");
      var qualName = i < 0 ? ["", name] : name.split(":");
      var prefix = qualName[0];
      var local = qualName[1];

      // <x "xmlns"="http://foo">
      if (attribute && name === "xmlns") {
        prefix = "xmlns";
        local = "";
      }

      return { prefix: prefix, local: local };
    }

    function attrib(parser) {
      if (!parser.strict) {
        parser.attribName = parser.attribName[parser.looseCase]();
      }

      if (
        parser.attribList.indexOf(parser.attribName) !== -1 ||
        parser.tag.attributes.hasOwnProperty(parser.attribName)
      ) {
        parser.attribName = parser.attribValue = "";
        return;
      }

      if (parser.opt.xmlns) {
        var qn = qname(parser.attribName, true);
        var prefix = qn.prefix;
        var local = qn.local;

        if (prefix === "xmlns") {
          // namespace binding attribute. push the binding into scope
          if (local === "xml" && parser.attribValue !== XML_NAMESPACE) {
            strictFail(
              parser,
              "xml: prefix must be bound to " +
                XML_NAMESPACE +
                "\n" +
                "Actual: " +
                parser.attribValue,
            );
          } else if (
            local === "xmlns" &&
            parser.attribValue !== XMLNS_NAMESPACE
          ) {
            strictFail(
              parser,
              "xmlns: prefix must be bound to " +
                XMLNS_NAMESPACE +
                "\n" +
                "Actual: " +
                parser.attribValue,
            );
          } else {
            var tag = parser.tag;
            var parent = parser.tags[parser.tags.length - 1] || parser;
            if (tag.ns === parent.ns) {
              tag.ns = Object.create(parent.ns);
            }
            tag.ns[local] = parser.attribValue;
          }
        }

        // defer onattribute events until all attributes have been seen
        // so any new bindings can take effect. preserve attribute order
        // so deferred events can be emitted in document order
        parser.attribList.push([parser.attribName, parser.attribValue]);
      } else {
        // in non-xmlns mode, we can emit the event right away
        parser.tag.attributes[parser.attribName] = parser.attribValue;
        emitNode(parser, "onattribute", {
          name: parser.attribName,
          value: parser.attribValue,
        });
      }

      parser.attribName = parser.attribValue = "";
    }

    function openTag(parser, selfClosing) {
      if (parser.opt.xmlns) {
        // emit namespace binding events
        var tag = parser.tag;

        // add namespace info to tag
        var qn = qname(parser.tagName);
        tag.prefix = qn.prefix;
        tag.local = qn.local;
        tag.uri = tag.ns[qn.prefix] || "";

        if (tag.prefix && !tag.uri) {
          strictFail(
            parser,
            "Unbound namespace prefix: " + JSON.stringify(parser.tagName),
          );
          tag.uri = qn.prefix;
        }

        var parent = parser.tags[parser.tags.length - 1] || parser;
        if (tag.ns && parent.ns !== tag.ns) {
          Object.keys(tag.ns).forEach(function (p) {
            emitNode(parser, "onopennamespace", {
              prefix: p,
              uri: tag.ns[p],
            });
          });
        }

        // handle deferred onattribute events
        // Note: do not apply default ns to attributes:
        //   http://www.w3.org/TR/REC-xml-names/#defaulting
        for (var i = 0, l = parser.attribList.length; i < l; i++) {
          var nv = parser.attribList[i];
          var name = nv[0];
          var value = nv[1];
          var qualName = qname(name, true);
          var prefix = qualName.prefix;
          var local = qualName.local;
          var uri = prefix === "" ? "" : tag.ns[prefix] || "";
          var a = {
            name: name,
            value: value,
            prefix: prefix,
            local: local,
            uri: uri,
          };

          // if there's any attributes with an undefined namespace,
          // then fail on them now.
          if (prefix && prefix !== "xmlns" && !uri) {
            strictFail(
              parser,
              "Unbound namespace prefix: " + JSON.stringify(prefix),
            );
            a.uri = prefix;
          }
          parser.tag.attributes[name] = a;
          emitNode(parser, "onattribute", a);
        }
        parser.attribList.length = 0;
      }

      parser.tag.isSelfClosing = !!selfClosing;

      // process the tag
      parser.sawRoot = true;
      parser.tags.push(parser.tag);
      emitNode(parser, "onopentag", parser.tag);
      if (!selfClosing) {
        // special case for <script> in non-strict mode.
        if (!parser.noscript && parser.tagName.toLowerCase() === "script") {
          parser.state = S.SCRIPT;
        } else {
          parser.state = S.TEXT;
        }
        parser.tag = null;
        parser.tagName = "";
      }
      parser.attribName = parser.attribValue = "";
      parser.attribList.length = 0;
    }

    function closeTag(parser) {
      if (!parser.tagName) {
        strictFail(parser, "Weird empty close tag.");
        parser.textNode += "</>";
        parser.state = S.TEXT;
        return;
      }

      if (parser.script) {
        if (parser.tagName !== "script") {
          parser.script += "</" + parser.tagName + ">";
          parser.tagName = "";
          parser.state = S.SCRIPT;
          return;
        }
        emitNode(parser, "onscript", parser.script);
        parser.script = "";
      }

      // first make sure that the closing tag actually exists.
      // <a><b></c></b></a> will close everything, otherwise.
      var t = parser.tags.length;
      var tagName = parser.tagName;
      if (!parser.strict) {
        tagName = tagName[parser.looseCase]();
      }
      var closeTo = tagName;
      while (t--) {
        var close = parser.tags[t];
        if (close.name !== closeTo) {
          // fail the first time in strict mode
          strictFail(parser, "Unexpected close tag");
        } else {
          break;
        }
      }

      // didn't find it.  we already failed for strict, so just abort.
      if (t < 0) {
        strictFail(parser, "Unmatched closing tag: " + parser.tagName);
        parser.textNode += "</" + parser.tagName + ">";
        parser.state = S.TEXT;
        return;
      }
      parser.tagName = tagName;
      var s = parser.tags.length;
      while (s-- > t) {
        var tag = (parser.tag = parser.tags.pop());
        parser.tagName = parser.tag.name;
        emitNode(parser, "onclosetag", parser.tagName);

        var x = {};
        for (var i in tag.ns) {
          x[i] = tag.ns[i];
        }

        var parent = parser.tags[parser.tags.length - 1] || parser;
        if (parser.opt.xmlns && tag.ns !== parent.ns) {
          // remove namespace bindings introduced by tag
          Object.keys(tag.ns).forEach(function (p) {
            var n = tag.ns[p];
            emitNode(parser, "onclosenamespace", { prefix: p, uri: n });
          });
        }
      }
      if (t === 0) parser.closedRoot = true;
      parser.tagName = parser.attribValue = parser.attribName = "";
      parser.attribList.length = 0;
      parser.state = S.TEXT;
    }

    function parseEntity(parser) {
      var entity = parser.entity;
      var entityLC = entity.toLowerCase();
      var num;
      var numStr = "";

      if (parser.ENTITIES[entity]) {
        return parser.ENTITIES[entity];
      }
      if (parser.ENTITIES[entityLC]) {
        return parser.ENTITIES[entityLC];
      }
      entity = entityLC;
      if (entity.charAt(0) === "#") {
        if (entity.charAt(1) === "x") {
          entity = entity.slice(2);
          num = parseInt(entity, 16);
          numStr = num.toString(16);
        } else {
          entity = entity.slice(1);
          num = parseInt(entity, 10);
          numStr = num.toString(10);
        }
      }
      entity = entity.replace(/^0+/, "");
      if (isNaN(num) || numStr.toLowerCase() !== entity) {
        strictFail(parser, "Invalid character entity");
        return "&" + parser.entity + ";";
      }

      return String.fromCodePoint(num);
    }

    function beginWhiteSpace(parser, c) {
      if (c === "<") {
        parser.state = S.OPEN_WAKA;
        parser.startTagPosition = parser.position;
      } else if (!isWhitespace(c)) {
        // have to process this as a text node.
        // weird, but happens.
        strictFail(parser, "Non-whitespace before first tag.");
        parser.textNode = c;
        parser.state = S.TEXT;
      }
    }

    function charAt(chunk, i) {
      var result = "";
      if (i < chunk.length) {
        result = chunk.charAt(i);
      }
      return result;
    }

    function write(chunk) {
      var parser = this;
      if (this.error) {
        throw this.error;
      }
      if (parser.closed) {
        return error(
          parser,
          "Cannot write after close. Assign an onready handler.",
        );
      }
      if (chunk === null) {
        return end(parser);
      }
      if (typeof chunk === "object") {
        chunk = chunk.toString();
      }
      var i = 0;
      var c = "";
      while (true) {
        c = charAt(chunk, i++);
        parser.c = c;

        if (!c) {
          break;
        }

        if (parser.trackPosition) {
          parser.position++;
          if (c === "\n") {
            parser.line++;
            parser.column = 0;
          } else {
            parser.column++;
          }
        }

        switch (parser.state) {
          case S.BEGIN:
            parser.state = S.BEGIN_WHITESPACE;
            if (c === "\uFEFF") {
              continue;
            }
            beginWhiteSpace(parser, c);
            continue;

          case S.BEGIN_WHITESPACE:
            beginWhiteSpace(parser, c);
            continue;

          case S.TEXT:
            if (parser.sawRoot && !parser.closedRoot) {
              var starti = i - 1;
              while (c && c !== "<" && c !== "&") {
                c = charAt(chunk, i++);
                if (c && parser.trackPosition) {
                  parser.position++;
                  if (c === "\n") {
                    parser.line++;
                    parser.column = 0;
                  } else {
                    parser.column++;
                  }
                }
              }
              parser.textNode += chunk.substring(starti, i - 1);
            }
            if (
              c === "<" &&
              !(parser.sawRoot && parser.closedRoot && !parser.strict)
            ) {
              parser.state = S.OPEN_WAKA;
              parser.startTagPosition = parser.position;
            } else {
              if (!isWhitespace(c) && (!parser.sawRoot || parser.closedRoot)) {
                strictFail(parser, "Text data outside of root node.");
              }
              if (c === "&") {
                parser.state = S.TEXT_ENTITY;
              } else {
                parser.textNode += c;
              }
            }
            continue;

          case S.SCRIPT:
            // only non-strict
            if (c === "<") {
              parser.state = S.SCRIPT_ENDING;
            } else {
              parser.script += c;
            }
            continue;

          case S.SCRIPT_ENDING:
            if (c === "/") {
              parser.state = S.CLOSE_TAG;
            } else {
              parser.script += "<" + c;
              parser.state = S.SCRIPT;
            }
            continue;

          case S.OPEN_WAKA:
            // either a /, ?, !, or text is coming next.
            if (c === "!") {
              parser.state = S.SGML_DECL;
              parser.sgmlDecl = "";
            } else if (isWhitespace(c));
            else if (isMatch(nameStart, c)) {
              parser.state = S.OPEN_TAG;
              parser.tagName = c;
            } else if (c === "/") {
              parser.state = S.CLOSE_TAG;
              parser.tagName = "";
            } else if (c === "?") {
              parser.state = S.PROC_INST;
              parser.procInstName = parser.procInstBody = "";
            } else {
              strictFail(parser, "Unencoded <");
              // if there was some whitespace, then add that in.
              if (parser.startTagPosition + 1 < parser.position) {
                var pad = parser.position - parser.startTagPosition;
                c = new Array(pad).join(" ") + c;
              }
              parser.textNode += "<" + c;
              parser.state = S.TEXT;
            }
            continue;

          case S.SGML_DECL:
            if ((parser.sgmlDecl + c).toUpperCase() === CDATA) {
              emitNode(parser, "onopencdata");
              parser.state = S.CDATA;
              parser.sgmlDecl = "";
              parser.cdata = "";
            } else if (parser.sgmlDecl + c === "--") {
              parser.state = S.COMMENT;
              parser.comment = "";
              parser.sgmlDecl = "";
            } else if ((parser.sgmlDecl + c).toUpperCase() === DOCTYPE) {
              parser.state = S.DOCTYPE;
              if (parser.doctype || parser.sawRoot) {
                strictFail(
                  parser,
                  "Inappropriately located doctype declaration",
                );
              }
              parser.doctype = "";
              parser.sgmlDecl = "";
            } else if (c === ">") {
              emitNode(parser, "onsgmldeclaration", parser.sgmlDecl);
              parser.sgmlDecl = "";
              parser.state = S.TEXT;
            } else if (isQuote(c)) {
              parser.state = S.SGML_DECL_QUOTED;
              parser.sgmlDecl += c;
            } else {
              parser.sgmlDecl += c;
            }
            continue;

          case S.SGML_DECL_QUOTED:
            if (c === parser.q) {
              parser.state = S.SGML_DECL;
              parser.q = "";
            }
            parser.sgmlDecl += c;
            continue;

          case S.DOCTYPE:
            if (c === ">") {
              parser.state = S.TEXT;
              emitNode(parser, "ondoctype", parser.doctype);
              parser.doctype = true; // just remember that we saw it.
            } else {
              parser.doctype += c;
              if (c === "[") {
                parser.state = S.DOCTYPE_DTD;
              } else if (isQuote(c)) {
                parser.state = S.DOCTYPE_QUOTED;
                parser.q = c;
              }
            }
            continue;

          case S.DOCTYPE_QUOTED:
            parser.doctype += c;
            if (c === parser.q) {
              parser.q = "";
              parser.state = S.DOCTYPE;
            }
            continue;

          case S.DOCTYPE_DTD:
            parser.doctype += c;
            if (c === "]") {
              parser.state = S.DOCTYPE;
            } else if (isQuote(c)) {
              parser.state = S.DOCTYPE_DTD_QUOTED;
              parser.q = c;
            }
            continue;

          case S.DOCTYPE_DTD_QUOTED:
            parser.doctype += c;
            if (c === parser.q) {
              parser.state = S.DOCTYPE_DTD;
              parser.q = "";
            }
            continue;

          case S.COMMENT:
            if (c === "-") {
              parser.state = S.COMMENT_ENDING;
            } else {
              parser.comment += c;
            }
            continue;

          case S.COMMENT_ENDING:
            if (c === "-") {
              parser.state = S.COMMENT_ENDED;
              parser.comment = textopts(parser.opt, parser.comment);
              if (parser.comment) {
                emitNode(parser, "oncomment", parser.comment);
              }
              parser.comment = "";
            } else {
              parser.comment += "-" + c;
              parser.state = S.COMMENT;
            }
            continue;

          case S.COMMENT_ENDED:
            if (c !== ">") {
              strictFail(parser, "Malformed comment");
              // allow <!-- blah -- bloo --> in non-strict mode,
              // which is a comment of " blah -- bloo "
              parser.comment += "--" + c;
              parser.state = S.COMMENT;
            } else {
              parser.state = S.TEXT;
            }
            continue;

          case S.CDATA:
            if (c === "]") {
              parser.state = S.CDATA_ENDING;
            } else {
              parser.cdata += c;
            }
            continue;

          case S.CDATA_ENDING:
            if (c === "]") {
              parser.state = S.CDATA_ENDING_2;
            } else {
              parser.cdata += "]" + c;
              parser.state = S.CDATA;
            }
            continue;

          case S.CDATA_ENDING_2:
            if (c === ">") {
              if (parser.cdata) {
                emitNode(parser, "oncdata", parser.cdata);
              }
              emitNode(parser, "onclosecdata");
              parser.cdata = "";
              parser.state = S.TEXT;
            } else if (c === "]") {
              parser.cdata += "]";
            } else {
              parser.cdata += "]]" + c;
              parser.state = S.CDATA;
            }
            continue;

          case S.PROC_INST:
            if (c === "?") {
              parser.state = S.PROC_INST_ENDING;
            } else if (isWhitespace(c)) {
              parser.state = S.PROC_INST_BODY;
            } else {
              parser.procInstName += c;
            }
            continue;

          case S.PROC_INST_BODY:
            if (!parser.procInstBody && isWhitespace(c)) {
              continue;
            } else if (c === "?") {
              parser.state = S.PROC_INST_ENDING;
            } else {
              parser.procInstBody += c;
            }
            continue;

          case S.PROC_INST_ENDING:
            if (c === ">") {
              emitNode(parser, "onprocessinginstruction", {
                name: parser.procInstName,
                body: parser.procInstBody,
              });
              parser.procInstName = parser.procInstBody = "";
              parser.state = S.TEXT;
            } else {
              parser.procInstBody += "?" + c;
              parser.state = S.PROC_INST_BODY;
            }
            continue;

          case S.OPEN_TAG:
            if (isMatch(nameBody, c)) {
              parser.tagName += c;
            } else {
              newTag(parser);
              if (c === ">") {
                openTag(parser);
              } else if (c === "/") {
                parser.state = S.OPEN_TAG_SLASH;
              } else {
                if (!isWhitespace(c)) {
                  strictFail(parser, "Invalid character in tag name");
                }
                parser.state = S.ATTRIB;
              }
            }
            continue;

          case S.OPEN_TAG_SLASH:
            if (c === ">") {
              openTag(parser, true);
              closeTag(parser);
            } else {
              strictFail(
                parser,
                "Forward-slash in opening tag not followed by >",
              );
              parser.state = S.ATTRIB;
            }
            continue;

          case S.ATTRIB:
            // haven't read the attribute name yet.
            if (isWhitespace(c)) {
              continue;
            } else if (c === ">") {
              openTag(parser);
            } else if (c === "/") {
              parser.state = S.OPEN_TAG_SLASH;
            } else if (isMatch(nameStart, c)) {
              parser.attribName = c;
              parser.attribValue = "";
              parser.state = S.ATTRIB_NAME;
            } else {
              strictFail(parser, "Invalid attribute name");
            }
            continue;

          case S.ATTRIB_NAME:
            if (c === "=") {
              parser.state = S.ATTRIB_VALUE;
            } else if (c === ">") {
              strictFail(parser, "Attribute without value");
              parser.attribValue = parser.attribName;
              attrib(parser);
              openTag(parser);
            } else if (isWhitespace(c)) {
              parser.state = S.ATTRIB_NAME_SAW_WHITE;
            } else if (isMatch(nameBody, c)) {
              parser.attribName += c;
            } else {
              strictFail(parser, "Invalid attribute name");
            }
            continue;

          case S.ATTRIB_NAME_SAW_WHITE:
            if (c === "=") {
              parser.state = S.ATTRIB_VALUE;
            } else if (isWhitespace(c)) {
              continue;
            } else {
              strictFail(parser, "Attribute without value");
              parser.tag.attributes[parser.attribName] = "";
              parser.attribValue = "";
              emitNode(parser, "onattribute", {
                name: parser.attribName,
                value: "",
              });
              parser.attribName = "";
              if (c === ">") {
                openTag(parser);
              } else if (isMatch(nameStart, c)) {
                parser.attribName = c;
                parser.state = S.ATTRIB_NAME;
              } else {
                strictFail(parser, "Invalid attribute name");
                parser.state = S.ATTRIB;
              }
            }
            continue;

          case S.ATTRIB_VALUE:
            if (isWhitespace(c)) {
              continue;
            } else if (isQuote(c)) {
              parser.q = c;
              parser.state = S.ATTRIB_VALUE_QUOTED;
            } else {
              strictFail(parser, "Unquoted attribute value");
              parser.state = S.ATTRIB_VALUE_UNQUOTED;
              parser.attribValue = c;
            }
            continue;

          case S.ATTRIB_VALUE_QUOTED:
            if (c !== parser.q) {
              if (c === "&") {
                parser.state = S.ATTRIB_VALUE_ENTITY_Q;
              } else {
                parser.attribValue += c;
              }
              continue;
            }
            attrib(parser);
            parser.q = "";
            parser.state = S.ATTRIB_VALUE_CLOSED;
            continue;

          case S.ATTRIB_VALUE_CLOSED:
            if (isWhitespace(c)) {
              parser.state = S.ATTRIB;
            } else if (c === ">") {
              openTag(parser);
            } else if (c === "/") {
              parser.state = S.OPEN_TAG_SLASH;
            } else if (isMatch(nameStart, c)) {
              strictFail(parser, "No whitespace between attributes");
              parser.attribName = c;
              parser.attribValue = "";
              parser.state = S.ATTRIB_NAME;
            } else {
              strictFail(parser, "Invalid attribute name");
            }
            continue;

          case S.ATTRIB_VALUE_UNQUOTED:
            if (!isAttribEnd(c)) {
              if (c === "&") {
                parser.state = S.ATTRIB_VALUE_ENTITY_U;
              } else {
                parser.attribValue += c;
              }
              continue;
            }
            attrib(parser);
            if (c === ">") {
              openTag(parser);
            } else {
              parser.state = S.ATTRIB;
            }
            continue;

          case S.CLOSE_TAG:
            if (!parser.tagName) {
              if (isWhitespace(c)) {
                continue;
              } else if (notMatch(nameStart, c)) {
                if (parser.script) {
                  parser.script += "</" + c;
                  parser.state = S.SCRIPT;
                } else {
                  strictFail(parser, "Invalid tagname in closing tag.");
                }
              } else {
                parser.tagName = c;
              }
            } else if (c === ">") {
              closeTag(parser);
            } else if (isMatch(nameBody, c)) {
              parser.tagName += c;
            } else if (parser.script) {
              parser.script += "</" + parser.tagName;
              parser.tagName = "";
              parser.state = S.SCRIPT;
            } else {
              if (!isWhitespace(c)) {
                strictFail(parser, "Invalid tagname in closing tag");
              }
              parser.state = S.CLOSE_TAG_SAW_WHITE;
            }
            continue;

          case S.CLOSE_TAG_SAW_WHITE:
            if (isWhitespace(c)) {
              continue;
            }
            if (c === ">") {
              closeTag(parser);
            } else {
              strictFail(parser, "Invalid characters in closing tag");
            }
            continue;

          case S.TEXT_ENTITY:
          case S.ATTRIB_VALUE_ENTITY_Q:
          case S.ATTRIB_VALUE_ENTITY_U:
            var returnState;
            var buffer;
            switch (parser.state) {
              case S.TEXT_ENTITY:
                returnState = S.TEXT;
                buffer = "textNode";
                break;

              case S.ATTRIB_VALUE_ENTITY_Q:
                returnState = S.ATTRIB_VALUE_QUOTED;
                buffer = "attribValue";
                break;

              case S.ATTRIB_VALUE_ENTITY_U:
                returnState = S.ATTRIB_VALUE_UNQUOTED;
                buffer = "attribValue";
                break;
            }

            if (c === ";") {
              var parsedEntity = parseEntity(parser);

              // Custom entities can contain tags, so we potentially need to parse the result
              if (
                parser.state === S.TEXT_ENTITY &&
                !sax.ENTITIES[parser.entity] &&
                parsedEntity !== "&" + parser.entity + ";"
              ) {
                chunk = chunk.slice(0, i) + parsedEntity + chunk.slice(i);
              } else {
                parser[buffer] += parsedEntity;
              }

              parser.entity = "";
              parser.state = returnState;
            } else if (
              isMatch(parser.entity.length ? entityBody : entityStart, c)
            ) {
              parser.entity += c;
            } else {
              strictFail(parser, "Invalid character in entity name");
              parser[buffer] += "&" + parser.entity + c;
              parser.entity = "";
              parser.state = returnState;
            }

            continue;

          default:
            throw new Error(parser, "Unknown state: " + parser.state);
        }
      } // while

      if (parser.position >= parser.bufferCheckPosition) {
        checkBufferLength(parser);
      }
      return parser;
    }
  })(exports);
})(sax);

var _collections = {};

(function (exports) {
  // https://www.w3.org/TR/SVG11/intro.html#Definitions

  /**
   * @type {Record<string, Set<string>>}
   */
  exports.elemsGroups = {
    animation: new Set([
      "animate",
      "animateColor",
      "animateMotion",
      "animateTransform",
      "set",
    ]),
    descriptive: new Set(["desc", "metadata", "title"]),
    shape: new Set([
      "circle",
      "ellipse",
      "line",
      "path",
      "polygon",
      "polyline",
      "rect",
    ]),
    structural: new Set(["defs", "g", "svg", "symbol", "use"]),
    paintServer: new Set([
      "hatch",
      "linearGradient",
      "meshGradient",
      "pattern",
      "radialGradient",
      "solidColor",
    ]),
    nonRendering: new Set([
      "clipPath",
      "filter",
      "linearGradient",
      "marker",
      "mask",
      "pattern",
      "radialGradient",
      "solidColor",
      "symbol",
    ]),
    container: new Set([
      "a",
      "defs",
      "foreignObject",
      "g",
      "marker",
      "mask",
      "missing-glyph",
      "pattern",
      "svg",
      "switch",
      "symbol",
    ]),
    textContent: new Set([
      "altGlyph",
      "altGlyphDef",
      "altGlyphItem",
      "glyph",
      "glyphRef",
      "text",
      "textPath",
      "tref",
      "tspan",
    ]),
    textContentChild: new Set(["altGlyph", "textPath", "tref", "tspan"]),
    lightSource: new Set([
      "feDiffuseLighting",
      "feDistantLight",
      "fePointLight",
      "feSpecularLighting",
      "feSpotLight",
    ]),
    filterPrimitive: new Set([
      "feBlend",
      "feColorMatrix",
      "feComponentTransfer",
      "feComposite",
      "feConvolveMatrix",
      "feDiffuseLighting",
      "feDisplacementMap",
      "feDropShadow",
      "feFlood",
      "feFuncA",
      "feFuncB",
      "feFuncG",
      "feFuncR",
      "feGaussianBlur",
      "feImage",
      "feMerge",
      "feMergeNode",
      "feMorphology",
      "feOffset",
      "feSpecularLighting",
      "feTile",
      "feTurbulence",
    ]),
  };

  /**
   * Elements where adding or removing whitespace may effect rendering, metadata,
   * or semantic meaning.
   *
   * @see https://developer.mozilla.org/docs/Web/HTML/Element/pre
   */
  exports.textElems = new Set([
    ...exports.elemsGroups.textContent,
    "pre",
    "title",
  ]);

  exports.pathElems = new Set(["glyph", "missing-glyph", "path"]);

  /**
   * @type {Record<string, Set<string>>}
   * @see https://www.w3.org/TR/SVG11/intro.html#Definitions
   */
  exports.attrsGroups = {
    animationAddition: new Set(["additive", "accumulate"]),
    animationAttributeTarget: new Set(["attributeType", "attributeName"]),
    animationEvent: new Set(["onbegin", "onend", "onrepeat", "onload"]),
    animationTiming: new Set([
      "begin",
      "dur",
      "end",
      "fill",
      "max",
      "min",
      "repeatCount",
      "repeatDur",
      "restart",
    ]),
    animationValue: new Set([
      "by",
      "calcMode",
      "from",
      "keySplines",
      "keyTimes",
      "to",
      "values",
    ]),
    conditionalProcessing: new Set([
      "requiredExtensions",
      "requiredFeatures",
      "systemLanguage",
    ]),
    core: new Set(["id", "tabindex", "xml:base", "xml:lang", "xml:space"]),
    graphicalEvent: new Set([
      "onactivate",
      "onclick",
      "onfocusin",
      "onfocusout",
      "onload",
      "onmousedown",
      "onmousemove",
      "onmouseout",
      "onmouseover",
      "onmouseup",
    ]),
    presentation: new Set([
      "alignment-baseline",
      "baseline-shift",
      "clip-path",
      "clip-rule",
      "clip",
      "color-interpolation-filters",
      "color-interpolation",
      "color-profile",
      "color-rendering",
      "color",
      "cursor",
      "direction",
      "display",
      "dominant-baseline",
      "enable-background",
      "fill-opacity",
      "fill-rule",
      "fill",
      "filter",
      "flood-color",
      "flood-opacity",
      "font-family",
      "font-size-adjust",
      "font-size",
      "font-stretch",
      "font-style",
      "font-variant",
      "font-weight",
      "glyph-orientation-horizontal",
      "glyph-orientation-vertical",
      "image-rendering",
      "letter-spacing",
      "lighting-color",
      "marker-end",
      "marker-mid",
      "marker-start",
      "mask",
      "opacity",
      "overflow",
      "paint-order",
      "pointer-events",
      "shape-rendering",
      "stop-color",
      "stop-opacity",
      "stroke-dasharray",
      "stroke-dashoffset",
      "stroke-linecap",
      "stroke-linejoin",
      "stroke-miterlimit",
      "stroke-opacity",
      "stroke-width",
      "stroke",
      "text-anchor",
      "text-decoration",
      "text-overflow",
      "text-rendering",
      "transform-origin",
      "transform",
      "unicode-bidi",
      "vector-effect",
      "visibility",
      "word-spacing",
      "writing-mode",
    ]),
    xlink: new Set([
      "xlink:actuate",
      "xlink:arcrole",
      "xlink:href",
      "xlink:role",
      "xlink:show",
      "xlink:title",
      "xlink:type",
    ]),
    documentEvent: new Set([
      "onabort",
      "onerror",
      "onresize",
      "onscroll",
      "onunload",
      "onzoom",
    ]),
    documentElementEvent: new Set(["oncopy", "oncut", "onpaste"]),
    globalEvent: new Set([
      "oncancel",
      "oncanplay",
      "oncanplaythrough",
      "onchange",
      "onclick",
      "onclose",
      "oncuechange",
      "ondblclick",
      "ondrag",
      "ondragend",
      "ondragenter",
      "ondragleave",
      "ondragover",
      "ondragstart",
      "ondrop",
      "ondurationchange",
      "onemptied",
      "onended",
      "onerror",
      "onfocus",
      "oninput",
      "oninvalid",
      "onkeydown",
      "onkeypress",
      "onkeyup",
      "onload",
      "onloadeddata",
      "onloadedmetadata",
      "onloadstart",
      "onmousedown",
      "onmouseenter",
      "onmouseleave",
      "onmousemove",
      "onmouseout",
      "onmouseover",
      "onmouseup",
      "onmousewheel",
      "onpause",
      "onplay",
      "onplaying",
      "onprogress",
      "onratechange",
      "onreset",
      "onresize",
      "onscroll",
      "onseeked",
      "onseeking",
      "onselect",
      "onshow",
      "onstalled",
      "onsubmit",
      "onsuspend",
      "ontimeupdate",
      "ontoggle",
      "onvolumechange",
      "onwaiting",
    ]),
    filterPrimitive: new Set(["x", "y", "width", "height", "result"]),
    transferFunction: new Set([
      "amplitude",
      "exponent",
      "intercept",
      "offset",
      "slope",
      "tableValues",
      "type",
    ]),
  };

  /**
   * @type {Record<string, Record<string, string>>}
   */
  exports.attrsGroupsDefaults = {
    core: { "xml:space": "default" },
    presentation: {
      clip: "auto",
      "clip-path": "none",
      "clip-rule": "nonzero",
      mask: "none",
      opacity: "1",
      "stop-color": "#000",
      "stop-opacity": "1",
      "fill-opacity": "1",
      "fill-rule": "nonzero",
      fill: "#000",
      stroke: "none",
      "stroke-width": "1",
      "stroke-linecap": "butt",
      "stroke-linejoin": "miter",
      "stroke-miterlimit": "4",
      "stroke-dasharray": "none",
      "stroke-dashoffset": "0",
      "stroke-opacity": "1",
      "paint-order": "normal",
      "vector-effect": "none",
      display: "inline",
      visibility: "visible",
      "marker-start": "none",
      "marker-mid": "none",
      "marker-end": "none",
      "color-interpolation": "sRGB",
      "color-interpolation-filters": "linearRGB",
      "color-rendering": "auto",
      "shape-rendering": "auto",
      "text-rendering": "auto",
      "image-rendering": "auto",
      "font-style": "normal",
      "font-variant": "normal",
      "font-weight": "normal",
      "font-stretch": "normal",
      "font-size": "medium",
      "font-size-adjust": "none",
      kerning: "auto",
      "letter-spacing": "normal",
      "word-spacing": "normal",
      "text-decoration": "none",
      "text-anchor": "start",
      "text-overflow": "clip",
      "writing-mode": "lr-tb",
      "glyph-orientation-vertical": "auto",
      "glyph-orientation-horizontal": "0deg",
      direction: "ltr",
      "unicode-bidi": "normal",
      "dominant-baseline": "auto",
      "alignment-baseline": "baseline",
      "baseline-shift": "baseline",
    },
    transferFunction: {
      slope: "1",
      intercept: "0",
      amplitude: "1",
      exponent: "1",
      offset: "0",
    },
  };

  /**
   * @type {Record<string, {
   *   attrsGroups: Set<string>,
   *   attrs?: Set<string>,
   *   defaults?: Record<string, string>,
   *   contentGroups?: Set<string>,
   *   content?: Set<string>,
   * }>}
   * @see https://www.w3.org/TR/SVG11/eltindex.html
   */
  exports.elems = {
    a: {
      attrsGroups: new Set([
        "conditionalProcessing",
        "core",
        "graphicalEvent",
        "presentation",
        "xlink",
      ]),
      attrs: new Set([
        "class",
        "externalResourcesRequired",
        "style",
        "target",
        "transform",
      ]),
      defaults: {
        target: "_self",
      },
      contentGroups: new Set([
        "animation",
        "descriptive",
        "paintServer",
        "shape",
        "structural",
      ]),
      content: new Set([
        "a",
        "altGlyphDef",
        "clipPath",
        "color-profile",
        "cursor",
        "filter",
        "font-face",
        "font",
        "foreignObject",
        "image",
        "marker",
        "mask",
        "pattern",
        "script",
        "style",
        "switch",
        "text",
        "view",
        // not spec compliant
        "tspan",
      ]),
    },
    altGlyph: {
      attrsGroups: new Set([
        "conditionalProcessing",
        "core",
        "graphicalEvent",
        "presentation",
        "xlink",
      ]),
      attrs: new Set([
        "class",
        "dx",
        "dy",
        "externalResourcesRequired",
        "format",
        "glyphRef",
        "rotate",
        "style",
        "x",
        "y",
      ]),
    },
    altGlyphDef: {
      attrsGroups: new Set(["core"]),
      content: new Set(["glyphRef"]),
    },
    altGlyphItem: {
      attrsGroups: new Set(["core"]),
      content: new Set(["glyphRef", "altGlyphItem"]),
    },
    animate: {
      attrsGroups: new Set([
        "animationAddition",
        "animationAttributeTarget",
        "animationEvent",
        "animationTiming",
        "animationValue",
        "conditionalProcessing",
        "core",
        "presentation",
        "xlink",
      ]),
      attrs: new Set(["externalResourcesRequired"]),
      contentGroups: new Set(["descriptive"]),
    },
    animateColor: {
      attrsGroups: new Set([
        "animationAddition",
        "animationAttributeTarget",
        "animationEvent",
        "animationTiming",
        "animationValue",
        "conditionalProcessing",
        "core",
        "presentation",
        "xlink",
      ]),
      attrs: new Set(["externalResourcesRequired"]),
      contentGroups: new Set(["descriptive"]),
    },
    animateMotion: {
      attrsGroups: new Set([
        "animationAddition",
        "animationEvent",
        "animationTiming",
        "animationValue",
        "conditionalProcessing",
        "core",
        "xlink",
      ]),
      attrs: new Set([
        "externalResourcesRequired",
        "keyPoints",
        "origin",
        "path",
        "rotate",
      ]),
      defaults: {
        rotate: "0",
      },
      contentGroups: new Set(["descriptive"]),
      content: new Set(["mpath"]),
    },
    animateTransform: {
      attrsGroups: new Set([
        "animationAddition",
        "animationAttributeTarget",
        "animationEvent",
        "animationTiming",
        "animationValue",
        "conditionalProcessing",
        "core",
        "xlink",
      ]),
      attrs: new Set(["externalResourcesRequired", "type"]),
      contentGroups: new Set(["descriptive"]),
    },
    circle: {
      attrsGroups: new Set([
        "conditionalProcessing",
        "core",
        "graphicalEvent",
        "presentation",
      ]),
      attrs: new Set([
        "class",
        "cx",
        "cy",
        "externalResourcesRequired",
        "r",
        "style",
        "transform",
      ]),
      defaults: {
        cx: "0",
        cy: "0",
      },
      contentGroups: new Set(["animation", "descriptive"]),
    },
    clipPath: {
      attrsGroups: new Set(["conditionalProcessing", "core", "presentation"]),
      attrs: new Set([
        "class",
        "clipPathUnits",
        "externalResourcesRequired",
        "style",
        "transform",
      ]),
      defaults: {
        clipPathUnits: "userSpaceOnUse",
      },
      contentGroups: new Set(["animation", "descriptive", "shape"]),
      content: new Set(["text", "use"]),
    },
    "color-profile": {
      attrsGroups: new Set(["core", "xlink"]),
      attrs: new Set(["local", "name", "rendering-intent"]),
      defaults: {
        name: "sRGB",
        "rendering-intent": "auto",
      },
      contentGroups: new Set(["descriptive"]),
    },
    cursor: {
      attrsGroups: new Set(["core", "conditionalProcessing", "xlink"]),
      attrs: new Set(["externalResourcesRequired", "x", "y"]),
      defaults: {
        x: "0",
        y: "0",
      },
      contentGroups: new Set(["descriptive"]),
    },
    defs: {
      attrsGroups: new Set([
        "conditionalProcessing",
        "core",
        "graphicalEvent",
        "presentation",
      ]),
      attrs: new Set([
        "class",
        "externalResourcesRequired",
        "style",
        "transform",
      ]),
      contentGroups: new Set([
        "animation",
        "descriptive",
        "paintServer",
        "shape",
        "structural",
      ]),
      content: new Set([
        "a",
        "altGlyphDef",
        "clipPath",
        "color-profile",
        "cursor",
        "filter",
        "font-face",
        "font",
        "foreignObject",
        "image",
        "marker",
        "mask",
        "pattern",
        "script",
        "style",
        "switch",
        "text",
        "view",
      ]),
    },
    desc: {
      attrsGroups: new Set(["core"]),
      attrs: new Set(["class", "style"]),
    },
    ellipse: {
      attrsGroups: new Set([
        "conditionalProcessing",
        "core",
        "graphicalEvent",
        "presentation",
      ]),
      attrs: new Set([
        "class",
        "cx",
        "cy",
        "externalResourcesRequired",
        "rx",
        "ry",
        "style",
        "transform",
      ]),
      defaults: {
        cx: "0",
        cy: "0",
      },
      contentGroups: new Set(["animation", "descriptive"]),
    },
    feBlend: {
      attrsGroups: new Set(["core", "presentation", "filterPrimitive"]),
      attrs: new Set([
        "class",
        "style",
        // TODO: in - 'If no value is provided and this is the first filter primitive,
        // then this filter primitive will use SourceGraphic as its input'
        "in",
        "in2",
        "mode",
      ]),
      defaults: {
        mode: "normal",
      },
      content: new Set(["animate", "set"]),
    },
    feColorMatrix: {
      attrsGroups: new Set(["core", "presentation", "filterPrimitive"]),
      attrs: new Set(["class", "style", "in", "type", "values"]),
      defaults: {
        type: "matrix",
      },
      content: new Set(["animate", "set"]),
    },
    feComponentTransfer: {
      attrsGroups: new Set(["core", "presentation", "filterPrimitive"]),
      attrs: new Set(["class", "style", "in"]),
      content: new Set(["feFuncA", "feFuncB", "feFuncG", "feFuncR"]),
    },
    feComposite: {
      attrsGroups: new Set(["core", "presentation", "filterPrimitive"]),
      attrs: new Set([
        "class",
        "in",
        "in2",
        "k1",
        "k2",
        "k3",
        "k4",
        "operator",
        "style",
      ]),
      defaults: {
        operator: "over",
        k1: "0",
        k2: "0",
        k3: "0",
        k4: "0",
      },
      content: new Set(["animate", "set"]),
    },
    feConvolveMatrix: {
      attrsGroups: new Set(["core", "presentation", "filterPrimitive"]),
      attrs: new Set([
        "class",
        "in",
        "kernelMatrix",
        "order",
        "style",
        // TODO: divisor - 'The default value is the sum of all values in kernelMatrix,
        // with the exception that if the sum is zero, then the divisor is set to 1'
        "bias",
        "divisor",
        // TODO: targetX - 'By default, the convolution matrix is centered in X over each
        // pixel of the input image (i.e., targetX = floor ( orderX / 2 ))'
        "edgeMode",
        "targetX",
        "targetY",
        // TODO: kernelUnitLength - 'The first number is the <dx> value. The second number
        // is the <dy> value. If the <dy> value is not specified, it defaults to the same value as <dx>'
        "kernelUnitLength",
        "preserveAlpha",
      ]),
      defaults: {
        order: "3",
        bias: "0",
        edgeMode: "duplicate",
        preserveAlpha: "false",
      },
      content: new Set(["animate", "set"]),
    },
    feDiffuseLighting: {
      attrsGroups: new Set(["core", "presentation", "filterPrimitive"]),
      attrs: new Set([
        "class",
        "diffuseConstant",
        "in",
        "kernelUnitLength",
        "style",
        "surfaceScale",
      ]),
      defaults: {
        surfaceScale: "1",
        diffuseConstant: "1",
      },
      contentGroups: new Set(["descriptive"]),
      content: new Set([
        // TODO: 'exactly one light source element, in any order'
        "feDistantLight",
        "fePointLight",
        "feSpotLight",
      ]),
    },
    feDisplacementMap: {
      attrsGroups: new Set(["core", "presentation", "filterPrimitive"]),
      attrs: new Set([
        "class",
        "in",
        "in2",
        "scale",
        "style",
        "xChannelSelector",
        "yChannelSelector",
      ]),
      defaults: {
        scale: "0",
        xChannelSelector: "A",
        yChannelSelector: "A",
      },
      content: new Set(["animate", "set"]),
    },
    feDistantLight: {
      attrsGroups: new Set(["core"]),
      attrs: new Set(["azimuth", "elevation"]),
      defaults: {
        azimuth: "0",
        elevation: "0",
      },
      content: new Set(["animate", "set"]),
    },
    feFlood: {
      attrsGroups: new Set(["core", "presentation", "filterPrimitive"]),
      attrs: new Set(["class", "style"]),
      content: new Set(["animate", "animateColor", "set"]),
    },
    feFuncA: {
      attrsGroups: new Set(["core", "transferFunction"]),
      content: new Set(["set", "animate"]),
    },
    feFuncB: {
      attrsGroups: new Set(["core", "transferFunction"]),
      content: new Set(["set", "animate"]),
    },
    feFuncG: {
      attrsGroups: new Set(["core", "transferFunction"]),
      content: new Set(["set", "animate"]),
    },
    feFuncR: {
      attrsGroups: new Set(["core", "transferFunction"]),
      content: new Set(["set", "animate"]),
    },
    feGaussianBlur: {
      attrsGroups: new Set(["core", "presentation", "filterPrimitive"]),
      attrs: new Set(["class", "style", "in", "stdDeviation"]),
      defaults: {
        stdDeviation: "0",
      },
      content: new Set(["set", "animate"]),
    },
    feImage: {
      attrsGroups: new Set([
        "core",
        "presentation",
        "filterPrimitive",
        "xlink",
      ]),
      attrs: new Set([
        "class",
        "externalResourcesRequired",
        "href",
        "preserveAspectRatio",
        "style",
        "xlink:href",
      ]),
      defaults: {
        preserveAspectRatio: "xMidYMid meet",
      },
      content: new Set(["animate", "animateTransform", "set"]),
    },
    feMerge: {
      attrsGroups: new Set(["core", "presentation", "filterPrimitive"]),
      attrs: new Set(["class", "style"]),
      content: new Set(["feMergeNode"]),
    },
    feMergeNode: {
      attrsGroups: new Set(["core"]),
      attrs: new Set(["in"]),
      content: new Set(["animate", "set"]),
    },
    feMorphology: {
      attrsGroups: new Set(["core", "presentation", "filterPrimitive"]),
      attrs: new Set(["class", "style", "in", "operator", "radius"]),
      defaults: {
        operator: "erode",
        radius: "0",
      },
      content: new Set(["animate", "set"]),
    },
    feOffset: {
      attrsGroups: new Set(["core", "presentation", "filterPrimitive"]),
      attrs: new Set(["class", "style", "in", "dx", "dy"]),
      defaults: {
        dx: "0",
        dy: "0",
      },
      content: new Set(["animate", "set"]),
    },
    fePointLight: {
      attrsGroups: new Set(["core"]),
      attrs: new Set(["x", "y", "z"]),
      defaults: {
        x: "0",
        y: "0",
        z: "0",
      },
      content: new Set(["animate", "set"]),
    },
    feSpecularLighting: {
      attrsGroups: new Set(["core", "presentation", "filterPrimitive"]),
      attrs: new Set([
        "class",
        "in",
        "kernelUnitLength",
        "specularConstant",
        "specularExponent",
        "style",
        "surfaceScale",
      ]),
      defaults: {
        surfaceScale: "1",
        specularConstant: "1",
        specularExponent: "1",
      },
      contentGroups: new Set([
        "descriptive",
        // TODO: exactly one 'light source element'
        "lightSource",
      ]),
    },
    feSpotLight: {
      attrsGroups: new Set(["core"]),
      attrs: new Set([
        "limitingConeAngle",
        "pointsAtX",
        "pointsAtY",
        "pointsAtZ",
        "specularExponent",
        "x",
        "y",
        "z",
      ]),
      defaults: {
        x: "0",
        y: "0",
        z: "0",
        pointsAtX: "0",
        pointsAtY: "0",
        pointsAtZ: "0",
        specularExponent: "1",
      },
      content: new Set(["animate", "set"]),
    },
    feTile: {
      attrsGroups: new Set(["core", "presentation", "filterPrimitive"]),
      attrs: new Set(["class", "style", "in"]),
      content: new Set(["animate", "set"]),
    },
    feTurbulence: {
      attrsGroups: new Set(["core", "presentation", "filterPrimitive"]),
      attrs: new Set([
        "baseFrequency",
        "class",
        "numOctaves",
        "seed",
        "stitchTiles",
        "style",
        "type",
      ]),
      defaults: {
        baseFrequency: "0",
        numOctaves: "1",
        seed: "0",
        stitchTiles: "noStitch",
        type: "turbulence",
      },
      content: new Set(["animate", "set"]),
    },
    filter: {
      attrsGroups: new Set(["core", "presentation", "xlink"]),
      attrs: new Set([
        "class",
        "externalResourcesRequired",
        "filterRes",
        "filterUnits",
        "height",
        "href",
        "primitiveUnits",
        "style",
        "width",
        "x",
        "xlink:href",
        "y",
      ]),
      defaults: {
        primitiveUnits: "userSpaceOnUse",
        x: "-10%",
        y: "-10%",
        width: "120%",
        height: "120%",
      },
      contentGroups: new Set(["descriptive", "filterPrimitive"]),
      content: new Set(["animate", "set"]),
    },
    font: {
      attrsGroups: new Set(["core", "presentation"]),
      attrs: new Set([
        "class",
        "externalResourcesRequired",
        "horiz-adv-x",
        "horiz-origin-x",
        "horiz-origin-y",
        "style",
        "vert-adv-y",
        "vert-origin-x",
        "vert-origin-y",
      ]),
      defaults: {
        "horiz-origin-x": "0",
        "horiz-origin-y": "0",
      },
      contentGroups: new Set(["descriptive"]),
      content: new Set([
        "font-face",
        "glyph",
        "hkern",
        "missing-glyph",
        "vkern",
      ]),
    },
    "font-face": {
      attrsGroups: new Set(["core"]),
      attrs: new Set([
        "font-family",
        "font-style",
        "font-variant",
        "font-weight",
        "font-stretch",
        "font-size",
        "unicode-range",
        "units-per-em",
        "panose-1",
        "stemv",
        "stemh",
        "slope",
        "cap-height",
        "x-height",
        "accent-height",
        "ascent",
        "descent",
        "widths",
        "bbox",
        "ideographic",
        "alphabetic",
        "mathematical",
        "hanging",
        "v-ideographic",
        "v-alphabetic",
        "v-mathematical",
        "v-hanging",
        "underline-position",
        "underline-thickness",
        "strikethrough-position",
        "strikethrough-thickness",
        "overline-position",
        "overline-thickness",
      ]),
      defaults: {
        "font-style": "all",
        "font-variant": "normal",
        "font-weight": "all",
        "font-stretch": "normal",
        "unicode-range": "U+0-10FFFF",
        "units-per-em": "1000",
        "panose-1": "0 0 0 0 0 0 0 0 0 0",
        slope: "0",
      },
      contentGroups: new Set(["descriptive"]),
      content: new Set([
        // TODO: "at most one 'font-face-src' element"
        "font-face-src",
      ]),
    },
    // TODO: empty content
    "font-face-format": {
      attrsGroups: new Set(["core"]),
      attrs: new Set(["string"]),
    },
    "font-face-name": {
      attrsGroups: new Set(["core"]),
      attrs: new Set(["name"]),
    },
    "font-face-src": {
      attrsGroups: new Set(["core"]),
      content: new Set(["font-face-name", "font-face-uri"]),
    },
    "font-face-uri": {
      attrsGroups: new Set(["core", "xlink"]),
      attrs: new Set(["href", "xlink:href"]),
      content: new Set(["font-face-format"]),
    },
    foreignObject: {
      attrsGroups: new Set([
        "conditionalProcessing",
        "core",
        "graphicalEvent",
        "presentation",
      ]),
      attrs: new Set([
        "class",
        "externalResourcesRequired",
        "height",
        "style",
        "transform",
        "width",
        "x",
        "y",
      ]),
      defaults: {
        x: "0",
        y: "0",
      },
    },
    g: {
      attrsGroups: new Set([
        "conditionalProcessing",
        "core",
        "graphicalEvent",
        "presentation",
      ]),
      attrs: new Set([
        "class",
        "externalResourcesRequired",
        "style",
        "transform",
      ]),
      contentGroups: new Set([
        "animation",
        "descriptive",
        "paintServer",
        "shape",
        "structural",
      ]),
      content: new Set([
        "a",
        "altGlyphDef",
        "clipPath",
        "color-profile",
        "cursor",
        "filter",
        "font-face",
        "font",
        "foreignObject",
        "image",
        "marker",
        "mask",
        "pattern",
        "script",
        "style",
        "switch",
        "text",
        "view",
      ]),
    },
    glyph: {
      attrsGroups: new Set(["core", "presentation"]),
      attrs: new Set([
        "arabic-form",
        "class",
        "d",
        "glyph-name",
        "horiz-adv-x",
        "lang",
        "orientation",
        "style",
        "unicode",
        "vert-adv-y",
        "vert-origin-x",
        "vert-origin-y",
      ]),
      defaults: {
        "arabic-form": "initial",
      },
      contentGroups: new Set([
        "animation",
        "descriptive",
        "paintServer",
        "shape",
        "structural",
      ]),
      content: new Set([
        "a",
        "altGlyphDef",
        "clipPath",
        "color-profile",
        "cursor",
        "filter",
        "font-face",
        "font",
        "foreignObject",
        "image",
        "marker",
        "mask",
        "pattern",
        "script",
        "style",
        "switch",
        "text",
        "view",
      ]),
    },
    glyphRef: {
      attrsGroups: new Set(["core", "presentation"]),
      attrs: new Set([
        "class",
        "d",
        "horiz-adv-x",
        "style",
        "vert-adv-y",
        "vert-origin-x",
        "vert-origin-y",
      ]),
      contentGroups: new Set([
        "animation",
        "descriptive",
        "paintServer",
        "shape",
        "structural",
      ]),
      content: new Set([
        "a",
        "altGlyphDef",
        "clipPath",
        "color-profile",
        "cursor",
        "filter",
        "font-face",
        "font",
        "foreignObject",
        "image",
        "marker",
        "mask",
        "pattern",
        "script",
        "style",
        "switch",
        "text",
        "view",
      ]),
    },
    hatch: {
      attrsGroups: new Set(["core", "presentation", "xlink"]),
      attrs: new Set([
        "class",
        "hatchContentUnits",
        "hatchUnits",
        "pitch",
        "rotate",
        "style",
        "transform",
        "x",
        "y",
      ]),
      defaults: {
        hatchUnits: "objectBoundingBox",
        hatchContentUnits: "userSpaceOnUse",
        x: "0",
        y: "0",
        pitch: "0",
        rotate: "0",
      },
      contentGroups: new Set(["animation", "descriptive"]),
      content: new Set(["hatchPath"]),
    },
    hatchPath: {
      attrsGroups: new Set(["core", "presentation", "xlink"]),
      attrs: new Set(["class", "style", "d", "offset"]),
      defaults: {
        offset: "0",
      },
      contentGroups: new Set(["animation", "descriptive"]),
    },
    hkern: {
      attrsGroups: new Set(["core"]),
      attrs: new Set(["u1", "g1", "u2", "g2", "k"]),
    },
    image: {
      attrsGroups: new Set([
        "conditionalProcessing",
        "core",
        "graphicalEvent",
        "presentation",
        "xlink",
      ]),
      attrs: new Set([
        "class",
        "externalResourcesRequired",
        "height",
        "href",
        "preserveAspectRatio",
        "style",
        "transform",
        "width",
        "x",
        "xlink:href",
        "y",
      ]),
      defaults: {
        x: "0",
        y: "0",
        preserveAspectRatio: "xMidYMid meet",
      },
      contentGroups: new Set(["animation", "descriptive"]),
    },
    line: {
      attrsGroups: new Set([
        "conditionalProcessing",
        "core",
        "graphicalEvent",
        "presentation",
      ]),
      attrs: new Set([
        "class",
        "externalResourcesRequired",
        "style",
        "transform",
        "x1",
        "x2",
        "y1",
        "y2",
      ]),
      defaults: {
        x1: "0",
        y1: "0",
        x2: "0",
        y2: "0",
      },
      contentGroups: new Set(["animation", "descriptive"]),
    },
    linearGradient: {
      attrsGroups: new Set(["core", "presentation", "xlink"]),
      attrs: new Set([
        "class",
        "externalResourcesRequired",
        "gradientTransform",
        "gradientUnits",
        "href",
        "spreadMethod",
        "style",
        "x1",
        "x2",
        "xlink:href",
        "y1",
        "y2",
      ]),
      defaults: {
        x1: "0",
        y1: "0",
        x2: "100%",
        y2: "0",
        spreadMethod: "pad",
      },
      contentGroups: new Set(["descriptive"]),
      content: new Set(["animate", "animateTransform", "set", "stop"]),
    },
    marker: {
      attrsGroups: new Set(["core", "presentation"]),
      attrs: new Set([
        "class",
        "externalResourcesRequired",
        "markerHeight",
        "markerUnits",
        "markerWidth",
        "orient",
        "preserveAspectRatio",
        "refX",
        "refY",
        "style",
        "viewBox",
      ]),
      defaults: {
        markerUnits: "strokeWidth",
        refX: "0",
        refY: "0",
        markerWidth: "3",
        markerHeight: "3",
      },
      contentGroups: new Set([
        "animation",
        "descriptive",
        "paintServer",
        "shape",
        "structural",
      ]),
      content: new Set([
        "a",
        "altGlyphDef",
        "clipPath",
        "color-profile",
        "cursor",
        "filter",
        "font-face",
        "font",
        "foreignObject",
        "image",
        "marker",
        "mask",
        "pattern",
        "script",
        "style",
        "switch",
        "text",
        "view",
      ]),
    },
    mask: {
      attrsGroups: new Set(["conditionalProcessing", "core", "presentation"]),
      attrs: new Set([
        "class",
        "externalResourcesRequired",
        "height",
        "mask-type",
        "maskContentUnits",
        "maskUnits",
        "style",
        "width",
        "x",
        "y",
      ]),
      defaults: {
        maskUnits: "objectBoundingBox",
        maskContentUnits: "userSpaceOnUse",
        x: "-10%",
        y: "-10%",
        width: "120%",
        height: "120%",
      },
      contentGroups: new Set([
        "animation",
        "descriptive",
        "paintServer",
        "shape",
        "structural",
      ]),
      content: new Set([
        "a",
        "altGlyphDef",
        "clipPath",
        "color-profile",
        "cursor",
        "filter",
        "font-face",
        "font",
        "foreignObject",
        "image",
        "marker",
        "mask",
        "pattern",
        "script",
        "style",
        "switch",
        "text",
        "view",
      ]),
    },
    metadata: {
      attrsGroups: new Set(["core"]),
    },
    "missing-glyph": {
      attrsGroups: new Set(["core", "presentation"]),
      attrs: new Set([
        "class",
        "d",
        "horiz-adv-x",
        "style",
        "vert-adv-y",
        "vert-origin-x",
        "vert-origin-y",
      ]),
      contentGroups: new Set([
        "animation",
        "descriptive",
        "paintServer",
        "shape",
        "structural",
      ]),
      content: new Set([
        "a",
        "altGlyphDef",
        "clipPath",
        "color-profile",
        "cursor",
        "filter",
        "font-face",
        "font",
        "foreignObject",
        "image",
        "marker",
        "mask",
        "pattern",
        "script",
        "style",
        "switch",
        "text",
        "view",
      ]),
    },
    mpath: {
      attrsGroups: new Set(["core", "xlink"]),
      attrs: new Set(["externalResourcesRequired", "href", "xlink:href"]),
      contentGroups: new Set(["descriptive"]),
    },
    path: {
      attrsGroups: new Set([
        "conditionalProcessing",
        "core",
        "graphicalEvent",
        "presentation",
      ]),
      attrs: new Set([
        "class",
        "d",
        "externalResourcesRequired",
        "pathLength",
        "style",
        "transform",
      ]),
      contentGroups: new Set(["animation", "descriptive"]),
    },
    pattern: {
      attrsGroups: new Set([
        "conditionalProcessing",
        "core",
        "presentation",
        "xlink",
      ]),
      attrs: new Set([
        "class",
        "externalResourcesRequired",
        "height",
        "href",
        "patternContentUnits",
        "patternTransform",
        "patternUnits",
        "preserveAspectRatio",
        "style",
        "viewBox",
        "width",
        "x",
        "xlink:href",
        "y",
      ]),
      defaults: {
        patternUnits: "objectBoundingBox",
        patternContentUnits: "userSpaceOnUse",
        x: "0",
        y: "0",
        width: "0",
        height: "0",
        preserveAspectRatio: "xMidYMid meet",
      },
      contentGroups: new Set([
        "animation",
        "descriptive",
        "paintServer",
        "shape",
        "structural",
      ]),
      content: new Set([
        "a",
        "altGlyphDef",
        "clipPath",
        "color-profile",
        "cursor",
        "filter",
        "font-face",
        "font",
        "foreignObject",
        "image",
        "marker",
        "mask",
        "pattern",
        "script",
        "style",
        "switch",
        "text",
        "view",
      ]),
    },
    polygon: {
      attrsGroups: new Set([
        "conditionalProcessing",
        "core",
        "graphicalEvent",
        "presentation",
      ]),
      attrs: new Set([
        "class",
        "externalResourcesRequired",
        "points",
        "style",
        "transform",
      ]),
      contentGroups: new Set(["animation", "descriptive"]),
    },
    polyline: {
      attrsGroups: new Set([
        "conditionalProcessing",
        "core",
        "graphicalEvent",
        "presentation",
      ]),
      attrs: new Set([
        "class",
        "externalResourcesRequired",
        "points",
        "style",
        "transform",
      ]),
      contentGroups: new Set(["animation", "descriptive"]),
    },
    radialGradient: {
      attrsGroups: new Set(["core", "presentation", "xlink"]),
      attrs: new Set([
        "class",
        "cx",
        "cy",
        "externalResourcesRequired",
        "fr",
        "fx",
        "fy",
        "gradientTransform",
        "gradientUnits",
        "href",
        "r",
        "spreadMethod",
        "style",
        "xlink:href",
      ]),
      defaults: {
        gradientUnits: "objectBoundingBox",
        cx: "50%",
        cy: "50%",
        r: "50%",
      },
      contentGroups: new Set(["descriptive"]),
      content: new Set(["animate", "animateTransform", "set", "stop"]),
    },
    meshGradient: {
      attrsGroups: new Set(["core", "presentation", "xlink"]),
      attrs: new Set([
        "class",
        "style",
        "x",
        "y",
        "gradientUnits",
        "transform",
      ]),
      contentGroups: new Set(["descriptive", "paintServer", "animation"]),
      content: new Set(["meshRow"]),
    },
    meshRow: {
      attrsGroups: new Set(["core", "presentation"]),
      attrs: new Set(["class", "style"]),
      contentGroups: new Set(["descriptive"]),
      content: new Set(["meshPatch"]),
    },
    meshPatch: {
      attrsGroups: new Set(["core", "presentation"]),
      attrs: new Set(["class", "style"]),
      contentGroups: new Set(["descriptive"]),
      content: new Set(["stop"]),
    },
    rect: {
      attrsGroups: new Set([
        "conditionalProcessing",
        "core",
        "graphicalEvent",
        "presentation",
      ]),
      attrs: new Set([
        "class",
        "externalResourcesRequired",
        "height",
        "rx",
        "ry",
        "style",
        "transform",
        "width",
        "x",
        "y",
      ]),
      defaults: {
        x: "0",
        y: "0",
      },
      contentGroups: new Set(["animation", "descriptive"]),
    },
    script: {
      attrsGroups: new Set(["core", "xlink"]),
      attrs: new Set([
        "externalResourcesRequired",
        "type",
        "href",
        "xlink:href",
      ]),
    },
    set: {
      attrsGroups: new Set([
        "animation",
        "animationAttributeTarget",
        "animationTiming",
        "conditionalProcessing",
        "core",
        "xlink",
      ]),
      attrs: new Set(["externalResourcesRequired", "to"]),
      contentGroups: new Set(["descriptive"]),
    },
    solidColor: {
      attrsGroups: new Set(["core", "presentation"]),
      attrs: new Set(["class", "style"]),
      contentGroups: new Set(["paintServer"]),
    },
    stop: {
      attrsGroups: new Set(["core", "presentation"]),
      attrs: new Set(["class", "style", "offset", "path"]),
      content: new Set(["animate", "animateColor", "set"]),
    },
    style: {
      attrsGroups: new Set(["core"]),
      attrs: new Set(["type", "media", "title"]),
      defaults: {
        type: "text/css",
      },
    },
    svg: {
      attrsGroups: new Set([
        "conditionalProcessing",
        "core",
        "documentEvent",
        "graphicalEvent",
        "presentation",
      ]),
      attrs: new Set([
        "baseProfile",
        "class",
        "contentScriptType",
        "contentStyleType",
        "height",
        "preserveAspectRatio",
        "style",
        "version",
        "viewBox",
        "width",
        "x",
        "y",
        "zoomAndPan",
      ]),
      defaults: {
        x: "0",
        y: "0",
        width: "100%",
        height: "100%",
        preserveAspectRatio: "xMidYMid meet",
        zoomAndPan: "magnify",
        version: "1.1",
        baseProfile: "none",
        contentScriptType: "application/ecmascript",
        contentStyleType: "text/css",
      },
      contentGroups: new Set([
        "animation",
        "descriptive",
        "paintServer",
        "shape",
        "structural",
      ]),
      content: new Set([
        "a",
        "altGlyphDef",
        "clipPath",
        "color-profile",
        "cursor",
        "filter",
        "font-face",
        "font",
        "foreignObject",
        "image",
        "marker",
        "mask",
        "pattern",
        "script",
        "style",
        "switch",
        "text",
        "view",
      ]),
    },
    switch: {
      attrsGroups: new Set([
        "conditionalProcessing",
        "core",
        "graphicalEvent",
        "presentation",
      ]),
      attrs: new Set([
        "class",
        "externalResourcesRequired",
        "style",
        "transform",
      ]),
      contentGroups: new Set(["animation", "descriptive", "shape"]),
      content: new Set([
        "a",
        "foreignObject",
        "g",
        "image",
        "svg",
        "switch",
        "text",
        "use",
      ]),
    },
    symbol: {
      attrsGroups: new Set(["core", "graphicalEvent", "presentation"]),
      attrs: new Set([
        "class",
        "externalResourcesRequired",
        "preserveAspectRatio",
        "refX",
        "refY",
        "style",
        "viewBox",
      ]),
      defaults: {
        refX: "0",
        refY: "0",
      },
      contentGroups: new Set([
        "animation",
        "descriptive",
        "paintServer",
        "shape",
        "structural",
      ]),
      content: new Set([
        "a",
        "altGlyphDef",
        "clipPath",
        "color-profile",
        "cursor",
        "filter",
        "font-face",
        "font",
        "foreignObject",
        "image",
        "marker",
        "mask",
        "pattern",
        "script",
        "style",
        "switch",
        "text",
        "view",
      ]),
    },
    text: {
      attrsGroups: new Set([
        "conditionalProcessing",
        "core",
        "graphicalEvent",
        "presentation",
      ]),
      attrs: new Set([
        "class",
        "dx",
        "dy",
        "externalResourcesRequired",
        "lengthAdjust",
        "rotate",
        "style",
        "textLength",
        "transform",
        "x",
        "y",
      ]),
      defaults: {
        x: "0",
        y: "0",
        lengthAdjust: "spacing",
      },
      contentGroups: new Set(["animation", "descriptive", "textContentChild"]),
      content: new Set(["a"]),
    },
    textPath: {
      attrsGroups: new Set([
        "conditionalProcessing",
        "core",
        "graphicalEvent",
        "presentation",
        "xlink",
      ]),
      attrs: new Set([
        "class",
        "d",
        "externalResourcesRequired",
        "href",
        "method",
        "spacing",
        "startOffset",
        "style",
        "xlink:href",
      ]),
      defaults: {
        startOffset: "0",
        method: "align",
        spacing: "exact",
      },
      contentGroups: new Set(["descriptive"]),
      content: new Set([
        "a",
        "altGlyph",
        "animate",
        "animateColor",
        "set",
        "tref",
        "tspan",
      ]),
    },
    title: {
      attrsGroups: new Set(["core"]),
      attrs: new Set(["class", "style"]),
    },
    tref: {
      attrsGroups: new Set([
        "conditionalProcessing",
        "core",
        "graphicalEvent",
        "presentation",
        "xlink",
      ]),
      attrs: new Set([
        "class",
        "externalResourcesRequired",
        "href",
        "style",
        "xlink:href",
      ]),
      contentGroups: new Set(["descriptive"]),
      content: new Set(["animate", "animateColor", "set"]),
    },
    tspan: {
      attrsGroups: new Set([
        "conditionalProcessing",
        "core",
        "graphicalEvent",
        "presentation",
      ]),
      attrs: new Set([
        "class",
        "dx",
        "dy",
        "externalResourcesRequired",
        "lengthAdjust",
        "rotate",
        "style",
        "textLength",
        "x",
        "y",
      ]),
      contentGroups: new Set(["descriptive"]),
      content: new Set([
        "a",
        "altGlyph",
        "animate",
        "animateColor",
        "set",
        "tref",
        "tspan",
      ]),
    },
    use: {
      attrsGroups: new Set([
        "conditionalProcessing",
        "core",
        "graphicalEvent",
        "presentation",
        "xlink",
      ]),
      attrs: new Set([
        "class",
        "externalResourcesRequired",
        "height",
        "href",
        "style",
        "transform",
        "width",
        "x",
        "xlink:href",
        "y",
      ]),
      defaults: {
        x: "0",
        y: "0",
      },
      contentGroups: new Set(["animation", "descriptive"]),
    },
    view: {
      attrsGroups: new Set(["core"]),
      attrs: new Set([
        "externalResourcesRequired",
        "preserveAspectRatio",
        "viewBox",
        "viewTarget",
        "zoomAndPan",
      ]),
      contentGroups: new Set(["descriptive"]),
    },
    vkern: {
      attrsGroups: new Set(["core"]),
      attrs: new Set(["u1", "g1", "u2", "g2", "k"]),
    },
  };

  // https://wiki.inkscape.org/wiki/index.php/Inkscape-specific_XML_attributes
  exports.editorNamespaces = new Set([
    "http://creativecommons.org/ns#",
    "http://inkscape.sourceforge.net/DTD/sodipodi-0.dtd",
    "http://ns.adobe.com/AdobeIllustrator/10.0/",
    "http://ns.adobe.com/AdobeSVGViewerExtensions/3.0/",
    "http://ns.adobe.com/Extensibility/1.0/",
    "http://ns.adobe.com/Flows/1.0/",
    "http://ns.adobe.com/GenericCustomNamespace/1.0/",
    "http://ns.adobe.com/Graphs/1.0/",
    "http://ns.adobe.com/ImageReplacement/1.0/",
    "http://ns.adobe.com/SaveForWeb/1.0/",
    "http://ns.adobe.com/Variables/1.0/",
    "http://ns.adobe.com/XPath/1.0/",
    "http://purl.org/dc/elements/1.1/",
    "http://schemas.microsoft.com/visio/2003/SVGExtensions/",
    "http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd",
    "http://taptrix.com/vectorillustrator/svg_extensions",
    "http://www.bohemiancoding.com/sketch/ns",
    "http://www.figma.com/figma/ns",
    "http://www.inkscape.org/namespaces/inkscape",
    "http://www.serif.com/",
    "http://www.vector.evaxdesign.sk",
    "http://www.w3.org/1999/02/22-rdf-syntax-ns#",
  ]);

  /**
   * @see https://www.w3.org/TR/SVG11/linking.html#processingIRI
   */
  exports.referencesProps = new Set([
    "clip-path",
    "color-profile",
    "fill",
    "filter",
    "marker-end",
    "marker-mid",
    "marker-start",
    "mask",
    "stroke",
    "style",
  ]);

  /**
   * @see https://www.w3.org/TR/SVG11/propidx.html
   */
  exports.inheritableAttrs = new Set([
    "clip-rule",
    "color-interpolation-filters",
    "color-interpolation",
    "color-profile",
    "color-rendering",
    "color",
    "cursor",
    "direction",
    "dominant-baseline",
    "fill-opacity",
    "fill-rule",
    "fill",
    "font-family",
    "font-size-adjust",
    "font-size",
    "font-stretch",
    "font-style",
    "font-variant",
    "font-weight",
    "font",
    "glyph-orientation-horizontal",
    "glyph-orientation-vertical",
    "image-rendering",
    "letter-spacing",
    "marker-end",
    "marker-mid",
    "marker-start",
    "marker",
    "paint-order",
    "pointer-events",
    "shape-rendering",
    "stroke-dasharray",
    "stroke-dashoffset",
    "stroke-linecap",
    "stroke-linejoin",
    "stroke-miterlimit",
    "stroke-opacity",
    "stroke-width",
    "stroke",
    "text-anchor",
    "text-rendering",
    "transform",
    "visibility",
    "word-spacing",
    "writing-mode",
  ]);

  exports.presentationNonInheritableGroupAttrs = new Set([
    "clip-path",
    "display",
    "filter",
    "mask",
    "opacity",
    "text-decoration",
    "transform",
    "unicode-bidi",
  ]);

  /**
   * https://www.w3.org/TR/SVG11/single-page.html#types-ColorKeywords
   *
   * @type {Record<string, string>}
   */
  exports.colorsNames = {
    aliceblue: "#f0f8ff",
    antiquewhite: "#faebd7",
    aqua: "#0ff",
    aquamarine: "#7fffd4",
    azure: "#f0ffff",
    beige: "#f5f5dc",
    bisque: "#ffe4c4",
    black: "#000",
    blanchedalmond: "#ffebcd",
    blue: "#00f",
    blueviolet: "#8a2be2",
    brown: "#a52a2a",
    burlywood: "#deb887",
    cadetblue: "#5f9ea0",
    chartreuse: "#7fff00",
    chocolate: "#d2691e",
    coral: "#ff7f50",
    cornflowerblue: "#6495ed",
    cornsilk: "#fff8dc",
    crimson: "#dc143c",
    cyan: "#0ff",
    darkblue: "#00008b",
    darkcyan: "#008b8b",
    darkgoldenrod: "#b8860b",
    darkgray: "#a9a9a9",
    darkgreen: "#006400",
    darkgrey: "#a9a9a9",
    darkkhaki: "#bdb76b",
    darkmagenta: "#8b008b",
    darkolivegreen: "#556b2f",
    darkorange: "#ff8c00",
    darkorchid: "#9932cc",
    darkred: "#8b0000",
    darksalmon: "#e9967a",
    darkseagreen: "#8fbc8f",
    darkslateblue: "#483d8b",
    darkslategray: "#2f4f4f",
    darkslategrey: "#2f4f4f",
    darkturquoise: "#00ced1",
    darkviolet: "#9400d3",
    deeppink: "#ff1493",
    deepskyblue: "#00bfff",
    dimgray: "#696969",
    dimgrey: "#696969",
    dodgerblue: "#1e90ff",
    firebrick: "#b22222",
    floralwhite: "#fffaf0",
    forestgreen: "#228b22",
    fuchsia: "#f0f",
    gainsboro: "#dcdcdc",
    ghostwhite: "#f8f8ff",
    gold: "#ffd700",
    goldenrod: "#daa520",
    gray: "#808080",
    green: "#008000",
    greenyellow: "#adff2f",
    grey: "#808080",
    honeydew: "#f0fff0",
    hotpink: "#ff69b4",
    indianred: "#cd5c5c",
    indigo: "#4b0082",
    ivory: "#fffff0",
    khaki: "#f0e68c",
    lavender: "#e6e6fa",
    lavenderblush: "#fff0f5",
    lawngreen: "#7cfc00",
    lemonchiffon: "#fffacd",
    lightblue: "#add8e6",
    lightcoral: "#f08080",
    lightcyan: "#e0ffff",
    lightgoldenrodyellow: "#fafad2",
    lightgray: "#d3d3d3",
    lightgreen: "#90ee90",
    lightgrey: "#d3d3d3",
    lightpink: "#ffb6c1",
    lightsalmon: "#ffa07a",
    lightseagreen: "#20b2aa",
    lightskyblue: "#87cefa",
    lightslategray: "#789",
    lightslategrey: "#789",
    lightsteelblue: "#b0c4de",
    lightyellow: "#ffffe0",
    lime: "#0f0",
    limegreen: "#32cd32",
    linen: "#faf0e6",
    magenta: "#f0f",
    maroon: "#800000",
    mediumaquamarine: "#66cdaa",
    mediumblue: "#0000cd",
    mediumorchid: "#ba55d3",
    mediumpurple: "#9370db",
    mediumseagreen: "#3cb371",
    mediumslateblue: "#7b68ee",
    mediumspringgreen: "#00fa9a",
    mediumturquoise: "#48d1cc",
    mediumvioletred: "#c71585",
    midnightblue: "#191970",
    mintcream: "#f5fffa",
    mistyrose: "#ffe4e1",
    moccasin: "#ffe4b5",
    navajowhite: "#ffdead",
    navy: "#000080",
    oldlace: "#fdf5e6",
    olive: "#808000",
    olivedrab: "#6b8e23",
    orange: "#ffa500",
    orangered: "#ff4500",
    orchid: "#da70d6",
    palegoldenrod: "#eee8aa",
    palegreen: "#98fb98",
    paleturquoise: "#afeeee",
    palevioletred: "#db7093",
    papayawhip: "#ffefd5",
    peachpuff: "#ffdab9",
    peru: "#cd853f",
    pink: "#ffc0cb",
    plum: "#dda0dd",
    powderblue: "#b0e0e6",
    purple: "#800080",
    rebeccapurple: "#639",
    red: "#f00",
    rosybrown: "#bc8f8f",
    royalblue: "#4169e1",
    saddlebrown: "#8b4513",
    salmon: "#fa8072",
    sandybrown: "#f4a460",
    seagreen: "#2e8b57",
    seashell: "#fff5ee",
    sienna: "#a0522d",
    silver: "#c0c0c0",
    skyblue: "#87ceeb",
    slateblue: "#6a5acd",
    slategray: "#708090",
    slategrey: "#708090",
    snow: "#fffafa",
    springgreen: "#00ff7f",
    steelblue: "#4682b4",
    tan: "#d2b48c",
    teal: "#008080",
    thistle: "#d8bfd8",
    tomato: "#ff6347",
    turquoise: "#40e0d0",
    violet: "#ee82ee",
    wheat: "#f5deb3",
    white: "#fff",
    whitesmoke: "#f5f5f5",
    yellow: "#ff0",
    yellowgreen: "#9acd32",
  };

  /**
   * @type {Record<string, string>}
   */
  exports.colorsShortNames = {
    "#f0ffff": "azure",
    "#f5f5dc": "beige",
    "#ffe4c4": "bisque",
    "#a52a2a": "brown",
    "#ff7f50": "coral",
    "#ffd700": "gold",
    "#808080": "gray",
    "#008000": "green",
    "#4b0082": "indigo",
    "#fffff0": "ivory",
    "#f0e68c": "khaki",
    "#faf0e6": "linen",
    "#800000": "maroon",
    "#000080": "navy",
    "#808000": "olive",
    "#ffa500": "orange",
    "#da70d6": "orchid",
    "#cd853f": "peru",
    "#ffc0cb": "pink",
    "#dda0dd": "plum",
    "#800080": "purple",
    "#f00": "red",
    "#ff0000": "red",
    "#fa8072": "salmon",
    "#a0522d": "sienna",
    "#c0c0c0": "silver",
    "#fffafa": "snow",
    "#d2b48c": "tan",
    "#008080": "teal",
    "#ff6347": "tomato",
    "#ee82ee": "violet",
    "#f5deb3": "wheat",
  };

  /**
   * @see https://www.w3.org/TR/SVG11/single-page.html#types-DataTypeColor
   */
  exports.colorsProps = new Set([
    "color",
    "fill",
    "flood-color",
    "lighting-color",
    "stop-color",
    "stroke",
  ]);

  /** @see https://developer.mozilla.org/docs/Web/CSS/Pseudo-classes */
  exports.pseudoClasses = {
    displayState: new Set(["fullscreen", "modal", "picture-in-picture"]),
    input: new Set([
      "autofill",
      "blank",
      "checked",
      "default",
      "disabled",
      "enabled",
      "in-range",
      "indetermined",
      "invalid",
      "optional",
      "out-of-range",
      "placeholder-shown",
      "read-only",
      "read-write",
      "required",
      "user-invalid",
      "valid",
    ]),
    linguistic: new Set(["dir", "lang"]),
    location: new Set([
      "any-link",
      "link",
      "local-link",
      "scope",
      "target-within",
      "target",
      "visited",
    ]),
    resourceState: new Set(["playing", "paused"]),
    timeDimensional: new Set(["current", "past", "future"]),
    treeStructural: new Set([
      "empty",
      "first-child",
      "first-of-type",
      "last-child",
      "last-of-type",
      "nth-child",
      "nth-last-child",
      "nth-last-of-type",
      "nth-of-type",
      "only-child",
      "only-of-type",
      "root",
    ]),
    userAction: new Set([
      "active",
      "focus-visible",
      "focus-within",
      "focus",
      "hover",
    ]),
    functional: new Set(["is", "not", "where", "has"]),
  };
})(_collections);

/**
 * @typedef {import('./types').XastNode} XastNode
 * @typedef {import('./types').XastInstruction} XastInstruction
 * @typedef {import('./types').XastDoctype} XastDoctype
 * @typedef {import('./types').XastComment} XastComment
 * @typedef {import('./types').XastRoot} XastRoot
 * @typedef {import('./types').XastElement} XastElement
 * @typedef {import('./types').XastCdata} XastCdata
 * @typedef {import('./types').XastText} XastText
 * @typedef {import('./types').XastParent} XastParent
 * @typedef {import('./types').XastChild} XastChild
 */

// @ts-ignore sax will be replaced with something else later
const SAX = sax;
const { textElems: textElems$1 } = _collections;

class SvgoParserError extends Error {
  /**
   * @param message {string}
   * @param line {number}
   * @param column {number}
   * @param source {string}
   * @param file {void | string}
   */
  constructor(message, line, column, source, file) {
    super(message);
    this.name = "SvgoParserError";
    this.message = `${file || "<input>"}:${line}:${column}: ${message}`;
    this.reason = message;
    this.line = line;
    this.column = column;
    this.source = source;
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, SvgoParserError);
    }
  }
  toString() {
    const lines = this.source.split(/\r?\n/);
    const startLine = Math.max(this.line - 3, 0);
    const endLine = Math.min(this.line + 2, lines.length);
    const lineNumberWidth = String(endLine).length;
    const startColumn = Math.max(this.column - 54, 0);
    const endColumn = Math.max(this.column + 20, 80);
    const code = lines
      .slice(startLine, endLine)
      .map((line, index) => {
        const lineSlice = line.slice(startColumn, endColumn);
        let ellipsisPrefix = "";
        let ellipsisSuffix = "";
        if (startColumn !== 0) {
          ellipsisPrefix = startColumn > line.length - 1 ? " " : "";
        }
        if (endColumn < line.length - 1) {
          ellipsisSuffix = "";
        }
        const number = startLine + 1 + index;
        const gutter = ` ${number.toString().padStart(lineNumberWidth)} | `;
        if (number === this.line) {
          const gutterSpacing = gutter.replace(/[^|]/g, " ");
          const lineSpacing = (
            ellipsisPrefix + line.slice(startColumn, this.column - 1)
          ).replace(/[^\t]/g, " ");
          const spacing = gutterSpacing + lineSpacing;
          return `>${gutter}${ellipsisPrefix}${lineSlice}${ellipsisSuffix}\n ${spacing}^`;
        }
        return ` ${gutter}${ellipsisPrefix}${lineSlice}${ellipsisSuffix}`;
      })
      .join("\n");
    return `${this.name}: ${this.message}\n\n${code}\n`;
  }
}

const entityDeclaration = /<!ENTITY\s+(\S+)\s+(?:'([^']+)'|"([^"]+)")\s*>/g;

const config$4 = {
  strict: true,
  trim: false,
  normalize: false,
  lowercase: true,
  xmlns: true,
  position: true,
};

/**
 * Convert SVG (XML) string to SVG-as-JS object.
 *
 * @type {(data: string, from?: string) => XastRoot}
 */
const parseSvg$1 = (data, from) => {
  const sax = SAX.parser(config$4.strict, config$4);
  /**
   * @type {XastRoot}
   */
  const root = { type: "root", children: [] };
  /**
   * @type {XastParent}
   */
  let current = root;
  /**
   * @type {XastParent[]}
   */
  const stack = [root];

  /**
   * @type {(node: XastChild) => void}
   */
  const pushToContent = (node) => {
    // TODO remove legacy parentNode in v4
    Object.defineProperty(node, "parentNode", {
      writable: true,
      value: current,
    });
    current.children.push(node);
  };

  /**
   * @type {(doctype: string) => void}
   */
  sax.ondoctype = (doctype) => {
    /**
     * @type {XastDoctype}
     */
    const node = {
      type: "doctype",
      // TODO parse doctype for name, public and system to match xast
      name: "svg",
      data: {
        doctype,
      },
    };
    pushToContent(node);
    const subsetStart = doctype.indexOf("[");
    if (subsetStart >= 0) {
      entityDeclaration.lastIndex = subsetStart;
      let entityMatch = entityDeclaration.exec(data);
      while (entityMatch != null) {
        sax.ENTITIES[entityMatch[1]] = entityMatch[2] || entityMatch[3];
        entityMatch = entityDeclaration.exec(data);
      }
    }
  };

  /**
   * @type {(data: { name: string, body: string }) => void}
   */
  sax.onprocessinginstruction = (data) => {
    /**
     * @type {XastInstruction}
     */
    const node = {
      type: "instruction",
      name: data.name,
      value: data.body,
    };
    pushToContent(node);
  };

  /**
   * @type {(comment: string) => void}
   */
  sax.oncomment = (comment) => {
    /**
     * @type {XastComment}
     */
    const node = {
      type: "comment",
      value: comment.trim(),
    };
    pushToContent(node);
  };

  /**
   * @type {(cdata: string) => void}
   */
  sax.oncdata = (cdata) => {
    /**
     * @type {XastCdata}
     */
    const node = {
      type: "cdata",
      value: cdata,
    };
    pushToContent(node);
  };

  /**
   * @type {(data: { name: string, attributes: Record<string, { value: string }>}) => void}
   */
  sax.onopentag = (data) => {
    /**
     * @type {XastElement}
     */
    let element = {
      type: "element",
      name: data.name,
      attributes: {},
      children: [],
    };
    for (const [name, attr] of Object.entries(data.attributes)) {
      element.attributes[name] = attr.value;
    }
    pushToContent(element);
    current = element;
    stack.push(element);
  };

  /**
   * @type {(text: string) => void}
   */
  sax.ontext = (text) => {
    if (current.type === "element") {
      // prevent trimming of meaningful whitespace inside textual tags
      if (textElems$1.has(current.name)) {
        /**
         * @type {XastText}
         */
        const node = {
          type: "text",
          value: text,
        };
        pushToContent(node);
      } else if (/\S/.test(text)) {
        /**
         * @type {XastText}
         */
        const node = {
          type: "text",
          value: text.trim(),
        };
        pushToContent(node);
      }
    }
  };

  sax.onclosetag = () => {
    stack.pop();
    current = stack[stack.length - 1];
  };

  /**
   * @type {(e: any) => void}
   */
  sax.onerror = (e) => {
    const error = new SvgoParserError(
      e.reason,
      e.line + 1,
      e.column,
      data,
      from,
    );
    if (e.message.indexOf("Unexpected end") === -1) {
      throw error;
    }
  };

  sax.write(data).close();
  return root;
};
parser$4.parseSvg = parseSvg$1;

var stringifier = {};

/**
 * @typedef {import('./types').XastParent} XastParent
 * @typedef {import('./types').XastRoot} XastRoot
 * @typedef {import('./types').XastElement} XastElement
 * @typedef {import('./types').XastInstruction} XastInstruction
 * @typedef {import('./types').XastDoctype} XastDoctype
 * @typedef {import('./types').XastText} XastText
 * @typedef {import('./types').XastCdata} XastCdata
 * @typedef {import('./types').XastComment} XastComment
 * @typedef {import('./types').StringifyOptions} StringifyOptions
 */

const { textElems } = _collections;

/**
 * @typedef {{
 *   indent: string,
 *   textContext: ?XastElement,
 *   indentLevel: number,
 * }} State
 */

/**
 * @typedef {Required<StringifyOptions>} Options
 */

/**
 * @type {(char: string) => string}
 */
const encodeEntity = (char) => {
  return entities[char];
};

/** @type {Options} */
const defaults = {
  doctypeStart: "<!DOCTYPE",
  doctypeEnd: ">",
  procInstStart: "<?",
  procInstEnd: "?>",
  tagOpenStart: "<",
  tagOpenEnd: ">",
  tagCloseStart: "</",
  tagCloseEnd: ">",
  tagShortStart: "<",
  tagShortEnd: "/>",
  attrStart: '="',
  attrEnd: '"',
  commentStart: "<!--",
  commentEnd: "-->",
  cdataStart: "<![CDATA[",
  cdataEnd: "]]>",
  textStart: "",
  textEnd: "",
  indent: 4,
  regEntities: /[&'"<>]/g,
  regValEntities: /[&"<>]/g,
  encodeEntity,
  pretty: false,
  useShortTags: true,
  eol: "lf",
  finalNewline: false,
};

/** @type {Record<string, string>} */
const entities = {
  "&": "&amp;",
  "'": "&apos;",
  '"': "&quot;",
  ">": "&gt;",
  "<": "&lt;",
};

/**
 * convert XAST to SVG string
 *
 * @type {(data: XastRoot, config: StringifyOptions) => string}
 */
const stringifySvg$1 = (data, userOptions = {}) => {
  /**
   * @type {Options}
   */
  const config = { ...defaults, ...userOptions };
  const indent = config.indent;
  let newIndent = "    ";
  if (typeof indent === "number" && Number.isNaN(indent) === false) {
    newIndent = indent < 0 ? "\t" : " ".repeat(indent);
  } else if (typeof indent === "string") {
    newIndent = indent;
  }
  /**
   * @type {State}
   */
  const state = {
    indent: newIndent,
    textContext: null,
    indentLevel: 0,
  };
  const eol = config.eol === "crlf" ? "\r\n" : "\n";
  if (config.pretty) {
    config.doctypeEnd += eol;
    config.procInstEnd += eol;
    config.commentEnd += eol;
    config.cdataEnd += eol;
    config.tagShortEnd += eol;
    config.tagOpenEnd += eol;
    config.tagCloseEnd += eol;
    config.textEnd += eol;
  }
  let svg = stringifyNode(data, config, state);
  if (config.finalNewline && svg.length > 0 && !svg.endsWith("\n")) {
    svg += eol;
  }
  return svg;
};
stringifier.stringifySvg = stringifySvg$1;

/**
 * @type {(node: XastParent, config: Options, state: State) => string}
 */
const stringifyNode = (data, config, state) => {
  let svg = "";
  state.indentLevel += 1;
  for (const item of data.children) {
    if (item.type === "element") {
      svg += stringifyElement(item, config, state);
    }
    if (item.type === "text") {
      svg += stringifyText(item, config, state);
    }
    if (item.type === "doctype") {
      svg += stringifyDoctype(item, config);
    }
    if (item.type === "instruction") {
      svg += stringifyInstruction(item, config);
    }
    if (item.type === "comment") {
      svg += stringifyComment(item, config);
    }
    if (item.type === "cdata") {
      svg += stringifyCdata(item, config, state);
    }
  }
  state.indentLevel -= 1;
  return svg;
};

/**
 * create indent string in accordance with the current node level.
 *
 * @type {(config: Options, state: State) => string}
 */
const createIndent = (config, state) => {
  let indent = "";
  if (config.pretty && state.textContext == null) {
    indent = state.indent.repeat(state.indentLevel - 1);
  }
  return indent;
};

/**
 * @type {(node: XastDoctype, config: Options) => string}
 */
const stringifyDoctype = (node, config) => {
  return config.doctypeStart + node.data.doctype + config.doctypeEnd;
};

/**
 * @type {(node: XastInstruction, config: Options) => string}
 */
const stringifyInstruction = (node, config) => {
  return (
    config.procInstStart + node.name + " " + node.value + config.procInstEnd
  );
};

/**
 * @type {(node: XastComment, config: Options) => string}
 */
const stringifyComment = (node, config) => {
  return config.commentStart + node.value + config.commentEnd;
};

/**
 * @type {(node: XastCdata, config: Options, state: State) => string}
 */
const stringifyCdata = (node, config, state) => {
  return (
    createIndent(config, state) +
    config.cdataStart +
    node.value +
    config.cdataEnd
  );
};

/**
 * @type {(node: XastElement, config: Options, state: State) => string}
 */
const stringifyElement = (node, config, state) => {
  // empty element and short tag
  if (node.children.length === 0) {
    if (config.useShortTags) {
      return (
        createIndent(config, state) +
        config.tagShortStart +
        node.name +
        stringifyAttributes(node, config) +
        config.tagShortEnd
      );
    } else {
      return (
        createIndent(config, state) +
        config.tagShortStart +
        node.name +
        stringifyAttributes(node, config) +
        config.tagOpenEnd +
        config.tagCloseStart +
        node.name +
        config.tagCloseEnd
      );
    }
    // non-empty element
  } else {
    let tagOpenStart = config.tagOpenStart;
    let tagOpenEnd = config.tagOpenEnd;
    let tagCloseStart = config.tagCloseStart;
    let tagCloseEnd = config.tagCloseEnd;
    let openIndent = createIndent(config, state);
    let closeIndent = createIndent(config, state);

    if (state.textContext) {
      tagOpenStart = defaults.tagOpenStart;
      tagOpenEnd = defaults.tagOpenEnd;
      tagCloseStart = defaults.tagCloseStart;
      tagCloseEnd = defaults.tagCloseEnd;
      openIndent = "";
    } else if (textElems.has(node.name)) {
      tagOpenEnd = defaults.tagOpenEnd;
      tagCloseStart = defaults.tagCloseStart;
      closeIndent = "";
      state.textContext = node;
    }

    const children = stringifyNode(node, config, state);

    if (state.textContext === node) {
      state.textContext = null;
    }

    return (
      openIndent +
      tagOpenStart +
      node.name +
      stringifyAttributes(node, config) +
      tagOpenEnd +
      children +
      closeIndent +
      tagCloseStart +
      node.name +
      tagCloseEnd
    );
  }
};

/**
 * @type {(node: XastElement, config: Options) => string}
 */
const stringifyAttributes = (node, config) => {
  let attrs = "";
  for (const [name, value] of Object.entries(node.attributes)) {
    // TODO remove attributes without values support in v3
    if (value !== undefined) {
      const encodedValue = value
        .toString()
        .replace(config.regValEntities, config.encodeEntity);
      attrs += " " + name + config.attrStart + encodedValue + config.attrEnd;
    } else {
      attrs += " " + name;
    }
  }
  return attrs;
};

/**
 * @type {(node: XastText, config: Options, state: State) => string}
 */
const stringifyText = (node, config, state) => {
  return (
    createIndent(config, state) +
    config.textStart +
    node.value.replace(config.regEntities, config.encodeEntity) +
    (state.textContext ? "" : config.textEnd)
  );
};

var builtin$1 = {};

var plugins = {};

var xast = {};

var lib = {};

var compile$1 = {};

const require$$1$2 = /*@__PURE__*/ getAugmentedNamespace(es);

var sort = {};

Object.defineProperty(sort, "__esModule", { value: true });
sort.isTraversal = void 0;
var css_what_1$2 = require$$1$2;
var procedure = new Map([
  [css_what_1$2.SelectorType.Universal, 50],
  [css_what_1$2.SelectorType.Tag, 30],
  [css_what_1$2.SelectorType.Attribute, 1],
  [css_what_1$2.SelectorType.Pseudo, 0],
]);
function isTraversal(token) {
  return !procedure.has(token.type);
}
sort.isTraversal = isTraversal;
var attributes$1 = new Map([
  [css_what_1$2.AttributeAction.Exists, 10],
  [css_what_1$2.AttributeAction.Equals, 8],
  [css_what_1$2.AttributeAction.Not, 7],
  [css_what_1$2.AttributeAction.Start, 6],
  [css_what_1$2.AttributeAction.End, 6],
  [css_what_1$2.AttributeAction.Any, 5],
]);
/**
 * Sort the parts of the passed selector,
 * as there is potential for optimization
 * (some types of selectors are faster than others)
 *
 * @param arr Selector to sort
 */
function sortByProcedure(arr) {
  var procs = arr.map(getProcedure);
  for (var i = 1; i < arr.length; i++) {
    var procNew = procs[i];
    if (procNew < 0) continue;
    for (var j = i - 1; j >= 0 && procNew < procs[j]; j--) {
      var token = arr[j + 1];
      arr[j + 1] = arr[j];
      arr[j] = token;
      procs[j + 1] = procs[j];
      procs[j] = procNew;
    }
  }
}
sort.default = sortByProcedure;
function getProcedure(token) {
  var _a, _b;
  var proc =
    (_a = procedure.get(token.type)) !== null && _a !== void 0 ? _a : -1;
  if (token.type === css_what_1$2.SelectorType.Attribute) {
    proc =
      (_b = attributes$1.get(token.action)) !== null && _b !== void 0 ? _b : 4;
    if (
      token.action === css_what_1$2.AttributeAction.Equals &&
      token.name === "id"
    ) {
      // Prefer ID selectors (eg. #ID)
      proc = 9;
    }
    if (token.ignoreCase) {
      /*
       * IgnoreCase adds some overhead, prefer "normal" token
       * this is a binary operation, to ensure it's still an int
       */
      proc >>= 1;
    }
  } else if (token.type === css_what_1$2.SelectorType.Pseudo) {
    if (!token.data) {
      proc = 3;
    } else if (token.name === "has" || token.name === "contains") {
      proc = 0; // Expensive in any case
    } else if (Array.isArray(token.data)) {
      // Eg. :matches, :not
      proc = Math.min.apply(
        Math,
        token.data.map(function (d) {
          return Math.min.apply(Math, d.map(getProcedure));
        }),
      );
      // If we have traversals, try to avoid executing this selector
      if (proc < 0) {
        proc = 0;
      }
    } else {
      proc = 2;
    }
  }
  return proc;
}

var general = {};

var attributes = {};

var __importDefault$1 =
  (commonjsGlobal && commonjsGlobal.__importDefault) ||
  function (mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
Object.defineProperty(attributes, "__esModule", { value: true });
attributes.attributeRules = void 0;
var boolbase_1$1 = __importDefault$1(boolbase);
/**
 * All reserved characters in a regex, used for escaping.
 *
 * Taken from XRegExp, (c) 2007-2020 Steven Levithan under the MIT license
 * https://github.com/slevithan/xregexp/blob/95eeebeb8fac8754d54eafe2b4743661ac1cf028/src/xregexp.js#L794
 */
var reChars = /[-[\]{}()*+?.,\\^$|#\s]/g;
function escapeRegex(value) {
  return value.replace(reChars, "\\$&");
}
/**
 * Attributes that are case-insensitive in HTML.
 *
 * @private
 * @see https://html.spec.whatwg.org/multipage/semantics-other.html#case-sensitivity-of-selectors
 */
var caseInsensitiveAttributes = new Set([
  "accept",
  "accept-charset",
  "align",
  "alink",
  "axis",
  "bgcolor",
  "charset",
  "checked",
  "clear",
  "codetype",
  "color",
  "compact",
  "declare",
  "defer",
  "dir",
  "direction",
  "disabled",
  "enctype",
  "face",
  "frame",
  "hreflang",
  "http-equiv",
  "lang",
  "language",
  "link",
  "media",
  "method",
  "multiple",
  "nohref",
  "noresize",
  "noshade",
  "nowrap",
  "readonly",
  "rel",
  "rev",
  "rules",
  "scope",
  "scrolling",
  "selected",
  "shape",
  "target",
  "text",
  "type",
  "valign",
  "valuetype",
  "vlink",
]);
function shouldIgnoreCase(selector, options) {
  return typeof selector.ignoreCase === "boolean"
    ? selector.ignoreCase
    : selector.ignoreCase === "quirks"
      ? !!options.quirksMode
      : !options.xmlMode && caseInsensitiveAttributes.has(selector.name);
}
/**
 * Attribute selectors
 */
attributes.attributeRules = {
  equals: function (next, data, options) {
    var adapter = options.adapter;
    var name = data.name;
    var value = data.value;
    if (shouldIgnoreCase(data, options)) {
      value = value.toLowerCase();
      return function (elem) {
        var attr = adapter.getAttributeValue(elem, name);
        return (
          attr != null &&
          attr.length === value.length &&
          attr.toLowerCase() === value &&
          next(elem)
        );
      };
    }
    return function (elem) {
      return adapter.getAttributeValue(elem, name) === value && next(elem);
    };
  },
  hyphen: function (next, data, options) {
    var adapter = options.adapter;
    var name = data.name;
    var value = data.value;
    var len = value.length;
    if (shouldIgnoreCase(data, options)) {
      value = value.toLowerCase();
      return function hyphenIC(elem) {
        var attr = adapter.getAttributeValue(elem, name);
        return (
          attr != null &&
          (attr.length === len || attr.charAt(len) === "-") &&
          attr.substr(0, len).toLowerCase() === value &&
          next(elem)
        );
      };
    }
    return function hyphen(elem) {
      var attr = adapter.getAttributeValue(elem, name);
      return (
        attr != null &&
        (attr.length === len || attr.charAt(len) === "-") &&
        attr.substr(0, len) === value &&
        next(elem)
      );
    };
  },
  element: function (next, data, options) {
    var adapter = options.adapter;
    var name = data.name,
      value = data.value;
    if (/\s/.test(value)) {
      return boolbase_1$1.default.falseFunc;
    }
    var regex = new RegExp(
      "(?:^|\\s)".concat(escapeRegex(value), "(?:$|\\s)"),
      shouldIgnoreCase(data, options) ? "i" : "",
    );
    return function element(elem) {
      var attr = adapter.getAttributeValue(elem, name);
      return (
        attr != null &&
        attr.length >= value.length &&
        regex.test(attr) &&
        next(elem)
      );
    };
  },
  exists: function (next, _a, _b) {
    var name = _a.name;
    var adapter = _b.adapter;
    return function (elem) {
      return adapter.hasAttrib(elem, name) && next(elem);
    };
  },
  start: function (next, data, options) {
    var adapter = options.adapter;
    var name = data.name;
    var value = data.value;
    var len = value.length;
    if (len === 0) {
      return boolbase_1$1.default.falseFunc;
    }
    if (shouldIgnoreCase(data, options)) {
      value = value.toLowerCase();
      return function (elem) {
        var attr = adapter.getAttributeValue(elem, name);
        return (
          attr != null &&
          attr.length >= len &&
          attr.substr(0, len).toLowerCase() === value &&
          next(elem)
        );
      };
    }
    return function (elem) {
      var _a;
      return (
        !!((_a = adapter.getAttributeValue(elem, name)) === null ||
        _a === void 0
          ? void 0
          : _a.startsWith(value)) && next(elem)
      );
    };
  },
  end: function (next, data, options) {
    var adapter = options.adapter;
    var name = data.name;
    var value = data.value;
    var len = -value.length;
    if (len === 0) {
      return boolbase_1$1.default.falseFunc;
    }
    if (shouldIgnoreCase(data, options)) {
      value = value.toLowerCase();
      return function (elem) {
        var _a;
        return (
          ((_a = adapter.getAttributeValue(elem, name)) === null ||
          _a === void 0
            ? void 0
            : _a.substr(len).toLowerCase()) === value && next(elem)
        );
      };
    }
    return function (elem) {
      var _a;
      return (
        !!((_a = adapter.getAttributeValue(elem, name)) === null ||
        _a === void 0
          ? void 0
          : _a.endsWith(value)) && next(elem)
      );
    };
  },
  any: function (next, data, options) {
    var adapter = options.adapter;
    var name = data.name,
      value = data.value;
    if (value === "") {
      return boolbase_1$1.default.falseFunc;
    }
    if (shouldIgnoreCase(data, options)) {
      var regex_1 = new RegExp(escapeRegex(value), "i");
      return function anyIC(elem) {
        var attr = adapter.getAttributeValue(elem, name);
        return (
          attr != null &&
          attr.length >= value.length &&
          regex_1.test(attr) &&
          next(elem)
        );
      };
    }
    return function (elem) {
      var _a;
      return (
        !!((_a = adapter.getAttributeValue(elem, name)) === null ||
        _a === void 0
          ? void 0
          : _a.includes(value)) && next(elem)
      );
    };
  },
  not: function (next, data, options) {
    var adapter = options.adapter;
    var name = data.name;
    var value = data.value;
    if (value === "") {
      return function (elem) {
        return !!adapter.getAttributeValue(elem, name) && next(elem);
      };
    } else if (shouldIgnoreCase(data, options)) {
      value = value.toLowerCase();
      return function (elem) {
        var attr = adapter.getAttributeValue(elem, name);
        return (
          (attr == null ||
            attr.length !== value.length ||
            attr.toLowerCase() !== value) &&
          next(elem)
        );
      };
    }
    return function (elem) {
      return adapter.getAttributeValue(elem, name) !== value && next(elem);
    };
  },
};

var pseudoSelectors = {};

var filters$1 = {};

(function (exports) {
  var __importDefault =
    (commonjsGlobal && commonjsGlobal.__importDefault) ||
    function (mod) {
      return mod && mod.__esModule ? mod : { default: mod };
    };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.filters = void 0;
  var nth_check_1 = __importDefault(lib$1);
  var boolbase_1 = __importDefault(boolbase);
  function getChildFunc(next, adapter) {
    return function (elem) {
      var parent = adapter.getParent(elem);
      return parent != null && adapter.isTag(parent) && next(elem);
    };
  }
  exports.filters = {
    contains: function (next, text, _a) {
      var adapter = _a.adapter;
      return function contains(elem) {
        return next(elem) && adapter.getText(elem).includes(text);
      };
    },
    icontains: function (next, text, _a) {
      var adapter = _a.adapter;
      var itext = text.toLowerCase();
      return function icontains(elem) {
        return (
          next(elem) && adapter.getText(elem).toLowerCase().includes(itext)
        );
      };
    },
    // Location specific methods
    "nth-child": function (next, rule, _a) {
      var adapter = _a.adapter,
        equals = _a.equals;
      var func = (0, nth_check_1.default)(rule);
      if (func === boolbase_1.default.falseFunc)
        return boolbase_1.default.falseFunc;
      if (func === boolbase_1.default.trueFunc)
        return getChildFunc(next, adapter);
      return function nthChild(elem) {
        var siblings = adapter.getSiblings(elem);
        var pos = 0;
        for (var i = 0; i < siblings.length; i++) {
          if (equals(elem, siblings[i])) break;
          if (adapter.isTag(siblings[i])) {
            pos++;
          }
        }
        return func(pos) && next(elem);
      };
    },
    "nth-last-child": function (next, rule, _a) {
      var adapter = _a.adapter,
        equals = _a.equals;
      var func = (0, nth_check_1.default)(rule);
      if (func === boolbase_1.default.falseFunc)
        return boolbase_1.default.falseFunc;
      if (func === boolbase_1.default.trueFunc)
        return getChildFunc(next, adapter);
      return function nthLastChild(elem) {
        var siblings = adapter.getSiblings(elem);
        var pos = 0;
        for (var i = siblings.length - 1; i >= 0; i--) {
          if (equals(elem, siblings[i])) break;
          if (adapter.isTag(siblings[i])) {
            pos++;
          }
        }
        return func(pos) && next(elem);
      };
    },
    "nth-of-type": function (next, rule, _a) {
      var adapter = _a.adapter,
        equals = _a.equals;
      var func = (0, nth_check_1.default)(rule);
      if (func === boolbase_1.default.falseFunc)
        return boolbase_1.default.falseFunc;
      if (func === boolbase_1.default.trueFunc)
        return getChildFunc(next, adapter);
      return function nthOfType(elem) {
        var siblings = adapter.getSiblings(elem);
        var pos = 0;
        for (var i = 0; i < siblings.length; i++) {
          var currentSibling = siblings[i];
          if (equals(elem, currentSibling)) break;
          if (
            adapter.isTag(currentSibling) &&
            adapter.getName(currentSibling) === adapter.getName(elem)
          ) {
            pos++;
          }
        }
        return func(pos) && next(elem);
      };
    },
    "nth-last-of-type": function (next, rule, _a) {
      var adapter = _a.adapter,
        equals = _a.equals;
      var func = (0, nth_check_1.default)(rule);
      if (func === boolbase_1.default.falseFunc)
        return boolbase_1.default.falseFunc;
      if (func === boolbase_1.default.trueFunc)
        return getChildFunc(next, adapter);
      return function nthLastOfType(elem) {
        var siblings = adapter.getSiblings(elem);
        var pos = 0;
        for (var i = siblings.length - 1; i >= 0; i--) {
          var currentSibling = siblings[i];
          if (equals(elem, currentSibling)) break;
          if (
            adapter.isTag(currentSibling) &&
            adapter.getName(currentSibling) === adapter.getName(elem)
          ) {
            pos++;
          }
        }
        return func(pos) && next(elem);
      };
    },
    // TODO determine the actual root element
    root: function (next, _rule, _a) {
      var adapter = _a.adapter;
      return function (elem) {
        var parent = adapter.getParent(elem);
        return (parent == null || !adapter.isTag(parent)) && next(elem);
      };
    },
    scope: function (next, rule, options, context) {
      var equals = options.equals;
      if (!context || context.length === 0) {
        // Equivalent to :root
        return exports.filters["root"](next, rule, options);
      }
      if (context.length === 1) {
        // NOTE: can't be unpacked, as :has uses this for side-effects
        return function (elem) {
          return equals(context[0], elem) && next(elem);
        };
      }
      return function (elem) {
        return context.includes(elem) && next(elem);
      };
    },
    hover: dynamicStatePseudo("isHovered"),
    visited: dynamicStatePseudo("isVisited"),
    active: dynamicStatePseudo("isActive"),
  };
  /**
   * Dynamic state pseudos. These depend on optional Adapter methods.
   *
   * @param name The name of the adapter method to call.
   * @returns Pseudo for the `filters` object.
   */
  function dynamicStatePseudo(name) {
    return function dynamicPseudo(next, _rule, _a) {
      var adapter = _a.adapter;
      var func = adapter[name];
      if (typeof func !== "function") {
        return boolbase_1.default.falseFunc;
      }
      return function active(elem) {
        return func(elem) && next(elem);
      };
    };
  }
})(filters$1);

var pseudos = {};

Object.defineProperty(pseudos, "__esModule", { value: true });
pseudos.verifyPseudoArgs = pseudos.pseudos = void 0;
// While filters are precompiled, pseudos get called when they are needed
pseudos.pseudos = {
  empty: function (elem, _a) {
    var adapter = _a.adapter;
    return !adapter.getChildren(elem).some(function (elem) {
      // FIXME: `getText` call is potentially expensive.
      return adapter.isTag(elem) || adapter.getText(elem) !== "";
    });
  },
  "first-child": function (elem, _a) {
    var adapter = _a.adapter,
      equals = _a.equals;
    if (adapter.prevElementSibling) {
      return adapter.prevElementSibling(elem) == null;
    }
    var firstChild = adapter.getSiblings(elem).find(function (elem) {
      return adapter.isTag(elem);
    });
    return firstChild != null && equals(elem, firstChild);
  },
  "last-child": function (elem, _a) {
    var adapter = _a.adapter,
      equals = _a.equals;
    var siblings = adapter.getSiblings(elem);
    for (var i = siblings.length - 1; i >= 0; i--) {
      if (equals(elem, siblings[i])) return true;
      if (adapter.isTag(siblings[i])) break;
    }
    return false;
  },
  "first-of-type": function (elem, _a) {
    var adapter = _a.adapter,
      equals = _a.equals;
    var siblings = adapter.getSiblings(elem);
    var elemName = adapter.getName(elem);
    for (var i = 0; i < siblings.length; i++) {
      var currentSibling = siblings[i];
      if (equals(elem, currentSibling)) return true;
      if (
        adapter.isTag(currentSibling) &&
        adapter.getName(currentSibling) === elemName
      ) {
        break;
      }
    }
    return false;
  },
  "last-of-type": function (elem, _a) {
    var adapter = _a.adapter,
      equals = _a.equals;
    var siblings = adapter.getSiblings(elem);
    var elemName = adapter.getName(elem);
    for (var i = siblings.length - 1; i >= 0; i--) {
      var currentSibling = siblings[i];
      if (equals(elem, currentSibling)) return true;
      if (
        adapter.isTag(currentSibling) &&
        adapter.getName(currentSibling) === elemName
      ) {
        break;
      }
    }
    return false;
  },
  "only-of-type": function (elem, _a) {
    var adapter = _a.adapter,
      equals = _a.equals;
    var elemName = adapter.getName(elem);
    return adapter.getSiblings(elem).every(function (sibling) {
      return (
        equals(elem, sibling) ||
        !adapter.isTag(sibling) ||
        adapter.getName(sibling) !== elemName
      );
    });
  },
  "only-child": function (elem, _a) {
    var adapter = _a.adapter,
      equals = _a.equals;
    return adapter.getSiblings(elem).every(function (sibling) {
      return equals(elem, sibling) || !adapter.isTag(sibling);
    });
  },
};
function verifyPseudoArgs(func, name, subselect, argIndex) {
  if (subselect === null) {
    if (func.length > argIndex) {
      throw new Error("Pseudo-class :".concat(name, " requires an argument"));
    }
  } else if (func.length === argIndex) {
    throw new Error(
      "Pseudo-class :".concat(name, " doesn't have any arguments"),
    );
  }
}
pseudos.verifyPseudoArgs = verifyPseudoArgs;

var aliases = {};

Object.defineProperty(aliases, "__esModule", { value: true });
aliases.aliases = void 0;
/**
 * Aliases are pseudos that are expressed as selectors.
 */
aliases.aliases = {
  // Links
  "any-link": ":is(a, area, link)[href]",
  link: ":any-link:not(:visited)",
  // Forms
  // https://html.spec.whatwg.org/multipage/scripting.html#disabled-elements
  disabled:
    ":is(\n        :is(button, input, select, textarea, optgroup, option)[disabled],\n        optgroup[disabled] > option,\n        fieldset[disabled]:not(fieldset[disabled] legend:first-of-type *)\n    )",
  enabled: ":not(:disabled)",
  checked:
    ":is(:is(input[type=radio], input[type=checkbox])[checked], option:selected)",
  required: ":is(input, select, textarea)[required]",
  optional: ":is(input, select, textarea):not([required])",
  // JQuery extensions
  // https://html.spec.whatwg.org/multipage/form-elements.html#concept-option-selectedness
  selected:
    "option:is([selected], select:not([multiple]):not(:has(> option[selected])) > :first-of-type)",
  checkbox: "[type=checkbox]",
  file: "[type=file]",
  password: "[type=password]",
  radio: "[type=radio]",
  reset: "[type=reset]",
  image: "[type=image]",
  submit: "[type=submit]",
  parent: ":not(:empty)",
  header: ":is(h1, h2, h3, h4, h5, h6)",
  button: ":is(button, input[type=button])",
  input: ":is(input, textarea, select, button)",
  text: "input:is(:not([type!='']), [type=text])",
};

var subselects = {};

(function (exports) {
  var __spreadArray =
    (commonjsGlobal && commonjsGlobal.__spreadArray) ||
    function (to, from, pack) {
      if (pack || arguments.length === 2)
        for (var i = 0, l = from.length, ar; i < l; i++) {
          if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
          }
        }
      return to.concat(ar || Array.prototype.slice.call(from));
    };
  var __importDefault =
    (commonjsGlobal && commonjsGlobal.__importDefault) ||
    function (mod) {
      return mod && mod.__esModule ? mod : { default: mod };
    };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.subselects =
    exports.getNextSiblings =
    exports.ensureIsTag =
    exports.PLACEHOLDER_ELEMENT =
      void 0;
  var boolbase_1 = __importDefault(boolbase);
  var sort_js_1 = sort;
  /** Used as a placeholder for :has. Will be replaced with the actual element. */
  exports.PLACEHOLDER_ELEMENT = {};
  function ensureIsTag(next, adapter) {
    if (next === boolbase_1.default.falseFunc)
      return boolbase_1.default.falseFunc;
    return function (elem) {
      return adapter.isTag(elem) && next(elem);
    };
  }
  exports.ensureIsTag = ensureIsTag;
  function getNextSiblings(elem, adapter) {
    var siblings = adapter.getSiblings(elem);
    if (siblings.length <= 1) return [];
    var elemIndex = siblings.indexOf(elem);
    if (elemIndex < 0 || elemIndex === siblings.length - 1) return [];
    return siblings.slice(elemIndex + 1).filter(adapter.isTag);
  }
  exports.getNextSiblings = getNextSiblings;
  function copyOptions(options) {
    // Not copied: context, rootFunc
    return {
      xmlMode: !!options.xmlMode,
      lowerCaseAttributeNames: !!options.lowerCaseAttributeNames,
      lowerCaseTags: !!options.lowerCaseTags,
      quirksMode: !!options.quirksMode,
      cacheResults: !!options.cacheResults,
      pseudos: options.pseudos,
      adapter: options.adapter,
      equals: options.equals,
    };
  }
  var is = function (next, token, options, context, compileToken) {
    var func = compileToken(token, copyOptions(options), context);
    return func === boolbase_1.default.trueFunc
      ? next
      : func === boolbase_1.default.falseFunc
        ? boolbase_1.default.falseFunc
        : function (elem) {
            return func(elem) && next(elem);
          };
  };
  /*
   * :not, :has, :is, :matches and :where have to compile selectors
   * doing this in src/pseudos.ts would lead to circular dependencies,
   * so we add them here
   */
  exports.subselects = {
    is: is,
    /**
     * `:matches` and `:where` are aliases for `:is`.
     */
    matches: is,
    where: is,
    not: function (next, token, options, context, compileToken) {
      var func = compileToken(token, copyOptions(options), context);
      return func === boolbase_1.default.falseFunc
        ? next
        : func === boolbase_1.default.trueFunc
          ? boolbase_1.default.falseFunc
          : function (elem) {
              return !func(elem) && next(elem);
            };
    },
    has: function (next, subselect, options, _context, compileToken) {
      var adapter = options.adapter;
      var opts = copyOptions(options);
      opts.relativeSelector = true;
      var context = subselect.some(function (s) {
        return s.some(sort_js_1.isTraversal);
      })
        ? // Used as a placeholder. Will be replaced with the actual element.
          [exports.PLACEHOLDER_ELEMENT]
        : undefined;
      var compiled = compileToken(subselect, opts, context);
      if (compiled === boolbase_1.default.falseFunc)
        return boolbase_1.default.falseFunc;
      var hasElement = ensureIsTag(compiled, adapter);
      // If `compiled` is `trueFunc`, we can skip this.
      if (context && compiled !== boolbase_1.default.trueFunc) {
        /*
         * `shouldTestNextSiblings` will only be true if the query starts with
         * a traversal (sibling or adjacent). That means we will always have a context.
         */
        var _a = compiled.shouldTestNextSiblings,
          shouldTestNextSiblings_1 = _a === void 0 ? false : _a;
        return function (elem) {
          if (!next(elem)) return false;
          context[0] = elem;
          var childs = adapter.getChildren(elem);
          var nextElements = shouldTestNextSiblings_1
            ? __spreadArray(
                __spreadArray([], childs, true),
                getNextSiblings(elem, adapter),
                true,
              )
            : childs;
          return adapter.existsOne(hasElement, nextElements);
        };
      }
      return function (elem) {
        return (
          next(elem) && adapter.existsOne(hasElement, adapter.getChildren(elem))
        );
      };
    },
  };
})(subselects);

(function (exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.compilePseudoSelector =
    exports.aliases =
    exports.pseudos =
    exports.filters =
      void 0;
  var css_what_1 = require$$1$2;
  var filters_js_1 = filters$1;
  Object.defineProperty(exports, "filters", {
    enumerable: true,
    get: function () {
      return filters_js_1.filters;
    },
  });
  var pseudos_js_1 = pseudos;
  Object.defineProperty(exports, "pseudos", {
    enumerable: true,
    get: function () {
      return pseudos_js_1.pseudos;
    },
  });
  var aliases_js_1 = aliases;
  Object.defineProperty(exports, "aliases", {
    enumerable: true,
    get: function () {
      return aliases_js_1.aliases;
    },
  });
  var subselects_js_1 = subselects;
  function compilePseudoSelector(
    next,
    selector,
    options,
    context,
    compileToken,
  ) {
    var _a;
    var name = selector.name,
      data = selector.data;
    if (Array.isArray(data)) {
      if (!(name in subselects_js_1.subselects)) {
        throw new Error(
          "Unknown pseudo-class :".concat(name, "(").concat(data, ")"),
        );
      }
      return subselects_js_1.subselects[name](
        next,
        data,
        options,
        context,
        compileToken,
      );
    }
    var userPseudo =
      (_a = options.pseudos) === null || _a === void 0 ? void 0 : _a[name];
    var stringPseudo =
      typeof userPseudo === "string" ? userPseudo : aliases_js_1.aliases[name];
    if (typeof stringPseudo === "string") {
      if (data != null) {
        throw new Error("Pseudo ".concat(name, " doesn't have any arguments"));
      }
      // The alias has to be parsed here, to make sure options are respected.
      var alias = (0, css_what_1.parse)(stringPseudo);
      return subselects_js_1.subselects["is"](
        next,
        alias,
        options,
        context,
        compileToken,
      );
    }
    if (typeof userPseudo === "function") {
      (0, pseudos_js_1.verifyPseudoArgs)(userPseudo, name, data, 1);
      return function (elem) {
        return userPseudo(elem, data) && next(elem);
      };
    }
    if (name in filters_js_1.filters) {
      return filters_js_1.filters[name](next, data, options, context);
    }
    if (name in pseudos_js_1.pseudos) {
      var pseudo_1 = pseudos_js_1.pseudos[name];
      (0, pseudos_js_1.verifyPseudoArgs)(pseudo_1, name, data, 2);
      return function (elem) {
        return pseudo_1(elem, options, data) && next(elem);
      };
    }
    throw new Error("Unknown pseudo-class :".concat(name));
  }
  exports.compilePseudoSelector = compilePseudoSelector;
})(pseudoSelectors);

Object.defineProperty(general, "__esModule", { value: true });
general.compileGeneralSelector = void 0;
var attributes_js_1 = attributes;
var index_js_1 = pseudoSelectors;
var css_what_1$1 = require$$1$2;
function getElementParent(node, adapter) {
  var parent = adapter.getParent(node);
  if (parent && adapter.isTag(parent)) {
    return parent;
  }
  return null;
}
/*
 * All available rules
 */
function compileGeneralSelector(
  next,
  selector,
  options,
  context,
  compileToken,
) {
  var adapter = options.adapter,
    equals = options.equals;
  switch (selector.type) {
    case css_what_1$1.SelectorType.PseudoElement: {
      throw new Error("Pseudo-elements are not supported by css-select");
    }
    case css_what_1$1.SelectorType.ColumnCombinator: {
      throw new Error("Column combinators are not yet supported by css-select");
    }
    case css_what_1$1.SelectorType.Attribute: {
      if (selector.namespace != null) {
        throw new Error(
          "Namespaced attributes are not yet supported by css-select",
        );
      }
      if (!options.xmlMode || options.lowerCaseAttributeNames) {
        selector.name = selector.name.toLowerCase();
      }
      return attributes_js_1.attributeRules[selector.action](
        next,
        selector,
        options,
      );
    }
    case css_what_1$1.SelectorType.Pseudo: {
      return (0, index_js_1.compilePseudoSelector)(
        next,
        selector,
        options,
        context,
        compileToken,
      );
    }
    // Tags
    case css_what_1$1.SelectorType.Tag: {
      if (selector.namespace != null) {
        throw new Error(
          "Namespaced tag names are not yet supported by css-select",
        );
      }
      var name_1 = selector.name;
      if (!options.xmlMode || options.lowerCaseTags) {
        name_1 = name_1.toLowerCase();
      }
      return function tag(elem) {
        return adapter.getName(elem) === name_1 && next(elem);
      };
    }
    // Traversal
    case css_what_1$1.SelectorType.Descendant: {
      if (options.cacheResults === false || typeof WeakSet === "undefined") {
        return function descendant(elem) {
          var current = elem;
          while ((current = getElementParent(current, adapter))) {
            if (next(current)) {
              return true;
            }
          }
          return false;
        };
      }
      // @ts-expect-error `ElementNode` is not extending object
      var isFalseCache_1 = new WeakSet();
      return function cachedDescendant(elem) {
        var current = elem;
        while ((current = getElementParent(current, adapter))) {
          if (!isFalseCache_1.has(current)) {
            if (adapter.isTag(current) && next(current)) {
              return true;
            }
            isFalseCache_1.add(current);
          }
        }
        return false;
      };
    }
    case "_flexibleDescendant": {
      // Include element itself, only used while querying an array
      return function flexibleDescendant(elem) {
        var current = elem;
        do {
          if (next(current)) return true;
        } while ((current = getElementParent(current, adapter)));
        return false;
      };
    }
    case css_what_1$1.SelectorType.Parent: {
      return function parent(elem) {
        return adapter.getChildren(elem).some(function (elem) {
          return adapter.isTag(elem) && next(elem);
        });
      };
    }
    case css_what_1$1.SelectorType.Child: {
      return function child(elem) {
        var parent = adapter.getParent(elem);
        return parent != null && adapter.isTag(parent) && next(parent);
      };
    }
    case css_what_1$1.SelectorType.Sibling: {
      return function sibling(elem) {
        var siblings = adapter.getSiblings(elem);
        for (var i = 0; i < siblings.length; i++) {
          var currentSibling = siblings[i];
          if (equals(elem, currentSibling)) break;
          if (adapter.isTag(currentSibling) && next(currentSibling)) {
            return true;
          }
        }
        return false;
      };
    }
    case css_what_1$1.SelectorType.Adjacent: {
      if (adapter.prevElementSibling) {
        return function adjacent(elem) {
          var previous = adapter.prevElementSibling(elem);
          return previous != null && next(previous);
        };
      }
      return function adjacent(elem) {
        var siblings = adapter.getSiblings(elem);
        var lastElement;
        for (var i = 0; i < siblings.length; i++) {
          var currentSibling = siblings[i];
          if (equals(elem, currentSibling)) break;
          if (adapter.isTag(currentSibling)) {
            lastElement = currentSibling;
          }
        }
        return !!lastElement && next(lastElement);
      };
    }
    case css_what_1$1.SelectorType.Universal: {
      if (selector.namespace != null && selector.namespace !== "*") {
        throw new Error(
          "Namespaced universal selectors are not yet supported by css-select",
        );
      }
      return next;
    }
  }
}
general.compileGeneralSelector = compileGeneralSelector;

var __createBinding =
  (commonjsGlobal && commonjsGlobal.__createBinding) ||
  (Object.create
    ? function (o, m, k, k2) {
        if (k2 === undefined) k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (
          !desc ||
          ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)
        ) {
          desc = {
            enumerable: true,
            get: function () {
              return m[k];
            },
          };
        }
        Object.defineProperty(o, k2, desc);
      }
    : function (o, m, k, k2) {
        if (k2 === undefined) k2 = k;
        o[k2] = m[k];
      });
var __setModuleDefault =
  (commonjsGlobal && commonjsGlobal.__setModuleDefault) ||
  (Object.create
    ? function (o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
      }
    : function (o, v) {
        o["default"] = v;
      });
var __importStar =
  (commonjsGlobal && commonjsGlobal.__importStar) ||
  function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null)
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
  };
var __importDefault =
  (commonjsGlobal && commonjsGlobal.__importDefault) ||
  function (mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
Object.defineProperty(compile$1, "__esModule", { value: true });
compile$1.compileToken = compile$1.compileUnsafe = compile$1.compile = void 0;
var css_what_1 = require$$1$2;
var boolbase_1 = __importDefault(boolbase);
var sort_js_1 = __importStar(sort);
var general_js_1 = general;
var subselects_js_1 = subselects;
/**
 * Compiles a selector to an executable function.
 *
 * @param selector Selector to compile.
 * @param options Compilation options.
 * @param context Optional context for the selector.
 */
function compile(selector, options, context) {
  var next = compileUnsafe(selector, options, context);
  return (0, subselects_js_1.ensureIsTag)(next, options.adapter);
}
compile$1.compile = compile;
function compileUnsafe(selector, options, context) {
  var token =
    typeof selector === "string" ? (0, css_what_1.parse)(selector) : selector;
  return compileToken(token, options, context);
}
compile$1.compileUnsafe = compileUnsafe;
function includesScopePseudo(t) {
  return (
    t.type === css_what_1.SelectorType.Pseudo &&
    (t.name === "scope" ||
      (Array.isArray(t.data) &&
        t.data.some(function (data) {
          return data.some(includesScopePseudo);
        })))
  );
}
var DESCENDANT_TOKEN = { type: css_what_1.SelectorType.Descendant };
var FLEXIBLE_DESCENDANT_TOKEN = {
  type: "_flexibleDescendant",
};
var SCOPE_TOKEN = {
  type: css_what_1.SelectorType.Pseudo,
  name: "scope",
  data: null,
};
/*
 * CSS 4 Spec (Draft): 3.4.1. Absolutizing a Relative Selector
 * http://www.w3.org/TR/selectors4/#absolutizing
 */
function absolutize(token, _a, context) {
  var adapter = _a.adapter;
  // TODO Use better check if the context is a document
  var hasContext = !!(context === null || context === void 0
    ? void 0
    : context.every(function (e) {
        var parent = adapter.isTag(e) && adapter.getParent(e);
        return (
          e === subselects_js_1.PLACEHOLDER_ELEMENT ||
          (parent && adapter.isTag(parent))
        );
      }));
  for (var _i = 0, token_1 = token; _i < token_1.length; _i++) {
    var t = token_1[_i];
    if (
      t.length > 0 &&
      (0, sort_js_1.isTraversal)(t[0]) &&
      t[0].type !== css_what_1.SelectorType.Descendant
    );
    else if (hasContext && !t.some(includesScopePseudo)) {
      t.unshift(DESCENDANT_TOKEN);
    } else {
      continue;
    }
    t.unshift(SCOPE_TOKEN);
  }
}
function compileToken(token, options, context) {
  var _a;
  token.forEach(sort_js_1.default);
  context = (_a = options.context) !== null && _a !== void 0 ? _a : context;
  var isArrayContext = Array.isArray(context);
  var finalContext = context && (Array.isArray(context) ? context : [context]);
  // Check if the selector is relative
  if (options.relativeSelector !== false) {
    absolutize(token, options, finalContext);
  } else if (
    token.some(function (t) {
      return t.length > 0 && (0, sort_js_1.isTraversal)(t[0]);
    })
  ) {
    throw new Error(
      "Relative selectors are not allowed when the `relativeSelector` option is disabled",
    );
  }
  var shouldTestNextSiblings = false;
  var query = token
    .map(function (rules) {
      if (rules.length >= 2) {
        var first = rules[0],
          second = rules[1];
        if (
          first.type !== css_what_1.SelectorType.Pseudo ||
          first.name !== "scope"
        );
        else if (
          isArrayContext &&
          second.type === css_what_1.SelectorType.Descendant
        ) {
          rules[1] = FLEXIBLE_DESCENDANT_TOKEN;
        } else if (
          second.type === css_what_1.SelectorType.Adjacent ||
          second.type === css_what_1.SelectorType.Sibling
        ) {
          shouldTestNextSiblings = true;
        }
      }
      return compileRules(rules, options, finalContext);
    })
    .reduce(reduceRules, boolbase_1.default.falseFunc);
  query.shouldTestNextSiblings = shouldTestNextSiblings;
  return query;
}
compile$1.compileToken = compileToken;
function compileRules(rules, options, context) {
  var _a;
  return rules.reduce(
    function (previous, rule) {
      return previous === boolbase_1.default.falseFunc
        ? boolbase_1.default.falseFunc
        : (0, general_js_1.compileGeneralSelector)(
            previous,
            rule,
            options,
            context,
            compileToken,
          );
    },
    (_a = options.rootFunc) !== null && _a !== void 0
      ? _a
      : boolbase_1.default.trueFunc,
  );
}
function reduceRules(a, b) {
  if (b === boolbase_1.default.falseFunc || a === boolbase_1.default.trueFunc) {
    return a;
  }
  if (a === boolbase_1.default.falseFunc || b === boolbase_1.default.trueFunc) {
    return b;
  }
  return function combine(elem) {
    return a(elem) || b(elem);
  };
}

(function (exports) {
  var __createBinding =
    (commonjsGlobal && commonjsGlobal.__createBinding) ||
    (Object.create
      ? function (o, m, k, k2) {
          if (k2 === undefined) k2 = k;
          var desc = Object.getOwnPropertyDescriptor(m, k);
          if (
            !desc ||
            ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)
          ) {
            desc = {
              enumerable: true,
              get: function () {
                return m[k];
              },
            };
          }
          Object.defineProperty(o, k2, desc);
        }
      : function (o, m, k, k2) {
          if (k2 === undefined) k2 = k;
          o[k2] = m[k];
        });
  var __setModuleDefault =
    (commonjsGlobal && commonjsGlobal.__setModuleDefault) ||
    (Object.create
      ? function (o, v) {
          Object.defineProperty(o, "default", { enumerable: true, value: v });
        }
      : function (o, v) {
          o["default"] = v;
        });
  var __importStar =
    (commonjsGlobal && commonjsGlobal.__importStar) ||
    function (mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null)
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      __setModuleDefault(result, mod);
      return result;
    };
  var __importDefault =
    (commonjsGlobal && commonjsGlobal.__importDefault) ||
    function (mod) {
      return mod && mod.__esModule ? mod : { default: mod };
    };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.aliases =
    exports.pseudos =
    exports.filters =
    exports.is =
    exports.selectOne =
    exports.selectAll =
    exports.prepareContext =
    exports._compileToken =
    exports._compileUnsafe =
    exports.compile =
      void 0;
  var DomUtils = __importStar(lib$2);
  var boolbase_1 = __importDefault(boolbase);
  var compile_js_1 = compile$1;
  var subselects_js_1 = subselects;
  var defaultEquals = function (a, b) {
    return a === b;
  };
  var defaultOptions = {
    adapter: DomUtils,
    equals: defaultEquals,
  };
  function convertOptionFormats(options) {
    var _a, _b, _c, _d;
    /*
     * We force one format of options to the other one.
     */
    // @ts-expect-error Default options may have incompatible `Node` / `ElementNode`.
    var opts =
      options !== null && options !== void 0 ? options : defaultOptions;
    // @ts-expect-error Same as above.
    (_a = opts.adapter) !== null && _a !== void 0
      ? _a
      : (opts.adapter = DomUtils);
    // @ts-expect-error `equals` does not exist on `Options`
    (_b = opts.equals) !== null && _b !== void 0
      ? _b
      : (opts.equals =
          (_d =
            (_c = opts.adapter) === null || _c === void 0
              ? void 0
              : _c.equals) !== null && _d !== void 0
            ? _d
            : defaultEquals);
    return opts;
  }
  function wrapCompile(func) {
    return function addAdapter(selector, options, context) {
      var opts = convertOptionFormats(options);
      return func(selector, opts, context);
    };
  }
  /**
   * Compiles the query, returns a function.
   */
  exports.compile = wrapCompile(compile_js_1.compile);
  exports._compileUnsafe = wrapCompile(compile_js_1.compileUnsafe);
  exports._compileToken = wrapCompile(compile_js_1.compileToken);
  function getSelectorFunc(searchFunc) {
    return function select(query, elements, options) {
      var opts = convertOptionFormats(options);
      if (typeof query !== "function") {
        query = (0, compile_js_1.compileUnsafe)(query, opts, elements);
      }
      var filteredElements = prepareContext(
        elements,
        opts.adapter,
        query.shouldTestNextSiblings,
      );
      return searchFunc(query, filteredElements, opts);
    };
  }
  function prepareContext(elems, adapter, shouldTestNextSiblings) {
    if (shouldTestNextSiblings === void 0) {
      shouldTestNextSiblings = false;
    }
    /*
     * Add siblings if the query requires them.
     * See https://github.com/fb55/css-select/pull/43#issuecomment-225414692
     */
    if (shouldTestNextSiblings) {
      elems = appendNextSiblings(elems, adapter);
    }
    return Array.isArray(elems)
      ? adapter.removeSubsets(elems)
      : adapter.getChildren(elems);
  }
  exports.prepareContext = prepareContext;
  function appendNextSiblings(elem, adapter) {
    // Order matters because jQuery seems to check the children before the siblings
    var elems = Array.isArray(elem) ? elem.slice(0) : [elem];
    var elemsLength = elems.length;
    for (var i = 0; i < elemsLength; i++) {
      var nextSiblings = (0, subselects_js_1.getNextSiblings)(
        elems[i],
        adapter,
      );
      elems.push.apply(elems, nextSiblings);
    }
    return elems;
  }
  /**
   * @template Node The generic Node type for the DOM adapter being used.
   * @template ElementNode The Node type for elements for the DOM adapter being used.
   * @param elems Elements to query. If it is an element, its children will be queried..
   * @param query can be either a CSS selector string or a compiled query function.
   * @param [options] options for querying the document.
   * @see compile for supported selector queries.
   * @returns All matching elements.
   *
   */
  exports.selectAll = getSelectorFunc(function (query, elems, options) {
    return query === boolbase_1.default.falseFunc ||
      !elems ||
      elems.length === 0
      ? []
      : options.adapter.findAll(query, elems);
  });
  /**
   * @template Node The generic Node type for the DOM adapter being used.
   * @template ElementNode The Node type for elements for the DOM adapter being used.
   * @param elems Elements to query. If it is an element, its children will be queried..
   * @param query can be either a CSS selector string or a compiled query function.
   * @param [options] options for querying the document.
   * @see compile for supported selector queries.
   * @returns the first match, or null if there was no match.
   */
  exports.selectOne = getSelectorFunc(function (query, elems, options) {
    return query === boolbase_1.default.falseFunc ||
      !elems ||
      elems.length === 0
      ? null
      : options.adapter.findOne(query, elems);
  });
  /**
   * Tests whether or not an element is matched by query.
   *
   * @template Node The generic Node type for the DOM adapter being used.
   * @template ElementNode The Node type for elements for the DOM adapter being used.
   * @param elem The element to test if it matches the query.
   * @param query can be either a CSS selector string or a compiled query function.
   * @param [options] options for querying the document.
   * @see compile for supported selector queries.
   * @returns
   */
  function is(elem, query, options) {
    var opts = convertOptionFormats(options);
    return (
      typeof query === "function"
        ? query
        : (0, compile_js_1.compile)(query, opts)
    )(elem);
  }
  exports.is = is;
  /**
   * Alias for selectAll(query, elems, options).
   * @see [compile] for supported selector queries.
   */
  exports.default = exports.selectAll;
  // Export filters, pseudos and aliases to allow users to supply their own.
  /** @deprecated Use the `pseudos` option instead. */
  var index_js_1 = pseudoSelectors;
  Object.defineProperty(exports, "filters", {
    enumerable: true,
    get: function () {
      return index_js_1.filters;
    },
  });
  Object.defineProperty(exports, "pseudos", {
    enumerable: true,
    get: function () {
      return index_js_1.pseudos;
    },
  });
  Object.defineProperty(exports, "aliases", {
    enumerable: true,
    get: function () {
      return index_js_1.aliases;
    },
  });
})(lib);

const isTag = (node) => {
  return node.type === "element";
};

const existsOne = (test, elems) => {
  return elems.some((elem) => {
    if (isTag(elem)) {
      return test(elem) || existsOne(test, getChildren(elem));
    } else {
      return false;
    }
  });
};

const getAttributeValue = (elem, name) => {
  return elem.attributes[name];
};

const getChildren = (node) => {
  return node.children || [];
};

const getName = (elemAst) => {
  return elemAst.name;
};

const getParent = (node) => {
  return node.parentNode || null;
};

const getSiblings = (elem) => {
  var parent = getParent(elem);
  return parent ? getChildren(parent) : [];
};

const getText = (node) => {
  if (node.children[0].type === "text" && node.children[0].type === "cdata") {
    return node.children[0].value;
  }
  return "";
};

const hasAttrib = (elem, name) => {
  return elem.attributes[name] !== undefined;
};

const removeSubsets = (nodes) => {
  let idx = nodes.length;
  let node;
  let ancestor;
  let replace;
  // Check if each node (or one of its ancestors) is already contained in the
  // array.
  while (--idx > -1) {
    node = ancestor = nodes[idx];
    // Temporarily remove the node under consideration
    nodes[idx] = null;
    replace = true;
    while (ancestor) {
      if (nodes.includes(ancestor)) {
        replace = false;
        nodes.splice(idx, 1);
        break;
      }
      ancestor = getParent(ancestor);
    }
    // If the node has been found to be unique, re-insert it.
    if (replace) {
      nodes[idx] = node;
    }
  }
  return nodes;
};

const findAll$3 = (test, elems) => {
  const result = [];
  for (const elem of elems) {
    if (isTag(elem)) {
      if (test(elem)) {
        result.push(elem);
      }
      result.push(...findAll$3(test, getChildren(elem)));
    }
  }
  return result;
};

const findOne = (test, elems) => {
  for (const elem of elems) {
    if (isTag(elem)) {
      if (test(elem)) {
        return elem;
      }
      const result = findOne(test, getChildren(elem));
      if (result) {
        return result;
      }
    }
  }
  return null;
};

const svgoCssSelectAdapter = {
  isTag,
  existsOne,
  getAttributeValue,
  getChildren,
  getName,
  getParent,
  getSiblings,
  getText,
  hasAttrib,
  removeSubsets,
  findAll: findAll$3,
  findOne,
};

var cssSelectAdapter = svgoCssSelectAdapter;

/**
 * @typedef {import('./types').XastNode} XastNode
 * @typedef {import('./types').XastChild} XastChild
 * @typedef {import('./types').XastParent} XastParent
 * @typedef {import('./types').Visitor} Visitor
 */

const { selectAll, selectOne, is } = lib;
const xastAdaptor = cssSelectAdapter;

const cssSelectOptions = {
  xmlMode: true,
  adapter: xastAdaptor,
};

/**
 * @type {(node: XastNode, selector: string) => XastChild[]}
 */
const querySelectorAll$4 = (node, selector) => {
  return selectAll(selector, node, cssSelectOptions);
};
xast.querySelectorAll = querySelectorAll$4;

/**
 * @type {(node: XastNode, selector: string) => ?XastChild}
 */
const querySelector$2 = (node, selector) => {
  return selectOne(selector, node, cssSelectOptions);
};
xast.querySelector = querySelector$2;

/**
 * @type {(node: XastChild, selector: string) => boolean}
 */
const matches$1 = (node, selector) => {
  return is(node, selector, cssSelectOptions);
};
xast.matches = matches$1;

const visitSkip$7 = Symbol();
xast.visitSkip = visitSkip$7;

/**
 * @type {(node: XastNode, visitor: Visitor, parentNode?: any) => void}
 */
const visit$7 = (node, visitor, parentNode) => {
  const callbacks = visitor[node.type];
  if (callbacks && callbacks.enter) {
    // @ts-ignore hard to infer
    const symbol = callbacks.enter(node, parentNode);
    if (symbol === visitSkip$7) {
      return;
    }
  }
  // visit root children
  if (node.type === "root") {
    // copy children array to not loose cursor when children is spliced
    for (const child of node.children) {
      visit$7(child, visitor, node);
    }
  }
  // visit element children if still attached to parent
  if (node.type === "element") {
    if (parentNode.children.includes(node)) {
      for (const child of node.children) {
        visit$7(child, visitor, node);
      }
    }
  }
  if (callbacks && callbacks.exit) {
    // @ts-ignore hard to infer
    callbacks.exit(node, parentNode);
  }
};
xast.visit = visit$7;

/**
 * @param {XastChild} node
 * @param {XastParent} parentNode
 */
const detachNodeFromParent$o = (node, parentNode) => {
  // avoid splice to not break for loops
  parentNode.children = parentNode.children.filter((child) => child !== node);
};
xast.detachNodeFromParent = detachNodeFromParent$o;

const { visit: visit$6 } = xast;

/**
 * Plugins engine.
 *
 * @module plugins
 *
 * @param {Object} ast input ast
 * @param {Object} info extra information
 * @param {Array} plugins plugins object from config
 * @return {Object} output ast
 */
const invokePlugins$1 = (ast, info, plugins, overrides, globalOverrides) => {
  for (const plugin of plugins) {
    const override = overrides?.[plugin.name];
    if (override === false) {
      continue;
    }
    const params = { ...plugin.params, ...globalOverrides, ...override };

    const visitor = plugin.fn(ast, params, info);
    if (visitor != null) {
      visit$6(ast, visitor);
    }
  }
};
plugins.invokePlugins = invokePlugins$1;

const createPreset$1 = ({ name, plugins }) => {
  return {
    name,
    fn: (ast, params, info) => {
      const { floatPrecision, overrides } = params;
      const globalOverrides = {};
      if (floatPrecision != null) {
        globalOverrides.floatPrecision = floatPrecision;
      }
      if (overrides) {
        const pluginNames = plugins.map(({ name }) => name);
        for (const pluginName of Object.keys(overrides)) {
          if (!pluginNames.includes(pluginName)) {
            console.warn(
              `You are trying to configure ${pluginName} which is not part of ${name}.\n` +
                `Try to put it before or after, for example\n\n` +
                `plugins: [\n` +
                `  {\n` +
                `    name: '${name}',\n` +
                `  },\n` +
                `  '${pluginName}'\n` +
                `]\n`,
            );
          }
        }
      }
      invokePlugins$1(ast, info, plugins, overrides, globalOverrides);
    },
  };
};
plugins.createPreset = createPreset$1;

var removeDoctype$1 = {};

const { detachNodeFromParent: detachNodeFromParent$n } = xast;

removeDoctype$1.name = "removeDoctype";
removeDoctype$1.description = "removes doctype declaration";

/**
 * Remove DOCTYPE declaration.
 *
 * "Unfortunately the SVG DTDs are a source of so many
 * issues that the SVG WG has decided not to write one
 * for the upcoming SVG 1.2 standard. In fact SVG WG
 * members are even telling people not to use a DOCTYPE
 * declaration in SVG 1.0 and 1.1 documents"
 * https://jwatt.org/svg/authoring/#doctype-declaration
 *
 * @example
 * <!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN"
 * q"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
 *
 * @example
 * <!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 * "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd" [
 *     <!-- an internal subset can be embedded here -->
 * ]>
 *
 * @author Kir Belevich
 *
 * @type {import('./plugins-types').Plugin<'removeDoctype'>}
 */
removeDoctype$1.fn = () => {
  return {
    doctype: {
      enter: (node, parentNode) => {
        detachNodeFromParent$n(node, parentNode);
      },
    },
  };
};

var removeXMLProcInst$1 = {};

const { detachNodeFromParent: detachNodeFromParent$m } = xast;

removeXMLProcInst$1.name = "removeXMLProcInst";
removeXMLProcInst$1.description = "removes XML processing instructions";

/**
 * Remove XML Processing Instruction.
 *
 * @example
 * <?xml version="1.0" encoding="utf-8"?>
 *
 * @author Kir Belevich
 *
 * @type {import('./plugins-types').Plugin<'removeXMLProcInst'>}
 */
removeXMLProcInst$1.fn = () => {
  return {
    instruction: {
      enter: (node, parentNode) => {
        if (node.name === "xml") {
          detachNodeFromParent$m(node, parentNode);
        }
      },
    },
  };
};

var removeComments$1 = {};

const { detachNodeFromParent: detachNodeFromParent$l } = xast;

removeComments$1.name = "removeComments";
removeComments$1.description = "removes comments";

/**
 * If a comment matches one of the following patterns, it will be
 * preserved by default. Particularly for copyright/license information.
 */
const DEFAULT_PRESERVE_PATTERNS = [/^!/];

/**
 * Remove comments.
 *
 * @example
 * <!-- Generator: Adobe Illustrator 15.0.0, SVG Export
 * Plug-In . SVG Version: 6.00 Build 0)  -->
 *
 * @author Kir Belevich
 *
 * @type {import('./plugins-types').Plugin<'removeComments'>}
 */
removeComments$1.fn = (_root, params) => {
  const { preservePatterns = DEFAULT_PRESERVE_PATTERNS } = params;

  return {
    comment: {
      enter: (node, parentNode) => {
        if (preservePatterns) {
          if (!Array.isArray(preservePatterns)) {
            throw Error(
              `Expected array in removeComments preservePatterns parameter but received ${preservePatterns}`,
            );
          }

          const matches = preservePatterns.some((pattern) => {
            return new RegExp(pattern).test(node.value);
          });

          if (matches) {
            return;
          }
        }

        detachNodeFromParent$l(node, parentNode);
      },
    },
  };
};

var removeMetadata$1 = {};

const { detachNodeFromParent: detachNodeFromParent$k } = xast;

removeMetadata$1.name = "removeMetadata";
removeMetadata$1.description = "removes <metadata>";

/**
 * Remove <metadata>.
 *
 * https://www.w3.org/TR/SVG11/metadata.html
 *
 * @author Kir Belevich
 *
 * @type {import('./plugins-types').Plugin<'removeMetadata'>}
 */
removeMetadata$1.fn = () => {
  return {
    element: {
      enter: (node, parentNode) => {
        if (node.name === "metadata") {
          detachNodeFromParent$k(node, parentNode);
        }
      },
    },
  };
};

var removeEditorsNSData$1 = {};

const { detachNodeFromParent: detachNodeFromParent$j } = xast;
const { editorNamespaces } = _collections;

removeEditorsNSData$1.name = "removeEditorsNSData";
removeEditorsNSData$1.description =
  "removes editors namespaces, elements and attributes";

/**
 * Remove editors namespaces, elements and attributes.
 *
 * @example
 * <svg xmlns:sodipodi="http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd">
 * <sodipodi:namedview/>
 * <path sodipodi:nodetypes="cccc"/>
 *
 * @author Kir Belevich
 *
 * @type {import('./plugins-types').Plugin<'removeEditorsNSData'>}
 */
removeEditorsNSData$1.fn = (_root, params) => {
  let namespaces = [...editorNamespaces];
  if (Array.isArray(params.additionalNamespaces)) {
    namespaces = [...editorNamespaces, ...params.additionalNamespaces];
  }
  /**
   * @type {string[]}
   */
  const prefixes = [];
  return {
    element: {
      enter: (node, parentNode) => {
        // collect namespace prefixes from svg element
        if (node.name === "svg") {
          for (const [name, value] of Object.entries(node.attributes)) {
            if (name.startsWith("xmlns:") && namespaces.includes(value)) {
              prefixes.push(name.slice("xmlns:".length));
              // <svg xmlns:sodipodi="">
              delete node.attributes[name];
            }
          }
        }
        // remove editor attributes, for example
        // <* sodipodi:*="">
        for (const name of Object.keys(node.attributes)) {
          if (name.includes(":")) {
            const [prefix] = name.split(":");
            if (prefixes.includes(prefix)) {
              delete node.attributes[name];
            }
          }
        }
        // remove editor elements, for example
        // <sodipodi:*>
        if (node.name.includes(":")) {
          const [prefix] = node.name.split(":");
          if (prefixes.includes(prefix)) {
            detachNodeFromParent$j(node, parentNode);
          }
        }
      },
    },
  };
};

var cleanupAttrs$1 = {};

cleanupAttrs$1.name = "cleanupAttrs";
cleanupAttrs$1.description =
  "cleanups attributes from newlines, trailing and repeating spaces";

const regNewlinesNeedSpace = /(\S)\r?\n(\S)/g;
const regNewlines = /\r?\n/g;
const regSpaces = /\s{2,}/g;

/**
 * Cleanup attributes values from newlines, trailing and repeating spaces.
 *
 * @author Kir Belevich
 *
 * @type {import('./plugins-types').Plugin<'cleanupAttrs'>}
 */
cleanupAttrs$1.fn = (root, params) => {
  const { newlines = true, trim = true, spaces = true } = params;
  return {
    element: {
      enter: (node) => {
        for (const name of Object.keys(node.attributes)) {
          if (newlines) {
            // new line which requires a space instead of themself
            node.attributes[name] = node.attributes[name].replace(
              regNewlinesNeedSpace,
              (match, p1, p2) => p1 + " " + p2,
            );
            // simple new line
            node.attributes[name] = node.attributes[name].replace(
              regNewlines,
              "",
            );
          }
          if (trim) {
            node.attributes[name] = node.attributes[name].trim();
          }
          if (spaces) {
            node.attributes[name] = node.attributes[name].replace(
              regSpaces,
              " ",
            );
          }
        }
      },
    },
  };
};

var mergeStyles$1 = {};

/**
 * @typedef {import('../lib/types').XastElement} XastElement
 * @typedef {import('../lib/types').XastChild} XastChild
 */

const { visitSkip: visitSkip$6, detachNodeFromParent: detachNodeFromParent$i } =
  xast;

mergeStyles$1.name = "mergeStyles";
mergeStyles$1.description = "merge multiple style elements into one";

/**
 * Merge multiple style elements into one.
 *
 * @author strarsis <strarsis@gmail.com>
 *
 * @type {import('./plugins-types').Plugin<'mergeStyles'>}
 */
mergeStyles$1.fn = () => {
  /**
   * @type {?XastElement}
   */
  let firstStyleElement = null;
  let collectedStyles = "";
  /**
   * @type {'text' | 'cdata'}
   */
  let styleContentType = "text";

  return {
    element: {
      enter: (node, parentNode) => {
        // skip <foreignObject> content
        if (node.name === "foreignObject") {
          return visitSkip$6;
        }

        // collect style elements
        if (node.name !== "style") {
          return;
        }

        // skip <style> with invalid type attribute
        if (
          node.attributes.type != null &&
          node.attributes.type !== "" &&
          node.attributes.type !== "text/css"
        ) {
          return;
        }

        // extract style element content
        let css = "";
        for (const child of node.children) {
          if (child.type === "text") {
            css += child.value;
          }
          if (child.type === "cdata") {
            styleContentType = "cdata";
            css += child.value;
          }
        }

        // remove empty style elements
        if (css.trim().length === 0) {
          detachNodeFromParent$i(node, parentNode);
          return;
        }

        // collect css and wrap with media query if present in attribute
        if (node.attributes.media == null) {
          collectedStyles += css;
        } else {
          collectedStyles += `@media ${node.attributes.media}{${css}}`;
          delete node.attributes.media;
        }

        // combine collected styles in the first style element
        if (firstStyleElement == null) {
          firstStyleElement = node;
        } else {
          detachNodeFromParent$i(node, parentNode);
          /**
           * @type {XastChild}
           */
          const child = { type: styleContentType, value: collectedStyles };
          // TODO remove legacy parentNode in v4
          Object.defineProperty(child, "parentNode", {
            writable: true,
            value: firstStyleElement,
          });
          firstStyleElement.children = [child];
        }
      },
    },
  };
};

var inlineStyles$1 = {};

var cjs$2 = {};

var tokenizer$5 = {};

var types$1M = {};

// CSS Syntax Module Level 3
// https://www.w3.org/TR/css-syntax-3/
const EOF$6 = 0; // <EOF-token>
const Ident$1 = 1; // <ident-token>
const Function$6 = 2; // <function-token>
const AtKeyword$1 = 3; // <at-keyword-token>
const Hash$7 = 4; // <hash-token>
const String$4 = 5; // <string-token>
const BadString$1 = 6; // <bad-string-token>
const Url$9 = 7; // <url-token>
const BadUrl$1 = 8; // <bad-url-token>
const Delim$1 = 9; // <delim-token>
const Number$5 = 10; // <number-token>
const Percentage$9 = 11; // <percentage-token>
const Dimension$9 = 12; // <dimension-token>
const WhiteSpace$9 = 13; // <whitespace-token>
const CDO$7 = 14; // <CDO-token>
const CDC$7 = 15; // <CDC-token>
const Colon$1 = 16; // <colon-token>     :
const Semicolon$1 = 17; // <semicolon-token> ;
const Comma$1 = 18; // <comma-token>     ,
const LeftSquareBracket$1 = 19; // <[-token>
const RightSquareBracket$1 = 20; // <]-token>
const LeftParenthesis$1 = 21; // <(-token>
const RightParenthesis$1 = 22; // <)-token>
const LeftCurlyBracket$1 = 23; // <{-token>
const RightCurlyBracket$1 = 24; // <}-token>
const Comment$9 = 25;

types$1M.AtKeyword = AtKeyword$1;
types$1M.BadString = BadString$1;
types$1M.BadUrl = BadUrl$1;
types$1M.CDC = CDC$7;
types$1M.CDO = CDO$7;
types$1M.Colon = Colon$1;
types$1M.Comma = Comma$1;
types$1M.Comment = Comment$9;
types$1M.Delim = Delim$1;
types$1M.Dimension = Dimension$9;
types$1M.EOF = EOF$6;
types$1M.Function = Function$6;
types$1M.Hash = Hash$7;
types$1M.Ident = Ident$1;
types$1M.LeftCurlyBracket = LeftCurlyBracket$1;
types$1M.LeftParenthesis = LeftParenthesis$1;
types$1M.LeftSquareBracket = LeftSquareBracket$1;
types$1M.Number = Number$5;
types$1M.Percentage = Percentage$9;
types$1M.RightCurlyBracket = RightCurlyBracket$1;
types$1M.RightParenthesis = RightParenthesis$1;
types$1M.RightSquareBracket = RightSquareBracket$1;
types$1M.Semicolon = Semicolon$1;
types$1M.String = String$4;
types$1M.Url = Url$9;
types$1M.WhiteSpace = WhiteSpace$9;

var charCodeDefinitions$p = {};

const EOF$5 = 0;

// https://drafts.csswg.org/css-syntax-3/
//  4.2. Definitions

// digit
// A code point between U+0030 DIGIT ZERO (0) and U+0039 DIGIT NINE (9).
function isDigit$2(code) {
  return code >= 0x0030 && code <= 0x0039;
}

// hex digit
// A digit, or a code point between U+0041 LATIN CAPITAL LETTER A (A) and U+0046 LATIN CAPITAL LETTER F (F),
// or a code point between U+0061 LATIN SMALL LETTER A (a) and U+0066 LATIN SMALL LETTER F (f).
function isHexDigit$1(code) {
  return (
    isDigit$2(code) || // 0 .. 9
    (code >= 0x0041 && code <= 0x0046) || // A .. F
    (code >= 0x0061 && code <= 0x0066) // a .. f
  );
}

// uppercase letter
// A code point between U+0041 LATIN CAPITAL LETTER A (A) and U+005A LATIN CAPITAL LETTER Z (Z).
function isUppercaseLetter$1(code) {
  return code >= 0x0041 && code <= 0x005a;
}

// lowercase letter
// A code point between U+0061 LATIN SMALL LETTER A (a) and U+007A LATIN SMALL LETTER Z (z).
function isLowercaseLetter$1(code) {
  return code >= 0x0061 && code <= 0x007a;
}

// letter
// An uppercase letter or a lowercase letter.
function isLetter$1(code) {
  return isUppercaseLetter$1(code) || isLowercaseLetter$1(code);
}

// non-ASCII code point
// A code point with a value equal to or greater than U+0080 <control>.
function isNonAscii$1(code) {
  return code >= 0x0080;
}

// name-start code point
// A letter, a non-ASCII code point, or U+005F LOW LINE (_).
function isNameStart$1(code) {
  return isLetter$1(code) || isNonAscii$1(code) || code === 0x005f;
}

// name code point
// A name-start code point, a digit, or U+002D HYPHEN-MINUS (-).
function isName$1(code) {
  return isNameStart$1(code) || isDigit$2(code) || code === 0x002d;
}

// non-printable code point
// A code point between U+0000 NULL and U+0008 BACKSPACE, or U+000B LINE TABULATION,
// or a code point between U+000E SHIFT OUT and U+001F INFORMATION SEPARATOR ONE, or U+007F DELETE.
function isNonPrintable$1(code) {
  return (
    (code >= 0x0000 && code <= 0x0008) ||
    code === 0x000b ||
    (code >= 0x000e && code <= 0x001f) ||
    code === 0x007f
  );
}

// newline
// U+000A LINE FEED. Note that U+000D CARRIAGE RETURN and U+000C FORM FEED are not included in this definition,
// as they are converted to U+000A LINE FEED during preprocessing.
// TODO: we doesn't do a preprocessing, so check a code point for U+000D CARRIAGE RETURN and U+000C FORM FEED
function isNewline$1(code) {
  return code === 0x000a || code === 0x000d || code === 0x000c;
}

// whitespace
// A newline, U+0009 CHARACTER TABULATION, or U+0020 SPACE.
function isWhiteSpace$1(code) {
  return isNewline$1(code) || code === 0x0020 || code === 0x0009;
}

//  4.3.8. Check if two code points are a valid escape
function isValidEscape$1(first, second) {
  // If the first code point is not U+005C REVERSE SOLIDUS (\), return false.
  if (first !== 0x005c) {
    return false;
  }

  // Otherwise, if the second code point is a newline or EOF, return false.
  if (isNewline$1(second) || second === EOF$5) {
    return false;
  }

  // Otherwise, return true.
  return true;
}

//  4.3.9. Check if three code points would start an identifier
function isIdentifierStart$1(first, second, third) {
  // Look at the first code point:

  // U+002D HYPHEN-MINUS
  if (first === 0x002d) {
    // If the second code point is a name-start code point or a U+002D HYPHEN-MINUS,
    // or the second and third code points are a valid escape, return true. Otherwise, return false.
    return (
      isNameStart$1(second) ||
      second === 0x002d ||
      isValidEscape$1(second, third)
    );
  }

  // name-start code point
  if (isNameStart$1(first)) {
    // Return true.
    return true;
  }

  // U+005C REVERSE SOLIDUS (\)
  if (first === 0x005c) {
    // If the first and second code points are a valid escape, return true. Otherwise, return false.
    return isValidEscape$1(first, second);
  }

  // anything else
  // Return false.
  return false;
}

//  4.3.10. Check if three code points would start a number
function isNumberStart$1(first, second, third) {
  // Look at the first code point:

  // U+002B PLUS SIGN (+)
  // U+002D HYPHEN-MINUS (-)
  if (first === 0x002b || first === 0x002d) {
    // If the second code point is a digit, return true.
    if (isDigit$2(second)) {
      return 2;
    }

    // Otherwise, if the second code point is a U+002E FULL STOP (.)
    // and the third code point is a digit, return true.
    // Otherwise, return false.
    return second === 0x002e && isDigit$2(third) ? 3 : 0;
  }

  // U+002E FULL STOP (.)
  if (first === 0x002e) {
    // If the second code point is a digit, return true. Otherwise, return false.
    return isDigit$2(second) ? 2 : 0;
  }

  // digit
  if (isDigit$2(first)) {
    // Return true.
    return 1;
  }

  // anything else
  // Return false.
  return 0;
}

//
// Misc
//

// detect BOM (https://en.wikipedia.org/wiki/Byte_order_mark)
function isBOM$1(code) {
  // UTF-16BE
  if (code === 0xfeff) {
    return 1;
  }

  // UTF-16LE
  if (code === 0xfffe) {
    return 1;
  }

  return 0;
}

// Fast code category
// Only ASCII code points has a special meaning, that's why we define a maps for 0..127 codes only
const CATEGORY$1 = new Array(0x80);
const EofCategory$1 = 0x80;
const WhiteSpaceCategory$1 = 0x82;
const DigitCategory$1 = 0x83;
const NameStartCategory$1 = 0x84;
const NonPrintableCategory$1 = 0x85;

for (let i = 0; i < CATEGORY$1.length; i++) {
  CATEGORY$1[i] =
    (isWhiteSpace$1(i) && WhiteSpaceCategory$1) ||
    (isDigit$2(i) && DigitCategory$1) ||
    (isNameStart$1(i) && NameStartCategory$1) ||
    (isNonPrintable$1(i) && NonPrintableCategory$1) ||
    i ||
    EofCategory$1;
}

function charCodeCategory$1(code) {
  return code < 0x80 ? CATEGORY$1[code] : NameStartCategory$1;
}

charCodeDefinitions$p.DigitCategory = DigitCategory$1;
charCodeDefinitions$p.EofCategory = EofCategory$1;
charCodeDefinitions$p.NameStartCategory = NameStartCategory$1;
charCodeDefinitions$p.NonPrintableCategory = NonPrintableCategory$1;
charCodeDefinitions$p.WhiteSpaceCategory = WhiteSpaceCategory$1;
charCodeDefinitions$p.charCodeCategory = charCodeCategory$1;
charCodeDefinitions$p.isBOM = isBOM$1;
charCodeDefinitions$p.isDigit = isDigit$2;
charCodeDefinitions$p.isHexDigit = isHexDigit$1;
charCodeDefinitions$p.isIdentifierStart = isIdentifierStart$1;
charCodeDefinitions$p.isLetter = isLetter$1;
charCodeDefinitions$p.isLowercaseLetter = isLowercaseLetter$1;
charCodeDefinitions$p.isName = isName$1;
charCodeDefinitions$p.isNameStart = isNameStart$1;
charCodeDefinitions$p.isNewline = isNewline$1;
charCodeDefinitions$p.isNonAscii = isNonAscii$1;
charCodeDefinitions$p.isNonPrintable = isNonPrintable$1;
charCodeDefinitions$p.isNumberStart = isNumberStart$1;
charCodeDefinitions$p.isUppercaseLetter = isUppercaseLetter$1;
charCodeDefinitions$p.isValidEscape = isValidEscape$1;
charCodeDefinitions$p.isWhiteSpace = isWhiteSpace$1;

var utils$u = {};

const charCodeDefinitions$o = charCodeDefinitions$p;

function getCharCode$1(source, offset) {
  return offset < source.length ? source.charCodeAt(offset) : 0;
}

function getNewlineLength$1(source, offset, code) {
  if (
    code === 13 /* \r */ &&
    getCharCode$1(source, offset + 1) === 10 /* \n */
  ) {
    return 2;
  }

  return 1;
}

function cmpChar$1(testStr, offset, referenceCode) {
  let code = testStr.charCodeAt(offset);

  // code.toLowerCase() for A..Z
  if (charCodeDefinitions$o.isUppercaseLetter(code)) {
    code = code | 32;
  }

  return code === referenceCode;
}

function cmpStr$1(testStr, start, end, referenceStr) {
  if (end - start !== referenceStr.length) {
    return false;
  }

  if (start < 0 || end > testStr.length) {
    return false;
  }

  for (let i = start; i < end; i++) {
    const referenceCode = referenceStr.charCodeAt(i - start);
    let testCode = testStr.charCodeAt(i);

    // testCode.toLowerCase() for A..Z
    if (charCodeDefinitions$o.isUppercaseLetter(testCode)) {
      testCode = testCode | 32;
    }

    if (testCode !== referenceCode) {
      return false;
    }
  }

  return true;
}

function findWhiteSpaceStart$1(source, offset) {
  for (; offset >= 0; offset--) {
    if (!charCodeDefinitions$o.isWhiteSpace(source.charCodeAt(offset))) {
      break;
    }
  }

  return offset + 1;
}

function findWhiteSpaceEnd$1(source, offset) {
  for (; offset < source.length; offset++) {
    if (!charCodeDefinitions$o.isWhiteSpace(source.charCodeAt(offset))) {
      break;
    }
  }

  return offset;
}

function findDecimalNumberEnd$1(source, offset) {
  for (; offset < source.length; offset++) {
    if (!charCodeDefinitions$o.isDigit(source.charCodeAt(offset))) {
      break;
    }
  }

  return offset;
}

//  4.3.7. Consume an escaped code point
function consumeEscaped$1(source, offset) {
  // It assumes that the U+005C REVERSE SOLIDUS (\) has already been consumed and
  // that the next input code point has already been verified to be part of a valid escape.
  offset += 2;

  // hex digit
  if (charCodeDefinitions$o.isHexDigit(getCharCode$1(source, offset - 1))) {
    // Consume as many hex digits as possible, but no more than 5.
    // Note that this means 1-6 hex digits have been consumed in total.
    for (
      const maxOffset = Math.min(source.length, offset + 5);
      offset < maxOffset;
      offset++
    ) {
      if (!charCodeDefinitions$o.isHexDigit(getCharCode$1(source, offset))) {
        break;
      }
    }

    // If the next input code point is whitespace, consume it as well.
    const code = getCharCode$1(source, offset);
    if (charCodeDefinitions$o.isWhiteSpace(code)) {
      offset += getNewlineLength$1(source, offset, code);
    }
  }

  return offset;
}

// 4.3.11. Consume a name
// Note: This algorithm does not do the verification of the first few code points that are necessary
// to ensure the returned code points would constitute an <ident-token>. If that is the intended use,
// ensure that the stream starts with an identifier before calling this algorithm.
function consumeName$1(source, offset) {
  // Let result initially be an empty string.
  // Repeatedly consume the next input code point from the stream:
  for (; offset < source.length; offset++) {
    const code = source.charCodeAt(offset);

    // name code point
    if (charCodeDefinitions$o.isName(code)) {
      // Append the code point to result.
      continue;
    }

    // the stream starts with a valid escape
    if (
      charCodeDefinitions$o.isValidEscape(
        code,
        getCharCode$1(source, offset + 1),
      )
    ) {
      // Consume an escaped code point. Append the returned code point to result.
      offset = consumeEscaped$1(source, offset) - 1;
      continue;
    }

    // anything else
    // Reconsume the current input code point. Return result.
    break;
  }

  return offset;
}

// 4.3.12. Consume a number
function consumeNumber$3(source, offset) {
  let code = source.charCodeAt(offset);

  // 2. If the next input code point is U+002B PLUS SIGN (+) or U+002D HYPHEN-MINUS (-),
  // consume it and append it to repr.
  if (code === 0x002b || code === 0x002d) {
    code = source.charCodeAt((offset += 1));
  }

  // 3. While the next input code point is a digit, consume it and append it to repr.
  if (charCodeDefinitions$o.isDigit(code)) {
    offset = findDecimalNumberEnd$1(source, offset + 1);
    code = source.charCodeAt(offset);
  }

  // 4. If the next 2 input code points are U+002E FULL STOP (.) followed by a digit, then:
  if (
    code === 0x002e &&
    charCodeDefinitions$o.isDigit(source.charCodeAt(offset + 1))
  ) {
    // 4.1 Consume them.
    // 4.2 Append them to repr.
    offset += 2;

    // 4.3 Set type to "number".
    // TODO

    // 4.4 While the next input code point is a digit, consume it and append it to repr.

    offset = findDecimalNumberEnd$1(source, offset);
  }

  // 5. If the next 2 or 3 input code points are U+0045 LATIN CAPITAL LETTER E (E)
  // or U+0065 LATIN SMALL LETTER E (e), ... , followed by a digit, then:
  if (cmpChar$1(source, offset, 101 /* e */)) {
    let sign = 0;
    code = source.charCodeAt(offset + 1);

    // ... optionally followed by U+002D HYPHEN-MINUS (-) or U+002B PLUS SIGN (+) ...
    if (code === 0x002d || code === 0x002b) {
      sign = 1;
      code = source.charCodeAt(offset + 2);
    }

    // ... followed by a digit
    if (charCodeDefinitions$o.isDigit(code)) {
      // 5.1 Consume them.
      // 5.2 Append them to repr.

      // 5.3 Set type to "number".
      // TODO

      // 5.4 While the next input code point is a digit, consume it and append it to repr.
      offset = findDecimalNumberEnd$1(source, offset + 1 + sign + 1);
    }
  }

  return offset;
}

//  4.3.14. Consume the remnants of a bad url
// ... its sole use is to consume enough of the input stream to reach a recovery point
// where normal tokenizing can resume.
function consumeBadUrlRemnants$1(source, offset) {
  // Repeatedly consume the next input code point from the stream:
  for (; offset < source.length; offset++) {
    const code = source.charCodeAt(offset);

    // U+0029 RIGHT PARENTHESIS ())
    // EOF
    if (code === 0x0029) {
      // Return.
      offset++;
      break;
    }

    if (
      charCodeDefinitions$o.isValidEscape(
        code,
        getCharCode$1(source, offset + 1),
      )
    ) {
      // Consume an escaped code point.
      // Note: This allows an escaped right parenthesis ("\)") to be encountered
      // without ending the <bad-url-token>. This is otherwise identical to
      // the "anything else" clause.
      offset = consumeEscaped$1(source, offset);
    }
  }

  return offset;
}

//  4.3.7. Consume an escaped code point
// Note: This algorithm assumes that escaped is valid without leading U+005C REVERSE SOLIDUS (\)
function decodeEscaped$1(escaped) {
  // Single char escaped that's not a hex digit
  if (
    escaped.length === 1 &&
    !charCodeDefinitions$o.isHexDigit(escaped.charCodeAt(0))
  ) {
    return escaped[0];
  }

  // Interpret the hex digits as a hexadecimal number.
  let code = parseInt(escaped, 16);

  if (
    code === 0 || // If this number is zero,
    (code >= 0xd800 && code <= 0xdfff) || // or is for a surrogate,
    code > 0x10ffff // or is greater than the maximum allowed code point
  ) {
    // ... return U+FFFD REPLACEMENT CHARACTER
    code = 0xfffd;
  }

  // Otherwise, return the code point with that value.
  return String.fromCodePoint(code);
}

utils$u.cmpChar = cmpChar$1;
utils$u.cmpStr = cmpStr$1;
utils$u.consumeBadUrlRemnants = consumeBadUrlRemnants$1;
utils$u.consumeEscaped = consumeEscaped$1;
utils$u.consumeName = consumeName$1;
utils$u.consumeNumber = consumeNumber$3;
utils$u.decodeEscaped = decodeEscaped$1;
utils$u.findDecimalNumberEnd = findDecimalNumberEnd$1;
utils$u.findWhiteSpaceEnd = findWhiteSpaceEnd$1;
utils$u.findWhiteSpaceStart = findWhiteSpaceStart$1;
utils$u.getNewlineLength = getNewlineLength$1;

const tokenNames$1 = [
  "EOF-token",
  "ident-token",
  "function-token",
  "at-keyword-token",
  "hash-token",
  "string-token",
  "bad-string-token",
  "url-token",
  "bad-url-token",
  "delim-token",
  "number-token",
  "percentage-token",
  "dimension-token",
  "whitespace-token",
  "CDO-token",
  "CDC-token",
  "colon-token",
  "semicolon-token",
  "comma-token",
  "[-token",
  "]-token",
  "(-token",
  ")-token",
  "{-token",
  "}-token",
];

var names$g = tokenNames$1;

var OffsetToLocation$7 = {};

var adoptBuffer$7 = {};

const MIN_SIZE$1 = 16 * 1024;

function adoptBuffer$6(buffer = null, size) {
  if (buffer === null || buffer.length < size) {
    return new Uint32Array(Math.max(size + 1024, MIN_SIZE$1));
  }

  return buffer;
}

adoptBuffer$7.adoptBuffer = adoptBuffer$6;

const adoptBuffer$5 = adoptBuffer$7;
const charCodeDefinitions$n = charCodeDefinitions$p;

const N$9 = 10;
const F$5 = 12;
const R$5 = 13;

function computeLinesAndColumns$1(host) {
  const source = host.source;
  const sourceLength = source.length;
  const startOffset =
    source.length > 0 ? charCodeDefinitions$n.isBOM(source.charCodeAt(0)) : 0;
  const lines = adoptBuffer$5.adoptBuffer(host.lines, sourceLength);
  const columns = adoptBuffer$5.adoptBuffer(host.columns, sourceLength);
  let line = host.startLine;
  let column = host.startColumn;

  for (let i = startOffset; i < sourceLength; i++) {
    const code = source.charCodeAt(i);

    lines[i] = line;
    columns[i] = column++;

    if (code === N$9 || code === R$5 || code === F$5) {
      if (
        code === R$5 &&
        i + 1 < sourceLength &&
        source.charCodeAt(i + 1) === N$9
      ) {
        i++;
        lines[i] = line;
        columns[i] = column;
      }

      line++;
      column = 1;
    }
  }

  lines[sourceLength] = line;
  columns[sourceLength] = column;

  host.lines = lines;
  host.columns = columns;
  host.computed = true;
}

let OffsetToLocation$6 = class OffsetToLocation {
  constructor() {
    this.lines = null;
    this.columns = null;
    this.computed = false;
  }
  setSource(source, startOffset = 0, startLine = 1, startColumn = 1) {
    this.source = source;
    this.startOffset = startOffset;
    this.startLine = startLine;
    this.startColumn = startColumn;
    this.computed = false;
  }
  getLocation(offset, filename) {
    if (!this.computed) {
      computeLinesAndColumns$1(this);
    }

    return {
      source: filename,
      offset: this.startOffset + offset,
      line: this.lines[offset],
      column: this.columns[offset],
    };
  }
  getLocationRange(start, end, filename) {
    if (!this.computed) {
      computeLinesAndColumns$1(this);
    }

    return {
      source: filename,
      start: {
        offset: this.startOffset + start,
        line: this.lines[start],
        column: this.columns[start],
      },
      end: {
        offset: this.startOffset + end,
        line: this.lines[end],
        column: this.columns[end],
      },
    };
  }
};

OffsetToLocation$7.OffsetToLocation = OffsetToLocation$6;

var TokenStream$9 = {};

const adoptBuffer$4 = adoptBuffer$7;
const utils$t = utils$u;
const names$f = names$g;
const types$1L = types$1M;

const OFFSET_MASK$1 = 0x00ffffff;
const TYPE_SHIFT$1 = 24;
const balancePair$3 = new Map([
  [types$1L.Function, types$1L.RightParenthesis],
  [types$1L.LeftParenthesis, types$1L.RightParenthesis],
  [types$1L.LeftSquareBracket, types$1L.RightSquareBracket],
  [types$1L.LeftCurlyBracket, types$1L.RightCurlyBracket],
]);

let TokenStream$8 = class TokenStream {
  constructor(source, tokenize) {
    this.setSource(source, tokenize);
  }
  reset() {
    this.eof = false;
    this.tokenIndex = -1;
    this.tokenType = 0;
    this.tokenStart = this.firstCharOffset;
    this.tokenEnd = this.firstCharOffset;
  }
  setSource(source = "", tokenize = () => {}) {
    source = String(source || "");

    const sourceLength = source.length;
    const offsetAndType = adoptBuffer$4.adoptBuffer(
      this.offsetAndType,
      source.length + 1,
    ); // +1 because of eof-token
    const balance = adoptBuffer$4.adoptBuffer(this.balance, source.length + 1);
    let tokenCount = 0;
    let balanceCloseType = 0;
    let balanceStart = 0;
    let firstCharOffset = -1;

    // capture buffers
    this.offsetAndType = null;
    this.balance = null;

    tokenize(source, (type, start, end) => {
      switch (type) {
        default:
          balance[tokenCount] = sourceLength;
          break;

        case balanceCloseType: {
          let balancePrev = balanceStart & OFFSET_MASK$1;
          balanceStart = balance[balancePrev];
          balanceCloseType = balanceStart >> TYPE_SHIFT$1;
          balance[tokenCount] = balancePrev;
          balance[balancePrev++] = tokenCount;
          for (; balancePrev < tokenCount; balancePrev++) {
            if (balance[balancePrev] === sourceLength) {
              balance[balancePrev] = tokenCount;
            }
          }
          break;
        }

        case types$1L.LeftParenthesis:
        case types$1L.Function:
        case types$1L.LeftSquareBracket:
        case types$1L.LeftCurlyBracket:
          balance[tokenCount] = balanceStart;
          balanceCloseType = balancePair$3.get(type);
          balanceStart = (balanceCloseType << TYPE_SHIFT$1) | tokenCount;
          break;
      }

      offsetAndType[tokenCount++] = (type << TYPE_SHIFT$1) | end;
      if (firstCharOffset === -1) {
        firstCharOffset = start;
      }
    });

    // finalize buffers
    offsetAndType[tokenCount] = (types$1L.EOF << TYPE_SHIFT$1) | sourceLength; // <EOF-token>
    balance[tokenCount] = sourceLength;
    balance[sourceLength] = sourceLength; // prevents false positive balance match with any token
    while (balanceStart !== 0) {
      const balancePrev = balanceStart & OFFSET_MASK$1;
      balanceStart = balance[balancePrev];
      balance[balancePrev] = sourceLength;
    }

    this.source = source;
    this.firstCharOffset = firstCharOffset === -1 ? 0 : firstCharOffset;
    this.tokenCount = tokenCount;
    this.offsetAndType = offsetAndType;
    this.balance = balance;

    this.reset();
    this.next();
  }

  lookupType(offset) {
    offset += this.tokenIndex;

    if (offset < this.tokenCount) {
      return this.offsetAndType[offset] >> TYPE_SHIFT$1;
    }

    return types$1L.EOF;
  }
  lookupOffset(offset) {
    offset += this.tokenIndex;

    if (offset < this.tokenCount) {
      return this.offsetAndType[offset - 1] & OFFSET_MASK$1;
    }

    return this.source.length;
  }
  lookupValue(offset, referenceStr) {
    offset += this.tokenIndex;

    if (offset < this.tokenCount) {
      return utils$t.cmpStr(
        this.source,
        this.offsetAndType[offset - 1] & OFFSET_MASK$1,
        this.offsetAndType[offset] & OFFSET_MASK$1,
        referenceStr,
      );
    }

    return false;
  }
  getTokenStart(tokenIndex) {
    if (tokenIndex === this.tokenIndex) {
      return this.tokenStart;
    }

    if (tokenIndex > 0) {
      return tokenIndex < this.tokenCount
        ? this.offsetAndType[tokenIndex - 1] & OFFSET_MASK$1
        : this.offsetAndType[this.tokenCount] & OFFSET_MASK$1;
    }

    return this.firstCharOffset;
  }
  substrToCursor(start) {
    return this.source.substring(start, this.tokenStart);
  }

  isBalanceEdge(pos) {
    return this.balance[this.tokenIndex] < pos;
  }
  isDelim(code, offset) {
    if (offset) {
      return (
        this.lookupType(offset) === types$1L.Delim &&
        this.source.charCodeAt(this.lookupOffset(offset)) === code
      );
    }

    return (
      this.tokenType === types$1L.Delim &&
      this.source.charCodeAt(this.tokenStart) === code
    );
  }

  skip(tokenCount) {
    let next = this.tokenIndex + tokenCount;

    if (next < this.tokenCount) {
      this.tokenIndex = next;
      this.tokenStart = this.offsetAndType[next - 1] & OFFSET_MASK$1;
      next = this.offsetAndType[next];
      this.tokenType = next >> TYPE_SHIFT$1;
      this.tokenEnd = next & OFFSET_MASK$1;
    } else {
      this.tokenIndex = this.tokenCount;
      this.next();
    }
  }
  next() {
    let next = this.tokenIndex + 1;

    if (next < this.tokenCount) {
      this.tokenIndex = next;
      this.tokenStart = this.tokenEnd;
      next = this.offsetAndType[next];
      this.tokenType = next >> TYPE_SHIFT$1;
      this.tokenEnd = next & OFFSET_MASK$1;
    } else {
      this.eof = true;
      this.tokenIndex = this.tokenCount;
      this.tokenType = types$1L.EOF;
      this.tokenStart = this.tokenEnd = this.source.length;
    }
  }
  skipSC() {
    while (
      this.tokenType === types$1L.WhiteSpace ||
      this.tokenType === types$1L.Comment
    ) {
      this.next();
    }
  }
  skipUntilBalanced(startToken, stopConsume) {
    let cursor = startToken;
    let balanceEnd;
    let offset;

    loop: for (; cursor < this.tokenCount; cursor++) {
      balanceEnd = this.balance[cursor];

      // stop scanning on balance edge that points to offset before start token
      if (balanceEnd < startToken) {
        break loop;
      }

      offset =
        cursor > 0
          ? this.offsetAndType[cursor - 1] & OFFSET_MASK$1
          : this.firstCharOffset;

      // check stop condition
      switch (stopConsume(this.source.charCodeAt(offset))) {
        case 1: // just stop
          break loop;

        case 2: // stop & included
          cursor++;
          break loop;

        default:
          // fast forward to the end of balanced block
          if (this.balance[balanceEnd] === cursor) {
            cursor = balanceEnd;
          }
      }
    }

    this.skip(cursor - this.tokenIndex);
  }

  forEachToken(fn) {
    for (let i = 0, offset = this.firstCharOffset; i < this.tokenCount; i++) {
      const start = offset;
      const item = this.offsetAndType[i];
      const end = item & OFFSET_MASK$1;
      const type = item >> TYPE_SHIFT$1;

      offset = end;

      fn(type, start, end, i);
    }
  }
  dump() {
    const tokens = new Array(this.tokenCount);

    this.forEachToken((type, start, end, index) => {
      tokens[index] = {
        idx: index,
        type: names$f[type],
        chunk: this.source.substring(start, end),
        balance: this.balance[index],
      };
    });

    return tokens;
  }
};

TokenStream$9.TokenStream = TokenStream$8;

const types$1K = types$1M;
const charCodeDefinitions$m = charCodeDefinitions$p;
const utils$s = utils$u;
const names$e = names$g;
const OffsetToLocation$5 = OffsetToLocation$7;
const TokenStream$7 = TokenStream$9;

function tokenize$4(source, onToken) {
  function getCharCode(offset) {
    return offset < sourceLength ? source.charCodeAt(offset) : 0;
  }

  //  4.3.3. Consume a numeric token
  function consumeNumericToken() {
    // Consume a number and let number be the result.
    offset = utils$s.consumeNumber(source, offset);

    // If the next 3 input code points would start an identifier, then:
    if (
      charCodeDefinitions$m.isIdentifierStart(
        getCharCode(offset),
        getCharCode(offset + 1),
        getCharCode(offset + 2),
      )
    ) {
      // Create a <dimension-token> with the same value and type flag as number, and a unit set initially to the empty string.
      // Consume a name. Set the <dimension-token>s unit to the returned value.
      // Return the <dimension-token>.
      type = types$1K.Dimension;
      offset = utils$s.consumeName(source, offset);
      return;
    }

    // Otherwise, if the next input code point is U+0025 PERCENTAGE SIGN (%), consume it.
    if (getCharCode(offset) === 0x0025) {
      // Create a <percentage-token> with the same value as number, and return it.
      type = types$1K.Percentage;
      offset++;
      return;
    }

    // Otherwise, create a <number-token> with the same value and type flag as number, and return it.
    type = types$1K.Number;
  }

  //  4.3.4. Consume an ident-like token
  function consumeIdentLikeToken() {
    const nameStartOffset = offset;

    // Consume a name, and let string be the result.
    offset = utils$s.consumeName(source, offset);

    // If strings value is an ASCII case-insensitive match for "url",
    // and the next input code point is U+0028 LEFT PARENTHESIS ((), consume it.
    if (
      utils$s.cmpStr(source, nameStartOffset, offset, "url") &&
      getCharCode(offset) === 0x0028
    ) {
      // While the next two input code points are whitespace, consume the next input code point.
      offset = utils$s.findWhiteSpaceEnd(source, offset + 1);

      // If the next one or two input code points are U+0022 QUOTATION MARK ("), U+0027 APOSTROPHE ('),
      // or whitespace followed by U+0022 QUOTATION MARK (") or U+0027 APOSTROPHE ('),
      // then create a <function-token> with its value set to string and return it.
      if (getCharCode(offset) === 0x0022 || getCharCode(offset) === 0x0027) {
        type = types$1K.Function;
        offset = nameStartOffset + 4;
        return;
      }

      // Otherwise, consume a url token, and return it.
      consumeUrlToken();
      return;
    }

    // Otherwise, if the next input code point is U+0028 LEFT PARENTHESIS ((), consume it.
    // Create a <function-token> with its value set to string and return it.
    if (getCharCode(offset) === 0x0028) {
      type = types$1K.Function;
      offset++;
      return;
    }

    // Otherwise, create an <ident-token> with its value set to string and return it.
    type = types$1K.Ident;
  }

  //  4.3.5. Consume a string token
  function consumeStringToken(endingCodePoint) {
    // This algorithm may be called with an ending code point, which denotes the code point
    // that ends the string. If an ending code point is not specified,
    // the current input code point is used.
    if (!endingCodePoint) {
      endingCodePoint = getCharCode(offset++);
    }

    // Initially create a <string-token> with its value set to the empty string.
    type = types$1K.String;

    // Repeatedly consume the next input code point from the stream:
    for (; offset < source.length; offset++) {
      const code = source.charCodeAt(offset);

      switch (charCodeDefinitions$m.charCodeCategory(code)) {
        // ending code point
        case endingCodePoint:
          // Return the <string-token>.
          offset++;
          return;

        // EOF
        // case EofCategory:
        // This is a parse error. Return the <string-token>.
        // return;

        // newline
        case charCodeDefinitions$m.WhiteSpaceCategory:
          if (charCodeDefinitions$m.isNewline(code)) {
            // This is a parse error. Reconsume the current input code point,
            // create a <bad-string-token>, and return it.
            offset += utils$s.getNewlineLength(source, offset, code);
            type = types$1K.BadString;
            return;
          }
          break;

        // U+005C REVERSE SOLIDUS (\)
        case 0x005c:
          // If the next input code point is EOF, do nothing.
          if (offset === source.length - 1) {
            break;
          }

          const nextCode = getCharCode(offset + 1);

          // Otherwise, if the next input code point is a newline, consume it.
          if (charCodeDefinitions$m.isNewline(nextCode)) {
            offset += utils$s.getNewlineLength(source, offset + 1, nextCode);
          } else if (charCodeDefinitions$m.isValidEscape(code, nextCode)) {
            // Otherwise, (the stream starts with a valid escape) consume
            // an escaped code point and append the returned code point to
            // the <string-token>s value.
            offset = utils$s.consumeEscaped(source, offset) - 1;
          }
          break;

        // anything else
        // Append the current input code point to the <string-token>s value.
      }
    }
  }

  //  4.3.6. Consume a url token
  // Note: This algorithm assumes that the initial "url(" has already been consumed.
  // This algorithm also assumes that its being called to consume an "unquoted" value, like url(foo).
  // A quoted value, like url("foo"), is parsed as a <function-token>. Consume an ident-like token
  // automatically handles this distinction; this algorithm shouldnt be called directly otherwise.
  function consumeUrlToken() {
    // Initially create a <url-token> with its value set to the empty string.
    type = types$1K.Url;

    // Consume as much whitespace as possible.
    offset = utils$s.findWhiteSpaceEnd(source, offset);

    // Repeatedly consume the next input code point from the stream:
    for (; offset < source.length; offset++) {
      const code = source.charCodeAt(offset);

      switch (charCodeDefinitions$m.charCodeCategory(code)) {
        // U+0029 RIGHT PARENTHESIS ())
        case 0x0029:
          // Return the <url-token>.
          offset++;
          return;

        // EOF
        // case EofCategory:
        // This is a parse error. Return the <url-token>.
        // return;

        // whitespace
        case charCodeDefinitions$m.WhiteSpaceCategory:
          // Consume as much whitespace as possible.
          offset = utils$s.findWhiteSpaceEnd(source, offset);

          // If the next input code point is U+0029 RIGHT PARENTHESIS ()) or EOF,
          // consume it and return the <url-token>
          // (if EOF was encountered, this is a parse error);
          if (getCharCode(offset) === 0x0029 || offset >= source.length) {
            if (offset < source.length) {
              offset++;
            }
            return;
          }

          // otherwise, consume the remnants of a bad url, create a <bad-url-token>,
          // and return it.
          offset = utils$s.consumeBadUrlRemnants(source, offset);
          type = types$1K.BadUrl;
          return;

        // U+0022 QUOTATION MARK (")
        // U+0027 APOSTROPHE (')
        // U+0028 LEFT PARENTHESIS (()
        // non-printable code point
        case 0x0022:
        case 0x0027:
        case 0x0028:
        case charCodeDefinitions$m.NonPrintableCategory:
          // This is a parse error. Consume the remnants of a bad url,
          // create a <bad-url-token>, and return it.
          offset = utils$s.consumeBadUrlRemnants(source, offset);
          type = types$1K.BadUrl;
          return;

        // U+005C REVERSE SOLIDUS (\)
        case 0x005c:
          // If the stream starts with a valid escape, consume an escaped code point and
          // append the returned code point to the <url-token>s value.
          if (
            charCodeDefinitions$m.isValidEscape(code, getCharCode(offset + 1))
          ) {
            offset = utils$s.consumeEscaped(source, offset) - 1;
            break;
          }

          // Otherwise, this is a parse error. Consume the remnants of a bad url,
          // create a <bad-url-token>, and return it.
          offset = utils$s.consumeBadUrlRemnants(source, offset);
          type = types$1K.BadUrl;
          return;

        // anything else
        // Append the current input code point to the <url-token>s value.
      }
    }
  }

  // ensure source is a string
  source = String(source || "");

  const sourceLength = source.length;
  let start = charCodeDefinitions$m.isBOM(getCharCode(0));
  let offset = start;
  let type;

  // https://drafts.csswg.org/css-syntax-3/#consume-token
  //  4.3.1. Consume a token
  while (offset < sourceLength) {
    const code = source.charCodeAt(offset);

    switch (charCodeDefinitions$m.charCodeCategory(code)) {
      // whitespace
      case charCodeDefinitions$m.WhiteSpaceCategory:
        // Consume as much whitespace as possible. Return a <whitespace-token>.
        type = types$1K.WhiteSpace;
        offset = utils$s.findWhiteSpaceEnd(source, offset + 1);
        break;

      // U+0022 QUOTATION MARK (")
      case 0x0022:
        // Consume a string token and return it.
        consumeStringToken();
        break;

      // U+0023 NUMBER SIGN (#)
      case 0x0023:
        // If the next input code point is a name code point or the next two input code points are a valid escape, then:
        if (
          charCodeDefinitions$m.isName(getCharCode(offset + 1)) ||
          charCodeDefinitions$m.isValidEscape(
            getCharCode(offset + 1),
            getCharCode(offset + 2),
          )
        ) {
          // Create a <hash-token>.
          type = types$1K.Hash;

          // If the next 3 input code points would start an identifier, set the <hash-token>s type flag to "id".
          // if (isIdentifierStart(getCharCode(offset + 1), getCharCode(offset + 2), getCharCode(offset + 3))) {
          //     // TODO: set id flag
          // }

          // Consume a name, and set the <hash-token>s value to the returned string.
          offset = utils$s.consumeName(source, offset + 1);

          // Return the <hash-token>.
        } else {
          // Otherwise, return a <delim-token> with its value set to the current input code point.
          type = types$1K.Delim;
          offset++;
        }

        break;

      // U+0027 APOSTROPHE (')
      case 0x0027:
        // Consume a string token and return it.
        consumeStringToken();
        break;

      // U+0028 LEFT PARENTHESIS (()
      case 0x0028:
        // Return a <(-token>.
        type = types$1K.LeftParenthesis;
        offset++;
        break;

      // U+0029 RIGHT PARENTHESIS ())
      case 0x0029:
        // Return a <)-token>.
        type = types$1K.RightParenthesis;
        offset++;
        break;

      // U+002B PLUS SIGN (+)
      case 0x002b:
        // If the input stream starts with a number, ...
        if (
          charCodeDefinitions$m.isNumberStart(
            code,
            getCharCode(offset + 1),
            getCharCode(offset + 2),
          )
        ) {
          // ... reconsume the current input code point, consume a numeric token, and return it.
          consumeNumericToken();
        } else {
          // Otherwise, return a <delim-token> with its value set to the current input code point.
          type = types$1K.Delim;
          offset++;
        }
        break;

      // U+002C COMMA (,)
      case 0x002c:
        // Return a <comma-token>.
        type = types$1K.Comma;
        offset++;
        break;

      // U+002D HYPHEN-MINUS (-)
      case 0x002d:
        // If the input stream starts with a number, reconsume the current input code point, consume a numeric token, and return it.
        if (
          charCodeDefinitions$m.isNumberStart(
            code,
            getCharCode(offset + 1),
            getCharCode(offset + 2),
          )
        ) {
          consumeNumericToken();
        } else {
          // Otherwise, if the next 2 input code points are U+002D HYPHEN-MINUS U+003E GREATER-THAN SIGN (->), consume them and return a <CDC-token>.
          if (
            getCharCode(offset + 1) === 0x002d &&
            getCharCode(offset + 2) === 0x003e
          ) {
            type = types$1K.CDC;
            offset = offset + 3;
          } else {
            // Otherwise, if the input stream starts with an identifier, ...
            if (
              charCodeDefinitions$m.isIdentifierStart(
                code,
                getCharCode(offset + 1),
                getCharCode(offset + 2),
              )
            ) {
              // ... reconsume the current input code point, consume an ident-like token, and return it.
              consumeIdentLikeToken();
            } else {
              // Otherwise, return a <delim-token> with its value set to the current input code point.
              type = types$1K.Delim;
              offset++;
            }
          }
        }
        break;

      // U+002E FULL STOP (.)
      case 0x002e:
        // If the input stream starts with a number, ...
        if (
          charCodeDefinitions$m.isNumberStart(
            code,
            getCharCode(offset + 1),
            getCharCode(offset + 2),
          )
        ) {
          // ... reconsume the current input code point, consume a numeric token, and return it.
          consumeNumericToken();
        } else {
          // Otherwise, return a <delim-token> with its value set to the current input code point.
          type = types$1K.Delim;
          offset++;
        }

        break;

      // U+002F SOLIDUS (/)
      case 0x002f:
        // If the next two input code point are U+002F SOLIDUS (/) followed by a U+002A ASTERISK (*),
        if (getCharCode(offset + 1) === 0x002a) {
          // ... consume them and all following code points up to and including the first U+002A ASTERISK (*)
          // followed by a U+002F SOLIDUS (/), or up to an EOF code point.
          type = types$1K.Comment;
          offset = source.indexOf("*/", offset + 2);
          offset = offset === -1 ? source.length : offset + 2;
        } else {
          type = types$1K.Delim;
          offset++;
        }
        break;

      // U+003A COLON (:)
      case 0x003a:
        // Return a <colon-token>.
        type = types$1K.Colon;
        offset++;
        break;

      // U+003B SEMICOLON (;)
      case 0x003b:
        // Return a <semicolon-token>.
        type = types$1K.Semicolon;
        offset++;
        break;

      // U+003C LESS-THAN SIGN (<)
      case 0x003c:
        // If the next 3 input code points are U+0021 EXCLAMATION MARK U+002D HYPHEN-MINUS U+002D HYPHEN-MINUS (!--), ...
        if (
          getCharCode(offset + 1) === 0x0021 &&
          getCharCode(offset + 2) === 0x002d &&
          getCharCode(offset + 3) === 0x002d
        ) {
          // ... consume them and return a <CDO-token>.
          type = types$1K.CDO;
          offset = offset + 4;
        } else {
          // Otherwise, return a <delim-token> with its value set to the current input code point.
          type = types$1K.Delim;
          offset++;
        }

        break;

      // U+0040 COMMERCIAL AT (@)
      case 0x0040:
        // If the next 3 input code points would start an identifier, ...
        if (
          charCodeDefinitions$m.isIdentifierStart(
            getCharCode(offset + 1),
            getCharCode(offset + 2),
            getCharCode(offset + 3),
          )
        ) {
          // ... consume a name, create an <at-keyword-token> with its value set to the returned value, and return it.
          type = types$1K.AtKeyword;
          offset = utils$s.consumeName(source, offset + 1);
        } else {
          // Otherwise, return a <delim-token> with its value set to the current input code point.
          type = types$1K.Delim;
          offset++;
        }

        break;

      // U+005B LEFT SQUARE BRACKET ([)
      case 0x005b:
        // Return a <[-token>.
        type = types$1K.LeftSquareBracket;
        offset++;
        break;

      // U+005C REVERSE SOLIDUS (\)
      case 0x005c:
        // If the input stream starts with a valid escape, ...
        if (
          charCodeDefinitions$m.isValidEscape(code, getCharCode(offset + 1))
        ) {
          // ... reconsume the current input code point, consume an ident-like token, and return it.
          consumeIdentLikeToken();
        } else {
          // Otherwise, this is a parse error. Return a <delim-token> with its value set to the current input code point.
          type = types$1K.Delim;
          offset++;
        }
        break;

      // U+005D RIGHT SQUARE BRACKET (])
      case 0x005d:
        // Return a <]-token>.
        type = types$1K.RightSquareBracket;
        offset++;
        break;

      // U+007B LEFT CURLY BRACKET ({)
      case 0x007b:
        // Return a <{-token>.
        type = types$1K.LeftCurlyBracket;
        offset++;
        break;

      // U+007D RIGHT CURLY BRACKET (})
      case 0x007d:
        // Return a <}-token>.
        type = types$1K.RightCurlyBracket;
        offset++;
        break;

      // digit
      case charCodeDefinitions$m.DigitCategory:
        // Reconsume the current input code point, consume a numeric token, and return it.
        consumeNumericToken();
        break;

      // name-start code point
      case charCodeDefinitions$m.NameStartCategory:
        // Reconsume the current input code point, consume an ident-like token, and return it.
        consumeIdentLikeToken();
        break;

      // EOF
      // case EofCategory:
      // Return an <EOF-token>.
      // break;

      // anything else
      default:
        // Return a <delim-token> with its value set to the current input code point.
        type = types$1K.Delim;
        offset++;
    }

    // put token to stream
    onToken(type, start, (start = offset));
  }
}

tokenizer$5.AtKeyword = types$1K.AtKeyword;
tokenizer$5.BadString = types$1K.BadString;
tokenizer$5.BadUrl = types$1K.BadUrl;
tokenizer$5.CDC = types$1K.CDC;
tokenizer$5.CDO = types$1K.CDO;
tokenizer$5.Colon = types$1K.Colon;
tokenizer$5.Comma = types$1K.Comma;
tokenizer$5.Comment = types$1K.Comment;
tokenizer$5.Delim = types$1K.Delim;
tokenizer$5.Dimension = types$1K.Dimension;
tokenizer$5.EOF = types$1K.EOF;
tokenizer$5.Function = types$1K.Function;
tokenizer$5.Hash = types$1K.Hash;
tokenizer$5.Ident = types$1K.Ident;
tokenizer$5.LeftCurlyBracket = types$1K.LeftCurlyBracket;
tokenizer$5.LeftParenthesis = types$1K.LeftParenthesis;
tokenizer$5.LeftSquareBracket = types$1K.LeftSquareBracket;
tokenizer$5.Number = types$1K.Number;
tokenizer$5.Percentage = types$1K.Percentage;
tokenizer$5.RightCurlyBracket = types$1K.RightCurlyBracket;
tokenizer$5.RightParenthesis = types$1K.RightParenthesis;
tokenizer$5.RightSquareBracket = types$1K.RightSquareBracket;
tokenizer$5.Semicolon = types$1K.Semicolon;
tokenizer$5.String = types$1K.String;
tokenizer$5.Url = types$1K.Url;
tokenizer$5.WhiteSpace = types$1K.WhiteSpace;
tokenizer$5.tokenTypes = types$1K;
tokenizer$5.DigitCategory = charCodeDefinitions$m.DigitCategory;
tokenizer$5.EofCategory = charCodeDefinitions$m.EofCategory;
tokenizer$5.NameStartCategory = charCodeDefinitions$m.NameStartCategory;
tokenizer$5.NonPrintableCategory = charCodeDefinitions$m.NonPrintableCategory;
tokenizer$5.WhiteSpaceCategory = charCodeDefinitions$m.WhiteSpaceCategory;
tokenizer$5.charCodeCategory = charCodeDefinitions$m.charCodeCategory;
tokenizer$5.isBOM = charCodeDefinitions$m.isBOM;
tokenizer$5.isDigit = charCodeDefinitions$m.isDigit;
tokenizer$5.isHexDigit = charCodeDefinitions$m.isHexDigit;
tokenizer$5.isIdentifierStart = charCodeDefinitions$m.isIdentifierStart;
tokenizer$5.isLetter = charCodeDefinitions$m.isLetter;
tokenizer$5.isLowercaseLetter = charCodeDefinitions$m.isLowercaseLetter;
tokenizer$5.isName = charCodeDefinitions$m.isName;
tokenizer$5.isNameStart = charCodeDefinitions$m.isNameStart;
tokenizer$5.isNewline = charCodeDefinitions$m.isNewline;
tokenizer$5.isNonAscii = charCodeDefinitions$m.isNonAscii;
tokenizer$5.isNonPrintable = charCodeDefinitions$m.isNonPrintable;
tokenizer$5.isNumberStart = charCodeDefinitions$m.isNumberStart;
tokenizer$5.isUppercaseLetter = charCodeDefinitions$m.isUppercaseLetter;
tokenizer$5.isValidEscape = charCodeDefinitions$m.isValidEscape;
tokenizer$5.isWhiteSpace = charCodeDefinitions$m.isWhiteSpace;
tokenizer$5.cmpChar = utils$s.cmpChar;
tokenizer$5.cmpStr = utils$s.cmpStr;
tokenizer$5.consumeBadUrlRemnants = utils$s.consumeBadUrlRemnants;
tokenizer$5.consumeEscaped = utils$s.consumeEscaped;
tokenizer$5.consumeName = utils$s.consumeName;
tokenizer$5.consumeNumber = utils$s.consumeNumber;
tokenizer$5.decodeEscaped = utils$s.decodeEscaped;
tokenizer$5.findDecimalNumberEnd = utils$s.findDecimalNumberEnd;
tokenizer$5.findWhiteSpaceEnd = utils$s.findWhiteSpaceEnd;
tokenizer$5.findWhiteSpaceStart = utils$s.findWhiteSpaceStart;
tokenizer$5.getNewlineLength = utils$s.getNewlineLength;
tokenizer$5.tokenNames = names$e;
tokenizer$5.OffsetToLocation = OffsetToLocation$5.OffsetToLocation;
tokenizer$5.TokenStream = TokenStream$7.TokenStream;
tokenizer$5.tokenize = tokenize$4;

var create$e = {};

var List$f = {};

//
//                              list
//                            
//             head 
//                            tail
//                                         
//                                                 
//            item        item        item        item
//                      
//  null prev prev prev prev 
//           next next next next null
//                      
//           data      data      data      data 
//                      
//

let releasedCursors$1 = null;

let List$e = class List {
  static createItem(data) {
    return {
      prev: null,
      next: null,
      data,
    };
  }

  constructor() {
    this.head = null;
    this.tail = null;
    this.cursor = null;
  }
  createItem(data) {
    return List.createItem(data);
  }

  // cursor helpers
  allocateCursor(prev, next) {
    let cursor;

    if (releasedCursors$1 !== null) {
      cursor = releasedCursors$1;
      releasedCursors$1 = releasedCursors$1.cursor;
      cursor.prev = prev;
      cursor.next = next;
      cursor.cursor = this.cursor;
    } else {
      cursor = {
        prev,
        next,
        cursor: this.cursor,
      };
    }

    this.cursor = cursor;

    return cursor;
  }
  releaseCursor() {
    const { cursor } = this;

    this.cursor = cursor.cursor;
    cursor.prev = null;
    cursor.next = null;
    cursor.cursor = releasedCursors$1;
    releasedCursors$1 = cursor;
  }
  updateCursors(prevOld, prevNew, nextOld, nextNew) {
    let { cursor } = this;

    while (cursor !== null) {
      if (cursor.prev === prevOld) {
        cursor.prev = prevNew;
      }

      if (cursor.next === nextOld) {
        cursor.next = nextNew;
      }

      cursor = cursor.cursor;
    }
  }
  *[Symbol.iterator]() {
    for (let cursor = this.head; cursor !== null; cursor = cursor.next) {
      yield cursor.data;
    }
  }

  // getters
  get size() {
    let size = 0;

    for (let cursor = this.head; cursor !== null; cursor = cursor.next) {
      size++;
    }

    return size;
  }
  get isEmpty() {
    return this.head === null;
  }
  get first() {
    return this.head && this.head.data;
  }
  get last() {
    return this.tail && this.tail.data;
  }

  // convertors
  fromArray(array) {
    let cursor = null;
    this.head = null;

    for (let data of array) {
      const item = List.createItem(data);

      if (cursor !== null) {
        cursor.next = item;
      } else {
        this.head = item;
      }

      item.prev = cursor;
      cursor = item;
    }

    this.tail = cursor;
    return this;
  }
  toArray() {
    return [...this];
  }
  toJSON() {
    return [...this];
  }

  // array-like methods
  forEach(fn, thisArg = this) {
    // push cursor
    const cursor = this.allocateCursor(null, this.head);

    while (cursor.next !== null) {
      const item = cursor.next;
      cursor.next = item.next;
      fn.call(thisArg, item.data, item, this);
    }

    // pop cursor
    this.releaseCursor();
  }
  forEachRight(fn, thisArg = this) {
    // push cursor
    const cursor = this.allocateCursor(this.tail, null);

    while (cursor.prev !== null) {
      const item = cursor.prev;
      cursor.prev = item.prev;
      fn.call(thisArg, item.data, item, this);
    }

    // pop cursor
    this.releaseCursor();
  }
  reduce(fn, initialValue, thisArg = this) {
    // push cursor
    let cursor = this.allocateCursor(null, this.head);
    let acc = initialValue;
    let item;

    while (cursor.next !== null) {
      item = cursor.next;
      cursor.next = item.next;

      acc = fn.call(thisArg, acc, item.data, item, this);
    }

    // pop cursor
    this.releaseCursor();

    return acc;
  }
  reduceRight(fn, initialValue, thisArg = this) {
    // push cursor
    let cursor = this.allocateCursor(this.tail, null);
    let acc = initialValue;
    let item;

    while (cursor.prev !== null) {
      item = cursor.prev;
      cursor.prev = item.prev;

      acc = fn.call(thisArg, acc, item.data, item, this);
    }

    // pop cursor
    this.releaseCursor();

    return acc;
  }
  some(fn, thisArg = this) {
    for (let cursor = this.head; cursor !== null; cursor = cursor.next) {
      if (fn.call(thisArg, cursor.data, cursor, this)) {
        return true;
      }
    }

    return false;
  }
  map(fn, thisArg = this) {
    const result = new List();

    for (let cursor = this.head; cursor !== null; cursor = cursor.next) {
      result.appendData(fn.call(thisArg, cursor.data, cursor, this));
    }

    return result;
  }
  filter(fn, thisArg = this) {
    const result = new List();

    for (let cursor = this.head; cursor !== null; cursor = cursor.next) {
      if (fn.call(thisArg, cursor.data, cursor, this)) {
        result.appendData(cursor.data);
      }
    }

    return result;
  }

  nextUntil(start, fn, thisArg = this) {
    if (start === null) {
      return;
    }

    // push cursor
    const cursor = this.allocateCursor(null, start);

    while (cursor.next !== null) {
      const item = cursor.next;
      cursor.next = item.next;
      if (fn.call(thisArg, item.data, item, this)) {
        break;
      }
    }

    // pop cursor
    this.releaseCursor();
  }
  prevUntil(start, fn, thisArg = this) {
    if (start === null) {
      return;
    }

    // push cursor
    const cursor = this.allocateCursor(start, null);

    while (cursor.prev !== null) {
      const item = cursor.prev;
      cursor.prev = item.prev;
      if (fn.call(thisArg, item.data, item, this)) {
        break;
      }
    }

    // pop cursor
    this.releaseCursor();
  }

  // mutation
  clear() {
    this.head = null;
    this.tail = null;
  }
  copy() {
    const result = new List();

    for (let data of this) {
      result.appendData(data);
    }

    return result;
  }
  prepend(item) {
    //      head
    //    ^
    // item
    this.updateCursors(null, item, this.head, item);

    // insert to the beginning of the list
    if (this.head !== null) {
      // new item <- first item
      this.head.prev = item;
      // new item -> first item
      item.next = this.head;
    } else {
      // if list has no head, then it also has no tail
      // in this case tail points to the new item
      this.tail = item;
    }

    // head always points to new item
    this.head = item;
    return this;
  }
  prependData(data) {
    return this.prepend(List.createItem(data));
  }
  append(item) {
    return this.insert(item);
  }
  appendData(data) {
    return this.insert(List.createItem(data));
  }
  insert(item, before = null) {
    if (before !== null) {
      // prev   before
      //      ^
      //     item
      this.updateCursors(before.prev, item, before, item);

      if (before.prev === null) {
        // insert to the beginning of list
        if (this.head !== before) {
          throw new Error("before doesn't belong to list");
        }
        // since head points to before therefore list doesn't empty
        // no need to check tail
        this.head = item;
        before.prev = item;
        item.next = before;
        this.updateCursors(null, item);
      } else {
        // insert between two items
        before.prev.next = item;
        item.prev = before.prev;
        before.prev = item;
        item.next = before;
      }
    } else {
      // tail
      //      ^
      //      item
      this.updateCursors(this.tail, item, null, item);

      // insert to the ending of the list
      if (this.tail !== null) {
        // last item -> new item
        this.tail.next = item;
        // last item <- new item
        item.prev = this.tail;
      } else {
        // if list has no tail, then it also has no head
        // in this case head points to new item
        this.head = item;
      }

      // tail always points to new item
      this.tail = item;
    }

    return this;
  }
  insertData(data, before) {
    return this.insert(List.createItem(data), before);
  }
  remove(item) {
    //      item
    //       ^
    // prev     next
    this.updateCursors(item, item.prev, item, item.next);

    if (item.prev !== null) {
      item.prev.next = item.next;
    } else {
      if (this.head !== item) {
        throw new Error("item doesn't belong to list");
      }

      this.head = item.next;
    }

    if (item.next !== null) {
      item.next.prev = item.prev;
    } else {
      if (this.tail !== item) {
        throw new Error("item doesn't belong to list");
      }

      this.tail = item.prev;
    }

    item.prev = null;
    item.next = null;

    return item;
  }
  push(data) {
    this.insert(List.createItem(data));
  }
  pop() {
    return this.tail !== null ? this.remove(this.tail) : null;
  }
  unshift(data) {
    this.prepend(List.createItem(data));
  }
  shift() {
    return this.head !== null ? this.remove(this.head) : null;
  }
  prependList(list) {
    return this.insertList(list, this.head);
  }
  appendList(list) {
    return this.insertList(list);
  }
  insertList(list, before) {
    // ignore empty lists
    if (list.head === null) {
      return this;
    }

    if (before !== undefined && before !== null) {
      this.updateCursors(before.prev, list.tail, before, list.head);

      // insert in the middle of dist list
      if (before.prev !== null) {
        // before.prev <-> list.head
        before.prev.next = list.head;
        list.head.prev = before.prev;
      } else {
        this.head = list.head;
      }

      before.prev = list.tail;
      list.tail.next = before;
    } else {
      this.updateCursors(this.tail, list.tail, null, list.head);

      // insert to end of the list
      if (this.tail !== null) {
        // if destination list has a tail, then it also has a head,
        // but head doesn't change
        // dest tail -> source head
        this.tail.next = list.head;
        // dest tail <- source head
        list.head.prev = this.tail;
      } else {
        // if list has no a tail, then it also has no a head
        // in this case points head to new item
        this.head = list.head;
      }

      // tail always start point to new item
      this.tail = list.tail;
    }

    list.head = null;
    list.tail = null;
    return this;
  }
  replace(oldItem, newItemOrList) {
    if ("head" in newItemOrList) {
      this.insertList(newItemOrList, oldItem);
    } else {
      this.insert(newItemOrList, oldItem);
    }

    this.remove(oldItem);
  }
};

List$f.List = List$e;

var _SyntaxError$3 = {};

var createCustomError$9 = {};

function createCustomError$8(name, message) {
  // use Object.create(), because some VMs prevent setting line/column otherwise
  // (iOS Safari 10 even throws an exception)
  const error = Object.create(SyntaxError.prototype);
  const errorStack = new Error();

  return Object.assign(error, {
    name,
    message,
    get stack() {
      return (errorStack.stack || "").replace(
        /^(.+\n){1,3}/,
        `${name}: ${message}\n`,
      );
    },
  });
}

createCustomError$9.createCustomError = createCustomError$8;

const createCustomError$7 = createCustomError$9;

const MAX_LINE_LENGTH$1 = 100;
const OFFSET_CORRECTION$1 = 60;
const TAB_REPLACEMENT$1 = "    ";

function sourceFragment$1({ source, line, column }, extraLines) {
  function processLines(start, end) {
    return lines
      .slice(start, end)
      .map(
        (line, idx) =>
          String(start + idx + 1).padStart(maxNumLength) + " |" + line,
      )
      .join("\n");
  }

  const lines = source.split(/\r\n?|\n|\f/);
  const startLine = Math.max(1, line - extraLines) - 1;
  const endLine = Math.min(line + extraLines, lines.length + 1);
  const maxNumLength = Math.max(4, String(endLine).length) + 1;
  let cutLeft = 0;

  // column correction according to replaced tab before column
  column +=
    (TAB_REPLACEMENT$1.length - 1) *
    (lines[line - 1].substr(0, column - 1).match(/\t/g) || []).length;

  if (column > MAX_LINE_LENGTH$1) {
    cutLeft = column - OFFSET_CORRECTION$1 + 3;
    column = OFFSET_CORRECTION$1 - 2;
  }

  for (let i = startLine; i <= endLine; i++) {
    if (i >= 0 && i < lines.length) {
      lines[i] = lines[i].replace(/\t/g, TAB_REPLACEMENT$1);
      lines[i] =
        (cutLeft > 0 && lines[i].length > cutLeft ? "\u2026" : "") +
        lines[i].substr(cutLeft, MAX_LINE_LENGTH$1 - 2) +
        (lines[i].length > cutLeft + MAX_LINE_LENGTH$1 - 1 ? "\u2026" : "");
    }
  }

  return [
    processLines(startLine, line),
    new Array(column + maxNumLength + 2).join("-") + "^",
    processLines(line, endLine),
  ]
    .filter(Boolean)
    .join("\n");
}

function SyntaxError$a(message, source, offset, line, column) {
  const error = Object.assign(
    createCustomError$7.createCustomError("SyntaxError", message),
    {
      source,
      offset,
      line,
      column,
      sourceFragment(extraLines) {
        return sourceFragment$1(
          { source, line, column },
          isNaN(extraLines) ? 0 : extraLines,
        );
      },
      get formattedMessage() {
        return (
          `Parse error: ${message}\n` +
          sourceFragment$1({ source, line, column }, 2)
        );
      },
    },
  );

  return error;
}

_SyntaxError$3.SyntaxError = SyntaxError$a;

var sequence$3 = {};

const types$1J = types$1M;

function readSequence$3(recognizer) {
  const children = this.createList();
  let space = false;
  const context = {
    recognizer,
  };

  while (!this.eof) {
    switch (this.tokenType) {
      case types$1J.Comment:
        this.next();
        continue;

      case types$1J.WhiteSpace:
        space = true;
        this.next();
        continue;
    }

    let child = recognizer.getNode.call(this, context);

    if (child === undefined) {
      break;
    }

    if (space) {
      if (recognizer.onWhiteSpace) {
        recognizer.onWhiteSpace.call(this, child, children, context);
      }
      space = false;
    }

    children.push(child);
  }

  if (space && recognizer.onWhiteSpace) {
    recognizer.onWhiteSpace.call(this, null, children, context);
  }

  return children;
}

sequence$3.readSequence = readSequence$3;

const List$d = List$f;
const SyntaxError$9 = _SyntaxError$3;
const index$j = tokenizer$5;
const sequence$2 = sequence$3;
const OffsetToLocation$4 = OffsetToLocation$7;
const TokenStream$6 = TokenStream$9;
const utils$r = utils$u;
const types$1I = types$1M;
const names$d = names$g;

const NOOP$1 = () => {};
const EXCLAMATIONMARK$7 = 0x0021; // U+0021 EXCLAMATION MARK (!)
const NUMBERSIGN$9 = 0x0023; // U+0023 NUMBER SIGN (#)
const SEMICOLON$1 = 0x003b; // U+003B SEMICOLON (;)
const LEFTCURLYBRACKET$3 = 0x007b; // U+007B LEFT CURLY BRACKET ({)
const NULL$1 = 0;

function createParseContext$1(name) {
  return function () {
    return this[name]();
  };
}

function fetchParseValues$1(dict) {
  const result = Object.create(null);

  for (const name in dict) {
    const item = dict[name];
    const fn = item.parse || item;

    if (fn) {
      result[name] = fn;
    }
  }

  return result;
}

function processConfig$1(config) {
  const parseConfig = {
    context: Object.create(null),
    scope: Object.assign(Object.create(null), config.scope),
    atrule: fetchParseValues$1(config.atrule),
    pseudo: fetchParseValues$1(config.pseudo),
    node: fetchParseValues$1(config.node),
  };

  for (const name in config.parseContext) {
    switch (typeof config.parseContext[name]) {
      case "function":
        parseConfig.context[name] = config.parseContext[name];
        break;

      case "string":
        parseConfig.context[name] = createParseContext$1(
          config.parseContext[name],
        );
        break;
    }
  }

  return {
    config: parseConfig,
    ...parseConfig,
    ...parseConfig.node,
  };
}

function createParser$1(config) {
  let source = "";
  let filename = "<unknown>";
  let needPositions = false;
  let onParseError = NOOP$1;
  let onParseErrorThrow = false;

  const locationMap = new OffsetToLocation$4.OffsetToLocation();
  const parser = Object.assign(
    new TokenStream$6.TokenStream(),
    processConfig$1(config || {}),
    {
      parseAtrulePrelude: true,
      parseRulePrelude: true,
      parseValue: true,
      parseCustomProperty: false,

      readSequence: sequence$2.readSequence,

      consumeUntilBalanceEnd: () => 0,
      consumeUntilLeftCurlyBracket(code) {
        return code === LEFTCURLYBRACKET$3 ? 1 : 0;
      },
      consumeUntilLeftCurlyBracketOrSemicolon(code) {
        return code === LEFTCURLYBRACKET$3 || code === SEMICOLON$1 ? 1 : 0;
      },
      consumeUntilExclamationMarkOrSemicolon(code) {
        return code === EXCLAMATIONMARK$7 || code === SEMICOLON$1 ? 1 : 0;
      },
      consumeUntilSemicolonIncluded(code) {
        return code === SEMICOLON$1 ? 2 : 0;
      },

      createList() {
        return new List$d.List();
      },
      createSingleNodeList(node) {
        return new List$d.List().appendData(node);
      },
      getFirstListNode(list) {
        return list && list.first;
      },
      getLastListNode(list) {
        return list && list.last;
      },

      parseWithFallback(consumer, fallback) {
        const startToken = this.tokenIndex;

        try {
          return consumer.call(this);
        } catch (e) {
          if (onParseErrorThrow) {
            throw e;
          }

          const fallbackNode = fallback.call(this, startToken);

          onParseErrorThrow = true;
          onParseError(e, fallbackNode);
          onParseErrorThrow = false;

          return fallbackNode;
        }
      },

      lookupNonWSType(offset) {
        let type;

        do {
          type = this.lookupType(offset++);
          if (type !== types$1I.WhiteSpace) {
            return type;
          }
        } while (type !== NULL$1);

        return NULL$1;
      },

      charCodeAt(offset) {
        return offset >= 0 && offset < source.length
          ? source.charCodeAt(offset)
          : 0;
      },
      substring(offsetStart, offsetEnd) {
        return source.substring(offsetStart, offsetEnd);
      },
      substrToCursor(start) {
        return this.source.substring(start, this.tokenStart);
      },

      cmpChar(offset, charCode) {
        return utils$r.cmpChar(source, offset, charCode);
      },
      cmpStr(offsetStart, offsetEnd, str) {
        return utils$r.cmpStr(source, offsetStart, offsetEnd, str);
      },

      consume(tokenType) {
        const start = this.tokenStart;

        this.eat(tokenType);

        return this.substrToCursor(start);
      },
      consumeFunctionName() {
        const name = source.substring(this.tokenStart, this.tokenEnd - 1);

        this.eat(types$1I.Function);

        return name;
      },
      consumeNumber(type) {
        const number = source.substring(
          this.tokenStart,
          utils$r.consumeNumber(source, this.tokenStart),
        );

        this.eat(type);

        return number;
      },

      eat(tokenType) {
        if (this.tokenType !== tokenType) {
          const tokenName = names$d[tokenType]
            .slice(0, -6)
            .replace(/-/g, " ")
            .replace(/^./, (m) => m.toUpperCase());
          let message = `${
            /[[\](){}]/.test(tokenName) ? `"${tokenName}"` : tokenName
          } is expected`;
          let offset = this.tokenStart;

          // tweak message and offset
          switch (tokenType) {
            case types$1I.Ident:
              // when identifier is expected but there is a function or url
              if (
                this.tokenType === types$1I.Function ||
                this.tokenType === types$1I.Url
              ) {
                offset = this.tokenEnd - 1;
                message = "Identifier is expected but function found";
              } else {
                message = "Identifier is expected";
              }
              break;

            case types$1I.Hash:
              if (this.isDelim(NUMBERSIGN$9)) {
                this.next();
                offset++;
                message = "Name is expected";
              }
              break;

            case types$1I.Percentage:
              if (this.tokenType === types$1I.Number) {
                offset = this.tokenEnd;
                message = "Percent sign is expected";
              }
              break;
          }

          this.error(message, offset);
        }

        this.next();
      },
      eatIdent(name) {
        if (
          this.tokenType !== types$1I.Ident ||
          this.lookupValue(0, name) === false
        ) {
          this.error(`Identifier "${name}" is expected`);
        }

        this.next();
      },
      eatDelim(code) {
        if (!this.isDelim(code)) {
          this.error(`Delim "${String.fromCharCode(code)}" is expected`);
        }

        this.next();
      },

      getLocation(start, end) {
        if (needPositions) {
          return locationMap.getLocationRange(start, end, filename);
        }

        return null;
      },
      getLocationFromList(list) {
        if (needPositions) {
          const head = this.getFirstListNode(list);
          const tail = this.getLastListNode(list);
          return locationMap.getLocationRange(
            head !== null
              ? head.loc.start.offset - locationMap.startOffset
              : this.tokenStart,
            tail !== null
              ? tail.loc.end.offset - locationMap.startOffset
              : this.tokenStart,
            filename,
          );
        }

        return null;
      },

      error(message, offset) {
        const location =
          typeof offset !== "undefined" && offset < source.length
            ? locationMap.getLocation(offset)
            : this.eof
              ? locationMap.getLocation(
                  utils$r.findWhiteSpaceStart(source, source.length - 1),
                )
              : locationMap.getLocation(this.tokenStart);

        throw new SyntaxError$9.SyntaxError(
          message || "Unexpected input",
          source,
          location.offset,
          location.line,
          location.column,
        );
      },
    },
  );

  const parse = function (source_, options) {
    source = source_;
    options = options || {};

    parser.setSource(source, index$j.tokenize);
    locationMap.setSource(source, options.offset, options.line, options.column);

    filename = options.filename || "<unknown>";
    needPositions = Boolean(options.positions);
    onParseError =
      typeof options.onParseError === "function"
        ? options.onParseError
        : NOOP$1;
    onParseErrorThrow = false;

    parser.parseAtrulePrelude =
      "parseAtrulePrelude" in options
        ? Boolean(options.parseAtrulePrelude)
        : true;
    parser.parseRulePrelude =
      "parseRulePrelude" in options ? Boolean(options.parseRulePrelude) : true;
    parser.parseValue =
      "parseValue" in options ? Boolean(options.parseValue) : true;
    parser.parseCustomProperty =
      "parseCustomProperty" in options
        ? Boolean(options.parseCustomProperty)
        : false;

    const { context = "default", onComment } = options;

    if (context in parser.context === false) {
      throw new Error("Unknown context `" + context + "`");
    }

    if (typeof onComment === "function") {
      parser.forEachToken((type, start, end) => {
        if (type === types$1I.Comment) {
          const loc = parser.getLocation(start, end);
          const value = utils$r.cmpStr(source, end - 2, end, "*/")
            ? source.slice(start + 2, end - 2)
            : source.slice(start + 2, end);

          onComment(value, loc);
        }
      });
    }

    const ast = parser.context[context].call(parser, options);

    if (!parser.eof) {
      parser.error();
    }

    return ast;
  };

  return Object.assign(parse, {
    SyntaxError: SyntaxError$9.SyntaxError,
    config: parser.config,
  });
}

create$e.createParser = createParser$1;

var create$d = {};

var sourceMap$3 = {};

var sourceMapGenerator = {};

var base64Vlq = {};

var base64$1 = {};

/* -*- Mode: js; js-indent-level: 2; -*- */

/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

var intToCharMap =
  "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".split("");

/**
 * Encode an integer in the range of 0 to 63 to a single base 64 digit.
 */
base64$1.encode = function (number) {
  if (0 <= number && number < intToCharMap.length) {
    return intToCharMap[number];
  }
  throw new TypeError("Must be between 0 and 63: " + number);
};

/**
 * Decode a single base 64 character code digit to an integer. Returns -1 on
 * failure.
 */
base64$1.decode = function (charCode) {
  var bigA = 65; // 'A'
  var bigZ = 90; // 'Z'

  var littleA = 97; // 'a'
  var littleZ = 122; // 'z'

  var zero = 48; // '0'
  var nine = 57; // '9'

  var plus = 43; // '+'
  var slash = 47; // '/'

  var littleOffset = 26;
  var numberOffset = 52;

  // 0 - 25: ABCDEFGHIJKLMNOPQRSTUVWXYZ
  if (bigA <= charCode && charCode <= bigZ) {
    return charCode - bigA;
  }

  // 26 - 51: abcdefghijklmnopqrstuvwxyz
  if (littleA <= charCode && charCode <= littleZ) {
    return charCode - littleA + littleOffset;
  }

  // 52 - 61: 0123456789
  if (zero <= charCode && charCode <= nine) {
    return charCode - zero + numberOffset;
  }

  // 62: +
  if (charCode == plus) {
    return 62;
  }

  // 63: /
  if (charCode == slash) {
    return 63;
  }

  // Invalid base64 digit.
  return -1;
};

/* -*- Mode: js; js-indent-level: 2; -*- */

/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 *
 * Based on the Base 64 VLQ implementation in Closure Compiler:
 * https://code.google.com/p/closure-compiler/source/browse/trunk/src/com/google/debugging/sourcemap/Base64VLQ.java
 *
 * Copyright 2011 The Closure Compiler Authors. All rights reserved.
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *  * Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *  * Redistributions in binary form must reproduce the above
 *    copyright notice, this list of conditions and the following
 *    disclaimer in the documentation and/or other materials provided
 *    with the distribution.
 *  * Neither the name of Google Inc. nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

var base64 = base64$1;

// A single base 64 digit can contain 6 bits of data. For the base 64 variable
// length quantities we use in the source map spec, the first bit is the sign,
// the next four bits are the actual value, and the 6th bit is the
// continuation bit. The continuation bit tells us whether there are more
// digits in this value following this digit.
//
//   Continuation
//   |    Sign
//   |    |
//   V    V
//   101011

var VLQ_BASE_SHIFT = 5;

// binary: 100000
var VLQ_BASE = 1 << VLQ_BASE_SHIFT;

// binary: 011111
var VLQ_BASE_MASK = VLQ_BASE - 1;

// binary: 100000
var VLQ_CONTINUATION_BIT = VLQ_BASE;

/**
 * Converts from a two-complement value to a value where the sign bit is
 * placed in the least significant bit.  For example, as decimals:
 *   1 becomes 2 (10 binary), -1 becomes 3 (11 binary)
 *   2 becomes 4 (100 binary), -2 becomes 5 (101 binary)
 */
function toVLQSigned(aValue) {
  return aValue < 0 ? (-aValue << 1) + 1 : (aValue << 1) + 0;
}

/**
 * Converts to a two-complement value from a value where the sign bit is
 * placed in the least significant bit.  For example, as decimals:
 *   2 (10 binary) becomes 1, 3 (11 binary) becomes -1
 *   4 (100 binary) becomes 2, 5 (101 binary) becomes -2
 */
function fromVLQSigned(aValue) {
  var isNegative = (aValue & 1) === 1;
  var shifted = aValue >> 1;
  return isNegative ? -shifted : shifted;
}

/**
 * Returns the base 64 VLQ encoded value.
 */
base64Vlq.encode = function base64VLQ_encode(aValue) {
  var encoded = "";
  var digit;

  var vlq = toVLQSigned(aValue);

  do {
    digit = vlq & VLQ_BASE_MASK;
    vlq >>>= VLQ_BASE_SHIFT;
    if (vlq > 0) {
      // There are still more digits in this value, so we must make sure the
      // continuation bit is marked.
      digit |= VLQ_CONTINUATION_BIT;
    }
    encoded += base64.encode(digit);
  } while (vlq > 0);

  return encoded;
};

/**
 * Decodes the next base 64 VLQ value from the given string and returns the
 * value and the rest of the string via the out parameter.
 */
base64Vlq.decode = function base64VLQ_decode(aStr, aIndex, aOutParam) {
  var strLen = aStr.length;
  var result = 0;
  var shift = 0;
  var continuation, digit;

  do {
    if (aIndex >= strLen) {
      throw new Error("Expected more digits in base 64 VLQ value.");
    }

    digit = base64.decode(aStr.charCodeAt(aIndex++));
    if (digit === -1) {
      throw new Error("Invalid base64 digit: " + aStr.charAt(aIndex - 1));
    }

    continuation = !!(digit & VLQ_CONTINUATION_BIT);
    digit &= VLQ_BASE_MASK;
    result = result + (digit << shift);
    shift += VLQ_BASE_SHIFT;
  } while (continuation);

  aOutParam.value = fromVLQSigned(result);
  aOutParam.rest = aIndex;
};

var util$5 = {};

/* -*- Mode: js; js-indent-level: 2; -*- */

(function (exports) {
  /*
   * Copyright 2011 Mozilla Foundation and contributors
   * Licensed under the New BSD license. See LICENSE or:
   * http://opensource.org/licenses/BSD-3-Clause
   */

  /**
   * This is a helper function for getting values from parameter/options
   * objects.
   *
   * @param args The object we are extracting values from
   * @param name The name of the property we are getting.
   * @param defaultValue An optional value to return if the property is missing
   * from the object. If this is not specified and the property is missing, an
   * error will be thrown.
   */
  function getArg(aArgs, aName, aDefaultValue) {
    if (aName in aArgs) {
      return aArgs[aName];
    } else if (arguments.length === 3) {
      return aDefaultValue;
    } else {
      throw new Error('"' + aName + '" is a required argument.');
    }
  }
  exports.getArg = getArg;

  var urlRegexp =
    /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.-]*)(?::(\d+))?(.*)$/;
  var dataUrlRegexp = /^data:.+\,.+$/;

  function urlParse(aUrl) {
    var match = aUrl.match(urlRegexp);
    if (!match) {
      return null;
    }
    return {
      scheme: match[1],
      auth: match[2],
      host: match[3],
      port: match[4],
      path: match[5],
    };
  }
  exports.urlParse = urlParse;

  function urlGenerate(aParsedUrl) {
    var url = "";
    if (aParsedUrl.scheme) {
      url += aParsedUrl.scheme + ":";
    }
    url += "//";
    if (aParsedUrl.auth) {
      url += aParsedUrl.auth + "@";
    }
    if (aParsedUrl.host) {
      url += aParsedUrl.host;
    }
    if (aParsedUrl.port) {
      url += ":" + aParsedUrl.port;
    }
    if (aParsedUrl.path) {
      url += aParsedUrl.path;
    }
    return url;
  }
  exports.urlGenerate = urlGenerate;

  var MAX_CACHED_INPUTS = 32;

  /**
   * Takes some function `f(input) -> result` and returns a memoized version of
   * `f`.
   *
   * We keep at most `MAX_CACHED_INPUTS` memoized results of `f` alive. The
   * memoization is a dumb-simple, linear least-recently-used cache.
   */
  function lruMemoize(f) {
    var cache = [];

    return function (input) {
      for (var i = 0; i < cache.length; i++) {
        if (cache[i].input === input) {
          var temp = cache[0];
          cache[0] = cache[i];
          cache[i] = temp;
          return cache[0].result;
        }
      }

      var result = f(input);

      cache.unshift({
        input,
        result,
      });

      if (cache.length > MAX_CACHED_INPUTS) {
        cache.pop();
      }

      return result;
    };
  }

  /**
   * Normalizes a path, or the path portion of a URL:
   *
   * - Replaces consecutive slashes with one slash.
   * - Removes unnecessary '.' parts.
   * - Removes unnecessary '<dir>/..' parts.
   *
   * Based on code in the Node.js 'path' core module.
   *
   * @param aPath The path or url to normalize.
   */
  var normalize = lruMemoize(function normalize(aPath) {
    var path = aPath;
    var url = urlParse(aPath);
    if (url) {
      if (!url.path) {
        return aPath;
      }
      path = url.path;
    }
    var isAbsolute = exports.isAbsolute(path);
    // Split the path into parts between `/` characters. This is much faster than
    // using `.split(/\/+/g)`.
    var parts = [];
    var start = 0;
    var i = 0;
    while (true) {
      start = i;
      i = path.indexOf("/", start);
      if (i === -1) {
        parts.push(path.slice(start));
        break;
      } else {
        parts.push(path.slice(start, i));
        while (i < path.length && path[i] === "/") {
          i++;
        }
      }
    }

    for (var part, up = 0, i = parts.length - 1; i >= 0; i--) {
      part = parts[i];
      if (part === ".") {
        parts.splice(i, 1);
      } else if (part === "..") {
        up++;
      } else if (up > 0) {
        if (part === "") {
          // The first part is blank if the path is absolute. Trying to go
          // above the root is a no-op. Therefore we can remove all '..' parts
          // directly after the root.
          parts.splice(i + 1, up);
          up = 0;
        } else {
          parts.splice(i, 2);
          up--;
        }
      }
    }
    path = parts.join("/");

    if (path === "") {
      path = isAbsolute ? "/" : ".";
    }

    if (url) {
      url.path = path;
      return urlGenerate(url);
    }
    return path;
  });
  exports.normalize = normalize;

  /**
   * Joins two paths/URLs.
   *
   * @param aRoot The root path or URL.
   * @param aPath The path or URL to be joined with the root.
   *
   * - If aPath is a URL or a data URI, aPath is returned, unless aPath is a
   *   scheme-relative URL: Then the scheme of aRoot, if any, is prepended
   *   first.
   * - Otherwise aPath is a path. If aRoot is a URL, then its path portion
   *   is updated with the result and aRoot is returned. Otherwise the result
   *   is returned.
   *   - If aPath is absolute, the result is aPath.
   *   - Otherwise the two paths are joined with a slash.
   * - Joining for example 'http://' and 'www.example.com' is also supported.
   */
  function join(aRoot, aPath) {
    if (aRoot === "") {
      aRoot = ".";
    }
    if (aPath === "") {
      aPath = ".";
    }
    var aPathUrl = urlParse(aPath);
    var aRootUrl = urlParse(aRoot);
    if (aRootUrl) {
      aRoot = aRootUrl.path || "/";
    }

    // `join(foo, '//www.example.org')`
    if (aPathUrl && !aPathUrl.scheme) {
      if (aRootUrl) {
        aPathUrl.scheme = aRootUrl.scheme;
      }
      return urlGenerate(aPathUrl);
    }

    if (aPathUrl || aPath.match(dataUrlRegexp)) {
      return aPath;
    }

    // `join('http://', 'www.example.com')`
    if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {
      aRootUrl.host = aPath;
      return urlGenerate(aRootUrl);
    }

    var joined =
      aPath.charAt(0) === "/"
        ? aPath
        : normalize(aRoot.replace(/\/+$/, "") + "/" + aPath);

    if (aRootUrl) {
      aRootUrl.path = joined;
      return urlGenerate(aRootUrl);
    }
    return joined;
  }
  exports.join = join;

  exports.isAbsolute = function (aPath) {
    return aPath.charAt(0) === "/" || urlRegexp.test(aPath);
  };

  /**
   * Make a path relative to a URL or another path.
   *
   * @param aRoot The root path or URL.
   * @param aPath The path or URL to be made relative to aRoot.
   */
  function relative(aRoot, aPath) {
    if (aRoot === "") {
      aRoot = ".";
    }

    aRoot = aRoot.replace(/\/$/, "");

    // It is possible for the path to be above the root. In this case, simply
    // checking whether the root is a prefix of the path won't work. Instead, we
    // need to remove components from the root one by one, until either we find
    // a prefix that fits, or we run out of components to remove.
    var level = 0;
    while (aPath.indexOf(aRoot + "/") !== 0) {
      var index = aRoot.lastIndexOf("/");
      if (index < 0) {
        return aPath;
      }

      // If the only part of the root that is left is the scheme (i.e. http://,
      // file:///, etc.), one or more slashes (/), or simply nothing at all, we
      // have exhausted all components, so the path is not relative to the root.
      aRoot = aRoot.slice(0, index);
      if (aRoot.match(/^([^\/]+:\/)?\/*$/)) {
        return aPath;
      }

      ++level;
    }

    // Make sure we add a "../" for each component we removed from the root.
    return Array(level + 1).join("../") + aPath.substr(aRoot.length + 1);
  }
  exports.relative = relative;

  var supportsNullProto = (function () {
    var obj = Object.create(null);
    return !("__proto__" in obj);
  })();

  function identity(s) {
    return s;
  }

  /**
   * Because behavior goes wacky when you set `__proto__` on objects, we
   * have to prefix all the strings in our set with an arbitrary character.
   *
   * See https://github.com/mozilla/source-map/pull/31 and
   * https://github.com/mozilla/source-map/issues/30
   *
   * @param String aStr
   */
  function toSetString(aStr) {
    if (isProtoString(aStr)) {
      return "$" + aStr;
    }

    return aStr;
  }
  exports.toSetString = supportsNullProto ? identity : toSetString;

  function fromSetString(aStr) {
    if (isProtoString(aStr)) {
      return aStr.slice(1);
    }

    return aStr;
  }
  exports.fromSetString = supportsNullProto ? identity : fromSetString;

  function isProtoString(s) {
    if (!s) {
      return false;
    }

    var length = s.length;

    if (length < 9 /* "__proto__".length */) {
      return false;
    }

    if (
      s.charCodeAt(length - 1) !== 95 /* '_' */ ||
      s.charCodeAt(length - 2) !== 95 /* '_' */ ||
      s.charCodeAt(length - 3) !== 111 /* 'o' */ ||
      s.charCodeAt(length - 4) !== 116 /* 't' */ ||
      s.charCodeAt(length - 5) !== 111 /* 'o' */ ||
      s.charCodeAt(length - 6) !== 114 /* 'r' */ ||
      s.charCodeAt(length - 7) !== 112 /* 'p' */ ||
      s.charCodeAt(length - 8) !== 95 /* '_' */ ||
      s.charCodeAt(length - 9) !== 95 /* '_' */
    ) {
      return false;
    }

    for (var i = length - 10; i >= 0; i--) {
      if (s.charCodeAt(i) !== 36 /* '$' */) {
        return false;
      }
    }

    return true;
  }

  /**
   * Comparator between two mappings where the original positions are compared.
   *
   * Optionally pass in `true` as `onlyCompareGenerated` to consider two
   * mappings with the same original source/line/column, but different generated
   * line and column the same. Useful when searching for a mapping with a
   * stubbed out mapping.
   */
  function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {
    var cmp = strcmp(mappingA.source, mappingB.source);
    if (cmp !== 0) {
      return cmp;
    }

    cmp = mappingA.originalLine - mappingB.originalLine;
    if (cmp !== 0) {
      return cmp;
    }

    cmp = mappingA.originalColumn - mappingB.originalColumn;
    if (cmp !== 0 || onlyCompareOriginal) {
      return cmp;
    }

    cmp = mappingA.generatedColumn - mappingB.generatedColumn;
    if (cmp !== 0) {
      return cmp;
    }

    cmp = mappingA.generatedLine - mappingB.generatedLine;
    if (cmp !== 0) {
      return cmp;
    }

    return strcmp(mappingA.name, mappingB.name);
  }
  exports.compareByOriginalPositions = compareByOriginalPositions;

  function compareByOriginalPositionsNoSource(
    mappingA,
    mappingB,
    onlyCompareOriginal,
  ) {
    var cmp;

    cmp = mappingA.originalLine - mappingB.originalLine;
    if (cmp !== 0) {
      return cmp;
    }

    cmp = mappingA.originalColumn - mappingB.originalColumn;
    if (cmp !== 0 || onlyCompareOriginal) {
      return cmp;
    }

    cmp = mappingA.generatedColumn - mappingB.generatedColumn;
    if (cmp !== 0) {
      return cmp;
    }

    cmp = mappingA.generatedLine - mappingB.generatedLine;
    if (cmp !== 0) {
      return cmp;
    }

    return strcmp(mappingA.name, mappingB.name);
  }
  exports.compareByOriginalPositionsNoSource =
    compareByOriginalPositionsNoSource;

  /**
   * Comparator between two mappings with deflated source and name indices where
   * the generated positions are compared.
   *
   * Optionally pass in `true` as `onlyCompareGenerated` to consider two
   * mappings with the same generated line and column, but different
   * source/name/original line and column the same. Useful when searching for a
   * mapping with a stubbed out mapping.
   */
  function compareByGeneratedPositionsDeflated(
    mappingA,
    mappingB,
    onlyCompareGenerated,
  ) {
    var cmp = mappingA.generatedLine - mappingB.generatedLine;
    if (cmp !== 0) {
      return cmp;
    }

    cmp = mappingA.generatedColumn - mappingB.generatedColumn;
    if (cmp !== 0 || onlyCompareGenerated) {
      return cmp;
    }

    cmp = strcmp(mappingA.source, mappingB.source);
    if (cmp !== 0) {
      return cmp;
    }

    cmp = mappingA.originalLine - mappingB.originalLine;
    if (cmp !== 0) {
      return cmp;
    }

    cmp = mappingA.originalColumn - mappingB.originalColumn;
    if (cmp !== 0) {
      return cmp;
    }

    return strcmp(mappingA.name, mappingB.name);
  }
  exports.compareByGeneratedPositionsDeflated =
    compareByGeneratedPositionsDeflated;

  function compareByGeneratedPositionsDeflatedNoLine(
    mappingA,
    mappingB,
    onlyCompareGenerated,
  ) {
    var cmp = mappingA.generatedColumn - mappingB.generatedColumn;
    if (cmp !== 0 || onlyCompareGenerated) {
      return cmp;
    }

    cmp = strcmp(mappingA.source, mappingB.source);
    if (cmp !== 0) {
      return cmp;
    }

    cmp = mappingA.originalLine - mappingB.originalLine;
    if (cmp !== 0) {
      return cmp;
    }

    cmp = mappingA.originalColumn - mappingB.originalColumn;
    if (cmp !== 0) {
      return cmp;
    }

    return strcmp(mappingA.name, mappingB.name);
  }
  exports.compareByGeneratedPositionsDeflatedNoLine =
    compareByGeneratedPositionsDeflatedNoLine;

  function strcmp(aStr1, aStr2) {
    if (aStr1 === aStr2) {
      return 0;
    }

    if (aStr1 === null) {
      return 1; // aStr2 !== null
    }

    if (aStr2 === null) {
      return -1; // aStr1 !== null
    }

    if (aStr1 > aStr2) {
      return 1;
    }

    return -1;
  }

  /**
   * Comparator between two mappings with inflated source and name strings where
   * the generated positions are compared.
   */
  function compareByGeneratedPositionsInflated(mappingA, mappingB) {
    var cmp = mappingA.generatedLine - mappingB.generatedLine;
    if (cmp !== 0) {
      return cmp;
    }

    cmp = mappingA.generatedColumn - mappingB.generatedColumn;
    if (cmp !== 0) {
      return cmp;
    }

    cmp = strcmp(mappingA.source, mappingB.source);
    if (cmp !== 0) {
      return cmp;
    }

    cmp = mappingA.originalLine - mappingB.originalLine;
    if (cmp !== 0) {
      return cmp;
    }

    cmp = mappingA.originalColumn - mappingB.originalColumn;
    if (cmp !== 0) {
      return cmp;
    }

    return strcmp(mappingA.name, mappingB.name);
  }
  exports.compareByGeneratedPositionsInflated =
    compareByGeneratedPositionsInflated;

  /**
   * Strip any JSON XSSI avoidance prefix from the string (as documented
   * in the source maps specification), and then parse the string as
   * JSON.
   */
  function parseSourceMapInput(str) {
    return JSON.parse(str.replace(/^\)]}'[^\n]*\n/, ""));
  }
  exports.parseSourceMapInput = parseSourceMapInput;

  /**
   * Compute the URL of a source given the the source root, the source's
   * URL, and the source map's URL.
   */
  function computeSourceURL(sourceRoot, sourceURL, sourceMapURL) {
    sourceURL = sourceURL || "";

    if (sourceRoot) {
      // This follows what Chrome does.
      if (sourceRoot[sourceRoot.length - 1] !== "/" && sourceURL[0] !== "/") {
        sourceRoot += "/";
      }
      // The spec says:
      //   Line 4: An optional source root, useful for relocating source
      //   files on a server or removing repeated values in the
      //   sources entry.  This value is prepended to the individual
      //   entries in the source field.
      sourceURL = sourceRoot + sourceURL;
    }

    // Historically, SourceMapConsumer did not take the sourceMapURL as
    // a parameter.  This mode is still somewhat supported, which is why
    // this code block is conditional.  However, it's preferable to pass
    // the source map URL to SourceMapConsumer, so that this function
    // can implement the source URL resolution algorithm as outlined in
    // the spec.  This block is basically the equivalent of:
    //    new URL(sourceURL, sourceMapURL).toString()
    // ... except it avoids using URL, which wasn't available in the
    // older releases of node still supported by this library.
    //
    // The spec says:
    //   If the sources are not absolute URLs after prepending of the
    //   sourceRoot, the sources are resolved relative to the
    //   SourceMap (like resolving script src in a html document).
    if (sourceMapURL) {
      var parsed = urlParse(sourceMapURL);
      if (!parsed) {
        throw new Error("sourceMapURL could not be parsed");
      }
      if (parsed.path) {
        // Strip the last path component, but keep the "/".
        var index = parsed.path.lastIndexOf("/");
        if (index >= 0) {
          parsed.path = parsed.path.substring(0, index + 1);
        }
      }
      sourceURL = join(urlGenerate(parsed), sourceURL);
    }

    return normalize(sourceURL);
  }
  exports.computeSourceURL = computeSourceURL;
})(util$5);

var arraySet = {};

/* -*- Mode: js; js-indent-level: 2; -*- */

/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

var util$4 = util$5;
var has = Object.prototype.hasOwnProperty;
var hasNativeMap = typeof Map !== "undefined";

/**
 * A data structure which is a combination of an array and a set. Adding a new
 * member is O(1), testing for membership is O(1), and finding the index of an
 * element is O(1). Removing elements from the set is not supported. Only
 * strings are supported for membership.
 */
function ArraySet$1() {
  this._array = [];
  this._set = hasNativeMap ? new Map() : Object.create(null);
}

/**
 * Static method for creating ArraySet instances from an existing array.
 */
ArraySet$1.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {
  var set = new ArraySet$1();
  for (var i = 0, len = aArray.length; i < len; i++) {
    set.add(aArray[i], aAllowDuplicates);
  }
  return set;
};

/**
 * Return how many unique items are in this ArraySet. If duplicates have been
 * added, than those do not count towards the size.
 *
 * @returns Number
 */
ArraySet$1.prototype.size = function ArraySet_size() {
  return hasNativeMap
    ? this._set.size
    : Object.getOwnPropertyNames(this._set).length;
};

/**
 * Add the given string to this set.
 *
 * @param String aStr
 */
ArraySet$1.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {
  var sStr = hasNativeMap ? aStr : util$4.toSetString(aStr);
  var isDuplicate = hasNativeMap ? this.has(aStr) : has.call(this._set, sStr);
  var idx = this._array.length;
  if (!isDuplicate || aAllowDuplicates) {
    this._array.push(aStr);
  }
  if (!isDuplicate) {
    if (hasNativeMap) {
      this._set.set(aStr, idx);
    } else {
      this._set[sStr] = idx;
    }
  }
};

/**
 * Is the given string a member of this set?
 *
 * @param String aStr
 */
ArraySet$1.prototype.has = function ArraySet_has(aStr) {
  if (hasNativeMap) {
    return this._set.has(aStr);
  } else {
    var sStr = util$4.toSetString(aStr);
    return has.call(this._set, sStr);
  }
};

/**
 * What is the index of the given string in the array?
 *
 * @param String aStr
 */
ArraySet$1.prototype.indexOf = function ArraySet_indexOf(aStr) {
  if (hasNativeMap) {
    var idx = this._set.get(aStr);
    if (idx >= 0) {
      return idx;
    }
  } else {
    var sStr = util$4.toSetString(aStr);
    if (has.call(this._set, sStr)) {
      return this._set[sStr];
    }
  }

  throw new Error('"' + aStr + '" is not in the set.');
};

/**
 * What is the element at the given index?
 *
 * @param Number aIdx
 */
ArraySet$1.prototype.at = function ArraySet_at(aIdx) {
  if (aIdx >= 0 && aIdx < this._array.length) {
    return this._array[aIdx];
  }
  throw new Error("No element indexed by " + aIdx);
};

/**
 * Returns the array representation of this set (which has the proper indices
 * indicated by indexOf). Note that this is a copy of the internal array used
 * for storing the members so that no one can mess with internal state.
 */
ArraySet$1.prototype.toArray = function ArraySet_toArray() {
  return this._array.slice();
};

arraySet.ArraySet = ArraySet$1;

var mappingList = {};

/* -*- Mode: js; js-indent-level: 2; -*- */

/*
 * Copyright 2014 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

var util$3 = util$5;

/**
 * Determine whether mappingB is after mappingA with respect to generated
 * position.
 */
function generatedPositionAfter(mappingA, mappingB) {
  // Optimized for most common case
  var lineA = mappingA.generatedLine;
  var lineB = mappingB.generatedLine;
  var columnA = mappingA.generatedColumn;
  var columnB = mappingB.generatedColumn;
  return (
    lineB > lineA ||
    (lineB == lineA && columnB >= columnA) ||
    util$3.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0
  );
}

/**
 * A data structure to provide a sorted view of accumulated mappings in a
 * performance conscious manner. It trades a neglibable overhead in general
 * case for a large speedup in case of mappings being added in order.
 */
function MappingList$1() {
  this._array = [];
  this._sorted = true;
  // Serves as infimum
  this._last = { generatedLine: -1, generatedColumn: 0 };
}

/**
 * Iterate through internal items. This method takes the same arguments that
 * `Array.prototype.forEach` takes.
 *
 * NOTE: The order of the mappings is NOT guaranteed.
 */
MappingList$1.prototype.unsortedForEach = function MappingList_forEach(
  aCallback,
  aThisArg,
) {
  this._array.forEach(aCallback, aThisArg);
};

/**
 * Add the given source mapping.
 *
 * @param Object aMapping
 */
MappingList$1.prototype.add = function MappingList_add(aMapping) {
  if (generatedPositionAfter(this._last, aMapping)) {
    this._last = aMapping;
    this._array.push(aMapping);
  } else {
    this._sorted = false;
    this._array.push(aMapping);
  }
};

/**
 * Returns the flat, sorted array of mappings. The mappings are sorted by
 * generated position.
 *
 * WARNING: This method returns internal data without copying, for
 * performance. The return value must NOT be mutated, and should be treated as
 * an immutable borrow. If you want to take ownership, you must make your own
 * copy.
 */
MappingList$1.prototype.toArray = function MappingList_toArray() {
  if (!this._sorted) {
    this._array.sort(util$3.compareByGeneratedPositionsInflated);
    this._sorted = true;
  }
  return this._array;
};

mappingList.MappingList = MappingList$1;

/* -*- Mode: js; js-indent-level: 2; -*- */

/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

var base64VLQ = base64Vlq;
var util$2 = util$5;
var ArraySet = arraySet.ArraySet;
var MappingList = mappingList.MappingList;

/**
 * An instance of the SourceMapGenerator represents a source map which is
 * being built incrementally. You may pass an object with the following
 * properties:
 *
 *   - file: The filename of the generated source.
 *   - sourceRoot: A root for all relative URLs in this source map.
 */
function SourceMapGenerator(aArgs) {
  if (!aArgs) {
    aArgs = {};
  }
  this._file = util$2.getArg(aArgs, "file", null);
  this._sourceRoot = util$2.getArg(aArgs, "sourceRoot", null);
  this._skipValidation = util$2.getArg(aArgs, "skipValidation", false);
  this._sources = new ArraySet();
  this._names = new ArraySet();
  this._mappings = new MappingList();
  this._sourcesContents = null;
}

SourceMapGenerator.prototype._version = 3;

/**
 * Creates a new SourceMapGenerator based on a SourceMapConsumer
 *
 * @param aSourceMapConsumer The SourceMap.
 */
SourceMapGenerator.fromSourceMap = function SourceMapGenerator_fromSourceMap(
  aSourceMapConsumer,
) {
  var sourceRoot = aSourceMapConsumer.sourceRoot;
  var generator = new SourceMapGenerator({
    file: aSourceMapConsumer.file,
    sourceRoot: sourceRoot,
  });
  aSourceMapConsumer.eachMapping(function (mapping) {
    var newMapping = {
      generated: {
        line: mapping.generatedLine,
        column: mapping.generatedColumn,
      },
    };

    if (mapping.source != null) {
      newMapping.source = mapping.source;
      if (sourceRoot != null) {
        newMapping.source = util$2.relative(sourceRoot, newMapping.source);
      }

      newMapping.original = {
        line: mapping.originalLine,
        column: mapping.originalColumn,
      };

      if (mapping.name != null) {
        newMapping.name = mapping.name;
      }
    }

    generator.addMapping(newMapping);
  });
  aSourceMapConsumer.sources.forEach(function (sourceFile) {
    var sourceRelative = sourceFile;
    if (sourceRoot !== null) {
      sourceRelative = util$2.relative(sourceRoot, sourceFile);
    }

    if (!generator._sources.has(sourceRelative)) {
      generator._sources.add(sourceRelative);
    }

    var content = aSourceMapConsumer.sourceContentFor(sourceFile);
    if (content != null) {
      generator.setSourceContent(sourceFile, content);
    }
  });
  return generator;
};

/**
 * Add a single mapping from original source line and column to the generated
 * source's line and column for this source map being created. The mapping
 * object should have the following properties:
 *
 *   - generated: An object with the generated line and column positions.
 *   - original: An object with the original line and column positions.
 *   - source: The original source file (relative to the sourceRoot).
 *   - name: An optional original token name for this mapping.
 */
SourceMapGenerator.prototype.addMapping =
  function SourceMapGenerator_addMapping(aArgs) {
    var generated = util$2.getArg(aArgs, "generated");
    var original = util$2.getArg(aArgs, "original", null);
    var source = util$2.getArg(aArgs, "source", null);
    var name = util$2.getArg(aArgs, "name", null);

    if (!this._skipValidation) {
      this._validateMapping(generated, original, source, name);
    }

    if (source != null) {
      source = String(source);
      if (!this._sources.has(source)) {
        this._sources.add(source);
      }
    }

    if (name != null) {
      name = String(name);
      if (!this._names.has(name)) {
        this._names.add(name);
      }
    }

    this._mappings.add({
      generatedLine: generated.line,
      generatedColumn: generated.column,
      originalLine: original != null && original.line,
      originalColumn: original != null && original.column,
      source: source,
      name: name,
    });
  };

/**
 * Set the source content for a source file.
 */
SourceMapGenerator.prototype.setSourceContent =
  function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {
    var source = aSourceFile;
    if (this._sourceRoot != null) {
      source = util$2.relative(this._sourceRoot, source);
    }

    if (aSourceContent != null) {
      // Add the source content to the _sourcesContents map.
      // Create a new _sourcesContents map if the property is null.
      if (!this._sourcesContents) {
        this._sourcesContents = Object.create(null);
      }
      this._sourcesContents[util$2.toSetString(source)] = aSourceContent;
    } else if (this._sourcesContents) {
      // Remove the source file from the _sourcesContents map.
      // If the _sourcesContents map is empty, set the property to null.
      delete this._sourcesContents[util$2.toSetString(source)];
      if (Object.keys(this._sourcesContents).length === 0) {
        this._sourcesContents = null;
      }
    }
  };

/**
 * Applies the mappings of a sub-source-map for a specific source file to the
 * source map being generated. Each mapping to the supplied source file is
 * rewritten using the supplied source map. Note: The resolution for the
 * resulting mappings is the minimium of this map and the supplied map.
 *
 * @param aSourceMapConsumer The source map to be applied.
 * @param aSourceFile Optional. The filename of the source file.
 *        If omitted, SourceMapConsumer's file property will be used.
 * @param aSourceMapPath Optional. The dirname of the path to the source map
 *        to be applied. If relative, it is relative to the SourceMapConsumer.
 *        This parameter is needed when the two source maps aren't in the same
 *        directory, and the source map to be applied contains relative source
 *        paths. If so, those relative source paths need to be rewritten
 *        relative to the SourceMapGenerator.
 */
SourceMapGenerator.prototype.applySourceMap =
  function SourceMapGenerator_applySourceMap(
    aSourceMapConsumer,
    aSourceFile,
    aSourceMapPath,
  ) {
    var sourceFile = aSourceFile;
    // If aSourceFile is omitted, we will use the file property of the SourceMap
    if (aSourceFile == null) {
      if (aSourceMapConsumer.file == null) {
        throw new Error(
          "SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, " +
            'or the source map\'s "file" property. Both were omitted.',
        );
      }
      sourceFile = aSourceMapConsumer.file;
    }
    var sourceRoot = this._sourceRoot;
    // Make "sourceFile" relative if an absolute Url is passed.
    if (sourceRoot != null) {
      sourceFile = util$2.relative(sourceRoot, sourceFile);
    }
    // Applying the SourceMap can add and remove items from the sources and
    // the names array.
    var newSources = new ArraySet();
    var newNames = new ArraySet();

    // Find mappings for the "sourceFile"
    this._mappings.unsortedForEach(function (mapping) {
      if (mapping.source === sourceFile && mapping.originalLine != null) {
        // Check if it can be mapped by the source map, then update the mapping.
        var original = aSourceMapConsumer.originalPositionFor({
          line: mapping.originalLine,
          column: mapping.originalColumn,
        });
        if (original.source != null) {
          // Copy mapping
          mapping.source = original.source;
          if (aSourceMapPath != null) {
            mapping.source = util$2.join(aSourceMapPath, mapping.source);
          }
          if (sourceRoot != null) {
            mapping.source = util$2.relative(sourceRoot, mapping.source);
          }
          mapping.originalLine = original.line;
          mapping.originalColumn = original.column;
          if (original.name != null) {
            mapping.name = original.name;
          }
        }
      }

      var source = mapping.source;
      if (source != null && !newSources.has(source)) {
        newSources.add(source);
      }

      var name = mapping.name;
      if (name != null && !newNames.has(name)) {
        newNames.add(name);
      }
    }, this);
    this._sources = newSources;
    this._names = newNames;

    // Copy sourcesContents of applied map.
    aSourceMapConsumer.sources.forEach(function (sourceFile) {
      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
      if (content != null) {
        if (aSourceMapPath != null) {
          sourceFile = util$2.join(aSourceMapPath, sourceFile);
        }
        if (sourceRoot != null) {
          sourceFile = util$2.relative(sourceRoot, sourceFile);
        }
        this.setSourceContent(sourceFile, content);
      }
    }, this);
  };

/**
 * A mapping can have one of the three levels of data:
 *
 *   1. Just the generated position.
 *   2. The Generated position, original position, and original source.
 *   3. Generated and original position, original source, as well as a name
 *      token.
 *
 * To maintain consistency, we validate that any new mapping being added falls
 * in to one of these categories.
 */
SourceMapGenerator.prototype._validateMapping =
  function SourceMapGenerator_validateMapping(
    aGenerated,
    aOriginal,
    aSource,
    aName,
  ) {
    // When aOriginal is truthy but has empty values for .line and .column,
    // it is most likely a programmer error. In this case we throw a very
    // specific error message to try to guide them the right way.
    // For example: https://github.com/Polymer/polymer-bundler/pull/519
    if (
      aOriginal &&
      typeof aOriginal.line !== "number" &&
      typeof aOriginal.column !== "number"
    ) {
      throw new Error(
        "original.line and original.column are not numbers -- you probably meant to omit " +
          "the original mapping entirely and only map the generated position. If so, pass " +
          "null for the original mapping instead of an object with empty or null values.",
      );
    }

    if (
      aGenerated &&
      "line" in aGenerated &&
      "column" in aGenerated &&
      aGenerated.line > 0 &&
      aGenerated.column >= 0 &&
      !aOriginal &&
      !aSource &&
      !aName
    ) {
      // Case 1.
      return;
    } else if (
      aGenerated &&
      "line" in aGenerated &&
      "column" in aGenerated &&
      aOriginal &&
      "line" in aOriginal &&
      "column" in aOriginal &&
      aGenerated.line > 0 &&
      aGenerated.column >= 0 &&
      aOriginal.line > 0 &&
      aOriginal.column >= 0 &&
      aSource
    ) {
      // Cases 2 and 3.
      return;
    } else {
      throw new Error(
        "Invalid mapping: " +
          JSON.stringify({
            generated: aGenerated,
            source: aSource,
            original: aOriginal,
            name: aName,
          }),
      );
    }
  };

/**
 * Serialize the accumulated mappings in to the stream of base 64 VLQs
 * specified by the source map format.
 */
SourceMapGenerator.prototype._serializeMappings =
  function SourceMapGenerator_serializeMappings() {
    var previousGeneratedColumn = 0;
    var previousGeneratedLine = 1;
    var previousOriginalColumn = 0;
    var previousOriginalLine = 0;
    var previousName = 0;
    var previousSource = 0;
    var result = "";
    var next;
    var mapping;
    var nameIdx;
    var sourceIdx;

    var mappings = this._mappings.toArray();
    for (var i = 0, len = mappings.length; i < len; i++) {
      mapping = mappings[i];
      next = "";

      if (mapping.generatedLine !== previousGeneratedLine) {
        previousGeneratedColumn = 0;
        while (mapping.generatedLine !== previousGeneratedLine) {
          next += ";";
          previousGeneratedLine++;
        }
      } else {
        if (i > 0) {
          if (
            !util$2.compareByGeneratedPositionsInflated(
              mapping,
              mappings[i - 1],
            )
          ) {
            continue;
          }
          next += ",";
        }
      }

      next += base64VLQ.encode(
        mapping.generatedColumn - previousGeneratedColumn,
      );
      previousGeneratedColumn = mapping.generatedColumn;

      if (mapping.source != null) {
        sourceIdx = this._sources.indexOf(mapping.source);
        next += base64VLQ.encode(sourceIdx - previousSource);
        previousSource = sourceIdx;

        // lines are stored 0-based in SourceMap spec version 3
        next += base64VLQ.encode(
          mapping.originalLine - 1 - previousOriginalLine,
        );
        previousOriginalLine = mapping.originalLine - 1;

        next += base64VLQ.encode(
          mapping.originalColumn - previousOriginalColumn,
        );
        previousOriginalColumn = mapping.originalColumn;

        if (mapping.name != null) {
          nameIdx = this._names.indexOf(mapping.name);
          next += base64VLQ.encode(nameIdx - previousName);
          previousName = nameIdx;
        }
      }

      result += next;
    }

    return result;
  };

SourceMapGenerator.prototype._generateSourcesContent =
  function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {
    return aSources.map(function (source) {
      if (!this._sourcesContents) {
        return null;
      }
      if (aSourceRoot != null) {
        source = util$2.relative(aSourceRoot, source);
      }
      var key = util$2.toSetString(source);
      return Object.prototype.hasOwnProperty.call(this._sourcesContents, key)
        ? this._sourcesContents[key]
        : null;
    }, this);
  };

/**
 * Externalize the source map.
 */
SourceMapGenerator.prototype.toJSON = function SourceMapGenerator_toJSON() {
  var map = {
    version: this._version,
    sources: this._sources.toArray(),
    names: this._names.toArray(),
    mappings: this._serializeMappings(),
  };
  if (this._file != null) {
    map.file = this._file;
  }
  if (this._sourceRoot != null) {
    map.sourceRoot = this._sourceRoot;
  }
  if (this._sourcesContents) {
    map.sourcesContent = this._generateSourcesContent(
      map.sources,
      map.sourceRoot,
    );
  }

  return map;
};

/**
 * Render the source map being generated to a string.
 */
SourceMapGenerator.prototype.toString = function SourceMapGenerator_toString() {
  return JSON.stringify(this.toJSON());
};

sourceMapGenerator.SourceMapGenerator = SourceMapGenerator;

const sourceMapGenerator_js$1 = sourceMapGenerator;

const trackNodes$1 = new Set(["Atrule", "Selector", "Declaration"]);

function generateSourceMap$1(handlers) {
  const map = new sourceMapGenerator_js$1.SourceMapGenerator();
  const generated = {
    line: 1,
    column: 0,
  };
  const original = {
    line: 0, // should be zero to add first mapping
    column: 0,
  };
  const activatedGenerated = {
    line: 1,
    column: 0,
  };
  const activatedMapping = {
    generated: activatedGenerated,
  };
  let line = 1;
  let column = 0;
  let sourceMappingActive = false;

  const origHandlersNode = handlers.node;
  handlers.node = function (node) {
    if (node.loc && node.loc.start && trackNodes$1.has(node.type)) {
      const nodeLine = node.loc.start.line;
      const nodeColumn = node.loc.start.column - 1;

      if (original.line !== nodeLine || original.column !== nodeColumn) {
        original.line = nodeLine;
        original.column = nodeColumn;

        generated.line = line;
        generated.column = column;

        if (sourceMappingActive) {
          sourceMappingActive = false;
          if (
            generated.line !== activatedGenerated.line ||
            generated.column !== activatedGenerated.column
          ) {
            map.addMapping(activatedMapping);
          }
        }

        sourceMappingActive = true;
        map.addMapping({
          source: node.loc.source,
          original,
          generated,
        });
      }
    }

    origHandlersNode.call(this, node);

    if (sourceMappingActive && trackNodes$1.has(node.type)) {
      activatedGenerated.line = line;
      activatedGenerated.column = column;
    }
  };

  const origHandlersEmit = handlers.emit;
  handlers.emit = function (value, type, auto) {
    for (let i = 0; i < value.length; i++) {
      if (value.charCodeAt(i) === 10) {
        // \n
        line++;
        column = 0;
      } else {
        column++;
      }
    }

    origHandlersEmit(value, type, auto);
  };

  const origHandlersResult = handlers.result;
  handlers.result = function () {
    if (sourceMappingActive) {
      map.addMapping(activatedMapping);
    }

    return {
      css: origHandlersResult(),
      map,
    };
  };

  return handlers;
}

sourceMap$3.generateSourceMap = generateSourceMap$1;

var tokenBefore$3 = {};

const types$1H = types$1M;

const PLUSSIGN$j = 0x002b; // U+002B PLUS SIGN (+)
const HYPHENMINUS$d = 0x002d; // U+002D HYPHEN-MINUS (-)

const code$1 = (type, value) => {
  if (type === types$1H.Delim) {
    type = value;
  }

  if (typeof type === "string") {
    const charCode = type.charCodeAt(0);
    return charCode > 0x7f ? 0x8000 : charCode << 8;
  }

  return type;
};

// https://www.w3.org/TR/css-syntax-3/#serialization
// The only requirement for serialization is that it must "round-trip" with parsing,
// that is, parsing the stylesheet must produce the same data structures as parsing,
// serializing, and parsing again, except for consecutive <whitespace-token>s,
// which may be collapsed into a single token.

const specPairs$1 = [
  [types$1H.Ident, types$1H.Ident],
  [types$1H.Ident, types$1H.Function],
  [types$1H.Ident, types$1H.Url],
  [types$1H.Ident, types$1H.BadUrl],
  [types$1H.Ident, "-"],
  [types$1H.Ident, types$1H.Number],
  [types$1H.Ident, types$1H.Percentage],
  [types$1H.Ident, types$1H.Dimension],
  [types$1H.Ident, types$1H.CDC],
  [types$1H.Ident, types$1H.LeftParenthesis],

  [types$1H.AtKeyword, types$1H.Ident],
  [types$1H.AtKeyword, types$1H.Function],
  [types$1H.AtKeyword, types$1H.Url],
  [types$1H.AtKeyword, types$1H.BadUrl],
  [types$1H.AtKeyword, "-"],
  [types$1H.AtKeyword, types$1H.Number],
  [types$1H.AtKeyword, types$1H.Percentage],
  [types$1H.AtKeyword, types$1H.Dimension],
  [types$1H.AtKeyword, types$1H.CDC],

  [types$1H.Hash, types$1H.Ident],
  [types$1H.Hash, types$1H.Function],
  [types$1H.Hash, types$1H.Url],
  [types$1H.Hash, types$1H.BadUrl],
  [types$1H.Hash, "-"],
  [types$1H.Hash, types$1H.Number],
  [types$1H.Hash, types$1H.Percentage],
  [types$1H.Hash, types$1H.Dimension],
  [types$1H.Hash, types$1H.CDC],

  [types$1H.Dimension, types$1H.Ident],
  [types$1H.Dimension, types$1H.Function],
  [types$1H.Dimension, types$1H.Url],
  [types$1H.Dimension, types$1H.BadUrl],
  [types$1H.Dimension, "-"],
  [types$1H.Dimension, types$1H.Number],
  [types$1H.Dimension, types$1H.Percentage],
  [types$1H.Dimension, types$1H.Dimension],
  [types$1H.Dimension, types$1H.CDC],

  ["#", types$1H.Ident],
  ["#", types$1H.Function],
  ["#", types$1H.Url],
  ["#", types$1H.BadUrl],
  ["#", "-"],
  ["#", types$1H.Number],
  ["#", types$1H.Percentage],
  ["#", types$1H.Dimension],
  ["#", types$1H.CDC], // https://github.com/w3c/csswg-drafts/pull/6874

  ["-", types$1H.Ident],
  ["-", types$1H.Function],
  ["-", types$1H.Url],
  ["-", types$1H.BadUrl],
  ["-", "-"],
  ["-", types$1H.Number],
  ["-", types$1H.Percentage],
  ["-", types$1H.Dimension],
  ["-", types$1H.CDC], // https://github.com/w3c/csswg-drafts/pull/6874

  [types$1H.Number, types$1H.Ident],
  [types$1H.Number, types$1H.Function],
  [types$1H.Number, types$1H.Url],
  [types$1H.Number, types$1H.BadUrl],
  [types$1H.Number, types$1H.Number],
  [types$1H.Number, types$1H.Percentage],
  [types$1H.Number, types$1H.Dimension],
  [types$1H.Number, "%"],
  [types$1H.Number, types$1H.CDC], // https://github.com/w3c/csswg-drafts/pull/6874

  ["@", types$1H.Ident],
  ["@", types$1H.Function],
  ["@", types$1H.Url],
  ["@", types$1H.BadUrl],
  ["@", "-"],
  ["@", types$1H.CDC], // https://github.com/w3c/csswg-drafts/pull/6874

  [".", types$1H.Number],
  [".", types$1H.Percentage],
  [".", types$1H.Dimension],

  ["+", types$1H.Number],
  ["+", types$1H.Percentage],
  ["+", types$1H.Dimension],

  ["/", "*"],
];
// validate with scripts/generate-safe
const safePairs$1 = specPairs$1.concat([
  [types$1H.Ident, types$1H.Hash],

  [types$1H.Dimension, types$1H.Hash],

  [types$1H.Hash, types$1H.Hash],

  [types$1H.AtKeyword, types$1H.LeftParenthesis],
  [types$1H.AtKeyword, types$1H.String],
  [types$1H.AtKeyword, types$1H.Colon],

  [types$1H.Percentage, types$1H.Percentage],
  [types$1H.Percentage, types$1H.Dimension],
  [types$1H.Percentage, types$1H.Function],
  [types$1H.Percentage, "-"],

  [types$1H.RightParenthesis, types$1H.Ident],
  [types$1H.RightParenthesis, types$1H.Function],
  [types$1H.RightParenthesis, types$1H.Percentage],
  [types$1H.RightParenthesis, types$1H.Dimension],
  [types$1H.RightParenthesis, types$1H.Hash],
  [types$1H.RightParenthesis, "-"],
]);

function createMap$1(pairs) {
  const isWhiteSpaceRequired = new Set(
    pairs.map(([prev, next]) => (code$1(prev) << 16) | code$1(next)),
  );

  return function (prevCode, type, value) {
    const nextCode = code$1(type, value);
    const nextCharCode = value.charCodeAt(0);
    const emitWs =
      (nextCharCode === HYPHENMINUS$d &&
        type !== types$1H.Ident &&
        type !== types$1H.Function &&
        type !== types$1H.CDC) ||
      nextCharCode === PLUSSIGN$j
        ? isWhiteSpaceRequired.has((prevCode << 16) | (nextCharCode << 8))
        : isWhiteSpaceRequired.has((prevCode << 16) | nextCode);

    if (emitWs) {
      this.emit(" ", types$1H.WhiteSpace, true);
    }

    return nextCode;
  };
}

const spec$1 = createMap$1(specPairs$1);
const safe$1 = createMap$1(safePairs$1);

tokenBefore$3.safe = safe$1;
tokenBefore$3.spec = spec$1;

const index$i = tokenizer$5;
const sourceMap$2 = sourceMap$3;
const tokenBefore$2 = tokenBefore$3;
const types$1G = types$1M;

const REVERSESOLIDUS$1 = 0x005c; // U+005C REVERSE SOLIDUS (\)

function processChildren$1(node, delimeter) {
  if (typeof delimeter === "function") {
    let prev = null;

    node.children.forEach((node) => {
      if (prev !== null) {
        delimeter.call(this, prev);
      }

      this.node(node);
      prev = node;
    });

    return;
  }

  node.children.forEach(this.node, this);
}

function processChunk$1(chunk) {
  index$i.tokenize(chunk, (type, start, end) => {
    this.token(type, chunk.slice(start, end));
  });
}

function createGenerator$1(config) {
  const types$1 = new Map();

  for (let name in config.node) {
    const item = config.node[name];
    const fn = item.generate || item;

    if (typeof fn === "function") {
      types$1.set(name, item.generate || item);
    }
  }

  return function (node, options) {
    let buffer = "";
    let prevCode = 0;
    let handlers = {
      node(node) {
        if (types$1.has(node.type)) {
          types$1.get(node.type).call(publicApi, node);
        } else {
          throw new Error("Unknown node type: " + node.type);
        }
      },
      tokenBefore: tokenBefore$2.safe,
      token(type, value) {
        prevCode = this.tokenBefore(prevCode, type, value);

        this.emit(value, type, false);

        if (
          type === types$1G.Delim &&
          value.charCodeAt(0) === REVERSESOLIDUS$1
        ) {
          this.emit("\n", types$1G.WhiteSpace, true);
        }
      },
      emit(value) {
        buffer += value;
      },
      result() {
        return buffer;
      },
    };

    if (options) {
      if (typeof options.decorator === "function") {
        handlers = options.decorator(handlers);
      }

      if (options.sourceMap) {
        handlers = sourceMap$2.generateSourceMap(handlers);
      }

      if (options.mode in tokenBefore$2) {
        handlers.tokenBefore = tokenBefore$2[options.mode];
      }
    }

    const publicApi = {
      node: (node) => handlers.node(node),
      children: processChildren$1,
      token: (type, value) => handlers.token(type, value),
      tokenize: processChunk$1,
    };

    handlers.node(node);

    return handlers.result();
  };
}

create$d.createGenerator = createGenerator$1;

var create$c = {};

const List$c = List$f;

function createConvertor$1(walk) {
  return {
    fromPlainObject(ast) {
      walk(ast, {
        enter(node) {
          if (node.children && node.children instanceof List$c.List === false) {
            node.children = new List$c.List().fromArray(node.children);
          }
        },
      });

      return ast;
    },
    toPlainObject(ast) {
      walk(ast, {
        leave(node) {
          if (node.children && node.children instanceof List$c.List) {
            node.children = node.children.toArray();
          }
        },
      });

      return ast;
    },
  };
}

create$c.createConvertor = createConvertor$1;

var create$b = {};

const { hasOwnProperty: hasOwnProperty$c } = Object.prototype;
const noop$8 = function () {};

function ensureFunction$3(value) {
  return typeof value === "function" ? value : noop$8;
}

function invokeForType$1(fn, type) {
  return function (node, item, list) {
    if (node.type === type) {
      fn.call(this, node, item, list);
    }
  };
}

function getWalkersFromStructure$1(name, nodeType) {
  const structure = nodeType.structure;
  const walkers = [];

  for (const key in structure) {
    if (hasOwnProperty$c.call(structure, key) === false) {
      continue;
    }

    let fieldTypes = structure[key];
    const walker = {
      name: key,
      type: false,
      nullable: false,
    };

    if (!Array.isArray(fieldTypes)) {
      fieldTypes = [fieldTypes];
    }

    for (const fieldType of fieldTypes) {
      if (fieldType === null) {
        walker.nullable = true;
      } else if (typeof fieldType === "string") {
        walker.type = "node";
      } else if (Array.isArray(fieldType)) {
        walker.type = "list";
      }
    }

    if (walker.type) {
      walkers.push(walker);
    }
  }

  if (walkers.length) {
    return {
      context: nodeType.walkContext,
      fields: walkers,
    };
  }

  return null;
}

function getTypesFromConfig$1(config) {
  const types = {};

  for (const name in config.node) {
    if (hasOwnProperty$c.call(config.node, name)) {
      const nodeType = config.node[name];

      if (!nodeType.structure) {
        throw new Error(
          "Missed `structure` field in `" + name + "` node type definition",
        );
      }

      types[name] = getWalkersFromStructure$1(name, nodeType);
    }
  }

  return types;
}

function createTypeIterator$1(config, reverse) {
  const fields = config.fields.slice();
  const contextName = config.context;
  const useContext = typeof contextName === "string";

  if (reverse) {
    fields.reverse();
  }

  return function (node, context, walk, walkReducer) {
    let prevContextValue;

    if (useContext) {
      prevContextValue = context[contextName];
      context[contextName] = node;
    }

    for (const field of fields) {
      const ref = node[field.name];

      if (!field.nullable || ref) {
        if (field.type === "list") {
          const breakWalk = reverse
            ? ref.reduceRight(walkReducer, false)
            : ref.reduce(walkReducer, false);

          if (breakWalk) {
            return true;
          }
        } else if (walk(ref)) {
          return true;
        }
      }
    }

    if (useContext) {
      context[contextName] = prevContextValue;
    }
  };
}

function createFastTraveralMap$1({
  StyleSheet,
  Atrule,
  Rule,
  Block,
  DeclarationList,
}) {
  return {
    Atrule: {
      StyleSheet,
      Atrule,
      Rule,
      Block,
    },
    Rule: {
      StyleSheet,
      Atrule,
      Rule,
      Block,
    },
    Declaration: {
      StyleSheet,
      Atrule,
      Rule,
      Block,
      DeclarationList,
    },
  };
}

function createWalker$1(config) {
  const types = getTypesFromConfig$1(config);
  const iteratorsNatural = {};
  const iteratorsReverse = {};
  const breakWalk = Symbol("break-walk");
  const skipNode = Symbol("skip-node");

  for (const name in types) {
    if (hasOwnProperty$c.call(types, name) && types[name] !== null) {
      iteratorsNatural[name] = createTypeIterator$1(types[name], false);
      iteratorsReverse[name] = createTypeIterator$1(types[name], true);
    }
  }

  const fastTraversalIteratorsNatural =
    createFastTraveralMap$1(iteratorsNatural);
  const fastTraversalIteratorsReverse =
    createFastTraveralMap$1(iteratorsReverse);

  const walk = function (root, options) {
    function walkNode(node, item, list) {
      const enterRet = enter.call(context, node, item, list);

      if (enterRet === breakWalk) {
        return true;
      }

      if (enterRet === skipNode) {
        return false;
      }

      if (iterators.hasOwnProperty(node.type)) {
        if (iterators[node.type](node, context, walkNode, walkReducer)) {
          return true;
        }
      }

      if (leave.call(context, node, item, list) === breakWalk) {
        return true;
      }

      return false;
    }

    let enter = noop$8;
    let leave = noop$8;
    let iterators = iteratorsNatural;
    let walkReducer = (ret, data, item, list) =>
      ret || walkNode(data, item, list);
    const context = {
      break: breakWalk,
      skip: skipNode,

      root,
      stylesheet: null,
      atrule: null,
      atrulePrelude: null,
      rule: null,
      selector: null,
      block: null,
      declaration: null,
      function: null,
    };

    if (typeof options === "function") {
      enter = options;
    } else if (options) {
      enter = ensureFunction$3(options.enter);
      leave = ensureFunction$3(options.leave);

      if (options.reverse) {
        iterators = iteratorsReverse;
      }

      if (options.visit) {
        if (fastTraversalIteratorsNatural.hasOwnProperty(options.visit)) {
          iterators = options.reverse
            ? fastTraversalIteratorsReverse[options.visit]
            : fastTraversalIteratorsNatural[options.visit];
        } else if (!types.hasOwnProperty(options.visit)) {
          throw new Error(
            "Bad value `" +
              options.visit +
              "` for `visit` option (should be: " +
              Object.keys(types).sort().join(", ") +
              ")",
          );
        }

        enter = invokeForType$1(enter, options.visit);
        leave = invokeForType$1(leave, options.visit);
      }
    }

    if (enter === noop$8 && leave === noop$8) {
      throw new Error(
        "Neither `enter` nor `leave` walker handler is set or both aren't a function",
      );
    }

    walkNode(root);
  };

  walk.break = breakWalk;
  walk.skip = skipNode;

  walk.find = function (ast, fn) {
    let found = null;

    walk(ast, function (node, item, list) {
      if (fn.call(this, node, item, list)) {
        found = node;
        return breakWalk;
      }
    });

    return found;
  };

  walk.findLast = function (ast, fn) {
    let found = null;

    walk(ast, {
      reverse: true,
      enter(node, item, list) {
        if (fn.call(this, node, item, list)) {
          found = node;
          return breakWalk;
        }
      },
    });

    return found;
  };

  walk.findAll = function (ast, fn) {
    const found = [];

    walk(ast, function (node, item, list) {
      if (fn.call(this, node, item, list)) {
        found.push(node);
      }
    });

    return found;
  };

  return walk;
}

create$b.createWalker = createWalker$1;

var Lexer$7 = {};

var error$4 = {};

var generate$1u = {};

function noop$7(value) {
  return value;
}

function generateMultiplier$1(multiplier) {
  const { min, max, comma } = multiplier;

  if (min === 0 && max === 0) {
    return comma ? "#?" : "*";
  }

  if (min === 0 && max === 1) {
    return "?";
  }

  if (min === 1 && max === 0) {
    return comma ? "#" : "+";
  }

  if (min === 1 && max === 1) {
    return "";
  }

  return (
    (comma ? "#" : "") +
    (min === max
      ? "{" + min + "}"
      : "{" + min + "," + (max !== 0 ? max : "") + "}")
  );
}

function generateTypeOpts$1(node) {
  switch (node.type) {
    case "Range":
      return (
        " [" +
        (node.min === null ? "-" : node.min) +
        "," +
        (node.max === null ? "" : node.max) +
        "]"
      );

    default:
      throw new Error("Unknown node type `" + node.type + "`");
  }
}

function generateSequence$1(node, decorate, forceBraces, compact) {
  const combinator =
    node.combinator === " " || compact
      ? node.combinator
      : " " + node.combinator + " ";
  const result = node.terms
    .map((term) => internalGenerate$1(term, decorate, forceBraces, compact))
    .join(combinator);

  if (node.explicit || forceBraces) {
    return (
      (compact || result[0] === "," ? "[" : "[ ") +
      result +
      (compact ? "]" : " ]")
    );
  }

  return result;
}

function internalGenerate$1(node, decorate, forceBraces, compact) {
  let result;

  switch (node.type) {
    case "Group":
      result =
        generateSequence$1(node, decorate, forceBraces, compact) +
        (node.disallowEmpty ? "!" : "");
      break;

    case "Multiplier":
      // return since node is a composition
      return (
        internalGenerate$1(node.term, decorate, forceBraces, compact) +
        decorate(generateMultiplier$1(node), node)
      );

    case "Type":
      result =
        "<" +
        node.name +
        (node.opts ? decorate(generateTypeOpts$1(node.opts), node.opts) : "") +
        ">";
      break;

    case "Property":
      result = "<'" + node.name + "'>";
      break;

    case "Keyword":
      result = node.name;
      break;

    case "AtKeyword":
      result = "@" + node.name;
      break;

    case "Function":
      result = node.name + "(";
      break;

    case "String":
    case "Token":
      result = node.value;
      break;

    case "Comma":
      result = ",";
      break;

    default:
      throw new Error("Unknown node type `" + node.type + "`");
  }

  return decorate(result, node);
}

function generate$1t(node, options) {
  let decorate = noop$7;
  let forceBraces = false;
  let compact = false;

  if (typeof options === "function") {
    decorate = options;
  } else if (options) {
    forceBraces = Boolean(options.forceBraces);
    compact = Boolean(options.compact);
    if (typeof options.decorate === "function") {
      decorate = options.decorate;
    }
  }

  return internalGenerate$1(node, decorate, forceBraces, compact);
}

generate$1u.generate = generate$1t;

const createCustomError$6 = createCustomError$9;
const generate$1s = generate$1u;

const defaultLoc$1 = { offset: 0, line: 1, column: 1 };

function locateMismatch$1(matchResult, node) {
  const tokens = matchResult.tokens;
  const longestMatch = matchResult.longestMatch;
  const mismatchNode =
    longestMatch < tokens.length ? tokens[longestMatch].node || null : null;
  const badNode = mismatchNode !== node ? mismatchNode : null;
  let mismatchOffset = 0;
  let mismatchLength = 0;
  let entries = 0;
  let css = "";
  let start;
  let end;

  for (let i = 0; i < tokens.length; i++) {
    const token = tokens[i].value;

    if (i === longestMatch) {
      mismatchLength = token.length;
      mismatchOffset = css.length;
    }

    if (badNode !== null && tokens[i].node === badNode) {
      if (i <= longestMatch) {
        entries++;
      } else {
        entries = 0;
      }
    }

    css += token;
  }

  if (longestMatch === tokens.length || entries > 1) {
    // last
    start = fromLoc$1(badNode || node, "end") || buildLoc$1(defaultLoc$1, css);
    end = buildLoc$1(start);
  } else {
    start =
      fromLoc$1(badNode, "start") ||
      buildLoc$1(
        fromLoc$1(node, "start") || defaultLoc$1,
        css.slice(0, mismatchOffset),
      );
    end =
      fromLoc$1(badNode, "end") ||
      buildLoc$1(start, css.substr(mismatchOffset, mismatchLength));
  }

  return {
    css,
    mismatchOffset,
    mismatchLength,
    start,
    end,
  };
}

function fromLoc$1(node, point) {
  const value = node && node.loc && node.loc[point];

  if (value) {
    return "line" in value ? buildLoc$1(value) : value;
  }

  return null;
}

function buildLoc$1({ offset, line, column }, extra) {
  const loc = {
    offset,
    line,
    column,
  };

  if (extra) {
    const lines = extra.split(/\n|\r\n?|\f/);

    loc.offset += extra.length;
    loc.line += lines.length - 1;
    loc.column =
      lines.length === 1 ? loc.column + extra.length : lines.pop().length + 1;
  }

  return loc;
}

const SyntaxReferenceError$1 = function (type, referenceName) {
  const error = createCustomError$6.createCustomError(
    "SyntaxReferenceError",
    type + (referenceName ? " `" + referenceName + "`" : ""),
  );

  error.reference = referenceName;

  return error;
};

const SyntaxMatchError$1 = function (message, syntax, node, matchResult) {
  const error = createCustomError$6.createCustomError(
    "SyntaxMatchError",
    message,
  );
  const { css, mismatchOffset, mismatchLength, start, end } = locateMismatch$1(
    matchResult,
    node,
  );

  error.rawMessage = message;
  error.syntax = syntax ? generate$1s.generate(syntax) : "<generic>";
  error.css = css;
  error.mismatchOffset = mismatchOffset;
  error.mismatchLength = mismatchLength;
  error.message =
    message +
    "\n" +
    "  syntax: " +
    error.syntax +
    "\n" +
    "   value: " +
    (css || "<empty string>") +
    "\n" +
    "  --------" +
    new Array(error.mismatchOffset + 1).join("-") +
    "^";

  Object.assign(error, start);
  error.loc = {
    source: (node && node.loc && node.loc.source) || "<unknown>",
    start,
    end,
  };

  return error;
};

error$4.SyntaxMatchError = SyntaxMatchError$1;
error$4.SyntaxReferenceError = SyntaxReferenceError$1;

var names$c = {};

const keywords$4 = new Map();
const properties$3 = new Map();
const HYPHENMINUS$c = 45; // '-'.charCodeAt()

const keyword$1 = getKeywordDescriptor$1;
const property$1 = getPropertyDescriptor$1;
const vendorPrefix$1 = getVendorPrefix$1;
function isCustomProperty$1(str, offset) {
  offset = offset || 0;

  return (
    str.length - offset >= 2 &&
    str.charCodeAt(offset) === HYPHENMINUS$c &&
    str.charCodeAt(offset + 1) === HYPHENMINUS$c
  );
}

function getVendorPrefix$1(str, offset) {
  offset = offset || 0;

  // verdor prefix should be at least 3 chars length
  if (str.length - offset >= 3) {
    // vendor prefix starts with hyper minus following non-hyper minus
    if (
      str.charCodeAt(offset) === HYPHENMINUS$c &&
      str.charCodeAt(offset + 1) !== HYPHENMINUS$c
    ) {
      // vendor prefix should contain a hyper minus at the ending
      const secondDashIndex = str.indexOf("-", offset + 2);

      if (secondDashIndex !== -1) {
        return str.substring(offset, secondDashIndex + 1);
      }
    }
  }

  return "";
}

function getKeywordDescriptor$1(keyword) {
  if (keywords$4.has(keyword)) {
    return keywords$4.get(keyword);
  }

  const name = keyword.toLowerCase();
  let descriptor = keywords$4.get(name);

  if (descriptor === undefined) {
    const custom = isCustomProperty$1(name, 0);
    const vendor = !custom ? getVendorPrefix$1(name, 0) : "";
    descriptor = Object.freeze({
      basename: name.substr(vendor.length),
      name,
      prefix: vendor,
      vendor,
      custom,
    });
  }

  keywords$4.set(keyword, descriptor);

  return descriptor;
}

function getPropertyDescriptor$1(property) {
  if (properties$3.has(property)) {
    return properties$3.get(property);
  }

  let name = property;
  let hack = property[0];

  if (hack === "/") {
    hack = property[1] === "/" ? "//" : "/";
  } else if (
    hack !== "_" &&
    hack !== "*" &&
    hack !== "$" &&
    hack !== "#" &&
    hack !== "+" &&
    hack !== "&"
  ) {
    hack = "";
  }

  const custom = isCustomProperty$1(name, hack.length);

  // re-use result when possible (the same as for lower case)
  if (!custom) {
    name = name.toLowerCase();
    if (properties$3.has(name)) {
      const descriptor = properties$3.get(name);
      properties$3.set(property, descriptor);
      return descriptor;
    }
  }

  const vendor = !custom ? getVendorPrefix$1(name, hack.length) : "";
  const prefix = name.substr(0, hack.length + vendor.length);
  const descriptor = Object.freeze({
    basename: name.substr(prefix.length),
    name: name.substr(hack.length),
    hack,
    vendor,
    prefix,
    custom,
  });

  properties$3.set(property, descriptor);

  return descriptor;
}

names$c.isCustomProperty = isCustomProperty$1;
names$c.keyword = keyword$1;
names$c.property = property$1;
names$c.vendorPrefix = vendorPrefix$1;

var genericConst$5 = {};

// https://drafts.csswg.org/css-cascade-5/
const cssWideKeywords$1 = [
  "initial",
  "inherit",
  "unset",
  "revert",
  "revert-layer",
];

genericConst$5.cssWideKeywords = cssWideKeywords$1;

var generic$3 = {};

const charCodeDefinitions$l = charCodeDefinitions$p;
const types$1F = types$1M;
const utils$q = utils$u;

const PLUSSIGN$i = 0x002b; // U+002B PLUS SIGN (+)
const HYPHENMINUS$b = 0x002d; // U+002D HYPHEN-MINUS (-)
const N$8 = 0x006e; // U+006E LATIN SMALL LETTER N (n)
const DISALLOW_SIGN$3 = true;
const ALLOW_SIGN$3 = false;

function isDelim$3(token, code) {
  return (
    token !== null &&
    token.type === types$1F.Delim &&
    token.value.charCodeAt(0) === code
  );
}

function skipSC$1(token, offset, getNextToken) {
  while (
    token !== null &&
    (token.type === types$1F.WhiteSpace || token.type === types$1F.Comment)
  ) {
    token = getNextToken(++offset);
  }

  return offset;
}

function checkInteger$3(token, valueOffset, disallowSign, offset) {
  if (!token) {
    return 0;
  }

  const code = token.value.charCodeAt(valueOffset);

  if (code === PLUSSIGN$i || code === HYPHENMINUS$b) {
    if (disallowSign) {
      // Number sign is not allowed
      return 0;
    }
    valueOffset++;
  }

  for (; valueOffset < token.value.length; valueOffset++) {
    if (!charCodeDefinitions$l.isDigit(token.value.charCodeAt(valueOffset))) {
      // Integer is expected
      return 0;
    }
  }

  return offset + 1;
}

// ... <signed-integer>
// ... ['+' | '-'] <signless-integer>
function consumeB$3(token, offset_, getNextToken) {
  let sign = false;
  let offset = skipSC$1(token, offset_, getNextToken);

  token = getNextToken(offset);

  if (token === null) {
    return offset_;
  }

  if (token.type !== types$1F.Number) {
    if (isDelim$3(token, PLUSSIGN$i) || isDelim$3(token, HYPHENMINUS$b)) {
      sign = true;
      offset = skipSC$1(getNextToken(++offset), offset, getNextToken);
      token = getNextToken(offset);

      if (token === null || token.type !== types$1F.Number) {
        return 0;
      }
    } else {
      return offset_;
    }
  }

  if (!sign) {
    const code = token.value.charCodeAt(0);
    if (code !== PLUSSIGN$i && code !== HYPHENMINUS$b) {
      // Number sign is expected
      return 0;
    }
  }

  return checkInteger$3(token, sign ? 0 : 1, sign, offset);
}

// An+B microsyntax https://www.w3.org/TR/css-syntax-3/#anb
function anPlusB$1(token, getNextToken) {
  /* eslint-disable brace-style*/
  let offset = 0;

  if (!token) {
    return 0;
  }

  // <integer>
  if (token.type === types$1F.Number) {
    return checkInteger$3(token, 0, ALLOW_SIGN$3, offset); // b
  }

  // -n
  // -n <signed-integer>
  // -n ['+' | '-'] <signless-integer>
  // -n- <signless-integer>
  // <dashndashdigit-ident>
  else if (
    token.type === types$1F.Ident &&
    token.value.charCodeAt(0) === HYPHENMINUS$b
  ) {
    // expect 1st char is N
    if (!utils$q.cmpChar(token.value, 1, N$8)) {
      return 0;
    }

    switch (token.value.length) {
      // -n
      // -n <signed-integer>
      // -n ['+' | '-'] <signless-integer>
      case 2:
        return consumeB$3(getNextToken(++offset), offset, getNextToken);

      // -n- <signless-integer>
      case 3:
        if (token.value.charCodeAt(2) !== HYPHENMINUS$b) {
          return 0;
        }

        offset = skipSC$1(getNextToken(++offset), offset, getNextToken);
        token = getNextToken(offset);

        return checkInteger$3(token, 0, DISALLOW_SIGN$3, offset);

      // <dashndashdigit-ident>
      default:
        if (token.value.charCodeAt(2) !== HYPHENMINUS$b) {
          return 0;
        }

        return checkInteger$3(token, 3, DISALLOW_SIGN$3, offset);
    }
  }

  // '+'? n
  // '+'? n <signed-integer>
  // '+'? n ['+' | '-'] <signless-integer>
  // '+'? n- <signless-integer>
  // '+'? <ndashdigit-ident>
  else if (
    token.type === types$1F.Ident ||
    (isDelim$3(token, PLUSSIGN$i) &&
      getNextToken(offset + 1).type === types$1F.Ident)
  ) {
    // just ignore a plus
    if (token.type !== types$1F.Ident) {
      token = getNextToken(++offset);
    }

    if (token === null || !utils$q.cmpChar(token.value, 0, N$8)) {
      return 0;
    }

    switch (token.value.length) {
      // '+'? n
      // '+'? n <signed-integer>
      // '+'? n ['+' | '-'] <signless-integer>
      case 1:
        return consumeB$3(getNextToken(++offset), offset, getNextToken);

      // '+'? n- <signless-integer>
      case 2:
        if (token.value.charCodeAt(1) !== HYPHENMINUS$b) {
          return 0;
        }

        offset = skipSC$1(getNextToken(++offset), offset, getNextToken);
        token = getNextToken(offset);

        return checkInteger$3(token, 0, DISALLOW_SIGN$3, offset);

      // '+'? <ndashdigit-ident>
      default:
        if (token.value.charCodeAt(1) !== HYPHENMINUS$b) {
          return 0;
        }

        return checkInteger$3(token, 2, DISALLOW_SIGN$3, offset);
    }
  }

  // <ndashdigit-dimension>
  // <ndash-dimension> <signless-integer>
  // <n-dimension>
  // <n-dimension> <signed-integer>
  // <n-dimension> ['+' | '-'] <signless-integer>
  else if (token.type === types$1F.Dimension) {
    let code = token.value.charCodeAt(0);
    let sign = code === PLUSSIGN$i || code === HYPHENMINUS$b ? 1 : 0;
    let i = sign;

    for (; i < token.value.length; i++) {
      if (!charCodeDefinitions$l.isDigit(token.value.charCodeAt(i))) {
        break;
      }
    }

    if (i === sign) {
      // Integer is expected
      return 0;
    }

    if (!utils$q.cmpChar(token.value, i, N$8)) {
      return 0;
    }

    // <n-dimension>
    // <n-dimension> <signed-integer>
    // <n-dimension> ['+' | '-'] <signless-integer>
    if (i + 1 === token.value.length) {
      return consumeB$3(getNextToken(++offset), offset, getNextToken);
    } else {
      if (token.value.charCodeAt(i + 1) !== HYPHENMINUS$b) {
        return 0;
      }

      // <ndash-dimension> <signless-integer>
      if (i + 2 === token.value.length) {
        offset = skipSC$1(getNextToken(++offset), offset, getNextToken);
        token = getNextToken(offset);

        return checkInteger$3(token, 0, DISALLOW_SIGN$3, offset);
      }
      // <ndashdigit-dimension>
      else {
        return checkInteger$3(token, i + 2, DISALLOW_SIGN$3, offset);
      }
    }
  }

  return 0;
}

var genericAnPlusB$3 = anPlusB$1;

const charCodeDefinitions$k = charCodeDefinitions$p;
const types$1E = types$1M;
const utils$p = utils$u;

const PLUSSIGN$h = 0x002b; // U+002B PLUS SIGN (+)
const HYPHENMINUS$a = 0x002d; // U+002D HYPHEN-MINUS (-)
const QUESTIONMARK$5 = 0x003f; // U+003F QUESTION MARK (?)
const U$3 = 0x0075; // U+0075 LATIN SMALL LETTER U (u)

function isDelim$2(token, code) {
  return (
    token !== null &&
    token.type === types$1E.Delim &&
    token.value.charCodeAt(0) === code
  );
}

function startsWith$3(token, code) {
  return token.value.charCodeAt(0) === code;
}

function hexSequence$1(token, offset, allowDash) {
  let hexlen = 0;

  for (let pos = offset; pos < token.value.length; pos++) {
    const code = token.value.charCodeAt(pos);

    if (code === HYPHENMINUS$a && allowDash && hexlen !== 0) {
      hexSequence$1(token, offset + hexlen + 1, false);
      return 6; // dissallow following question marks
    }

    if (!charCodeDefinitions$k.isHexDigit(code)) {
      return 0; // not a hex digit
    }

    if (++hexlen > 6) {
      return 0; // too many hex digits
    }
  }

  return hexlen;
}

function withQuestionMarkSequence$1(consumed, length, getNextToken) {
  if (!consumed) {
    return 0; // nothing consumed
  }

  while (isDelim$2(getNextToken(length), QUESTIONMARK$5)) {
    if (++consumed > 6) {
      return 0; // too many question marks
    }

    length++;
  }

  return length;
}

// https://drafts.csswg.org/css-syntax/#urange
// Informally, the <urange> production has three forms:
// U+0001
//      Defines a range consisting of a single code point, in this case the code point "1".
// U+0001-00ff
//      Defines a range of codepoints between the first and the second value, in this case
//      the range between "1" and "ff" (255 in decimal) inclusive.
// U+00??
//      Defines a range of codepoints where the "?" characters range over all hex digits,
//      in this case defining the same as the value U+0000-00ff.
// In each form, a maximum of 6 digits is allowed for each hexadecimal number (if you treat "?" as a hexadecimal digit).
//
// <urange> =
//   u '+' <ident-token> '?'* |
//   u <dimension-token> '?'* |
//   u <number-token> '?'* |
//   u <number-token> <dimension-token> |
//   u <number-token> <number-token> |
//   u '+' '?'+
function urange$1(token, getNextToken) {
  let length = 0;

  // should start with `u` or `U`
  if (
    token === null ||
    token.type !== types$1E.Ident ||
    !utils$p.cmpChar(token.value, 0, U$3)
  ) {
    return 0;
  }

  token = getNextToken(++length);
  if (token === null) {
    return 0;
  }

  // u '+' <ident-token> '?'*
  // u '+' '?'+
  if (isDelim$2(token, PLUSSIGN$h)) {
    token = getNextToken(++length);
    if (token === null) {
      return 0;
    }

    if (token.type === types$1E.Ident) {
      // u '+' <ident-token> '?'*
      return withQuestionMarkSequence$1(
        hexSequence$1(token, 0, true),
        ++length,
        getNextToken,
      );
    }

    if (isDelim$2(token, QUESTIONMARK$5)) {
      // u '+' '?'+
      return withQuestionMarkSequence$1(1, ++length, getNextToken);
    }

    // Hex digit or question mark is expected
    return 0;
  }

  // u <number-token> '?'*
  // u <number-token> <dimension-token>
  // u <number-token> <number-token>
  if (token.type === types$1E.Number) {
    const consumedHexLength = hexSequence$1(token, 1, true);
    if (consumedHexLength === 0) {
      return 0;
    }

    token = getNextToken(++length);
    if (token === null) {
      // u <number-token> <eof>
      return length;
    }

    if (token.type === types$1E.Dimension || token.type === types$1E.Number) {
      // u <number-token> <dimension-token>
      // u <number-token> <number-token>
      if (
        !startsWith$3(token, HYPHENMINUS$a) ||
        !hexSequence$1(token, 1, false)
      ) {
        return 0;
      }

      return length + 1;
    }

    // u <number-token> '?'*
    return withQuestionMarkSequence$1(consumedHexLength, length, getNextToken);
  }

  // u <dimension-token> '?'*
  if (token.type === types$1E.Dimension) {
    return withQuestionMarkSequence$1(
      hexSequence$1(token, 1, true),
      ++length,
      getNextToken,
    );
  }

  return 0;
}

var genericUrange$3 = urange$1;

const genericConst$4 = genericConst$5;
const genericAnPlusB$2 = genericAnPlusB$3;
const genericUrange$2 = genericUrange$3;
const types$1D = types$1M;
const charCodeDefinitions$j = charCodeDefinitions$p;
const utils$o = utils$u;

const calcFunctionNames$1 = ["calc(", "-moz-calc(", "-webkit-calc("];
const balancePair$2 = new Map([
  [types$1D.Function, types$1D.RightParenthesis],
  [types$1D.LeftParenthesis, types$1D.RightParenthesis],
  [types$1D.LeftSquareBracket, types$1D.RightSquareBracket],
  [types$1D.LeftCurlyBracket, types$1D.RightCurlyBracket],
]);

// safe char code getter
function charCodeAt$1(str, index) {
  return index < str.length ? str.charCodeAt(index) : 0;
}

function eqStr$1(actual, expected) {
  return utils$o.cmpStr(actual, 0, actual.length, expected);
}

function eqStrAny$1(actual, expected) {
  for (let i = 0; i < expected.length; i++) {
    if (eqStr$1(actual, expected[i])) {
      return true;
    }
  }

  return false;
}

// IE postfix hack, i.e. 123\0 or 123px\9
function isPostfixIeHack$1(str, offset) {
  if (offset !== str.length - 2) {
    return false;
  }

  return (
    charCodeAt$1(str, offset) === 0x005c && // U+005C REVERSE SOLIDUS (\)
    charCodeDefinitions$j.isDigit(charCodeAt$1(str, offset + 1))
  );
}

function outOfRange$1(opts, value, numEnd) {
  if (opts && opts.type === "Range") {
    const num = Number(
      numEnd !== undefined && numEnd !== value.length
        ? value.substr(0, numEnd)
        : value,
    );

    if (isNaN(num)) {
      return true;
    }

    // FIXME: when opts.min is a string it's a dimension, skip a range validation
    // for now since it requires a type covertation which is not implmented yet
    if (opts.min !== null && num < opts.min && typeof opts.min !== "string") {
      return true;
    }

    // FIXME: when opts.max is a string it's a dimension, skip a range validation
    // for now since it requires a type covertation which is not implmented yet
    if (opts.max !== null && num > opts.max && typeof opts.max !== "string") {
      return true;
    }
  }

  return false;
}

function consumeFunction$1(token, getNextToken) {
  let balanceCloseType = 0;
  let balanceStash = [];
  let length = 0;

  // balanced token consuming
  scan: do {
    switch (token.type) {
      case types$1D.RightCurlyBracket:
      case types$1D.RightParenthesis:
      case types$1D.RightSquareBracket:
        if (token.type !== balanceCloseType) {
          break scan;
        }

        balanceCloseType = balanceStash.pop();

        if (balanceStash.length === 0) {
          length++;
          break scan;
        }

        break;

      case types$1D.Function:
      case types$1D.LeftParenthesis:
      case types$1D.LeftSquareBracket:
      case types$1D.LeftCurlyBracket:
        balanceStash.push(balanceCloseType);
        balanceCloseType = balancePair$2.get(token.type);
        break;
    }

    length++;
  } while ((token = getNextToken(length)));

  return length;
}

// TODO: implement
// can be used wherever <length>, <frequency>, <angle>, <time>, <percentage>, <number>, or <integer> values are allowed
// https://drafts.csswg.org/css-values/#calc-notation
function calc$1(next) {
  return function (token, getNextToken, opts) {
    if (token === null) {
      return 0;
    }

    if (
      token.type === types$1D.Function &&
      eqStrAny$1(token.value, calcFunctionNames$1)
    ) {
      return consumeFunction$1(token, getNextToken);
    }

    return next(token, getNextToken, opts);
  };
}

function tokenType$1(expectedTokenType) {
  return function (token) {
    if (token === null || token.type !== expectedTokenType) {
      return 0;
    }

    return 1;
  };
}

// =========================
// Complex types
//

// https://drafts.csswg.org/css-values-4/#custom-idents
// 4.2. Author-defined Identifiers: the <custom-ident> type
// Some properties accept arbitrary author-defined identifiers as a component value.
// This generic data type is denoted by <custom-ident>, and represents any valid CSS identifier
// that would not be misinterpreted as a pre-defined keyword in that propertys value definition.
//
// See also: https://developer.mozilla.org/en-US/docs/Web/CSS/custom-ident
function customIdent$1(token) {
  if (token === null || token.type !== types$1D.Ident) {
    return 0;
  }

  const name = token.value.toLowerCase();

  // The CSS-wide keywords are not valid <custom-ident>s
  if (eqStrAny$1(name, genericConst$4.cssWideKeywords)) {
    return 0;
  }

  // The default keyword is reserved and is also not a valid <custom-ident>
  if (eqStr$1(name, "default")) {
    return 0;
  }

  // TODO: ignore property specific keywords (as described https://developer.mozilla.org/en-US/docs/Web/CSS/custom-ident)
  // Specifications using <custom-ident> must specify clearly what other keywords
  // are excluded from <custom-ident>, if anyfor example by saying that any pre-defined keywords
  // in that propertys value definition are excluded. Excluded keywords are excluded
  // in all ASCII case permutations.

  return 1;
}

// https://drafts.csswg.org/css-variables/#typedef-custom-property-name
// A custom property is any property whose name starts with two dashes (U+002D HYPHEN-MINUS), like --foo.
// The <custom-property-name> production corresponds to this: its defined as any valid identifier
// that starts with two dashes, except -- itself, which is reserved for future use by CSS.
// NOTE: Current implementation treat `--` as a valid name since most (all?) major browsers treat it as valid.
function customPropertyName$1(token) {
  // ... defined as any valid identifier
  if (token === null || token.type !== types$1D.Ident) {
    return 0;
  }

  // ... that starts with two dashes (U+002D HYPHEN-MINUS)
  if (
    charCodeAt$1(token.value, 0) !== 0x002d ||
    charCodeAt$1(token.value, 1) !== 0x002d
  ) {
    return 0;
  }

  return 1;
}

// https://drafts.csswg.org/css-color-4/#hex-notation
// The syntax of a <hex-color> is a <hash-token> token whose value consists of 3, 4, 6, or 8 hexadecimal digits.
// In other words, a hex color is written as a hash character, "#", followed by some number of digits 0-9 or
// letters a-f (the case of the letters doesnt matter - #00ff00 is identical to #00FF00).
function hexColor$1(token) {
  if (token === null || token.type !== types$1D.Hash) {
    return 0;
  }

  const length = token.value.length;

  // valid values (length): #rgb (4), #rgba (5), #rrggbb (7), #rrggbbaa (9)
  if (length !== 4 && length !== 5 && length !== 7 && length !== 9) {
    return 0;
  }

  for (let i = 1; i < length; i++) {
    if (!charCodeDefinitions$j.isHexDigit(charCodeAt$1(token.value, i))) {
      return 0;
    }
  }

  return 1;
}

function idSelector$1(token) {
  if (token === null || token.type !== types$1D.Hash) {
    return 0;
  }

  if (
    !charCodeDefinitions$j.isIdentifierStart(
      charCodeAt$1(token.value, 1),
      charCodeAt$1(token.value, 2),
      charCodeAt$1(token.value, 3),
    )
  ) {
    return 0;
  }

  return 1;
}

// https://drafts.csswg.org/css-syntax/#any-value
// It represents the entirety of what a valid declaration can have as its value.
function declarationValue$1(token, getNextToken) {
  if (!token) {
    return 0;
  }

  let balanceCloseType = 0;
  let balanceStash = [];
  let length = 0;

  // The <declaration-value> production matches any sequence of one or more tokens,
  // so long as the sequence does not contain ...
  scan: do {
    switch (token.type) {
      // ... <bad-string-token>, <bad-url-token>,
      case types$1D.BadString:
      case types$1D.BadUrl:
        break scan;

      // ... unmatched <)-token>, <]-token>, or <}-token>,
      case types$1D.RightCurlyBracket:
      case types$1D.RightParenthesis:
      case types$1D.RightSquareBracket:
        if (token.type !== balanceCloseType) {
          break scan;
        }

        balanceCloseType = balanceStash.pop();
        break;

      // ... or top-level <semicolon-token> tokens
      case types$1D.Semicolon:
        if (balanceCloseType === 0) {
          break scan;
        }

        break;

      // ... or <delim-token> tokens with a value of "!"
      case types$1D.Delim:
        if (balanceCloseType === 0 && token.value === "!") {
          break scan;
        }

        break;

      case types$1D.Function:
      case types$1D.LeftParenthesis:
      case types$1D.LeftSquareBracket:
      case types$1D.LeftCurlyBracket:
        balanceStash.push(balanceCloseType);
        balanceCloseType = balancePair$2.get(token.type);
        break;
    }

    length++;
  } while ((token = getNextToken(length)));

  return length;
}

// https://drafts.csswg.org/css-syntax/#any-value
// The <any-value> production is identical to <declaration-value>, but also
// allows top-level <semicolon-token> tokens and <delim-token> tokens
// with a value of "!". It represents the entirety of what valid CSS can be in any context.
function anyValue$1(token, getNextToken) {
  if (!token) {
    return 0;
  }

  let balanceCloseType = 0;
  let balanceStash = [];
  let length = 0;

  // The <any-value> production matches any sequence of one or more tokens,
  // so long as the sequence ...
  scan: do {
    switch (token.type) {
      // ... does not contain <bad-string-token>, <bad-url-token>,
      case types$1D.BadString:
      case types$1D.BadUrl:
        break scan;

      // ... unmatched <)-token>, <]-token>, or <}-token>,
      case types$1D.RightCurlyBracket:
      case types$1D.RightParenthesis:
      case types$1D.RightSquareBracket:
        if (token.type !== balanceCloseType) {
          break scan;
        }

        balanceCloseType = balanceStash.pop();
        break;

      case types$1D.Function:
      case types$1D.LeftParenthesis:
      case types$1D.LeftSquareBracket:
      case types$1D.LeftCurlyBracket:
        balanceStash.push(balanceCloseType);
        balanceCloseType = balancePair$2.get(token.type);
        break;
    }

    length++;
  } while ((token = getNextToken(length)));

  return length;
}

// =========================
// Dimensions
//

function dimension$1(type) {
  if (type) {
    type = new Set(type);
  }

  return function (token, getNextToken, opts) {
    if (token === null || token.type !== types$1D.Dimension) {
      return 0;
    }

    const numberEnd = utils$o.consumeNumber(token.value, 0);

    // check unit
    if (type !== null) {
      // check for IE postfix hack, i.e. 123px\0 or 123px\9
      const reverseSolidusOffset = token.value.indexOf("\\", numberEnd);
      const unit =
        reverseSolidusOffset === -1 ||
        !isPostfixIeHack$1(token.value, reverseSolidusOffset)
          ? token.value.substr(numberEnd)
          : token.value.substring(numberEnd, reverseSolidusOffset);

      if (type.has(unit.toLowerCase()) === false) {
        return 0;
      }
    }

    // check range if specified
    if (outOfRange$1(opts, token.value, numberEnd)) {
      return 0;
    }

    return 1;
  };
}

// =========================
// Percentage
//

// 5.5. Percentages: the <percentage> type
// https://drafts.csswg.org/css-values-4/#percentages
function percentage$1(token, getNextToken, opts) {
  // ... corresponds to the <percentage-token> production
  if (token === null || token.type !== types$1D.Percentage) {
    return 0;
  }

  // check range if specified
  if (outOfRange$1(opts, token.value, token.value.length - 1)) {
    return 0;
  }

  return 1;
}

// =========================
// Numeric
//

// https://drafts.csswg.org/css-values-4/#numbers
// The value <zero> represents a literal number with the value 0. Expressions that merely
// evaluate to a <number> with the value 0 (for example, calc(0)) do not match <zero>;
// only literal <number-token>s do.
function zero$1(next) {
  if (typeof next !== "function") {
    next = function () {
      return 0;
    };
  }

  return function (token, getNextToken, opts) {
    if (token !== null && token.type === types$1D.Number) {
      if (Number(token.value) === 0) {
        return 1;
      }
    }

    return next(token, getNextToken, opts);
  };
}

//  5.3. Real Numbers: the <number> type
// https://drafts.csswg.org/css-values-4/#numbers
// Number values are denoted by <number>, and represent real numbers, possibly with a fractional component.
// ... It corresponds to the <number-token> production
function number$1(token, getNextToken, opts) {
  if (token === null) {
    return 0;
  }

  const numberEnd = utils$o.consumeNumber(token.value, 0);
  const isNumber = numberEnd === token.value.length;
  if (!isNumber && !isPostfixIeHack$1(token.value, numberEnd)) {
    return 0;
  }

  // check range if specified
  if (outOfRange$1(opts, token.value, numberEnd)) {
    return 0;
  }

  return 1;
}

// 5.2. Integers: the <integer> type
// https://drafts.csswg.org/css-values-4/#integers
function integer$1(token, getNextToken, opts) {
  // ... corresponds to a subset of the <number-token> production
  if (token === null || token.type !== types$1D.Number) {
    return 0;
  }

  // The first digit of an integer may be immediately preceded by `-` or `+` to indicate the integers sign.
  let i =
    charCodeAt$1(token.value, 0) === 0x002b || // U+002B PLUS SIGN (+)
    charCodeAt$1(token.value, 0) === 0x002d
      ? 1
      : 0; // U+002D HYPHEN-MINUS (-)

  // When written literally, an integer is one or more decimal digits 0 through 9 ...
  for (; i < token.value.length; i++) {
    if (!charCodeDefinitions$j.isDigit(charCodeAt$1(token.value, i))) {
      return 0;
    }
  }

  // check range if specified
  if (outOfRange$1(opts, token.value, i)) {
    return 0;
  }

  return 1;
}

// token types
const tokenTypes = {
  "ident-token": tokenType$1(types$1D.Ident),
  "function-token": tokenType$1(types$1D.Function),
  "at-keyword-token": tokenType$1(types$1D.AtKeyword),
  "hash-token": tokenType$1(types$1D.Hash),
  "string-token": tokenType$1(types$1D.String),
  "bad-string-token": tokenType$1(types$1D.BadString),
  "url-token": tokenType$1(types$1D.Url),
  "bad-url-token": tokenType$1(types$1D.BadUrl),
  "delim-token": tokenType$1(types$1D.Delim),
  "number-token": tokenType$1(types$1D.Number),
  "percentage-token": tokenType$1(types$1D.Percentage),
  "dimension-token": tokenType$1(types$1D.Dimension),
  "whitespace-token": tokenType$1(types$1D.WhiteSpace),
  "CDO-token": tokenType$1(types$1D.CDO),
  "CDC-token": tokenType$1(types$1D.CDC),
  "colon-token": tokenType$1(types$1D.Colon),
  "semicolon-token": tokenType$1(types$1D.Semicolon),
  "comma-token": tokenType$1(types$1D.Comma),
  "[-token": tokenType$1(types$1D.LeftSquareBracket),
  "]-token": tokenType$1(types$1D.RightSquareBracket),
  "(-token": tokenType$1(types$1D.LeftParenthesis),
  ")-token": tokenType$1(types$1D.RightParenthesis),
  "{-token": tokenType$1(types$1D.LeftCurlyBracket),
  "}-token": tokenType$1(types$1D.RightCurlyBracket),
};

// token production types
const productionTypes = {
  // token type aliases
  string: tokenType$1(types$1D.String),
  ident: tokenType$1(types$1D.Ident),

  // percentage
  percentage: calc$1(percentage$1),

  // numeric
  zero: zero$1(),
  number: calc$1(number$1),
  integer: calc$1(integer$1),

  // complex types
  "custom-ident": customIdent$1,
  "custom-property-name": customPropertyName$1,
  "hex-color": hexColor$1,
  "id-selector": idSelector$1, // element( <id-selector> )
  "an-plus-b": genericAnPlusB$2,
  urange: genericUrange$2,
  "declaration-value": declarationValue$1,
  "any-value": anyValue$1,
};

// dimensions types depend on units set
function createDemensionTypes(units) {
  const {
    angle,
    decibel,
    frequency,
    flex,
    length,
    resolution,
    semitones,
    time,
  } = units || {};

  return {
    dimension: calc$1(dimension$1(null)),
    angle: calc$1(dimension$1(angle)),
    decibel: calc$1(dimension$1(decibel)),
    frequency: calc$1(dimension$1(frequency)),
    flex: calc$1(dimension$1(flex)),
    length: calc$1(zero$1(dimension$1(length))),
    resolution: calc$1(dimension$1(resolution)),
    semitones: calc$1(dimension$1(semitones)),
    time: calc$1(dimension$1(time)),
  };
}

function createGenericTypes(units) {
  return {
    ...tokenTypes,
    ...productionTypes,
    ...createDemensionTypes(units),
  };
}

generic$3.createDemensionTypes = createDemensionTypes;
generic$3.createGenericTypes = createGenericTypes;
generic$3.productionTypes = productionTypes;
generic$3.tokenTypes = tokenTypes;

var units$1 = {};

const length = [
  // absolute length units https://www.w3.org/TR/css-values-3/#lengths
  "cm",
  "mm",
  "q",
  "in",
  "pt",
  "pc",
  "px",
  // font-relative length units https://drafts.csswg.org/css-values-4/#font-relative-lengths
  "em",
  "rem",
  "ex",
  "rex",
  "cap",
  "rcap",
  "ch",
  "rch",
  "ic",
  "ric",
  "lh",
  "rlh",
  // viewport-percentage lengths https://drafts.csswg.org/css-values-4/#viewport-relative-lengths
  "vw",
  "svw",
  "lvw",
  "dvw",
  "vh",
  "svh",
  "lvh",
  "dvh",
  "vi",
  "svi",
  "lvi",
  "dvi",
  "vb",
  "svb",
  "lvb",
  "dvb",
  "vmin",
  "svmin",
  "lvmin",
  "dvmin",
  "vmax",
  "svmax",
  "lvmax",
  "dvmax",
  // container relative lengths https://drafts.csswg.org/css-contain-3/#container-lengths
  "cqw",
  "cqh",
  "cqi",
  "cqb",
  "cqmin",
  "cqmax",
];
const angle = ["deg", "grad", "rad", "turn"]; // https://www.w3.org/TR/css-values-3/#angles
const time = ["s", "ms"]; // https://www.w3.org/TR/css-values-3/#time
const frequency = ["hz", "khz"]; // https://www.w3.org/TR/css-values-3/#frequency
const resolution = ["dpi", "dpcm", "dppx", "x"]; // https://www.w3.org/TR/css-values-3/#resolution
const flex$2 = ["fr"]; // https://drafts.csswg.org/css-grid/#fr-unit
const decibel = ["db"]; // https://www.w3.org/TR/css3-speech/#mixing-props-voice-volume
const semitones = ["st"]; // https://www.w3.org/TR/css3-speech/#voice-props-voice-pitch

units$1.angle = angle;
units$1.decibel = decibel;
units$1.flex = flex$2;
units$1.frequency = frequency;
units$1.length = length;
units$1.resolution = resolution;
units$1.semitones = semitones;
units$1.time = time;

const index$h = tokenizer$5;

const astToTokens$1 = {
  decorator(handlers) {
    const tokens = [];
    let curNode = null;

    return {
      ...handlers,
      node(node) {
        const tmp = curNode;
        curNode = node;
        handlers.node.call(this, node);
        curNode = tmp;
      },
      emit(value, type, auto) {
        tokens.push({
          type,
          value,
          node: auto ? null : curNode,
        });
      },
      result() {
        return tokens;
      },
    };
  },
};

function stringToTokens$1(str) {
  const tokens = [];

  index$h.tokenize(str, (type, start, end) =>
    tokens.push({
      type,
      value: str.slice(start, end),
      node: null,
    }),
  );

  return tokens;
}

function prepareTokens$3(value, syntax) {
  if (typeof value === "string") {
    return stringToTokens$1(value);
  }

  return syntax.generate(value, astToTokens$1);
}

var prepareTokens_1$1 = prepareTokens$3;

var matchGraph$5 = {};

var parse$1y = {};

var tokenizer$4 = {};

var _SyntaxError$2 = {};

const createCustomError$5 = createCustomError$9;

function SyntaxError$8(message, input, offset) {
  return Object.assign(
    createCustomError$5.createCustomError("SyntaxError", message),
    {
      input,
      offset,
      rawMessage: message,
      message:
        message +
        "\n" +
        "  " +
        input +
        "\n" +
        "--" +
        new Array((offset || input.length) + 1).join("-") +
        "^",
    },
  );
}

_SyntaxError$2.SyntaxError = SyntaxError$8;

const SyntaxError$7 = _SyntaxError$2;

const TAB$3 = 9;
const N$7 = 10;
const F$4 = 12;
const R$4 = 13;
const SPACE$7 = 32;

let Tokenizer$1 = class Tokenizer {
  constructor(str) {
    this.str = str;
    this.pos = 0;
  }
  charCodeAt(pos) {
    return pos < this.str.length ? this.str.charCodeAt(pos) : 0;
  }
  charCode() {
    return this.charCodeAt(this.pos);
  }
  nextCharCode() {
    return this.charCodeAt(this.pos + 1);
  }
  nextNonWsCode(pos) {
    return this.charCodeAt(this.findWsEnd(pos));
  }
  findWsEnd(pos) {
    for (; pos < this.str.length; pos++) {
      const code = this.str.charCodeAt(pos);
      if (
        code !== R$4 &&
        code !== N$7 &&
        code !== F$4 &&
        code !== SPACE$7 &&
        code !== TAB$3
      ) {
        break;
      }
    }

    return pos;
  }
  substringToPos(end) {
    return this.str.substring(this.pos, (this.pos = end));
  }
  eat(code) {
    if (this.charCode() !== code) {
      this.error("Expect `" + String.fromCharCode(code) + "`");
    }

    this.pos++;
  }
  peek() {
    return this.pos < this.str.length ? this.str.charAt(this.pos++) : "";
  }
  error(message) {
    throw new SyntaxError$7.SyntaxError(message, this.str, this.pos);
  }
};

tokenizer$4.Tokenizer = Tokenizer$1;

const tokenizer$3 = tokenizer$4;

const TAB$2 = 9;
const N$6 = 10;
const F$3 = 12;
const R$3 = 13;
const SPACE$6 = 32;
const EXCLAMATIONMARK$6 = 33; // !
const NUMBERSIGN$8 = 35; // #
const AMPERSAND$7 = 38; // &
const APOSTROPHE$5 = 39; // '
const LEFTPARENTHESIS$5 = 40; // (
const RIGHTPARENTHESIS$5 = 41; // )
const ASTERISK$d = 42; // *
const PLUSSIGN$g = 43; // +
const COMMA$1 = 44; // ,
const HYPERMINUS$1 = 45; // -
const LESSTHANSIGN$1 = 60; // <
const GREATERTHANSIGN$5 = 62; // >
const QUESTIONMARK$4 = 63; // ?
const COMMERCIALAT$1 = 64; // @
const LEFTSQUAREBRACKET$1 = 91; // [
const RIGHTSQUAREBRACKET$1 = 93; // ]
const LEFTCURLYBRACKET$2 = 123; // {
const VERTICALLINE$7 = 124; // |
const RIGHTCURLYBRACKET$1 = 125; // }
const INFINITY$1 = 8734; // 
const NAME_CHAR$1 = new Uint8Array(128).map((_, idx) =>
  /[a-zA-Z0-9\-]/.test(String.fromCharCode(idx)) ? 1 : 0,
);
const COMBINATOR_PRECEDENCE$1 = {
  " ": 1,
  "&&": 2,
  "||": 3,
  "|": 4,
};

function scanSpaces$1(tokenizer) {
  return tokenizer.substringToPos(tokenizer.findWsEnd(tokenizer.pos));
}

function scanWord$1(tokenizer) {
  let end = tokenizer.pos;

  for (; end < tokenizer.str.length; end++) {
    const code = tokenizer.str.charCodeAt(end);
    if (code >= 128 || NAME_CHAR$1[code] === 0) {
      break;
    }
  }

  if (tokenizer.pos === end) {
    tokenizer.error("Expect a keyword");
  }

  return tokenizer.substringToPos(end);
}

function scanNumber$1(tokenizer) {
  let end = tokenizer.pos;

  for (; end < tokenizer.str.length; end++) {
    const code = tokenizer.str.charCodeAt(end);
    if (code < 48 || code > 57) {
      break;
    }
  }

  if (tokenizer.pos === end) {
    tokenizer.error("Expect a number");
  }

  return tokenizer.substringToPos(end);
}

function scanString$1(tokenizer) {
  const end = tokenizer.str.indexOf("'", tokenizer.pos + 1);

  if (end === -1) {
    tokenizer.pos = tokenizer.str.length;
    tokenizer.error("Expect an apostrophe");
  }

  return tokenizer.substringToPos(end + 1);
}

function readMultiplierRange$1(tokenizer) {
  let min = null;
  let max = null;

  tokenizer.eat(LEFTCURLYBRACKET$2);

  min = scanNumber$1(tokenizer);

  if (tokenizer.charCode() === COMMA$1) {
    tokenizer.pos++;
    if (tokenizer.charCode() !== RIGHTCURLYBRACKET$1) {
      max = scanNumber$1(tokenizer);
    }
  } else {
    max = min;
  }

  tokenizer.eat(RIGHTCURLYBRACKET$1);

  return {
    min: Number(min),
    max: max ? Number(max) : 0,
  };
}

function readMultiplier$1(tokenizer) {
  let range = null;
  let comma = false;

  switch (tokenizer.charCode()) {
    case ASTERISK$d:
      tokenizer.pos++;

      range = {
        min: 0,
        max: 0,
      };

      break;

    case PLUSSIGN$g:
      tokenizer.pos++;

      range = {
        min: 1,
        max: 0,
      };

      break;

    case QUESTIONMARK$4:
      tokenizer.pos++;

      range = {
        min: 0,
        max: 1,
      };

      break;

    case NUMBERSIGN$8:
      tokenizer.pos++;

      comma = true;

      if (tokenizer.charCode() === LEFTCURLYBRACKET$2) {
        range = readMultiplierRange$1(tokenizer);
      } else if (tokenizer.charCode() === QUESTIONMARK$4) {
        // https://www.w3.org/TR/css-values-4/#component-multipliers
        // > the # and ? multipliers may be stacked as #?
        // In this case just treat "#?" as a single multiplier
        // { min: 0, max: 0, comma: true }
        tokenizer.pos++;
        range = {
          min: 0,
          max: 0,
        };
      } else {
        range = {
          min: 1,
          max: 0,
        };
      }

      break;

    case LEFTCURLYBRACKET$2:
      range = readMultiplierRange$1(tokenizer);
      break;

    default:
      return null;
  }

  return {
    type: "Multiplier",
    comma,
    min: range.min,
    max: range.max,
    term: null,
  };
}

function maybeMultiplied$1(tokenizer, node) {
  const multiplier = readMultiplier$1(tokenizer);

  if (multiplier !== null) {
    multiplier.term = node;

    // https://www.w3.org/TR/css-values-4/#component-multipliers
    // > The + and # multipliers may be stacked as +#;
    // Represent "+#" as nested multipliers:
    // { ...<multiplier #>,
    //   term: {
    //     ...<multipler +>,
    //     term: node
    //   }
    // }
    if (
      tokenizer.charCode() === NUMBERSIGN$8 &&
      tokenizer.charCodeAt(tokenizer.pos - 1) === PLUSSIGN$g
    ) {
      return maybeMultiplied$1(tokenizer, multiplier);
    }

    return multiplier;
  }

  return node;
}

function maybeToken$1(tokenizer) {
  const ch = tokenizer.peek();

  if (ch === "") {
    return null;
  }

  return {
    type: "Token",
    value: ch,
  };
}

function readProperty$3(tokenizer) {
  let name;

  tokenizer.eat(LESSTHANSIGN$1);
  tokenizer.eat(APOSTROPHE$5);

  name = scanWord$1(tokenizer);

  tokenizer.eat(APOSTROPHE$5);
  tokenizer.eat(GREATERTHANSIGN$5);

  return maybeMultiplied$1(tokenizer, {
    type: "Property",
    name,
  });
}

// https://drafts.csswg.org/css-values-3/#numeric-ranges
// 4.1. Range Restrictions and Range Definition Notation
//
// Range restrictions can be annotated in the numeric type notation using CSS bracketed
// range notation[min,max]within the angle brackets, after the identifying keyword,
// indicating a closed range between (and including) min and max.
// For example, <integer [0, 10]> indicates an integer between 0 and 10, inclusive.
function readTypeRange$1(tokenizer) {
  // use null for Infinity to make AST format JSON serializable/deserializable
  let min = null; // -Infinity
  let max = null; // Infinity
  let sign = 1;

  tokenizer.eat(LEFTSQUAREBRACKET$1);

  if (tokenizer.charCode() === HYPERMINUS$1) {
    tokenizer.peek();
    sign = -1;
  }

  if (sign == -1 && tokenizer.charCode() === INFINITY$1) {
    tokenizer.peek();
  } else {
    min = sign * Number(scanNumber$1(tokenizer));

    if (NAME_CHAR$1[tokenizer.charCode()] !== 0) {
      min += scanWord$1(tokenizer);
    }
  }

  scanSpaces$1(tokenizer);
  tokenizer.eat(COMMA$1);
  scanSpaces$1(tokenizer);

  if (tokenizer.charCode() === INFINITY$1) {
    tokenizer.peek();
  } else {
    sign = 1;

    if (tokenizer.charCode() === HYPERMINUS$1) {
      tokenizer.peek();
      sign = -1;
    }

    max = sign * Number(scanNumber$1(tokenizer));

    if (NAME_CHAR$1[tokenizer.charCode()] !== 0) {
      max += scanWord$1(tokenizer);
    }
  }

  tokenizer.eat(RIGHTSQUAREBRACKET$1);

  return {
    type: "Range",
    min,
    max,
  };
}

function readType$1(tokenizer) {
  let name;
  let opts = null;

  tokenizer.eat(LESSTHANSIGN$1);
  name = scanWord$1(tokenizer);

  if (
    tokenizer.charCode() === LEFTPARENTHESIS$5 &&
    tokenizer.nextCharCode() === RIGHTPARENTHESIS$5
  ) {
    tokenizer.pos += 2;
    name += "()";
  }

  if (
    tokenizer.charCodeAt(tokenizer.findWsEnd(tokenizer.pos)) ===
    LEFTSQUAREBRACKET$1
  ) {
    scanSpaces$1(tokenizer);
    opts = readTypeRange$1(tokenizer);
  }

  tokenizer.eat(GREATERTHANSIGN$5);

  return maybeMultiplied$1(tokenizer, {
    type: "Type",
    name,
    opts,
  });
}

function readKeywordOrFunction$1(tokenizer) {
  const name = scanWord$1(tokenizer);

  if (tokenizer.charCode() === LEFTPARENTHESIS$5) {
    tokenizer.pos++;

    return {
      type: "Function",
      name,
    };
  }

  return maybeMultiplied$1(tokenizer, {
    type: "Keyword",
    name,
  });
}

function regroupTerms$1(terms, combinators) {
  function createGroup(terms, combinator) {
    return {
      type: "Group",
      terms,
      combinator,
      disallowEmpty: false,
      explicit: false,
    };
  }

  let combinator;

  combinators = Object.keys(combinators).sort(
    (a, b) => COMBINATOR_PRECEDENCE$1[a] - COMBINATOR_PRECEDENCE$1[b],
  );

  while (combinators.length > 0) {
    combinator = combinators.shift();

    let i = 0;
    let subgroupStart = 0;

    for (; i < terms.length; i++) {
      const term = terms[i];

      if (term.type === "Combinator") {
        if (term.value === combinator) {
          if (subgroupStart === -1) {
            subgroupStart = i - 1;
          }
          terms.splice(i, 1);
          i--;
        } else {
          if (subgroupStart !== -1 && i - subgroupStart > 1) {
            terms.splice(
              subgroupStart,
              i - subgroupStart,
              createGroup(terms.slice(subgroupStart, i), combinator),
            );
            i = subgroupStart + 1;
          }
          subgroupStart = -1;
        }
      }
    }

    if (subgroupStart !== -1 && combinators.length) {
      terms.splice(
        subgroupStart,
        i - subgroupStart,
        createGroup(terms.slice(subgroupStart, i), combinator),
      );
    }
  }

  return combinator;
}

function readImplicitGroup$1(tokenizer) {
  const terms = [];
  const combinators = {};
  let token;
  let prevToken = null;
  let prevTokenPos = tokenizer.pos;

  while ((token = peek$1(tokenizer))) {
    if (token.type !== "Spaces") {
      if (token.type === "Combinator") {
        // check for combinator in group beginning and double combinator sequence
        if (prevToken === null || prevToken.type === "Combinator") {
          tokenizer.pos = prevTokenPos;
          tokenizer.error("Unexpected combinator");
        }

        combinators[token.value] = true;
      } else if (prevToken !== null && prevToken.type !== "Combinator") {
        combinators[" "] = true; // a b
        terms.push({
          type: "Combinator",
          value: " ",
        });
      }

      terms.push(token);
      prevToken = token;
      prevTokenPos = tokenizer.pos;
    }
  }

  // check for combinator in group ending
  if (prevToken !== null && prevToken.type === "Combinator") {
    tokenizer.pos -= prevTokenPos;
    tokenizer.error("Unexpected combinator");
  }

  return {
    type: "Group",
    terms,
    combinator: regroupTerms$1(terms, combinators) || " ",
    disallowEmpty: false,
    explicit: false,
  };
}

function readGroup$1(tokenizer) {
  let result;

  tokenizer.eat(LEFTSQUAREBRACKET$1);
  result = readImplicitGroup$1(tokenizer);
  tokenizer.eat(RIGHTSQUAREBRACKET$1);

  result.explicit = true;

  if (tokenizer.charCode() === EXCLAMATIONMARK$6) {
    tokenizer.pos++;
    result.disallowEmpty = true;
  }

  return result;
}

function peek$1(tokenizer) {
  let code = tokenizer.charCode();

  if (code < 128 && NAME_CHAR$1[code] === 1) {
    return readKeywordOrFunction$1(tokenizer);
  }

  switch (code) {
    case RIGHTSQUAREBRACKET$1:
      // don't eat, stop scan a group
      break;

    case LEFTSQUAREBRACKET$1:
      return maybeMultiplied$1(tokenizer, readGroup$1(tokenizer));

    case LESSTHANSIGN$1:
      return tokenizer.nextCharCode() === APOSTROPHE$5
        ? readProperty$3(tokenizer)
        : readType$1(tokenizer);

    case VERTICALLINE$7:
      return {
        type: "Combinator",
        value: tokenizer.substringToPos(
          tokenizer.pos + (tokenizer.nextCharCode() === VERTICALLINE$7 ? 2 : 1),
        ),
      };

    case AMPERSAND$7:
      tokenizer.pos++;
      tokenizer.eat(AMPERSAND$7);

      return {
        type: "Combinator",
        value: "&&",
      };

    case COMMA$1:
      tokenizer.pos++;
      return {
        type: "Comma",
      };

    case APOSTROPHE$5:
      return maybeMultiplied$1(tokenizer, {
        type: "String",
        value: scanString$1(tokenizer),
      });

    case SPACE$6:
    case TAB$2:
    case N$6:
    case R$3:
    case F$3:
      return {
        type: "Spaces",
        value: scanSpaces$1(tokenizer),
      };

    case COMMERCIALAT$1:
      code = tokenizer.nextCharCode();

      if (code < 128 && NAME_CHAR$1[code] === 1) {
        tokenizer.pos++;
        return {
          type: "AtKeyword",
          name: scanWord$1(tokenizer),
        };
      }

      return maybeToken$1(tokenizer);

    case ASTERISK$d:
    case PLUSSIGN$g:
    case QUESTIONMARK$4:
    case NUMBERSIGN$8:
    case EXCLAMATIONMARK$6:
      // prohibited tokens (used as a multiplier start)
      break;

    case LEFTCURLYBRACKET$2:
      // LEFTCURLYBRACKET is allowed since mdn/data uses it w/o quoting
      // check next char isn't a number, because it's likely a disjoined multiplier
      code = tokenizer.nextCharCode();

      if (code < 48 || code > 57) {
        return maybeToken$1(tokenizer);
      }

      break;

    default:
      return maybeToken$1(tokenizer);
  }
}

function parse$1x(source) {
  const tokenizer$1 = new tokenizer$3.Tokenizer(source);
  const result = readImplicitGroup$1(tokenizer$1);

  if (tokenizer$1.pos !== source.length) {
    tokenizer$1.error("Unexpected input");
  }

  // reduce redundant groups with single group term
  if (result.terms.length === 1 && result.terms[0].type === "Group") {
    return result.terms[0];
  }

  return result;
}

parse$1y.parse = parse$1x;

const parse$1w = parse$1y;

const MATCH$1 = { type: "Match" };
const MISMATCH$1 = { type: "Mismatch" };
const DISALLOW_EMPTY$1 = { type: "DisallowEmpty" };

const LEFTPARENTHESIS$4 = 40; // (
const RIGHTPARENTHESIS$4 = 41; // )

function createCondition$1(match, thenBranch, elseBranch) {
  // reduce node count
  if (thenBranch === MATCH$1 && elseBranch === MISMATCH$1) {
    return match;
  }

  if (match === MATCH$1 && thenBranch === MATCH$1 && elseBranch === MATCH$1) {
    return match;
  }

  if (
    match.type === "If" &&
    match.else === MISMATCH$1 &&
    thenBranch === MATCH$1
  ) {
    thenBranch = match.then;
    match = match.match;
  }

  return {
    type: "If",
    match,
    then: thenBranch,
    else: elseBranch,
  };
}

function isFunctionType$1(name) {
  return (
    name.length > 2 &&
    name.charCodeAt(name.length - 2) === LEFTPARENTHESIS$4 &&
    name.charCodeAt(name.length - 1) === RIGHTPARENTHESIS$4
  );
}

function isEnumCapatible$1(term) {
  return (
    term.type === "Keyword" ||
    term.type === "AtKeyword" ||
    term.type === "Function" ||
    (term.type === "Type" && isFunctionType$1(term.name))
  );
}

function buildGroupMatchGraph$1(combinator, terms, atLeastOneTermMatched) {
  switch (combinator) {
    case " ": {
      // Juxtaposing components means that all of them must occur, in the given order.
      //
      // a b c
      // =
      // match a
      //   then match b
      //     then match c
      //       then MATCH
      //       else MISMATCH
      //     else MISMATCH
      //   else MISMATCH
      let result = MATCH$1;

      for (let i = terms.length - 1; i >= 0; i--) {
        const term = terms[i];

        result = createCondition$1(term, result, MISMATCH$1);
      }
      return result;
    }

    case "|": {
      // A bar (|) separates two or more alternatives: exactly one of them must occur.
      //
      // a | b | c
      // =
      // match a
      //   then MATCH
      //   else match b
      //     then MATCH
      //     else match c
      //       then MATCH
      //       else MISMATCH

      let result = MISMATCH$1;
      let map = null;

      for (let i = terms.length - 1; i >= 0; i--) {
        let term = terms[i];

        // reduce sequence of keywords into a Enum
        if (isEnumCapatible$1(term)) {
          if (map === null && i > 0 && isEnumCapatible$1(terms[i - 1])) {
            map = Object.create(null);
            result = createCondition$1(
              {
                type: "Enum",
                map,
              },
              MATCH$1,
              result,
            );
          }

          if (map !== null) {
            const key = (
              isFunctionType$1(term.name) ? term.name.slice(0, -1) : term.name
            ).toLowerCase();
            if (key in map === false) {
              map[key] = term;
              continue;
            }
          }
        }

        map = null;

        // create a new conditonal node
        result = createCondition$1(term, MATCH$1, result);
      }
      return result;
    }

    case "&&": {
      // A double ampersand (&&) separates two or more components,
      // all of which must occur, in any order.

      // Use MatchOnce for groups with a large number of terms,
      // since &&-groups produces at least N!-node trees
      if (terms.length > 5) {
        return {
          type: "MatchOnce",
          terms,
          all: true,
        };
      }

      // Use a combination tree for groups with small number of terms
      //
      // a && b && c
      // =
      // match a
      //   then [b && c]
      //   else match b
      //     then [a && c]
      //     else match c
      //       then [a && b]
      //       else MISMATCH
      //
      // a && b
      // =
      // match a
      //   then match b
      //     then MATCH
      //     else MISMATCH
      //   else match b
      //     then match a
      //       then MATCH
      //       else MISMATCH
      //     else MISMATCH
      let result = MISMATCH$1;

      for (let i = terms.length - 1; i >= 0; i--) {
        const term = terms[i];
        let thenClause;

        if (terms.length > 1) {
          thenClause = buildGroupMatchGraph$1(
            combinator,
            terms.filter(function (newGroupTerm) {
              return newGroupTerm !== term;
            }),
            false,
          );
        } else {
          thenClause = MATCH$1;
        }

        result = createCondition$1(term, thenClause, result);
      }
      return result;
    }

    case "||": {
      // A double bar (||) separates two or more options:
      // one or more of them must occur, in any order.

      // Use MatchOnce for groups with a large number of terms,
      // since ||-groups produces at least N!-node trees
      if (terms.length > 5) {
        return {
          type: "MatchOnce",
          terms,
          all: false,
        };
      }

      // Use a combination tree for groups with small number of terms
      //
      // a || b || c
      // =
      // match a
      //   then [b || c]
      //   else match b
      //     then [a || c]
      //     else match c
      //       then [a || b]
      //       else MISMATCH
      //
      // a || b
      // =
      // match a
      //   then match b
      //     then MATCH
      //     else MATCH
      //   else match b
      //     then match a
      //       then MATCH
      //       else MATCH
      //     else MISMATCH
      let result = atLeastOneTermMatched ? MATCH$1 : MISMATCH$1;

      for (let i = terms.length - 1; i >= 0; i--) {
        const term = terms[i];
        let thenClause;

        if (terms.length > 1) {
          thenClause = buildGroupMatchGraph$1(
            combinator,
            terms.filter(function (newGroupTerm) {
              return newGroupTerm !== term;
            }),
            true,
          );
        } else {
          thenClause = MATCH$1;
        }

        result = createCondition$1(term, thenClause, result);
      }
      return result;
    }
  }
}

function buildMultiplierMatchGraph$1(node) {
  let result = MATCH$1;
  let matchTerm = buildMatchGraphInternal$1(node.term);

  if (node.max === 0) {
    // disable repeating of empty match to prevent infinite loop
    matchTerm = createCondition$1(matchTerm, DISALLOW_EMPTY$1, MISMATCH$1);

    // an occurrence count is not limited, make a cycle;
    // to collect more terms on each following matching mismatch
    result = createCondition$1(
      matchTerm,
      null, // will be a loop
      MISMATCH$1,
    );

    result.then = createCondition$1(
      MATCH$1,
      MATCH$1,
      result, // make a loop
    );

    if (node.comma) {
      result.then.else = createCondition$1(
        { type: "Comma", syntax: node },
        result,
        MISMATCH$1,
      );
    }
  } else {
    // create a match node chain for [min .. max] interval with optional matches
    for (let i = node.min || 1; i <= node.max; i++) {
      if (node.comma && result !== MATCH$1) {
        result = createCondition$1(
          { type: "Comma", syntax: node },
          result,
          MISMATCH$1,
        );
      }

      result = createCondition$1(
        matchTerm,
        createCondition$1(MATCH$1, MATCH$1, result),
        MISMATCH$1,
      );
    }
  }

  if (node.min === 0) {
    // allow zero match
    result = createCondition$1(MATCH$1, MATCH$1, result);
  } else {
    // create a match node chain to collect [0 ... min - 1] required matches
    for (let i = 0; i < node.min - 1; i++) {
      if (node.comma && result !== MATCH$1) {
        result = createCondition$1(
          { type: "Comma", syntax: node },
          result,
          MISMATCH$1,
        );
      }

      result = createCondition$1(matchTerm, result, MISMATCH$1);
    }
  }

  return result;
}

function buildMatchGraphInternal$1(node) {
  if (typeof node === "function") {
    return {
      type: "Generic",
      fn: node,
    };
  }

  switch (node.type) {
    case "Group": {
      let result = buildGroupMatchGraph$1(
        node.combinator,
        node.terms.map(buildMatchGraphInternal$1),
        false,
      );

      if (node.disallowEmpty) {
        result = createCondition$1(result, DISALLOW_EMPTY$1, MISMATCH$1);
      }

      return result;
    }

    case "Multiplier":
      return buildMultiplierMatchGraph$1(node);

    case "Type":
    case "Property":
      return {
        type: node.type,
        name: node.name,
        syntax: node,
      };

    case "Keyword":
      return {
        type: node.type,
        name: node.name.toLowerCase(),
        syntax: node,
      };

    case "AtKeyword":
      return {
        type: node.type,
        name: "@" + node.name.toLowerCase(),
        syntax: node,
      };

    case "Function":
      return {
        type: node.type,
        name: node.name.toLowerCase() + "(",
        syntax: node,
      };

    case "String":
      // convert a one char length String to a Token
      if (node.value.length === 3) {
        return {
          type: "Token",
          value: node.value.charAt(1),
          syntax: node,
        };
      }

      // otherwise use it as is
      return {
        type: node.type,
        value: node.value.substr(1, node.value.length - 2).replace(/\\'/g, "'"),
        syntax: node,
      };

    case "Token":
      return {
        type: node.type,
        value: node.value,
        syntax: node,
      };

    case "Comma":
      return {
        type: node.type,
        syntax: node,
      };

    default:
      throw new Error("Unknown node type:", node.type);
  }
}

function buildMatchGraph$1(syntaxTree, ref) {
  if (typeof syntaxTree === "string") {
    syntaxTree = parse$1w.parse(syntaxTree);
  }

  return {
    type: "MatchGraph",
    match: buildMatchGraphInternal$1(syntaxTree),
    syntax: ref || null,
    source: syntaxTree,
  };
}

matchGraph$5.DISALLOW_EMPTY = DISALLOW_EMPTY$1;
matchGraph$5.MATCH = MATCH$1;
matchGraph$5.MISMATCH = MISMATCH$1;
matchGraph$5.buildMatchGraph = buildMatchGraph$1;

var match$3 = {};

const matchGraph$4 = matchGraph$5;
const types$1C = types$1M;

const { hasOwnProperty: hasOwnProperty$b } = Object.prototype;
const STUB$1 = 0;
const TOKEN$1 = 1;
const OPEN_SYNTAX$1 = 2;
const CLOSE_SYNTAX$1 = 3;

const EXIT_REASON_MATCH$1 = "Match";
const EXIT_REASON_MISMATCH$1 = "Mismatch";
const EXIT_REASON_ITERATION_LIMIT$1 =
  "Maximum iteration number exceeded (please fill an issue on https://github.com/csstree/csstree/issues)";

const ITERATION_LIMIT$1 = 15000;

function reverseList$1(list) {
  let prev = null;
  let next = null;
  let item = list;

  while (item !== null) {
    next = item.prev;
    item.prev = prev;
    prev = item;
    item = next;
  }

  return prev;
}

function areStringsEqualCaseInsensitive$1(testStr, referenceStr) {
  if (testStr.length !== referenceStr.length) {
    return false;
  }

  for (let i = 0; i < testStr.length; i++) {
    const referenceCode = referenceStr.charCodeAt(i);
    let testCode = testStr.charCodeAt(i);

    // testCode.toLowerCase() for U+0041 LATIN CAPITAL LETTER A (A) .. U+005A LATIN CAPITAL LETTER Z (Z).
    if (testCode >= 0x0041 && testCode <= 0x005a) {
      testCode = testCode | 32;
    }

    if (testCode !== referenceCode) {
      return false;
    }
  }

  return true;
}

function isContextEdgeDelim$1(token) {
  if (token.type !== types$1C.Delim) {
    return false;
  }

  // Fix matching for unicode-range: U+30??, U+FF00-FF9F
  // Probably we need to check out previous match instead
  return token.value !== "?";
}

function isCommaContextStart$1(token) {
  if (token === null) {
    return true;
  }

  return (
    token.type === types$1C.Comma ||
    token.type === types$1C.Function ||
    token.type === types$1C.LeftParenthesis ||
    token.type === types$1C.LeftSquareBracket ||
    token.type === types$1C.LeftCurlyBracket ||
    isContextEdgeDelim$1(token)
  );
}

function isCommaContextEnd$1(token) {
  if (token === null) {
    return true;
  }

  return (
    token.type === types$1C.RightParenthesis ||
    token.type === types$1C.RightSquareBracket ||
    token.type === types$1C.RightCurlyBracket ||
    (token.type === types$1C.Delim && token.value === "/")
  );
}

function internalMatch$1(tokens, state, syntaxes) {
  function moveToNextToken() {
    do {
      tokenIndex++;
      token = tokenIndex < tokens.length ? tokens[tokenIndex] : null;
    } while (
      token !== null &&
      (token.type === types$1C.WhiteSpace || token.type === types$1C.Comment)
    );
  }

  function getNextToken(offset) {
    const nextIndex = tokenIndex + offset;

    return nextIndex < tokens.length ? tokens[nextIndex] : null;
  }

  function stateSnapshotFromSyntax(nextState, prev) {
    return {
      nextState,
      matchStack,
      syntaxStack,
      thenStack,
      tokenIndex,
      prev,
    };
  }

  function pushThenStack(nextState) {
    thenStack = {
      nextState,
      matchStack,
      syntaxStack,
      prev: thenStack,
    };
  }

  function pushElseStack(nextState) {
    elseStack = stateSnapshotFromSyntax(nextState, elseStack);
  }

  function addTokenToMatch() {
    matchStack = {
      type: TOKEN$1,
      syntax: state.syntax,
      token,
      prev: matchStack,
    };

    moveToNextToken();
    syntaxStash = null;

    if (tokenIndex > longestMatch) {
      longestMatch = tokenIndex;
    }
  }

  function openSyntax() {
    syntaxStack = {
      syntax: state.syntax,
      opts:
        state.syntax.opts || (syntaxStack !== null && syntaxStack.opts) || null,
      prev: syntaxStack,
    };

    matchStack = {
      type: OPEN_SYNTAX$1,
      syntax: state.syntax,
      token: matchStack.token,
      prev: matchStack,
    };
  }

  function closeSyntax() {
    if (matchStack.type === OPEN_SYNTAX$1) {
      matchStack = matchStack.prev;
    } else {
      matchStack = {
        type: CLOSE_SYNTAX$1,
        syntax: syntaxStack.syntax,
        token: matchStack.token,
        prev: matchStack,
      };
    }

    syntaxStack = syntaxStack.prev;
  }

  let syntaxStack = null;
  let thenStack = null;
  let elseStack = null;

  // null  stashing allowed, nothing stashed
  // false  stashing disabled, nothing stashed
  // anithing else  fail stashable syntaxes, some syntax stashed
  let syntaxStash = null;

  let iterationCount = 0; // count iterations and prevent infinite loop
  let exitReason = null;

  let token = null;
  let tokenIndex = -1;
  let longestMatch = 0;
  let matchStack = {
    type: STUB$1,
    syntax: null,
    token: null,
    prev: null,
  };

  moveToNextToken();

  while (exitReason === null && ++iterationCount < ITERATION_LIMIT$1) {
    // function mapList(list, fn) {
    //     const result = [];
    //     while (list) {
    //         result.unshift(fn(list));
    //         list = list.prev;
    //     }
    //     return result;
    // }
    // console.log('--\n',
    //     '#' + iterationCount,
    //     require('util').inspect({
    //         match: mapList(matchStack, x => x.type === TOKEN ? x.token && x.token.value : x.syntax ? ({ [OPEN_SYNTAX]: '<', [CLOSE_SYNTAX]: '</' }[x.type] || x.type) + '!' + x.syntax.name : null),
    //         token: token && token.value,
    //         tokenIndex,
    //         syntax: syntax.type + (syntax.id ? ' #' + syntax.id : '')
    //     }, { depth: null })
    // );
    switch (state.type) {
      case "Match":
        if (thenStack === null) {
          // turn to MISMATCH when some tokens left unmatched
          if (token !== null) {
            // doesn't mismatch if just one token left and it's an IE hack
            if (
              tokenIndex !== tokens.length - 1 ||
              (token.value !== "\\0" && token.value !== "\\9")
            ) {
              state = matchGraph$4.MISMATCH;
              break;
            }
          }

          // break the main loop, return a result - MATCH
          exitReason = EXIT_REASON_MATCH$1;
          break;
        }

        // go to next syntax (`then` branch)
        state = thenStack.nextState;

        // check match is not empty
        if (state === matchGraph$4.DISALLOW_EMPTY) {
          if (thenStack.matchStack === matchStack) {
            state = matchGraph$4.MISMATCH;
            break;
          } else {
            state = matchGraph$4.MATCH;
          }
        }

        // close syntax if needed
        while (thenStack.syntaxStack !== syntaxStack) {
          closeSyntax();
        }

        // pop stack
        thenStack = thenStack.prev;
        break;

      case "Mismatch":
        // when some syntax is stashed
        if (syntaxStash !== null && syntaxStash !== false) {
          // there is no else branches or a branch reduce match stack
          if (elseStack === null || tokenIndex > elseStack.tokenIndex) {
            // restore state from the stash
            elseStack = syntaxStash;
            syntaxStash = false; // disable stashing
          }
        } else if (elseStack === null) {
          // no else branches -> break the main loop
          // return a result - MISMATCH
          exitReason = EXIT_REASON_MISMATCH$1;
          break;
        }

        // go to next syntax (`else` branch)
        state = elseStack.nextState;

        // restore all the rest stack states
        thenStack = elseStack.thenStack;
        syntaxStack = elseStack.syntaxStack;
        matchStack = elseStack.matchStack;
        tokenIndex = elseStack.tokenIndex;
        token = tokenIndex < tokens.length ? tokens[tokenIndex] : null;

        // pop stack
        elseStack = elseStack.prev;
        break;

      case "MatchGraph":
        state = state.match;
        break;

      case "If":
        // IMPORTANT: else stack push must go first,
        // since it stores the state of thenStack before changes
        if (state.else !== matchGraph$4.MISMATCH) {
          pushElseStack(state.else);
        }

        if (state.then !== matchGraph$4.MATCH) {
          pushThenStack(state.then);
        }

        state = state.match;
        break;

      case "MatchOnce":
        state = {
          type: "MatchOnceBuffer",
          syntax: state,
          index: 0,
          mask: 0,
        };
        break;

      case "MatchOnceBuffer": {
        const terms = state.syntax.terms;

        if (state.index === terms.length) {
          // no matches at all or it's required all terms to be matched
          if (state.mask === 0 || state.syntax.all) {
            state = matchGraph$4.MISMATCH;
            break;
          }

          // a partial match is ok
          state = matchGraph$4.MATCH;
          break;
        }

        // all terms are matched
        if (state.mask === (1 << terms.length) - 1) {
          state = matchGraph$4.MATCH;
          break;
        }

        for (; state.index < terms.length; state.index++) {
          const matchFlag = 1 << state.index;

          if ((state.mask & matchFlag) === 0) {
            // IMPORTANT: else stack push must go first,
            // since it stores the state of thenStack before changes
            pushElseStack(state);
            pushThenStack({
              type: "AddMatchOnce",
              syntax: state.syntax,
              mask: state.mask | matchFlag,
            });

            // match
            state = terms[state.index++];
            break;
          }
        }
        break;
      }

      case "AddMatchOnce":
        state = {
          type: "MatchOnceBuffer",
          syntax: state.syntax,
          index: 0,
          mask: state.mask,
        };
        break;

      case "Enum":
        if (token !== null) {
          let name = token.value.toLowerCase();

          // drop \0 and \9 hack from keyword name
          if (name.indexOf("\\") !== -1) {
            name = name.replace(/\\[09].*$/, "");
          }

          if (hasOwnProperty$b.call(state.map, name)) {
            state = state.map[name];
            break;
          }
        }

        state = matchGraph$4.MISMATCH;
        break;

      case "Generic": {
        const opts = syntaxStack !== null ? syntaxStack.opts : null;
        const lastTokenIndex =
          tokenIndex + Math.floor(state.fn(token, getNextToken, opts));

        if (!isNaN(lastTokenIndex) && lastTokenIndex > tokenIndex) {
          while (tokenIndex < lastTokenIndex) {
            addTokenToMatch();
          }

          state = matchGraph$4.MATCH;
        } else {
          state = matchGraph$4.MISMATCH;
        }

        break;
      }

      case "Type":
      case "Property": {
        const syntaxDict = state.type === "Type" ? "types" : "properties";
        const dictSyntax = hasOwnProperty$b.call(syntaxes, syntaxDict)
          ? syntaxes[syntaxDict][state.name]
          : null;

        if (!dictSyntax || !dictSyntax.match) {
          throw new Error(
            "Bad syntax reference: " +
              (state.type === "Type"
                ? "<" + state.name + ">"
                : "<'" + state.name + "'>"),
          );
        }

        // stash a syntax for types with low priority
        if (syntaxStash !== false && token !== null && state.type === "Type") {
          const lowPriorityMatching =
            // https://drafts.csswg.org/css-values-4/#custom-idents
            // When parsing positionally-ambiguous keywords in a property value, a <custom-ident> production
            // can only claim the keyword if no other unfulfilled production can claim it.
            (state.name === "custom-ident" && token.type === types$1C.Ident) ||
            // https://drafts.csswg.org/css-values-4/#lengths
            // ... if a `0` could be parsed as either a <number> or a <length> in a property (such as line-height),
            // it must parse as a <number>
            (state.name === "length" && token.value === "0");

          if (lowPriorityMatching) {
            if (syntaxStash === null) {
              syntaxStash = stateSnapshotFromSyntax(state, elseStack);
            }

            state = matchGraph$4.MISMATCH;
            break;
          }
        }

        openSyntax();
        state = dictSyntax.match;
        break;
      }

      case "Keyword": {
        const name = state.name;

        if (token !== null) {
          let keywordName = token.value;

          // drop \0 and \9 hack from keyword name
          if (keywordName.indexOf("\\") !== -1) {
            keywordName = keywordName.replace(/\\[09].*$/, "");
          }

          if (areStringsEqualCaseInsensitive$1(keywordName, name)) {
            addTokenToMatch();
            state = matchGraph$4.MATCH;
            break;
          }
        }

        state = matchGraph$4.MISMATCH;
        break;
      }

      case "AtKeyword":
      case "Function":
        if (
          token !== null &&
          areStringsEqualCaseInsensitive$1(token.value, state.name)
        ) {
          addTokenToMatch();
          state = matchGraph$4.MATCH;
          break;
        }

        state = matchGraph$4.MISMATCH;
        break;

      case "Token":
        if (token !== null && token.value === state.value) {
          addTokenToMatch();
          state = matchGraph$4.MATCH;
          break;
        }

        state = matchGraph$4.MISMATCH;
        break;

      case "Comma":
        if (token !== null && token.type === types$1C.Comma) {
          if (isCommaContextStart$1(matchStack.token)) {
            state = matchGraph$4.MISMATCH;
          } else {
            addTokenToMatch();
            state = isCommaContextEnd$1(token)
              ? matchGraph$4.MISMATCH
              : matchGraph$4.MATCH;
          }
        } else {
          state =
            isCommaContextStart$1(matchStack.token) ||
            isCommaContextEnd$1(token)
              ? matchGraph$4.MATCH
              : matchGraph$4.MISMATCH;
        }

        break;

      case "String":
        let string = "";
        let lastTokenIndex = tokenIndex;

        for (
          ;
          lastTokenIndex < tokens.length && string.length < state.value.length;
          lastTokenIndex++
        ) {
          string += tokens[lastTokenIndex].value;
        }

        if (areStringsEqualCaseInsensitive$1(string, state.value)) {
          while (tokenIndex < lastTokenIndex) {
            addTokenToMatch();
          }

          state = matchGraph$4.MATCH;
        } else {
          state = matchGraph$4.MISMATCH;
        }

        break;

      default:
        throw new Error("Unknown node type: " + state.type);
    }
  }

  switch (exitReason) {
    case null:
      console.warn(
        "[csstree-match] BREAK after " + ITERATION_LIMIT$1 + " iterations",
      );
      exitReason = EXIT_REASON_ITERATION_LIMIT$1;
      matchStack = null;
      break;

    case EXIT_REASON_MATCH$1:
      while (syntaxStack !== null) {
        closeSyntax();
      }
      break;

    default:
      matchStack = null;
  }

  return {
    tokens,
    reason: exitReason,
    iterations: iterationCount,
    match: matchStack,
    longestMatch,
  };
}

function matchAsList$1(tokens, matchGraph, syntaxes) {
  const matchResult = internalMatch$1(tokens, matchGraph, syntaxes || {});

  if (matchResult.match !== null) {
    let item = reverseList$1(matchResult.match).prev;

    matchResult.match = [];

    while (item !== null) {
      switch (item.type) {
        case OPEN_SYNTAX$1:
        case CLOSE_SYNTAX$1:
          matchResult.match.push({
            type: item.type,
            syntax: item.syntax,
          });
          break;

        default:
          matchResult.match.push({
            token: item.token.value,
            node: item.token.node,
          });
          break;
      }

      item = item.prev;
    }
  }

  return matchResult;
}

function matchAsTree$1(tokens, matchGraph, syntaxes) {
  const matchResult = internalMatch$1(tokens, matchGraph, syntaxes || {});

  if (matchResult.match === null) {
    return matchResult;
  }

  let item = matchResult.match;
  let host = (matchResult.match = {
    syntax: matchGraph.syntax || null,
    match: [],
  });
  const hostStack = [host];

  // revert a list and start with 2nd item since 1st is a stub item
  item = reverseList$1(item).prev;

  // build a tree
  while (item !== null) {
    switch (item.type) {
      case OPEN_SYNTAX$1:
        host.match.push(
          (host = {
            syntax: item.syntax,
            match: [],
          }),
        );
        hostStack.push(host);
        break;

      case CLOSE_SYNTAX$1:
        hostStack.pop();
        host = hostStack[hostStack.length - 1];
        break;

      default:
        host.match.push({
          syntax: item.syntax || null,
          token: item.token.value,
          node: item.token.node,
        });
    }

    item = item.prev;
  }

  return matchResult;
}

match$3.matchAsList = matchAsList$1;
match$3.matchAsTree = matchAsTree$1;

var trace$3 = {};

function getTrace$1(node) {
  function shouldPutToTrace(syntax) {
    if (syntax === null) {
      return false;
    }

    return (
      syntax.type === "Type" ||
      syntax.type === "Property" ||
      syntax.type === "Keyword"
    );
  }

  function hasMatch(matchNode) {
    if (Array.isArray(matchNode.match)) {
      // use for-loop for better perfomance
      for (let i = 0; i < matchNode.match.length; i++) {
        if (hasMatch(matchNode.match[i])) {
          if (shouldPutToTrace(matchNode.syntax)) {
            result.unshift(matchNode.syntax);
          }

          return true;
        }
      }
    } else if (matchNode.node === node) {
      result = shouldPutToTrace(matchNode.syntax) ? [matchNode.syntax] : [];

      return true;
    }

    return false;
  }

  let result = null;

  if (this.matched !== null) {
    hasMatch(this.matched);
  }

  return result;
}

function isType$1(node, type) {
  return testNode$1(
    this,
    node,
    (match) => match.type === "Type" && match.name === type,
  );
}

function isProperty$1(node, property) {
  return testNode$1(
    this,
    node,
    (match) => match.type === "Property" && match.name === property,
  );
}

function isKeyword$1(node) {
  return testNode$1(this, node, (match) => match.type === "Keyword");
}

function testNode$1(match, node, fn) {
  const trace = getTrace$1.call(match, node);

  if (trace === null) {
    return false;
  }

  return trace.some(fn);
}

trace$3.getTrace = getTrace$1;
trace$3.isKeyword = isKeyword$1;
trace$3.isProperty = isProperty$1;
trace$3.isType = isType$1;

var search$3 = {};

const List$b = List$f;

function getFirstMatchNode$1(matchNode) {
  if ("node" in matchNode) {
    return matchNode.node;
  }

  return getFirstMatchNode$1(matchNode.match[0]);
}

function getLastMatchNode$1(matchNode) {
  if ("node" in matchNode) {
    return matchNode.node;
  }

  return getLastMatchNode$1(matchNode.match[matchNode.match.length - 1]);
}

function matchFragments$1(lexer, ast, match, type, name) {
  function findFragments(matchNode) {
    if (
      matchNode.syntax !== null &&
      matchNode.syntax.type === type &&
      matchNode.syntax.name === name
    ) {
      const start = getFirstMatchNode$1(matchNode);
      const end = getLastMatchNode$1(matchNode);

      lexer.syntax.walk(ast, function (node, item, list) {
        if (node === start) {
          const nodes = new List$b.List();

          do {
            nodes.appendData(item.data);

            if (item.data === end) {
              break;
            }

            item = item.next;
          } while (item !== null);

          fragments.push({
            parent: list,
            nodes,
          });
        }
      });
    }

    if (Array.isArray(matchNode.match)) {
      matchNode.match.forEach(findFragments);
    }
  }

  const fragments = [];

  if (match.matched !== null) {
    findFragments(match.matched);
  }

  return fragments;
}

search$3.matchFragments = matchFragments$1;

var structure$1k = {};

const List$a = List$f;

const { hasOwnProperty: hasOwnProperty$a } = Object.prototype;

function isValidNumber$1(value) {
  // Number.isInteger(value) && value >= 0
  return (
    typeof value === "number" &&
    isFinite(value) &&
    Math.floor(value) === value &&
    value >= 0
  );
}

function isValidLocation$1(loc) {
  return (
    Boolean(loc) &&
    isValidNumber$1(loc.offset) &&
    isValidNumber$1(loc.line) &&
    isValidNumber$1(loc.column)
  );
}

function createNodeStructureChecker$1(type, fields) {
  return function checkNode(node, warn) {
    if (!node || node.constructor !== Object) {
      return warn(node, "Type of node should be an Object");
    }

    for (let key in node) {
      let valid = true;

      if (hasOwnProperty$a.call(node, key) === false) {
        continue;
      }

      if (key === "type") {
        if (node.type !== type) {
          warn(
            node,
            "Wrong node type `" + node.type + "`, expected `" + type + "`",
          );
        }
      } else if (key === "loc") {
        if (node.loc === null) {
          continue;
        } else if (node.loc && node.loc.constructor === Object) {
          if (typeof node.loc.source !== "string") {
            key += ".source";
          } else if (!isValidLocation$1(node.loc.start)) {
            key += ".start";
          } else if (!isValidLocation$1(node.loc.end)) {
            key += ".end";
          } else {
            continue;
          }
        }

        valid = false;
      } else if (fields.hasOwnProperty(key)) {
        valid = false;

        for (let i = 0; !valid && i < fields[key].length; i++) {
          const fieldType = fields[key][i];

          switch (fieldType) {
            case String:
              valid = typeof node[key] === "string";
              break;

            case Boolean:
              valid = typeof node[key] === "boolean";
              break;

            case null:
              valid = node[key] === null;
              break;

            default:
              if (typeof fieldType === "string") {
                valid = node[key] && node[key].type === fieldType;
              } else if (Array.isArray(fieldType)) {
                valid = node[key] instanceof List$a.List;
              }
          }
        }
      } else {
        warn(node, "Unknown field `" + key + "` for " + type + " node type");
      }

      if (!valid) {
        warn(node, "Bad value for `" + type + "." + key + "`");
      }
    }

    for (const key in fields) {
      if (
        hasOwnProperty$a.call(fields, key) &&
        hasOwnProperty$a.call(node, key) === false
      ) {
        warn(node, "Field `" + type + "." + key + "` is missed");
      }
    }
  };
}

function processStructure$1(name, nodeType) {
  const structure = nodeType.structure;
  const fields = {
    type: String,
    loc: true,
  };
  const docs = {
    type: '"' + name + '"',
  };

  for (const key in structure) {
    if (hasOwnProperty$a.call(structure, key) === false) {
      continue;
    }

    const docsTypes = [];
    const fieldTypes = (fields[key] = Array.isArray(structure[key])
      ? structure[key].slice()
      : [structure[key]]);

    for (let i = 0; i < fieldTypes.length; i++) {
      const fieldType = fieldTypes[i];
      if (fieldType === String || fieldType === Boolean) {
        docsTypes.push(fieldType.name);
      } else if (fieldType === null) {
        docsTypes.push("null");
      } else if (typeof fieldType === "string") {
        docsTypes.push("<" + fieldType + ">");
      } else if (Array.isArray(fieldType)) {
        docsTypes.push("List"); // TODO: use type enum
      } else {
        throw new Error(
          "Wrong value `" +
            fieldType +
            "` in `" +
            name +
            "." +
            key +
            "` structure definition",
        );
      }
    }

    docs[key] = docsTypes.join(" | ");
  }

  return {
    docs,
    check: createNodeStructureChecker$1(name, fields),
  };
}

function getStructureFromConfig$1(config) {
  const structure = {};

  if (config.node) {
    for (const name in config.node) {
      if (hasOwnProperty$a.call(config.node, name)) {
        const nodeType = config.node[name];

        if (nodeType.structure) {
          structure[name] = processStructure$1(name, nodeType);
        } else {
          throw new Error(
            "Missed `structure` field in `" + name + "` node type definition",
          );
        }
      }
    }
  }

  return structure;
}

structure$1k.getStructureFromConfig = getStructureFromConfig$1;

var walk$a = {};

const noop$6 = function () {};

function ensureFunction$2(value) {
  return typeof value === "function" ? value : noop$6;
}

function walk$9(node, options, context) {
  function walk(node) {
    enter.call(context, node);

    switch (node.type) {
      case "Group":
        node.terms.forEach(walk);
        break;

      case "Multiplier":
        walk(node.term);
        break;

      case "Type":
      case "Property":
      case "Keyword":
      case "AtKeyword":
      case "Function":
      case "String":
      case "Token":
      case "Comma":
        break;

      default:
        throw new Error("Unknown type: " + node.type);
    }

    leave.call(context, node);
  }

  let enter = noop$6;
  let leave = noop$6;

  if (typeof options === "function") {
    enter = options;
  } else if (options) {
    enter = ensureFunction$2(options.enter);
    leave = ensureFunction$2(options.leave);
  }

  if (enter === noop$6 && leave === noop$6) {
    throw new Error(
      "Neither `enter` nor `leave` walker handler is set or both aren't a function",
    );
  }

  walk(node);
}

walk$a.walk = walk$9;

const error$3 = error$4;
const names$b = names$c;
const genericConst$3 = genericConst$5;
const generic$2 = generic$3;
const units = units$1;
const prepareTokens$2 = prepareTokens_1$1;
const matchGraph$3 = matchGraph$5;
const match$2 = match$3;
const trace$2 = trace$3;
const search$2 = search$3;
const structure$1j = structure$1k;
const parse$1v = parse$1y;
const generate$1r = generate$1u;
const walk$8 = walk$a;

const cssWideKeywordsSyntax$1 = matchGraph$3.buildMatchGraph(
  genericConst$3.cssWideKeywords.join(" | "),
);

function dumpMapSyntax$1(map, compact, syntaxAsAst) {
  const result = {};

  for (const name in map) {
    if (map[name].syntax) {
      result[name] = syntaxAsAst
        ? map[name].syntax
        : generate$1r.generate(map[name].syntax, { compact });
    }
  }

  return result;
}

function dumpAtruleMapSyntax$1(map, compact, syntaxAsAst) {
  const result = {};

  for (const [name, atrule] of Object.entries(map)) {
    result[name] = {
      prelude:
        atrule.prelude &&
        (syntaxAsAst
          ? atrule.prelude.syntax
          : generate$1r.generate(atrule.prelude.syntax, { compact })),
      descriptors:
        atrule.descriptors &&
        dumpMapSyntax$1(atrule.descriptors, compact, syntaxAsAst),
    };
  }

  return result;
}

function valueHasVar$1(tokens) {
  for (let i = 0; i < tokens.length; i++) {
    if (tokens[i].value.toLowerCase() === "var(") {
      return true;
    }
  }

  return false;
}

function buildMatchResult$1(matched, error, iterations) {
  return {
    matched,
    iterations,
    error,
    ...trace$2,
  };
}

function matchSyntax$1(lexer, syntax, value, useCssWideKeywords) {
  const tokens = prepareTokens$2(value, lexer.syntax);
  let result;

  if (valueHasVar$1(tokens)) {
    return buildMatchResult$1(
      null,
      new Error("Matching for a tree with var() is not supported"),
    );
  }

  if (useCssWideKeywords) {
    result = match$2.matchAsTree(tokens, lexer.cssWideKeywordsSyntax, lexer);
  }

  if (!useCssWideKeywords || !result.match) {
    result = match$2.matchAsTree(tokens, syntax.match, lexer);
    if (!result.match) {
      return buildMatchResult$1(
        null,
        new error$3.SyntaxMatchError(
          result.reason,
          syntax.syntax,
          value,
          result,
        ),
        result.iterations,
      );
    }
  }

  return buildMatchResult$1(result.match, null, result.iterations);
}

let Lexer$6 = class Lexer {
  constructor(config, syntax, structure$1) {
    this.cssWideKeywordsSyntax = cssWideKeywordsSyntax$1;
    this.syntax = syntax;
    this.generic = false;
    this.units = { ...units };
    this.atrules = Object.create(null);
    this.properties = Object.create(null);
    this.types = Object.create(null);
    this.structure = structure$1 || structure$1j.getStructureFromConfig(config);

    if (config) {
      if (config.units) {
        for (const group of Object.keys(units)) {
          if (Array.isArray(config.units[group])) {
            this.units[group] = config.units[group];
          }
        }
      }

      if (config.types) {
        for (const name in config.types) {
          this.addType_(name, config.types[name]);
        }
      }

      if (config.generic) {
        this.generic = true;
        for (const [name, value] of Object.entries(
          generic$2.createGenericTypes(this.units),
        )) {
          this.addType_(name, value);
        }
      }

      if (config.atrules) {
        for (const name in config.atrules) {
          this.addAtrule_(name, config.atrules[name]);
        }
      }

      if (config.properties) {
        for (const name in config.properties) {
          this.addProperty_(name, config.properties[name]);
        }
      }
    }
  }

  checkStructure(ast) {
    function collectWarning(node, message) {
      warns.push({ node, message });
    }

    const structure = this.structure;
    const warns = [];

    this.syntax.walk(ast, function (node) {
      if (structure.hasOwnProperty(node.type)) {
        structure[node.type].check(node, collectWarning);
      } else {
        collectWarning(node, "Unknown node type `" + node.type + "`");
      }
    });

    return warns.length ? warns : false;
  }

  createDescriptor(syntax, type, name, parent = null) {
    const ref = {
      type,
      name,
    };
    const descriptor = {
      type,
      name,
      parent,
      serializable:
        typeof syntax === "string" ||
        (syntax && typeof syntax.type === "string"),
      syntax: null,
      match: null,
    };

    if (typeof syntax === "function") {
      descriptor.match = matchGraph$3.buildMatchGraph(syntax, ref);
    } else {
      if (typeof syntax === "string") {
        // lazy parsing on first access
        Object.defineProperty(descriptor, "syntax", {
          get() {
            Object.defineProperty(descriptor, "syntax", {
              value: parse$1v.parse(syntax),
            });

            return descriptor.syntax;
          },
        });
      } else {
        descriptor.syntax = syntax;
      }

      // lazy graph build on first access
      Object.defineProperty(descriptor, "match", {
        get() {
          Object.defineProperty(descriptor, "match", {
            value: matchGraph$3.buildMatchGraph(descriptor.syntax, ref),
          });

          return descriptor.match;
        },
      });
    }

    return descriptor;
  }
  addAtrule_(name, syntax) {
    if (!syntax) {
      return;
    }

    this.atrules[name] = {
      type: "Atrule",
      name: name,
      prelude: syntax.prelude
        ? this.createDescriptor(syntax.prelude, "AtrulePrelude", name)
        : null,
      descriptors: syntax.descriptors
        ? Object.keys(syntax.descriptors).reduce((map, descName) => {
            map[descName] = this.createDescriptor(
              syntax.descriptors[descName],
              "AtruleDescriptor",
              descName,
              name,
            );
            return map;
          }, Object.create(null))
        : null,
    };
  }
  addProperty_(name, syntax) {
    if (!syntax) {
      return;
    }

    this.properties[name] = this.createDescriptor(syntax, "Property", name);
  }
  addType_(name, syntax) {
    if (!syntax) {
      return;
    }

    this.types[name] = this.createDescriptor(syntax, "Type", name);
  }

  checkAtruleName(atruleName) {
    if (!this.getAtrule(atruleName)) {
      return new error$3.SyntaxReferenceError(
        "Unknown at-rule",
        "@" + atruleName,
      );
    }
  }
  checkAtrulePrelude(atruleName, prelude) {
    const error = this.checkAtruleName(atruleName);

    if (error) {
      return error;
    }

    const atrule = this.getAtrule(atruleName);

    if (!atrule.prelude && prelude) {
      return new SyntaxError(
        "At-rule `@" + atruleName + "` should not contain a prelude",
      );
    }

    if (atrule.prelude && !prelude) {
      if (!matchSyntax$1(this, atrule.prelude, "", false).matched) {
        return new SyntaxError(
          "At-rule `@" + atruleName + "` should contain a prelude",
        );
      }
    }
  }
  checkAtruleDescriptorName(atruleName, descriptorName) {
    const error$1 = this.checkAtruleName(atruleName);

    if (error$1) {
      return error$1;
    }

    const atrule = this.getAtrule(atruleName);
    const descriptor = names$b.keyword(descriptorName);

    if (!atrule.descriptors) {
      return new SyntaxError(
        "At-rule `@" + atruleName + "` has no known descriptors",
      );
    }

    if (
      !atrule.descriptors[descriptor.name] &&
      !atrule.descriptors[descriptor.basename]
    ) {
      return new error$3.SyntaxReferenceError(
        "Unknown at-rule descriptor",
        descriptorName,
      );
    }
  }
  checkPropertyName(propertyName) {
    if (!this.getProperty(propertyName)) {
      return new error$3.SyntaxReferenceError("Unknown property", propertyName);
    }
  }

  matchAtrulePrelude(atruleName, prelude) {
    const error = this.checkAtrulePrelude(atruleName, prelude);

    if (error) {
      return buildMatchResult$1(null, error);
    }

    const atrule = this.getAtrule(atruleName);

    if (!atrule.prelude) {
      return buildMatchResult$1(null, null);
    }

    return matchSyntax$1(this, atrule.prelude, prelude || "", false);
  }
  matchAtruleDescriptor(atruleName, descriptorName, value) {
    const error = this.checkAtruleDescriptorName(atruleName, descriptorName);

    if (error) {
      return buildMatchResult$1(null, error);
    }

    const atrule = this.getAtrule(atruleName);
    const descriptor = names$b.keyword(descriptorName);

    return matchSyntax$1(
      this,
      atrule.descriptors[descriptor.name] ||
        atrule.descriptors[descriptor.basename],
      value,
      false,
    );
  }
  matchDeclaration(node) {
    if (node.type !== "Declaration") {
      return buildMatchResult$1(null, new Error("Not a Declaration node"));
    }

    return this.matchProperty(node.property, node.value);
  }
  matchProperty(propertyName, value) {
    // don't match syntax for a custom property at the moment
    if (names$b.property(propertyName).custom) {
      return buildMatchResult$1(
        null,
        new Error("Lexer matching doesn't applicable for custom properties"),
      );
    }

    const error = this.checkPropertyName(propertyName);

    if (error) {
      return buildMatchResult$1(null, error);
    }

    return matchSyntax$1(this, this.getProperty(propertyName), value, true);
  }
  matchType(typeName, value) {
    const typeSyntax = this.getType(typeName);

    if (!typeSyntax) {
      return buildMatchResult$1(
        null,
        new error$3.SyntaxReferenceError("Unknown type", typeName),
      );
    }

    return matchSyntax$1(this, typeSyntax, value, false);
  }
  match(syntax, value) {
    if (typeof syntax !== "string" && (!syntax || !syntax.type)) {
      return buildMatchResult$1(
        null,
        new error$3.SyntaxReferenceError("Bad syntax"),
      );
    }

    if (typeof syntax === "string" || !syntax.match) {
      syntax = this.createDescriptor(syntax, "Type", "anonymous");
    }

    return matchSyntax$1(this, syntax, value, false);
  }

  findValueFragments(propertyName, value, type, name) {
    return search$2.matchFragments(
      this,
      value,
      this.matchProperty(propertyName, value),
      type,
      name,
    );
  }
  findDeclarationValueFragments(declaration, type, name) {
    return search$2.matchFragments(
      this,
      declaration.value,
      this.matchDeclaration(declaration),
      type,
      name,
    );
  }
  findAllFragments(ast, type, name) {
    const result = [];

    this.syntax.walk(ast, {
      visit: "Declaration",
      enter: (declaration) => {
        result.push.apply(
          result,
          this.findDeclarationValueFragments(declaration, type, name),
        );
      },
    });

    return result;
  }

  getAtrule(atruleName, fallbackBasename = true) {
    const atrule = names$b.keyword(atruleName);
    const atruleEntry =
      atrule.vendor && fallbackBasename
        ? this.atrules[atrule.name] || this.atrules[atrule.basename]
        : this.atrules[atrule.name];

    return atruleEntry || null;
  }
  getAtrulePrelude(atruleName, fallbackBasename = true) {
    const atrule = this.getAtrule(atruleName, fallbackBasename);

    return (atrule && atrule.prelude) || null;
  }
  getAtruleDescriptor(atruleName, name) {
    return this.atrules.hasOwnProperty(atruleName) && this.atrules.declarators
      ? this.atrules[atruleName].declarators[name] || null
      : null;
  }
  getProperty(propertyName, fallbackBasename = true) {
    const property = names$b.property(propertyName);
    const propertyEntry =
      property.vendor && fallbackBasename
        ? this.properties[property.name] || this.properties[property.basename]
        : this.properties[property.name];

    return propertyEntry || null;
  }
  getType(name) {
    return hasOwnProperty.call(this.types, name) ? this.types[name] : null;
  }

  validate() {
    function validate(syntax, name, broken, descriptor) {
      if (broken.has(name)) {
        return broken.get(name);
      }

      broken.set(name, false);
      if (descriptor.syntax !== null) {
        walk$8.walk(
          descriptor.syntax,
          function (node) {
            if (node.type !== "Type" && node.type !== "Property") {
              return;
            }

            const map = node.type === "Type" ? syntax.types : syntax.properties;
            const brokenMap =
              node.type === "Type" ? brokenTypes : brokenProperties;

            if (
              !hasOwnProperty.call(map, node.name) ||
              validate(syntax, node.name, brokenMap, map[node.name])
            ) {
              broken.set(name, true);
            }
          },
          this,
        );
      }
    }

    let brokenTypes = new Map();
    let brokenProperties = new Map();

    for (const key in this.types) {
      validate(this, key, brokenTypes, this.types[key]);
    }

    for (const key in this.properties) {
      validate(this, key, brokenProperties, this.properties[key]);
    }

    brokenTypes = [...brokenTypes.keys()].filter((name) =>
      brokenTypes.get(name),
    );
    brokenProperties = [...brokenProperties.keys()].filter((name) =>
      brokenProperties.get(name),
    );

    if (brokenTypes.length || brokenProperties.length) {
      return {
        types: brokenTypes,
        properties: brokenProperties,
      };
    }

    return null;
  }
  dump(syntaxAsAst, pretty) {
    return {
      generic: this.generic,
      units: this.units,
      types: dumpMapSyntax$1(this.types, !pretty, syntaxAsAst),
      properties: dumpMapSyntax$1(this.properties, !pretty, syntaxAsAst),
      atrules: dumpAtruleMapSyntax$1(this.atrules, !pretty, syntaxAsAst),
    };
  }
  toString() {
    return JSON.stringify(this.dump());
  }
};

Lexer$7.Lexer = Lexer$6;

function appendOrSet(a, b) {
  if (typeof b === "string" && /^\s*\|/.test(b)) {
    return typeof a === "string" ? a + b : b.replace(/^\s*\|\s*/, "");
  }

  return b || null;
}

function sliceProps(obj, props) {
  const result = Object.create(null);

  for (const [key, value] of Object.entries(obj)) {
    if (value) {
      result[key] = {};
      for (const prop of Object.keys(value)) {
        if (props.includes(prop)) {
          result[key][prop] = value[prop];
        }
      }
    }
  }

  return result;
}

function mix$3(dest, src) {
  const result = { ...dest };

  for (const [prop, value] of Object.entries(src)) {
    switch (prop) {
      case "generic":
        result[prop] = Boolean(value);
        break;

      case "units":
        result[prop] = { ...dest[prop] };
        for (const [name, patch] of Object.entries(value)) {
          result[prop][name] = Array.isArray(patch) ? patch : [];
        }
        break;

      case "atrules":
        result[prop] = { ...dest[prop] };

        for (const [name, atrule] of Object.entries(value)) {
          const exists = result[prop][name] || {};
          const current = (result[prop][name] = {
            prelude: exists.prelude || null,
            descriptors: {
              ...exists.descriptors,
            },
          });

          if (!atrule) {
            continue;
          }

          current.prelude = atrule.prelude
            ? appendOrSet(current.prelude, atrule.prelude)
            : current.prelude || null;

          for (const [descriptorName, descriptorValue] of Object.entries(
            atrule.descriptors || {},
          )) {
            current.descriptors[descriptorName] = descriptorValue
              ? appendOrSet(
                  current.descriptors[descriptorName],
                  descriptorValue,
                )
              : null;
          }

          if (!Object.keys(current.descriptors).length) {
            current.descriptors = null;
          }
        }
        break;

      case "types":
      case "properties":
        result[prop] = { ...dest[prop] };
        for (const [name, syntax] of Object.entries(value)) {
          result[prop][name] = appendOrSet(result[prop][name], syntax);
        }
        break;

      case "scope":
        result[prop] = { ...dest[prop] };
        for (const [name, props] of Object.entries(value)) {
          result[prop][name] = { ...result[prop][name], ...props };
        }
        break;

      case "parseContext":
        result[prop] = {
          ...dest[prop],
          ...value,
        };
        break;

      case "atrule":
      case "pseudo":
        result[prop] = {
          ...dest[prop],
          ...sliceProps(value, ["parse"]),
        };
        break;

      case "node":
        result[prop] = {
          ...dest[prop],
          ...sliceProps(value, [
            "name",
            "structure",
            "parse",
            "generate",
            "walkContext",
          ]),
        };
        break;
    }
  }

  return result;
}

var mix_1$1 = mix$3;

const index$g = tokenizer$5;
const create$a = create$e;
const create$2$2 = create$d;
const create$3$1 = create$c;
const create$1$2 = create$b;
const Lexer$5 = Lexer$7;
const mix$2 = mix_1$1;

function createSyntax$2(config) {
  const parse = create$a.createParser(config);
  const walk = create$1$2.createWalker(config);
  const generate = create$2$2.createGenerator(config);
  const { fromPlainObject, toPlainObject } = create$3$1.createConvertor(walk);

  const syntax = {
    lexer: null,
    createLexer: (config) =>
      new Lexer$5.Lexer(config, syntax, syntax.lexer.structure),

    tokenize: index$g.tokenize,
    parse,
    generate,

    walk,
    find: walk.find,
    findLast: walk.findLast,
    findAll: walk.findAll,

    fromPlainObject,
    toPlainObject,

    fork(extension) {
      const base = mix$2({}, config); // copy of config

      return createSyntax$2(
        typeof extension === "function"
          ? extension(base, Object.assign)
          : mix$2(base, extension),
      );
    },
  };

  syntax.lexer = new Lexer$5.Lexer(
    {
      generic: true,
      units: config.units,
      types: config.types,
      atrules: config.atrules,
      properties: config.properties,
      node: config.node,
    },
    syntax,
  );

  return syntax;
}
const createSyntax$1$1 = (config) => createSyntax$2(mix$2({}, config));

var create_1$1 = createSyntax$1$1;

const atrules$1 = {
  charset: {
    prelude: "<string>",
  },
  "font-face": {
    descriptors: {
      "unicode-range": {
        comment: "replaces <unicode-range>, an old production name",
        syntax: "<urange>#",
      },
    },
  },
  nest: {
    prelude: "<complex-selector-list>",
  },
};
const properties$2 = {
  "-moz-background-clip": {
    comment:
      "deprecated syntax in old Firefox, https://developer.mozilla.org/en/docs/Web/CSS/background-clip",
    syntax: "padding | border",
  },
  "-moz-border-radius-bottomleft": {
    comment:
      "https://developer.mozilla.org/en-US/docs/Web/CSS/border-bottom-left-radius",
    syntax: "<'border-bottom-left-radius'>",
  },
  "-moz-border-radius-bottomright": {
    comment:
      "https://developer.mozilla.org/en-US/docs/Web/CSS/border-bottom-right-radius",
    syntax: "<'border-bottom-right-radius'>",
  },
  "-moz-border-radius-topleft": {
    comment:
      "https://developer.mozilla.org/en-US/docs/Web/CSS/border-top-left-radius",
    syntax: "<'border-top-left-radius'>",
  },
  "-moz-border-radius-topright": {
    comment:
      "https://developer.mozilla.org/en-US/docs/Web/CSS/border-bottom-right-radius",
    syntax: "<'border-bottom-right-radius'>",
  },
  "-moz-control-character-visibility": {
    comment:
      "firefox specific keywords, https://bugzilla.mozilla.org/show_bug.cgi?id=947588",
    syntax: "visible | hidden",
  },
  "-moz-osx-font-smoothing": {
    comment:
      "misssed old syntax https://developer.mozilla.org/en-US/docs/Web/CSS/font-smooth",
    syntax: "auto | grayscale",
  },
  "-moz-user-select": {
    comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/user-select",
    syntax: "none | text | all | -moz-none",
  },
  "-ms-flex-align": {
    comment:
      "misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-align",
    syntax: "start | end | center | baseline | stretch",
  },
  "-ms-flex-item-align": {
    comment:
      "misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-align",
    syntax: "auto | start | end | center | baseline | stretch",
  },
  "-ms-flex-line-pack": {
    comment:
      "misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-line-pack",
    syntax: "start | end | center | justify | distribute | stretch",
  },
  "-ms-flex-negative": {
    comment:
      "misssed old syntax implemented in IE; TODO: find references for comfirmation",
    syntax: "<'flex-shrink'>",
  },
  "-ms-flex-pack": {
    comment:
      "misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-pack",
    syntax: "start | end | center | justify | distribute",
  },
  "-ms-flex-order": {
    comment:
      "misssed old syntax implemented in IE; https://msdn.microsoft.com/en-us/library/jj127303(v=vs.85).aspx",
    syntax: "<integer>",
  },
  "-ms-flex-positive": {
    comment:
      "misssed old syntax implemented in IE; TODO: find references for comfirmation",
    syntax: "<'flex-grow'>",
  },
  "-ms-flex-preferred-size": {
    comment:
      "misssed old syntax implemented in IE; TODO: find references for comfirmation",
    syntax: "<'flex-basis'>",
  },
  "-ms-interpolation-mode": {
    comment: "https://msdn.microsoft.com/en-us/library/ff521095(v=vs.85).aspx",
    syntax: "nearest-neighbor | bicubic",
  },
  "-ms-grid-column-align": {
    comment:
      "add this property first since it uses as fallback for flexbox, https://msdn.microsoft.com/en-us/library/windows/apps/hh466338.aspx",
    syntax: "start | end | center | stretch",
  },
  "-ms-grid-row-align": {
    comment:
      "add this property first since it uses as fallback for flexbox, https://msdn.microsoft.com/en-us/library/windows/apps/hh466348.aspx",
    syntax: "start | end | center | stretch",
  },
  "-ms-hyphenate-limit-last": {
    comment:
      "misssed old syntax implemented in IE; https://www.w3.org/TR/css-text-4/#hyphenate-line-limits",
    syntax: "none | always | column | page | spread",
  },
  "-webkit-appearance": {
    comment: "webkit specific keywords",
    references: ["http://css-infos.net/property/-webkit-appearance"],
    syntax:
      "none | button | button-bevel | caps-lock-indicator | caret | checkbox | default-button | inner-spin-button | listbox | listitem | media-controls-background | media-controls-fullscreen-background | media-current-time-display | media-enter-fullscreen-button | media-exit-fullscreen-button | media-fullscreen-button | media-mute-button | media-overlay-play-button | media-play-button | media-seek-back-button | media-seek-forward-button | media-slider | media-sliderthumb | media-time-remaining-display | media-toggle-closed-captions-button | media-volume-slider | media-volume-slider-container | media-volume-sliderthumb | menulist | menulist-button | menulist-text | menulist-textfield | meter | progress-bar | progress-bar-value | push-button | radio | scrollbarbutton-down | scrollbarbutton-left | scrollbarbutton-right | scrollbarbutton-up | scrollbargripper-horizontal | scrollbargripper-vertical | scrollbarthumb-horizontal | scrollbarthumb-vertical | scrollbartrack-horizontal | scrollbartrack-vertical | searchfield | searchfield-cancel-button | searchfield-decoration | searchfield-results-button | searchfield-results-decoration | slider-horizontal | slider-vertical | sliderthumb-horizontal | sliderthumb-vertical | square-button | textarea | textfield | -apple-pay-button",
  },
  "-webkit-background-clip": {
    comment: "https://developer.mozilla.org/en/docs/Web/CSS/background-clip",
    syntax: "[ <box> | border | padding | content | text ]#",
  },
  "-webkit-column-break-after": {
    comment: "added, http://help.dottoro.com/lcrthhhv.php",
    syntax: "always | auto | avoid",
  },
  "-webkit-column-break-before": {
    comment: "added, http://help.dottoro.com/lcxquvkf.php",
    syntax: "always | auto | avoid",
  },
  "-webkit-column-break-inside": {
    comment: "added, http://help.dottoro.com/lclhnthl.php",
    syntax: "always | auto | avoid",
  },
  "-webkit-font-smoothing": {
    comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/font-smooth",
    syntax: "auto | none | antialiased | subpixel-antialiased",
  },
  "-webkit-mask-box-image": {
    comment:
      "missed; https://developer.mozilla.org/en-US/docs/Web/CSS/-webkit-mask-box-image",
    syntax:
      "[ <url> | <gradient> | none ] [ <length-percentage>{4} <-webkit-mask-box-repeat>{2} ]?",
  },
  "-webkit-print-color-adjust": {
    comment: "missed",
    references: [
      "https://developer.mozilla.org/en/docs/Web/CSS/-webkit-print-color-adjust",
    ],
    syntax: "economy | exact",
  },
  "-webkit-text-security": {
    comment: "missed; http://help.dottoro.com/lcbkewgt.php",
    syntax: "none | circle | disc | square",
  },
  "-webkit-user-drag": {
    comment: "missed; http://help.dottoro.com/lcbixvwm.php",
    syntax: "none | element | auto",
  },
  "-webkit-user-select": {
    comment:
      "auto is supported by old webkit, https://developer.mozilla.org/en-US/docs/Web/CSS/user-select",
    syntax: "auto | none | text | all",
  },
  "alignment-baseline": {
    comment: "added SVG property",
    references: [
      "https://www.w3.org/TR/SVG/text.html#AlignmentBaselineProperty",
    ],
    syntax:
      "auto | baseline | before-edge | text-before-edge | middle | central | after-edge | text-after-edge | ideographic | alphabetic | hanging | mathematical",
  },
  "background-clip": {
    comment:
      "used <bg-clip> from CSS Backgrounds and Borders 4 since it adds new values",
    references: ["https://github.com/csstree/csstree/issues/190"],
    syntax: "<bg-clip>#",
  },
  "baseline-shift": {
    comment: "added SVG property",
    references: ["https://www.w3.org/TR/SVG/text.html#BaselineShiftProperty"],
    syntax: "baseline | sub | super | <svg-length>",
  },
  behavior: {
    comment:
      "added old IE property https://msdn.microsoft.com/en-us/library/ms530723(v=vs.85).aspx",
    syntax: "<url>+",
  },
  "clip-rule": {
    comment: "added SVG property",
    references: ["https://www.w3.org/TR/SVG/masking.html#ClipRuleProperty"],
    syntax: "nonzero | evenodd",
  },
  cue: {
    comment: "https://www.w3.org/TR/css3-speech/#property-index",
    syntax: "<'cue-before'> <'cue-after'>?",
  },
  "cue-after": {
    comment: "https://www.w3.org/TR/css3-speech/#property-index",
    syntax: "<url> <decibel>? | none",
  },
  "cue-before": {
    comment: "https://www.w3.org/TR/css3-speech/#property-index",
    syntax: "<url> <decibel>? | none",
  },
  cursor: {
    comment:
      "added legacy keywords: hand, -webkit-grab. -webkit-grabbing, -webkit-zoom-in, -webkit-zoom-out, -moz-grab, -moz-grabbing, -moz-zoom-in, -moz-zoom-out",
    references: ["https://www.sitepoint.com/css3-cursor-styles/"],
    syntax:
      "[ [ <url> [ <x> <y> ]? , ]* [ auto | default | none | context-menu | help | pointer | progress | wait | cell | crosshair | text | vertical-text | alias | copy | move | no-drop | not-allowed | e-resize | n-resize | ne-resize | nw-resize | s-resize | se-resize | sw-resize | w-resize | ew-resize | ns-resize | nesw-resize | nwse-resize | col-resize | row-resize | all-scroll | zoom-in | zoom-out | grab | grabbing | hand | -webkit-grab | -webkit-grabbing | -webkit-zoom-in | -webkit-zoom-out | -moz-grab | -moz-grabbing | -moz-zoom-in | -moz-zoom-out ] ]",
  },
  display: {
    comment: "extended with -ms-flexbox",
    syntax: "| <-non-standard-display>",
  },
  position: {
    comment: "extended with -webkit-sticky",
    syntax: "| -webkit-sticky",
  },
  "dominant-baseline": {
    comment: "added SVG property",
    references: [
      "https://www.w3.org/TR/SVG/text.html#DominantBaselineProperty",
    ],
    syntax:
      "auto | use-script | no-change | reset-size | ideographic | alphabetic | hanging | mathematical | central | middle | text-after-edge | text-before-edge",
  },
  "image-rendering": {
    comment:
      "extended with <-non-standard-image-rendering>, added SVG keywords optimizeSpeed and optimizeQuality",
    references: [
      "https://developer.mozilla.org/en/docs/Web/CSS/image-rendering",
      "https://www.w3.org/TR/SVG/painting.html#ImageRenderingProperty",
    ],
    syntax:
      "| optimizeSpeed | optimizeQuality | <-non-standard-image-rendering>",
  },
  fill: {
    comment: "added SVG property",
    references: ["https://www.w3.org/TR/SVG/painting.html#FillProperty"],
    syntax: "<paint>",
  },
  "fill-opacity": {
    comment: "added SVG property",
    references: ["https://www.w3.org/TR/SVG/painting.html#FillProperty"],
    syntax: "<number-zero-one>",
  },
  "fill-rule": {
    comment: "added SVG property",
    references: ["https://www.w3.org/TR/SVG/painting.html#FillProperty"],
    syntax: "nonzero | evenodd",
  },
  filter: {
    comment: "extend with IE legacy syntaxes",
    syntax: "| <-ms-filter-function-list>",
  },
  "glyph-orientation-horizontal": {
    comment: "added SVG property",
    references: [
      "https://www.w3.org/TR/SVG/text.html#GlyphOrientationHorizontalProperty",
    ],
    syntax: "<angle>",
  },
  "glyph-orientation-vertical": {
    comment: "added SVG property",
    references: [
      "https://www.w3.org/TR/SVG/text.html#GlyphOrientationVerticalProperty",
    ],
    syntax: "<angle>",
  },
  kerning: {
    comment: "added SVG property",
    references: ["https://www.w3.org/TR/SVG/text.html#KerningProperty"],
    syntax: "auto | <svg-length>",
  },
  "letter-spacing": {
    comment: "fix syntax <length> -> <length-percentage>",
    references: [
      "https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/letter-spacing",
    ],
    syntax: "normal | <length-percentage>",
  },
  marker: {
    comment: "added SVG property",
    references: ["https://www.w3.org/TR/SVG/painting.html#MarkerProperties"],
    syntax: "none | <url>",
  },
  "marker-end": {
    comment: "added SVG property",
    references: ["https://www.w3.org/TR/SVG/painting.html#MarkerProperties"],
    syntax: "none | <url>",
  },
  "marker-mid": {
    comment: "added SVG property",
    references: ["https://www.w3.org/TR/SVG/painting.html#MarkerProperties"],
    syntax: "none | <url>",
  },
  "marker-start": {
    comment: "added SVG property",
    references: ["https://www.w3.org/TR/SVG/painting.html#MarkerProperties"],
    syntax: "none | <url>",
  },
  "max-width": {
    comment:
      "extend by non-standard width keywords https://developer.mozilla.org/en-US/docs/Web/CSS/max-width",
    syntax: "| <-non-standard-width>",
  },
  width: {
    references: [
      "https://developer.mozilla.org/en-US/docs/Web/CSS/width",
      "https://github.com/csstree/stylelint-validator/issues/29",
    ],
    syntax:
      "| fill | stretch | intrinsic | -moz-max-content | -webkit-max-content | -moz-fit-content | -webkit-fit-content",
  },
  "min-width": {
    comment:
      "extend by non-standard width keywords https://developer.mozilla.org/en-US/docs/Web/CSS/width",
    syntax: "| <-non-standard-width>",
  },
  overflow: {
    comment:
      "extend by vendor keywords https://developer.mozilla.org/en-US/docs/Web/CSS/overflow",
    syntax: "| <-non-standard-overflow>",
  },
  pause: {
    comment: "https://www.w3.org/TR/css3-speech/#property-index",
    syntax: "<'pause-before'> <'pause-after'>?",
  },
  "pause-after": {
    comment: "https://www.w3.org/TR/css3-speech/#property-index",
    syntax: "<time> | none | x-weak | weak | medium | strong | x-strong",
  },
  "pause-before": {
    comment: "https://www.w3.org/TR/css3-speech/#property-index",
    syntax: "<time> | none | x-weak | weak | medium | strong | x-strong",
  },
  rest: {
    comment: "https://www.w3.org/TR/css3-speech/#property-index",
    syntax: "<'rest-before'> <'rest-after'>?",
  },
  "rest-after": {
    comment: "https://www.w3.org/TR/css3-speech/#property-index",
    syntax: "<time> | none | x-weak | weak | medium | strong | x-strong",
  },
  "rest-before": {
    comment: "https://www.w3.org/TR/css3-speech/#property-index",
    syntax: "<time> | none | x-weak | weak | medium | strong | x-strong",
  },
  "shape-rendering": {
    comment: "added SVG property",
    references: [
      "https://www.w3.org/TR/SVG/painting.html#ShapeRenderingPropert",
    ],
    syntax: "auto | optimizeSpeed | crispEdges | geometricPrecision",
  },
  src: {
    comment:
      "added @font-face's src property https://developer.mozilla.org/en-US/docs/Web/CSS/@font-face/src",
    syntax: "[ <url> [ format( <string># ) ]? | local( <family-name> ) ]#",
  },
  speak: {
    comment: "https://www.w3.org/TR/css3-speech/#property-index",
    syntax: "auto | none | normal",
  },
  "speak-as": {
    comment: "https://www.w3.org/TR/css3-speech/#property-index",
    syntax:
      "normal | spell-out || digits || [ literal-punctuation | no-punctuation ]",
  },
  stroke: {
    comment: "added SVG property",
    references: ["https://www.w3.org/TR/SVG/painting.html#StrokeProperties"],
    syntax: "<paint>",
  },
  "stroke-dasharray": {
    comment:
      "added SVG property; a list of comma and/or white space separated <length>s and <percentage>s",
    references: ["https://www.w3.org/TR/SVG/painting.html#StrokeProperties"],
    syntax: "none | [ <svg-length>+ ]#",
  },
  "stroke-dashoffset": {
    comment: "added SVG property",
    references: ["https://www.w3.org/TR/SVG/painting.html#StrokeProperties"],
    syntax: "<svg-length>",
  },
  "stroke-linecap": {
    comment: "added SVG property",
    references: ["https://www.w3.org/TR/SVG/painting.html#StrokeProperties"],
    syntax: "butt | round | square",
  },
  "stroke-linejoin": {
    comment: "added SVG property",
    references: ["https://www.w3.org/TR/SVG/painting.html#StrokeProperties"],
    syntax: "miter | round | bevel",
  },
  "stroke-miterlimit": {
    comment: "added SVG property (<miterlimit> = <number-one-or-greater>) ",
    references: ["https://www.w3.org/TR/SVG/painting.html#StrokeProperties"],
    syntax: "<number-one-or-greater>",
  },
  "stroke-opacity": {
    comment: "added SVG property",
    references: ["https://www.w3.org/TR/SVG/painting.html#StrokeProperties"],
    syntax: "<number-zero-one>",
  },
  "stroke-width": {
    comment: "added SVG property",
    references: ["https://www.w3.org/TR/SVG/painting.html#StrokeProperties"],
    syntax: "<svg-length>",
  },
  "text-anchor": {
    comment: "added SVG property",
    references: ["https://www.w3.org/TR/SVG/text.html#TextAlignmentProperties"],
    syntax: "start | middle | end",
  },
  "unicode-bidi": {
    comment:
      "added prefixed keywords https://developer.mozilla.org/en-US/docs/Web/CSS/unicode-bidi",
    syntax:
      "| -moz-isolate | -moz-isolate-override | -moz-plaintext | -webkit-isolate | -webkit-isolate-override | -webkit-plaintext",
  },
  "unicode-range": {
    comment:
      "added missed property https://developer.mozilla.org/en-US/docs/Web/CSS/%40font-face/unicode-range",
    syntax: "<urange>#",
  },
  "voice-balance": {
    comment: "https://www.w3.org/TR/css3-speech/#property-index",
    syntax: "<number> | left | center | right | leftwards | rightwards",
  },
  "voice-duration": {
    comment: "https://www.w3.org/TR/css3-speech/#property-index",
    syntax: "auto | <time>",
  },
  "voice-family": {
    comment:
      "<name> -> <family-name>, https://www.w3.org/TR/css3-speech/#property-index",
    syntax:
      "[ [ <family-name> | <generic-voice> ] , ]* [ <family-name> | <generic-voice> ] | preserve",
  },
  "voice-pitch": {
    comment: "https://www.w3.org/TR/css3-speech/#property-index",
    syntax:
      "<frequency> && absolute | [ [ x-low | low | medium | high | x-high ] || [ <frequency> | <semitones> | <percentage> ] ]",
  },
  "voice-range": {
    comment: "https://www.w3.org/TR/css3-speech/#property-index",
    syntax:
      "<frequency> && absolute | [ [ x-low | low | medium | high | x-high ] || [ <frequency> | <semitones> | <percentage> ] ]",
  },
  "voice-rate": {
    comment: "https://www.w3.org/TR/css3-speech/#property-index",
    syntax:
      "[ normal | x-slow | slow | medium | fast | x-fast ] || <percentage>",
  },
  "voice-stress": {
    comment: "https://www.w3.org/TR/css3-speech/#property-index",
    syntax: "normal | strong | moderate | none | reduced",
  },
  "voice-volume": {
    comment: "https://www.w3.org/TR/css3-speech/#property-index",
    syntax:
      "silent | [ [ x-soft | soft | medium | loud | x-loud ] || <decibel> ]",
  },
  "writing-mode": {
    comment: "extend with SVG keywords",
    syntax: "| <svg-writing-mode>",
  },
};
const types$1B = {
  "-legacy-gradient": {
    comment: "added collection of legacy gradient syntaxes",
    syntax:
      "<-webkit-gradient()> | <-legacy-linear-gradient> | <-legacy-repeating-linear-gradient> | <-legacy-radial-gradient> | <-legacy-repeating-radial-gradient>",
  },
  "-legacy-linear-gradient": {
    comment:
      "like standard syntax but w/o `to` keyword https://developer.mozilla.org/en-US/docs/Web/CSS/linear-gradient",
    syntax:
      "-moz-linear-gradient( <-legacy-linear-gradient-arguments> ) | -webkit-linear-gradient( <-legacy-linear-gradient-arguments> ) | -o-linear-gradient( <-legacy-linear-gradient-arguments> )",
  },
  "-legacy-repeating-linear-gradient": {
    comment:
      "like standard syntax but w/o `to` keyword https://developer.mozilla.org/en-US/docs/Web/CSS/linear-gradient",
    syntax:
      "-moz-repeating-linear-gradient( <-legacy-linear-gradient-arguments> ) | -webkit-repeating-linear-gradient( <-legacy-linear-gradient-arguments> ) | -o-repeating-linear-gradient( <-legacy-linear-gradient-arguments> )",
  },
  "-legacy-linear-gradient-arguments": {
    comment:
      "like standard syntax but w/o `to` keyword https://developer.mozilla.org/en-US/docs/Web/CSS/linear-gradient",
    syntax: "[ <angle> | <side-or-corner> ]? , <color-stop-list>",
  },
  "-legacy-radial-gradient": {
    comment:
      "deprecated syntax that implemented by some browsers https://www.w3.org/TR/2011/WD-css3-images-20110908/#radial-gradients",
    syntax:
      "-moz-radial-gradient( <-legacy-radial-gradient-arguments> ) | -webkit-radial-gradient( <-legacy-radial-gradient-arguments> ) | -o-radial-gradient( <-legacy-radial-gradient-arguments> )",
  },
  "-legacy-repeating-radial-gradient": {
    comment:
      "deprecated syntax that implemented by some browsers https://www.w3.org/TR/2011/WD-css3-images-20110908/#radial-gradients",
    syntax:
      "-moz-repeating-radial-gradient( <-legacy-radial-gradient-arguments> ) | -webkit-repeating-radial-gradient( <-legacy-radial-gradient-arguments> ) | -o-repeating-radial-gradient( <-legacy-radial-gradient-arguments> )",
  },
  "-legacy-radial-gradient-arguments": {
    comment:
      "deprecated syntax that implemented by some browsers https://www.w3.org/TR/2011/WD-css3-images-20110908/#radial-gradients",
    syntax:
      "[ <position> , ]? [ [ [ <-legacy-radial-gradient-shape> || <-legacy-radial-gradient-size> ] | [ <length> | <percentage> ]{2} ] , ]? <color-stop-list>",
  },
  "-legacy-radial-gradient-size": {
    comment:
      "before a standard it contains 2 extra keywords (`contain` and `cover`) https://www.w3.org/TR/2011/WD-css3-images-20110908/#ltsize",
    syntax:
      "closest-side | closest-corner | farthest-side | farthest-corner | contain | cover",
  },
  "-legacy-radial-gradient-shape": {
    comment:
      "define to double sure it doesn't extends in future https://www.w3.org/TR/2011/WD-css3-images-20110908/#ltshape",
    syntax: "circle | ellipse",
  },
  "-non-standard-font": {
    comment: "non standard fonts",
    references: [
      "https://webkit.org/blog/3709/using-the-system-font-in-web-content/",
    ],
    syntax:
      "-apple-system-body | -apple-system-headline | -apple-system-subheadline | -apple-system-caption1 | -apple-system-caption2 | -apple-system-footnote | -apple-system-short-body | -apple-system-short-headline | -apple-system-short-subheadline | -apple-system-short-caption1 | -apple-system-short-footnote | -apple-system-tall-body",
  },
  "-non-standard-color": {
    comment: "non standard colors",
    references: [
      "http://cssdot.ru/%D0%A1%D0%BF%D1%80%D0%B0%D0%B2%D0%BE%D1%87%D0%BD%D0%B8%D0%BA_CSS/color-i305.html",
      "https://developer.mozilla.org/en-US/docs/Web/CSS/color_value#Mozilla_Color_Preference_Extensions",
    ],
    syntax:
      "-moz-ButtonDefault | -moz-ButtonHoverFace | -moz-ButtonHoverText | -moz-CellHighlight | -moz-CellHighlightText | -moz-Combobox | -moz-ComboboxText | -moz-Dialog | -moz-DialogText | -moz-dragtargetzone | -moz-EvenTreeRow | -moz-Field | -moz-FieldText | -moz-html-CellHighlight | -moz-html-CellHighlightText | -moz-mac-accentdarkestshadow | -moz-mac-accentdarkshadow | -moz-mac-accentface | -moz-mac-accentlightesthighlight | -moz-mac-accentlightshadow | -moz-mac-accentregularhighlight | -moz-mac-accentregularshadow | -moz-mac-chrome-active | -moz-mac-chrome-inactive | -moz-mac-focusring | -moz-mac-menuselect | -moz-mac-menushadow | -moz-mac-menutextselect | -moz-MenuHover | -moz-MenuHoverText | -moz-MenuBarText | -moz-MenuBarHoverText | -moz-nativehyperlinktext | -moz-OddTreeRow | -moz-win-communicationstext | -moz-win-mediatext | -moz-activehyperlinktext | -moz-default-background-color | -moz-default-color | -moz-hyperlinktext | -moz-visitedhyperlinktext | -webkit-activelink | -webkit-focus-ring-color | -webkit-link | -webkit-text",
  },
  "-non-standard-image-rendering": {
    comment:
      "non-standard keywords http://phrogz.net/tmp/canvas_image_zoom.html",
    syntax:
      "optimize-contrast | -moz-crisp-edges | -o-crisp-edges | -webkit-optimize-contrast",
  },
  "-non-standard-overflow": {
    comment:
      "non-standard keywords https://developer.mozilla.org/en-US/docs/Web/CSS/overflow",
    syntax:
      "-moz-scrollbars-none | -moz-scrollbars-horizontal | -moz-scrollbars-vertical | -moz-hidden-unscrollable",
  },
  "-non-standard-width": {
    comment:
      "non-standard keywords https://developer.mozilla.org/en-US/docs/Web/CSS/width",
    syntax:
      "fill-available | min-intrinsic | intrinsic | -moz-available | -moz-fit-content | -moz-min-content | -moz-max-content | -webkit-min-content | -webkit-max-content",
  },
  "-webkit-gradient()": {
    comment:
      "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/ - TODO: simplify when after match algorithm improvement ( [, point, radius | , point] -> [, radius]? , point )",
    syntax:
      "-webkit-gradient( <-webkit-gradient-type>, <-webkit-gradient-point> [, <-webkit-gradient-point> | , <-webkit-gradient-radius>, <-webkit-gradient-point> ] [, <-webkit-gradient-radius>]? [, <-webkit-gradient-color-stop>]* )",
  },
  "-webkit-gradient-color-stop": {
    comment:
      "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/",
    syntax:
      "from( <color> ) | color-stop( [ <number-zero-one> | <percentage> ] , <color> ) | to( <color> )",
  },
  "-webkit-gradient-point": {
    comment:
      "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/",
    syntax:
      "[ left | center | right | <length-percentage> ] [ top | center | bottom | <length-percentage> ]",
  },
  "-webkit-gradient-radius": {
    comment:
      "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/",
    syntax: "<length> | <percentage>",
  },
  "-webkit-gradient-type": {
    comment:
      "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/",
    syntax: "linear | radial",
  },
  "-webkit-mask-box-repeat": {
    comment:
      "missed; https://developer.mozilla.org/en-US/docs/Web/CSS/-webkit-mask-box-image",
    syntax: "repeat | stretch | round",
  },
  "-webkit-mask-clip-style": {
    comment:
      "missed; there is no enough information about `-webkit-mask-clip` property, but looks like all those keywords are working",
    syntax:
      "border | border-box | padding | padding-box | content | content-box | text",
  },
  "-ms-filter-function-list": {
    comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-filter",
    syntax: "<-ms-filter-function>+",
  },
  "-ms-filter-function": {
    comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-filter",
    syntax: "<-ms-filter-function-progid> | <-ms-filter-function-legacy>",
  },
  "-ms-filter-function-progid": {
    comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-filter",
    syntax:
      "'progid:' [ <ident-token> '.' ]* [ <ident-token> | <function-token> <any-value>? ) ]",
  },
  "-ms-filter-function-legacy": {
    comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-filter",
    syntax: "<ident-token> | <function-token> <any-value>? )",
  },
  "-ms-filter": {
    syntax: "<string>",
  },
  age: {
    comment: "https://www.w3.org/TR/css3-speech/#voice-family",
    syntax: "child | young | old",
  },
  "attr-name": {
    syntax: "<wq-name>",
  },
  "attr-fallback": {
    syntax: "<any-value>",
  },
  "bg-clip": {
    comment:
      "missed, https://drafts.csswg.org/css-backgrounds-4/#typedef-bg-clip",
    syntax: "<box> | border | text",
  },
  bottom: {
    comment:
      "missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect",
    syntax: "<length> | auto",
  },
  "content-list": {
    comment: "added attr(), see https://github.com/csstree/csstree/issues/201",
    syntax:
      "[ <string> | contents | <image> | <counter> | <quote> | <target> | <leader()> | <attr()> ]+",
  },
  "element()": {
    comment:
      "https://drafts.csswg.org/css-gcpm/#element-syntax & https://drafts.csswg.org/css-images-4/#element-notation",
    syntax:
      "element( <custom-ident> , [ first | start | last | first-except ]? ) | element( <id-selector> )",
  },
  "generic-voice": {
    comment: "https://www.w3.org/TR/css3-speech/#voice-family",
    syntax: "[ <age>? <gender> <integer>? ]",
  },
  gender: {
    comment: "https://www.w3.org/TR/css3-speech/#voice-family",
    syntax: "male | female | neutral",
  },
  "generic-family": {
    comment: "added -apple-system",
    references: [
      "https://webkit.org/blog/3709/using-the-system-font-in-web-content/",
    ],
    syntax: "| -apple-system",
  },
  gradient: {
    comment: "added legacy syntaxes support",
    syntax: "| <-legacy-gradient>",
  },
  left: {
    comment:
      "missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect",
    syntax: "<length> | auto",
  },
  "mask-image": {
    comment: "missed; https://drafts.fxtf.org/css-masking-1/#the-mask-image",
    syntax: "<mask-reference>#",
  },
  "named-color": {
    comment: "added non standard color names",
    syntax: "| <-non-standard-color>",
  },
  paint: {
    comment:
      "used by SVG https://www.w3.org/TR/SVG/painting.html#SpecifyingPaint",
    syntax:
      "none | <color> | <url> [ none | <color> ]? | context-fill | context-stroke",
  },
  right: {
    comment:
      "missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect",
    syntax: "<length> | auto",
  },
  shape: {
    comment:
      "missed spaces in function body and add backwards compatible syntax",
    syntax:
      "rect( <top>, <right>, <bottom>, <left> ) | rect( <top> <right> <bottom> <left> )",
  },
  "scroll-timeline-axis": {
    comment: "missed definition",
    syntax: "block | inline | vertical | horizontal",
  },
  "scroll-timeline-name": {
    comment: "missed definition",
    references: [
      "https://w3c.github.io/csswg-drafts/scroll-animations/#propdef-scroll-timeline-name",
    ],
    syntax: "none | <custom-ident>",
  },
  "single-animation-composition": {
    comment: "missed definition",
    references: [
      "https://w3c.github.io/csswg-drafts/css-animations-2/#typedef-single-animation-composition",
    ],
    syntax: "replace | add | accumulate",
  },
  "svg-length": {
    comment:
      "All coordinates and lengths in SVG can be specified with or without a unit identifier",
    references: ["https://www.w3.org/TR/SVG11/coords.html#Units"],
    syntax: "<percentage> | <length> | <number>",
  },
  "svg-writing-mode": {
    comment: "SVG specific keywords (deprecated for CSS)",
    references: [
      "https://developer.mozilla.org/en/docs/Web/CSS/writing-mode",
      "https://www.w3.org/TR/SVG/text.html#WritingModeProperty",
    ],
    syntax: "lr-tb | rl-tb | tb-rl | lr | rl | tb",
  },
  top: {
    comment:
      "missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect",
    syntax: "<length> | auto",
  },
  x: {
    comment:
      "missed; not sure we should add it, but no others except `cursor` is using it so it's ok for now; https://drafts.csswg.org/css-ui-3/#cursor",
    syntax: "<number>",
  },
  y: {
    comment:
      "missed; not sure we should add it, but no others except `cursor` is using so it's ok for now; https://drafts.csswg.org/css-ui-3/#cursor",
    syntax: "<number>",
  },
  declaration: {
    comment: "missed, restored by https://drafts.csswg.org/css-syntax",
    syntax: "<ident-token> : <declaration-value>? [ '!' important ]?",
  },
  "declaration-list": {
    comment: "missed, restored by https://drafts.csswg.org/css-syntax",
    syntax: "[ <declaration>? ';' ]* <declaration>?",
  },
  url: {
    comment: "https://drafts.csswg.org/css-values-4/#urls",
    syntax: "url( <string> <url-modifier>* ) | <url-token>",
  },
  "url-modifier": {
    comment: "https://drafts.csswg.org/css-values-4/#typedef-url-modifier",
    syntax: "<ident> | <function-token> <any-value> )",
  },
  "number-zero-one": {
    syntax: "<number [0,1]>",
  },
  "number-one-or-greater": {
    syntax: "<number [1,]>",
  },
  "-non-standard-display": {
    syntax:
      "-ms-inline-flexbox | -ms-grid | -ms-inline-grid | -webkit-flex | -webkit-inline-flex | -webkit-box | -webkit-inline-box | -moz-inline-stack | -moz-box | -moz-inline-box",
  },
};
const require$$0$4 = {
  atrules: atrules$1,
  properties: properties$2,
  types: types$1B,
};

const patch$2 = require$$0$4;

const patch$1$1 = patch$2;

var dataPatch$3 = patch$1$1;

const require$$1$1 = {
  "@charset": {
    syntax: '@charset "<charset>";',
    groups: ["CSS Charsets"],
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@charset",
  },
  "@counter-style": {
    syntax:
      "@counter-style <counter-style-name> {\n  [ system: <counter-system>; ] ||\n  [ symbols: <counter-symbols>; ] ||\n  [ additive-symbols: <additive-symbols>; ] ||\n  [ negative: <negative-symbol>; ] ||\n  [ prefix: <prefix>; ] ||\n  [ suffix: <suffix>; ] ||\n  [ range: <range>; ] ||\n  [ pad: <padding>; ] ||\n  [ speak-as: <speak-as>; ] ||\n  [ fallback: <counter-style-name>; ]\n}",
    interfaces: ["CSSCounterStyleRule"],
    groups: ["CSS Counter Styles"],
    descriptors: {
      "additive-symbols": {
        syntax: "[ <integer> && <symbol> ]#",
        media: "all",
        initial: "n/a (required)",
        percentages: "no",
        computed: "asSpecified",
        order: "orderOfAppearance",
        status: "standard",
      },
      fallback: {
        syntax: "<counter-style-name>",
        media: "all",
        initial: "decimal",
        percentages: "no",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
      },
      negative: {
        syntax: "<symbol> <symbol>?",
        media: "all",
        initial: '"-" hyphen-minus',
        percentages: "no",
        computed: "asSpecified",
        order: "orderOfAppearance",
        status: "standard",
      },
      pad: {
        syntax: "<integer> && <symbol>",
        media: "all",
        initial: '0 ""',
        percentages: "no",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
      },
      prefix: {
        syntax: "<symbol>",
        media: "all",
        initial: '""',
        percentages: "no",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
      },
      range: {
        syntax: "[ [ <integer> | infinite ]{2} ]# | auto",
        media: "all",
        initial: "auto",
        percentages: "no",
        computed: "asSpecified",
        order: "orderOfAppearance",
        status: "standard",
      },
      "speak-as": {
        syntax:
          "auto | bullets | numbers | words | spell-out | <counter-style-name>",
        media: "all",
        initial: "auto",
        percentages: "no",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
      },
      suffix: {
        syntax: "<symbol>",
        media: "all",
        initial: '". "',
        percentages: "no",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
      },
      symbols: {
        syntax: "<symbol>+",
        media: "all",
        initial: "n/a (required)",
        percentages: "no",
        computed: "asSpecified",
        order: "orderOfAppearance",
        status: "standard",
      },
      system: {
        syntax:
          "cyclic | numeric | alphabetic | symbolic | additive | [ fixed <integer>? ] | [ extends <counter-style-name> ]",
        media: "all",
        initial: "symbolic",
        percentages: "no",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
      },
    },
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@counter-style",
  },
  "@document": {
    syntax:
      "@document [ <url> | url-prefix(<string>) | domain(<string>) | media-document(<string>) | regexp(<string>) ]# {\n  <group-rule-body>\n}",
    interfaces: ["CSSGroupingRule", "CSSConditionRule"],
    groups: ["CSS Conditional Rules"],
    status: "nonstandard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@document",
  },
  "@font-face": {
    syntax:
      "@font-face {\n  [ font-family: <family-name>; ] ||\n  [ src: <src>; ] ||\n  [ unicode-range: <unicode-range>; ] ||\n  [ font-variant: <font-variant>; ] ||\n  [ font-feature-settings: <font-feature-settings>; ] ||\n  [ font-variation-settings: <font-variation-settings>; ] ||\n  [ font-stretch: <font-stretch>; ] ||\n  [ font-weight: <font-weight>; ] ||\n  [ font-style: <font-style>; ] ||\n  [ size-adjust: <size-adjust>; ] ||\n  [ ascent-override: <ascent-override>; ] ||\n  [ descent-override: <descent-override>; ] ||\n  [ line-gap-override: <line-gap-override>; ]\n}",
    interfaces: ["CSSFontFaceRule"],
    groups: ["CSS Fonts"],
    descriptors: {
      "ascent-override": {
        syntax: "normal | <percentage>",
        media: "all",
        initial: "normal",
        percentages: "asSpecified",
        computed: "asSpecified",
        order: "orderOfAppearance",
        status: "experimental",
      },
      "descent-override": {
        syntax: "normal | <percentage>",
        media: "all",
        initial: "normal",
        percentages: "asSpecified",
        computed: "asSpecified",
        order: "orderOfAppearance",
        status: "experimental",
      },
      "font-display": {
        syntax: "[ auto | block | swap | fallback | optional ]",
        media: "visual",
        percentages: "no",
        initial: "auto",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "experimental",
      },
      "font-family": {
        syntax: "<family-name>",
        media: "all",
        initial: "n/a (required)",
        percentages: "no",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
      },
      "font-feature-settings": {
        syntax: "normal | <feature-tag-value>#",
        media: "all",
        initial: "normal",
        percentages: "no",
        computed: "asSpecified",
        order: "orderOfAppearance",
        status: "standard",
      },
      "font-variation-settings": {
        syntax: "normal | [ <string> <number> ]#",
        media: "all",
        initial: "normal",
        percentages: "no",
        computed: "asSpecified",
        order: "orderOfAppearance",
        status: "standard",
      },
      "font-stretch": {
        syntax: "<font-stretch-absolute>{1,2}",
        media: "all",
        initial: "normal",
        percentages: "no",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
      },
      "font-style": {
        syntax: "normal | italic | oblique <angle>{0,2}",
        media: "all",
        initial: "normal",
        percentages: "no",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
      },
      "font-weight": {
        syntax: "<font-weight-absolute>{1,2}",
        media: "all",
        initial: "normal",
        percentages: "no",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
      },
      "font-variant": {
        syntax:
          "normal | none | [ <common-lig-values> || <discretionary-lig-values> || <historical-lig-values> || <contextual-alt-values> || stylistic(<feature-value-name>) || historical-forms || styleset(<feature-value-name>#) || character-variant(<feature-value-name>#) || swash(<feature-value-name>) || ornaments(<feature-value-name>) || annotation(<feature-value-name>) || [ small-caps | all-small-caps | petite-caps | all-petite-caps | unicase | titling-caps ] || <numeric-figure-values> || <numeric-spacing-values> || <numeric-fraction-values> || ordinal || slashed-zero || <east-asian-variant-values> || <east-asian-width-values> || ruby ]",
        media: "all",
        initial: "normal",
        percentages: "no",
        computed: "asSpecified",
        order: "orderOfAppearance",
        status: "standard",
      },
      "line-gap-override": {
        syntax: "normal | <percentage>",
        media: "all",
        initial: "normal",
        percentages: "asSpecified",
        computed: "asSpecified",
        order: "orderOfAppearance",
        status: "experimental",
      },
      "size-adjust": {
        syntax: "<percentage>",
        media: "all",
        initial: "100%",
        percentages: "asSpecified",
        computed: "asSpecified",
        order: "orderOfAppearance",
        status: "experimental",
      },
      src: {
        syntax: "[ <url> [ format( <string># ) ]? | local( <family-name> ) ]#",
        media: "all",
        initial: "n/a (required)",
        percentages: "no",
        computed: "asSpecified",
        order: "orderOfAppearance",
        status: "standard",
      },
      "unicode-range": {
        syntax: "<unicode-range>#",
        media: "all",
        initial: "U+0-10FFFF",
        percentages: "no",
        computed: "asSpecified",
        order: "orderOfAppearance",
        status: "standard",
      },
    },
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@font-face",
  },
  "@font-feature-values": {
    syntax:
      "@font-feature-values <family-name># {\n  <feature-value-block-list>\n}",
    interfaces: ["CSSFontFeatureValuesRule"],
    groups: ["CSS Fonts"],
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@font-feature-values",
  },
  "@import": {
    syntax:
      "@import [ <string> | <url> ]\n        [ layer | layer(<layer-name>) ]?\n        [ supports( [ <supports-condition> | <declaration> ] ) ]?\n        <media-query-list>? ;",
    groups: ["CSS Conditional Rules", "Media Queries"],
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@import",
  },
  "@keyframes": {
    syntax: "@keyframes <keyframes-name> {\n  <keyframe-block-list>\n}",
    interfaces: ["CSSKeyframeRule", "CSSKeyframesRule"],
    groups: ["CSS Animations"],
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@keyframes",
  },
  "@layer": {
    syntax: "@layer [ <layer-name># | <layer-name>?  {\n  <stylesheet>\n} ]",
    interfaces: ["CSSLayerBlockRule", "CSSLayerStatementRule"],
    groups: ["CSS Cascading and Inheritance"],
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@layer",
  },
  "@media": {
    syntax: "@media <media-query-list> {\n  <group-rule-body>\n}",
    interfaces: [
      "CSSGroupingRule",
      "CSSConditionRule",
      "CSSMediaRule",
      "CSSCustomMediaRule",
    ],
    groups: ["CSS Conditional Rules", "Media Queries"],
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@media",
  },
  "@namespace": {
    syntax: "@namespace <namespace-prefix>? [ <string> | <url> ];",
    groups: ["CSS Namespaces"],
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@namespace",
  },
  "@page": {
    syntax: "@page <page-selector-list> {\n  <page-body>\n}",
    interfaces: ["CSSPageRule"],
    groups: ["CSS Pages"],
    descriptors: {
      bleed: {
        syntax: "auto | <length>",
        media: ["visual", "paged"],
        initial: "auto",
        percentages: "no",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
      },
      marks: {
        syntax: "none | [ crop || cross ]",
        media: ["visual", "paged"],
        initial: "none",
        percentages: "no",
        computed: "asSpecified",
        order: "orderOfAppearance",
        status: "standard",
      },
      size: {
        syntax:
          "<length>{1,2} | auto | [ <page-size> || [ portrait | landscape ] ]",
        media: ["visual", "paged"],
        initial: "auto",
        percentages: "no",
        computed: "asSpecifiedRelativeToAbsoluteLengths",
        order: "orderOfAppearance",
        status: "standard",
      },
    },
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@page",
  },
  "@property": {
    syntax: "@property <custom-property-name> {\n  <declaration-list>\n}",
    interfaces: ["CSS", "CSSPropertyRule"],
    groups: ["CSS Houdini"],
    descriptors: {
      syntax: {
        syntax: "<string>",
        media: "all",
        percentages: "no",
        initial: "n/a (required)",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "experimental",
      },
      inherits: {
        syntax: "true | false",
        media: "all",
        percentages: "no",
        initial: "auto",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "experimental",
      },
      "initial-value": {
        syntax: "<string>",
        media: "all",
        initial: "n/a (required)",
        percentages: "no",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "experimental",
      },
    },
    status: "experimental",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@property",
  },
  "@scroll-timeline": {
    syntax: "@scroll-timeline <timeline-name> { <declaration-list> }",
    interfaces: ["ScrollTimeline"],
    groups: ["CSS Animations"],
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@scroll-timeline",
  },
  "@supports": {
    syntax: "@supports <supports-condition> {\n  <group-rule-body>\n}",
    interfaces: ["CSSGroupingRule", "CSSConditionRule", "CSSSupportsRule"],
    groups: ["CSS Conditional Rules"],
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@supports",
  },
  "@viewport": {
    syntax: "@viewport {\n  <group-rule-body>\n}",
    interfaces: ["CSSViewportRule"],
    groups: ["CSS Device Adaptation"],
    descriptors: {
      height: {
        syntax: "<viewport-length>{1,2}",
        media: ["visual", "continuous"],
        initial: ["min-height", "max-height"],
        percentages: ["min-height", "max-height"],
        computed: ["min-height", "max-height"],
        order: "orderOfAppearance",
        status: "standard",
      },
      "max-height": {
        syntax: "<viewport-length>",
        media: ["visual", "continuous"],
        initial: "auto",
        percentages: "referToHeightOfInitialViewport",
        computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
        order: "uniqueOrder",
        status: "standard",
      },
      "max-width": {
        syntax: "<viewport-length>",
        media: ["visual", "continuous"],
        initial: "auto",
        percentages: "referToWidthOfInitialViewport",
        computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
        order: "uniqueOrder",
        status: "standard",
      },
      "max-zoom": {
        syntax: "auto | <number> | <percentage>",
        media: ["visual", "continuous"],
        initial: "auto",
        percentages: "the zoom factor itself",
        computed: "autoNonNegativeOrPercentage",
        order: "uniqueOrder",
        status: "standard",
      },
      "min-height": {
        syntax: "<viewport-length>",
        media: ["visual", "continuous"],
        initial: "auto",
        percentages: "referToHeightOfInitialViewport",
        computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
        order: "uniqueOrder",
        status: "standard",
      },
      "min-width": {
        syntax: "<viewport-length>",
        media: ["visual", "continuous"],
        initial: "auto",
        percentages: "referToWidthOfInitialViewport",
        computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
        order: "uniqueOrder",
        status: "standard",
      },
      "min-zoom": {
        syntax: "auto | <number> | <percentage>",
        media: ["visual", "continuous"],
        initial: "auto",
        percentages: "the zoom factor itself",
        computed: "autoNonNegativeOrPercentage",
        order: "uniqueOrder",
        status: "standard",
      },
      orientation: {
        syntax: "auto | portrait | landscape",
        media: ["visual", "continuous"],
        initial: "auto",
        percentages: "referToSizeOfBoundingBox",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
      },
      "user-zoom": {
        syntax: "zoom | fixed",
        media: ["visual", "continuous"],
        initial: "zoom",
        percentages: "referToSizeOfBoundingBox",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
      },
      "viewport-fit": {
        syntax: "auto | contain | cover",
        media: ["visual", "continuous"],
        initial: "auto",
        percentages: "no",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
      },
      width: {
        syntax: "<viewport-length>{1,2}",
        media: ["visual", "continuous"],
        initial: ["min-width", "max-width"],
        percentages: ["min-width", "max-width"],
        computed: ["min-width", "max-width"],
        order: "orderOfAppearance",
        status: "standard",
      },
      zoom: {
        syntax: "auto | <number> | <percentage>",
        media: ["visual", "continuous"],
        initial: "auto",
        percentages: "the zoom factor itself",
        computed: "autoNonNegativeOrPercentage",
        order: "uniqueOrder",
        status: "standard",
      },
    },
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@viewport",
  },
};

const all$1 = {
  syntax: "initial | inherit | unset | revert | revert-layer",
  media: "noPracticalMedia",
  inherited: false,
  animationType: "eachOfShorthandPropertiesExceptUnicodeBiDiAndDirection",
  percentages: "no",
  groups: ["CSS Miscellaneous"],
  initial: "noPracticalInitialValue",
  appliesto: "allElements",
  computed: "asSpecifiedAppliesToEachProperty",
  order: "uniqueOrder",
  status: "standard",
  mdn_url: "https://developer.mozilla.org/docs/Web/CSS/all",
};
const animation$1 = {
  syntax: "<single-animation>#",
  media: "visual",
  inherited: false,
  animationType: "notAnimatable",
  percentages: "no",
  groups: ["CSS Animations"],
  initial: [
    "animation-name",
    "animation-duration",
    "animation-timing-function",
    "animation-delay",
    "animation-iteration-count",
    "animation-direction",
    "animation-fill-mode",
    "animation-play-state",
    "animation-timeline",
  ],
  appliesto: "allElementsAndPseudos",
  computed: [
    "animation-name",
    "animation-duration",
    "animation-timing-function",
    "animation-delay",
    "animation-direction",
    "animation-iteration-count",
    "animation-fill-mode",
    "animation-play-state",
    "animation-timeline",
  ],
  order: "orderOfAppearance",
  status: "standard",
  mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation",
};
const appearance$1 = {
  syntax: "none | auto | textfield | menulist-button | <compat-auto>",
  media: "all",
  inherited: false,
  animationType: "discrete",
  percentages: "no",
  groups: ["CSS Basic User Interface"],
  initial: "none",
  appliesto: "allElements",
  computed: "asSpecified",
  order: "perGrammar",
  status: "experimental",
  mdn_url: "https://developer.mozilla.org/docs/Web/CSS/appearance",
};
const azimuth$1 = {
  syntax:
    "<angle> | [ [ left-side | far-left | left | center-left | center | center-right | right | far-right | right-side ] || behind ] | leftwards | rightwards",
  media: "aural",
  inherited: true,
  animationType: "discrete",
  percentages: "no",
  groups: ["CSS Speech"],
  initial: "center",
  appliesto: "allElements",
  computed: "normalizedAngle",
  order: "orderOfAppearance",
  status: "obsolete",
  mdn_url: "https://developer.mozilla.org/docs/Web/CSS/azimuth",
};
const background$3 = {
  syntax: "[ <bg-layer> , ]* <final-bg-layer>",
  media: "visual",
  inherited: false,
  animationType: [
    "background-color",
    "background-image",
    "background-clip",
    "background-position",
    "background-size",
    "background-repeat",
    "background-attachment",
  ],
  percentages: ["background-position", "background-size"],
  groups: ["CSS Backgrounds and Borders"],
  initial: [
    "background-image",
    "background-position",
    "background-size",
    "background-repeat",
    "background-origin",
    "background-clip",
    "background-attachment",
    "background-color",
  ],
  appliesto: "allElements",
  computed: [
    "background-image",
    "background-position",
    "background-size",
    "background-repeat",
    "background-origin",
    "background-clip",
    "background-attachment",
    "background-color",
  ],
  order: "orderOfAppearance",
  alsoAppliesTo: ["::first-letter", "::first-line", "::placeholder"],
  status: "standard",
  mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background",
};
const border$3 = {
  syntax: "<line-width> || <line-style> || <color>",
  media: "visual",
  inherited: false,
  animationType: ["border-color", "border-style", "border-width"],
  percentages: "no",
  groups: ["CSS Backgrounds and Borders"],
  initial: ["border-width", "border-style", "border-color"],
  appliesto: "allElements",
  computed: ["border-width", "border-style", "border-color"],
  order: "orderOfAppearance",
  alsoAppliesTo: ["::first-letter"],
  status: "standard",
  mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border",
};
const bottom$1 = {
  syntax: "<length> | <percentage> | auto",
  media: "visual",
  inherited: false,
  animationType: "lpc",
  percentages: "referToContainingBlockHeight",
  groups: ["CSS Positioning"],
  initial: "auto",
  appliesto: "positionedElements",
  computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
  order: "uniqueOrder",
  status: "standard",
  mdn_url: "https://developer.mozilla.org/docs/Web/CSS/bottom",
};
const caret = {
  syntax: "<'caret-color'> || <'caret-shape'>",
  media: "interactive",
  inherited: true,
  animationType: ["caret-color", "caret-shape"],
  percentages: "no",
  groups: ["CSS Basic User Interface"],
  initial: ["caret-color", "caret-shape"],
  appliesto: "elementsThatAcceptInput",
  computed: ["caret-color", "caret-shape"],
  order: "perGrammar",
  status: "standard",
};
const clear$1 = {
  syntax: "none | left | right | both | inline-start | inline-end",
  media: "visual",
  inherited: false,
  animationType: "discrete",
  percentages: "no",
  groups: ["CSS Positioning"],
  initial: "none",
  appliesto: "blockLevelElements",
  computed: "asSpecified",
  order: "uniqueOrder",
  status: "standard",
  mdn_url: "https://developer.mozilla.org/docs/Web/CSS/clear",
};
const clip$1 = {
  syntax: "<shape> | auto",
  media: "visual",
  inherited: false,
  animationType: "rectangle",
  percentages: "no",
  groups: ["CSS Masking"],
  initial: "auto",
  appliesto: "absolutelyPositionedElements",
  computed: "autoOrRectangle",
  order: "uniqueOrder",
  status: "standard",
  mdn_url: "https://developer.mozilla.org/docs/Web/CSS/clip",
};
const color$5 = {
  syntax: "<color>",
  media: "visual",
  inherited: true,
  animationType: "byComputedValueType",
  percentages: "no",
  groups: ["CSS Color"],
  initial: "canvastext",
  appliesto: "allElementsAndText",
  computed: "computedColor",
  order: "perGrammar",
  alsoAppliesTo: ["::first-letter", "::first-line", "::placeholder"],
  status: "standard",
  mdn_url: "https://developer.mozilla.org/docs/Web/CSS/color",
};
const columns$1 = {
  syntax: "<'column-width'> || <'column-count'>",
  media: "visual",
  inherited: false,
  animationType: ["column-width", "column-count"],
  percentages: "no",
  groups: ["CSS Columns"],
  initial: ["column-width", "column-count"],
  appliesto: "blockContainersExceptTableWrappers",
  computed: ["column-width", "column-count"],
  order: "perGrammar",
  status: "standard",
  mdn_url: "https://developer.mozilla.org/docs/Web/CSS/columns",
};
const contain$1 = {
  syntax:
    "none | strict | content | [ [ size || inline-size ] || layout || style || paint ]",
  media: "all",
  inherited: false,
  animationType: "discrete",
  percentages: "no",
  groups: ["CSS Containment"],
  initial: "none",
  appliesto: "allElements",
  computed: "asSpecified",
  order: "perGrammar",
  status: "standard",
  mdn_url: "https://developer.mozilla.org/docs/Web/CSS/contain",
};
const content$1 = {
  syntax:
    "normal | none | [ <content-replacement> | <content-list> ] [/ [ <string> | <counter> ]+ ]?",
  media: "all",
  inherited: false,
  animationType: "discrete",
  percentages: "no",
  groups: ["CSS Generated Content"],
  initial: "normal",
  appliesto: "allElementsTreeAbidingPseudoElementsPageMarginBoxes",
  computed: "normalOnElementsForPseudosNoneAbsoluteURIStringOrAsSpecified",
  order: "uniqueOrder",
  status: "standard",
  mdn_url: "https://developer.mozilla.org/docs/Web/CSS/content",
};
const cursor$1 = {
  syntax:
    "[ [ <url> [ <x> <y> ]? , ]* [ auto | default | none | context-menu | help | pointer | progress | wait | cell | crosshair | text | vertical-text | alias | copy | move | no-drop | not-allowed | e-resize | n-resize | ne-resize | nw-resize | s-resize | se-resize | sw-resize | w-resize | ew-resize | ns-resize | nesw-resize | nwse-resize | col-resize | row-resize | all-scroll | zoom-in | zoom-out | grab | grabbing ] ]",
  media: ["visual", "interactive"],
  inherited: true,
  animationType: "discrete",
  percentages: "no",
  groups: ["CSS Basic User Interface"],
  initial: "auto",
  appliesto: "allElements",
  computed: "asSpecifiedURLsAbsolute",
  order: "uniqueOrder",
  status: "standard",
  mdn_url: "https://developer.mozilla.org/docs/Web/CSS/cursor",
};
const direction$1 = {
  syntax: "ltr | rtl",
  media: "visual",
  inherited: true,
  animationType: "discrete",
  percentages: "no",
  groups: ["CSS Writing Modes"],
  initial: "ltr",
  appliesto: "allElements",
  computed: "asSpecified",
  order: "uniqueOrder",
  status: "standard",
  mdn_url: "https://developer.mozilla.org/docs/Web/CSS/direction",
};
const display$1 = {
  syntax:
    "[ <display-outside> || <display-inside> ] | <display-listitem> | <display-internal> | <display-box> | <display-legacy>",
  media: "all",
  inherited: false,
  animationType: "notAnimatable",
  percentages: "no",
  groups: ["CSS Display"],
  initial: "inline",
  appliesto: "allElements",
  computed:
    "asSpecifiedExceptPositionedFloatingAndRootElementsKeywordMaybeDifferent",
  order: "uniqueOrder",
  status: "standard",
  mdn_url: "https://developer.mozilla.org/docs/Web/CSS/display",
};
const filter$1 = {
  syntax: "none | <filter-function-list>",
  media: "visual",
  inherited: false,
  animationType: "filterList",
  percentages: "no",
  groups: ["Filter Effects"],
  initial: "none",
  appliesto: "allElementsSVGContainerElements",
  computed: "asSpecified",
  order: "uniqueOrder",
  status: "standard",
  mdn_url: "https://developer.mozilla.org/docs/Web/CSS/filter",
};
const flex$1 = {
  syntax: "none | [ <'flex-grow'> <'flex-shrink'>? || <'flex-basis'> ]",
  media: "visual",
  inherited: false,
  animationType: ["flex-grow", "flex-shrink", "flex-basis"],
  percentages: "no",
  groups: ["CSS Flexible Box Layout"],
  initial: ["flex-grow", "flex-shrink", "flex-basis"],
  appliesto: "flexItemsAndInFlowPseudos",
  computed: ["flex-grow", "flex-shrink", "flex-basis"],
  order: "orderOfAppearance",
  status: "standard",
  mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex",
};
const float$1 = {
  syntax: "left | right | none | inline-start | inline-end",
  media: "visual",
  inherited: false,
  animationType: "discrete",
  percentages: "no",
  groups: ["CSS Positioning"],
  initial: "none",
  appliesto: "allElementsNoEffectIfDisplayNone",
  computed: "asSpecified",
  order: "uniqueOrder",
  status: "standard",
  mdn_url: "https://developer.mozilla.org/docs/Web/CSS/float",
};
const font$3 = {
  syntax:
    "[ [ <'font-style'> || <font-variant-css21> || <'font-weight'> || <'font-stretch'> ]? <'font-size'> [ / <'line-height'> ]? <'font-family'> ] | caption | icon | menu | message-box | small-caption | status-bar",
  media: "visual",
  inherited: true,
  animationType: [
    "font-style",
    "font-variant",
    "font-weight",
    "font-stretch",
    "font-size",
    "line-height",
    "font-family",
  ],
  percentages: ["font-size", "line-height"],
  groups: ["CSS Fonts"],
  initial: [
    "font-style",
    "font-variant",
    "font-weight",
    "font-stretch",
    "font-size",
    "line-height",
    "font-family",
  ],
  appliesto: "allElements",
  computed: [
    "font-style",
    "font-variant",
    "font-weight",
    "font-stretch",
    "font-size",
    "line-height",
    "font-family",
  ],
  order: "orderOfAppearance",
  alsoAppliesTo: ["::first-letter", "::first-line", "::placeholder"],
  status: "standard",
  mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font",
};
const gap$1 = {
  syntax: "<'row-gap'> <'column-gap'>?",
  media: "visual",
  inherited: false,
  animationType: ["row-gap", "column-gap"],
  percentages: "no",
  groups: ["CSS Box Alignment"],
  initial: ["row-gap", "column-gap"],
  appliesto: "multiColumnElementsFlexContainersGridContainers",
  computed: ["row-gap", "column-gap"],
  order: "uniqueOrder",
  status: "standard",
  mdn_url: "https://developer.mozilla.org/docs/Web/CSS/gap",
};
const grid$1 = {
  syntax:
    "<'grid-template'> | <'grid-template-rows'> / [ auto-flow && dense? ] <'grid-auto-columns'>? | [ auto-flow && dense? ] <'grid-auto-rows'>? / <'grid-template-columns'>",
  media: "visual",
  inherited: false,
  animationType: "discrete",
  percentages: [
    "grid-template-rows",
    "grid-template-columns",
    "grid-auto-rows",
    "grid-auto-columns",
  ],
  groups: ["CSS Grid Layout"],
  initial: [
    "grid-template-rows",
    "grid-template-columns",
    "grid-template-areas",
    "grid-auto-rows",
    "grid-auto-columns",
    "grid-auto-flow",
    "grid-column-gap",
    "grid-row-gap",
    "column-gap",
    "row-gap",
  ],
  appliesto: "gridContainers",
  computed: [
    "grid-template-rows",
    "grid-template-columns",
    "grid-template-areas",
    "grid-auto-rows",
    "grid-auto-columns",
    "grid-auto-flow",
    "grid-column-gap",
    "grid-row-gap",
    "column-gap",
    "row-gap",
  ],
  order: "uniqueOrder",
  status: "standard",
  mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid",
};
const height$1 = {
  syntax:
    "auto | <length> | <percentage> | min-content | max-content | fit-content | fit-content(<length-percentage>)",
  media: "visual",
  inherited: false,
  animationType: "lpc",
  percentages:
    "regardingHeightOfGeneratedBoxContainingBlockPercentagesRelativeToContainingBlock",
  groups: ["CSS Box Model"],
  initial: "auto",
  appliesto: "allElementsButNonReplacedAndTableColumns",
  computed: "percentageAutoOrAbsoluteLength",
  order: "uniqueOrder",
  status: "standard",
  mdn_url: "https://developer.mozilla.org/docs/Web/CSS/height",
};
const hyphens$1 = {
  syntax: "none | manual | auto",
  media: "visual",
  inherited: true,
  animationType: "discrete",
  percentages: "no",
  groups: ["CSS Text"],
  initial: "manual",
  appliesto: "allElements",
  computed: "asSpecified",
  order: "uniqueOrder",
  status: "standard",
  mdn_url: "https://developer.mozilla.org/docs/Web/CSS/hyphens",
};
const inset$1 = {
  syntax: "<'top'>{1,4}",
  media: "visual",
  inherited: false,
  animationType: "lpc",
  percentages: "logicalHeightOrWidthOfContainingBlock",
  groups: ["CSS Logical Properties"],
  initial: ["top", "bottom", "left", "right"],
  appliesto: "positionedElements",
  computed: ["top", "bottom", "left", "right"],
  order: "uniqueOrder",
  status: "standard",
  mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset",
};
const isolation$1 = {
  syntax: "auto | isolate",
  media: "visual",
  inherited: false,
  animationType: "discrete",
  percentages: "no",
  groups: ["Compositing and Blending"],
  initial: "auto",
  appliesto: "allElementsSVGContainerGraphicsAndGraphicsReferencingElements",
  computed: "asSpecified",
  order: "uniqueOrder",
  status: "standard",
  mdn_url: "https://developer.mozilla.org/docs/Web/CSS/isolation",
};
const left$1 = {
  syntax: "<length> | <percentage> | auto",
  media: "visual",
  inherited: false,
  animationType: "lpc",
  percentages: "referToWidthOfContainingBlock",
  groups: ["CSS Positioning"],
  initial: "auto",
  appliesto: "positionedElements",
  computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
  order: "uniqueOrder",
  status: "standard",
  mdn_url: "https://developer.mozilla.org/docs/Web/CSS/left",
};
const margin$1 = {
  syntax: "[ <length> | <percentage> | auto ]{1,4}",
  media: "visual",
  inherited: false,
  animationType: "length",
  percentages: "referToWidthOfContainingBlock",
  groups: ["CSS Box Model"],
  initial: ["margin-bottom", "margin-left", "margin-right", "margin-top"],
  appliesto: "allElementsExceptTableDisplayTypes",
  computed: ["margin-bottom", "margin-left", "margin-right", "margin-top"],
  order: "uniqueOrder",
  alsoAppliesTo: ["::first-letter", "::first-line"],
  status: "standard",
  mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin",
};
const mask$1 = {
  syntax: "<mask-layer>#",
  media: "visual",
  inherited: false,
  animationType: [
    "mask-image",
    "mask-mode",
    "mask-repeat",
    "mask-position",
    "mask-clip",
    "mask-origin",
    "mask-size",
    "mask-composite",
  ],
  percentages: ["mask-position"],
  groups: ["CSS Masking"],
  initial: [
    "mask-image",
    "mask-mode",
    "mask-repeat",
    "mask-position",
    "mask-clip",
    "mask-origin",
    "mask-size",
    "mask-composite",
  ],
  appliesto: "allElementsSVGContainerElements",
  computed: [
    "mask-image",
    "mask-mode",
    "mask-repeat",
    "mask-position",
    "mask-clip",
    "mask-origin",
    "mask-size",
    "mask-composite",
  ],
  order: "perGrammar",
  stacking: true,
  status: "standard",
  mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask",
};
const offset$1 = {
  syntax:
    "[ <'offset-position'>? [ <'offset-path'> [ <'offset-distance'> || <'offset-rotate'> ]? ]? ]! [ / <'offset-anchor'> ]?",
  media: "visual",
  inherited: false,
  animationType: [
    "offset-position",
    "offset-path",
    "offset-distance",
    "offset-anchor",
    "offset-rotate",
  ],
  percentages: ["offset-position", "offset-distance", "offset-anchor"],
  groups: ["CSS Motion Path"],
  initial: [
    "offset-position",
    "offset-path",
    "offset-distance",
    "offset-anchor",
    "offset-rotate",
  ],
  appliesto: "transformableElements",
  computed: [
    "offset-position",
    "offset-path",
    "offset-distance",
    "offset-anchor",
    "offset-rotate",
  ],
  order: "perGrammar",
  stacking: true,
  status: "standard",
  mdn_url: "https://developer.mozilla.org/docs/Web/CSS/offset",
};
const opacity$1 = {
  syntax: "<alpha-value>",
  media: "visual",
  inherited: false,
  animationType: "byComputedValueType",
  percentages: "mapToRange0To1",
  groups: ["CSS Color"],
  initial: "1",
  appliesto: "allElements",
  computed: "specifiedValueNumberClipped0To1",
  order: "perGrammar",
  alsoAppliesTo: ["::placeholder"],
  status: "standard",
  mdn_url: "https://developer.mozilla.org/docs/Web/CSS/opacity",
};
const order$1 = {
  syntax: "<integer>",
  media: "visual",
  inherited: false,
  animationType: "integer",
  percentages: "no",
  groups: ["CSS Flexible Box Layout"],
  initial: "0",
  appliesto: "flexItemsGridItemsAbsolutelyPositionedContainerChildren",
  computed: "asSpecified",
  order: "uniqueOrder",
  status: "standard",
  mdn_url: "https://developer.mozilla.org/docs/Web/CSS/order",
};
const orphans$1 = {
  syntax: "<integer>",
  media: "visual",
  inherited: true,
  animationType: "discrete",
  percentages: "no",
  groups: ["CSS Fragmentation"],
  initial: "2",
  appliesto: "blockContainerElements",
  computed: "asSpecified",
  order: "perGrammar",
  status: "standard",
  mdn_url: "https://developer.mozilla.org/docs/Web/CSS/orphans",
};
const outline$1 = {
  syntax: "[ <'outline-color'> || <'outline-style'> || <'outline-width'> ]",
  media: ["visual", "interactive"],
  inherited: false,
  animationType: ["outline-color", "outline-width", "outline-style"],
  percentages: "no",
  groups: ["CSS Basic User Interface"],
  initial: ["outline-color", "outline-style", "outline-width"],
  appliesto: "allElements",
  computed: ["outline-color", "outline-width", "outline-style"],
  order: "orderOfAppearance",
  status: "standard",
  mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline",
};
const overflow$1 = {
  syntax: "[ visible | hidden | clip | scroll | auto ]{1,2}",
  media: "visual",
  inherited: false,
  animationType: "discrete",
  percentages: "no",
  groups: ["CSS Overflow"],
  initial: "visible",
  appliesto: "blockContainersFlexContainersGridContainers",
  computed: ["overflow-x", "overflow-y"],
  order: "uniqueOrder",
  status: "standard",
  mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow",
};
const padding$1 = {
  syntax: "[ <length> | <percentage> ]{1,4}",
  media: "visual",
  inherited: false,
  animationType: "length",
  percentages: "referToWidthOfContainingBlock",
  groups: ["CSS Box Model"],
  initial: ["padding-bottom", "padding-left", "padding-right", "padding-top"],
  appliesto: "allElementsExceptInternalTableDisplayTypes",
  computed: ["padding-bottom", "padding-left", "padding-right", "padding-top"],
  order: "uniqueOrder",
  alsoAppliesTo: ["::first-letter", "::first-line"],
  status: "standard",
  mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding",
};
const perspective$1 = {
  syntax: "none | <length>",
  media: "visual",
  inherited: false,
  animationType: "length",
  percentages: "no",
  groups: ["CSS Transforms"],
  initial: "none",
  appliesto: "transformableElements",
  computed: "absoluteLengthOrNone",
  order: "uniqueOrder",
  stacking: true,
  status: "standard",
  mdn_url: "https://developer.mozilla.org/docs/Web/CSS/perspective",
};
const position$3 = {
  syntax: "static | relative | absolute | sticky | fixed",
  media: "visual",
  inherited: false,
  animationType: "discrete",
  percentages: "no",
  groups: ["CSS Positioning"],
  initial: "static",
  appliesto: "allElements",
  computed: "asSpecified",
  order: "uniqueOrder",
  stacking: true,
  status: "standard",
  mdn_url: "https://developer.mozilla.org/docs/Web/CSS/position",
};
const quotes$1 = {
  syntax: "none | auto | [ <string> <string> ]+",
  media: "visual",
  inherited: true,
  animationType: "discrete",
  percentages: "no",
  groups: ["CSS Generated Content"],
  initial: "dependsOnUserAgent",
  appliesto: "allElements",
  computed: "asSpecified",
  order: "uniqueOrder",
  status: "standard",
  mdn_url: "https://developer.mozilla.org/docs/Web/CSS/quotes",
};
const resize$1 = {
  syntax: "none | both | horizontal | vertical | block | inline",
  media: "visual",
  inherited: false,
  animationType: "discrete",
  percentages: "no",
  groups: ["CSS Basic User Interface"],
  initial: "none",
  appliesto: "elementsWithOverflowNotVisibleAndReplacedElements",
  computed: "asSpecified",
  order: "uniqueOrder",
  status: "standard",
  mdn_url: "https://developer.mozilla.org/docs/Web/CSS/resize",
};
const right$1 = {
  syntax: "<length> | <percentage> | auto",
  media: "visual",
  inherited: false,
  animationType: "lpc",
  percentages: "referToWidthOfContainingBlock",
  groups: ["CSS Positioning"],
  initial: "auto",
  appliesto: "positionedElements",
  computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
  order: "uniqueOrder",
  status: "standard",
  mdn_url: "https://developer.mozilla.org/docs/Web/CSS/right",
};
const rotate$1 = {
  syntax: "none | <angle> | [ x | y | z | <number>{3} ] && <angle>",
  media: "visual",
  inherited: false,
  animationType: "transform",
  percentages: "no",
  groups: ["CSS Transforms"],
  initial: "none",
  appliesto: "transformableElements",
  computed: "asSpecified",
  order: "perGrammar",
  stacking: true,
  status: "standard",
  mdn_url: "https://developer.mozilla.org/docs/Web/CSS/rotate",
};
const scale$1 = {
  syntax: "none | <number>{1,3}",
  media: "visual",
  inherited: false,
  animationType: "transform",
  percentages: "no",
  groups: ["CSS Transforms"],
  initial: "none",
  appliesto: "transformableElements",
  computed: "asSpecified",
  order: "perGrammar",
  stacking: true,
  status: "standard",
  mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scale",
};
const top$1 = {
  syntax: "<length> | <percentage> | auto",
  media: "visual",
  inherited: false,
  animationType: "lpc",
  percentages: "referToContainingBlockHeight",
  groups: ["CSS Positioning"],
  initial: "auto",
  appliesto: "positionedElements",
  computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
  order: "uniqueOrder",
  status: "standard",
  mdn_url: "https://developer.mozilla.org/docs/Web/CSS/top",
};
const transform$1 = {
  syntax: "none | <transform-list>",
  media: "visual",
  inherited: false,
  animationType: "transform",
  percentages: "referToSizeOfBoundingBox",
  groups: ["CSS Transforms"],
  initial: "none",
  appliesto: "transformableElements",
  computed: "asSpecifiedRelativeToAbsoluteLengths",
  order: "uniqueOrder",
  stacking: true,
  status: "standard",
  mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transform",
};
const transition$1 = {
  syntax: "<single-transition>#",
  media: "interactive",
  inherited: false,
  animationType: "discrete",
  percentages: "no",
  groups: ["CSS Transitions"],
  initial: [
    "transition-delay",
    "transition-duration",
    "transition-property",
    "transition-timing-function",
  ],
  appliesto: "allElementsAndPseudos",
  computed: [
    "transition-delay",
    "transition-duration",
    "transition-property",
    "transition-timing-function",
  ],
  order: "orderOfAppearance",
  status: "standard",
  mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition",
};
const translate$1 = {
  syntax: "none | <length-percentage> [ <length-percentage> <length>? ]?",
  media: "visual",
  inherited: false,
  animationType: "transform",
  percentages: "referToSizeOfBoundingBox",
  groups: ["CSS Transforms"],
  initial: "none",
  appliesto: "transformableElements",
  computed: "asSpecifiedRelativeToAbsoluteLengths",
  order: "perGrammar",
  stacking: true,
  status: "standard",
  mdn_url: "https://developer.mozilla.org/docs/Web/CSS/translate",
};
const visibility$1 = {
  syntax: "visible | hidden | collapse",
  media: "visual",
  inherited: true,
  animationType: "visibility",
  percentages: "no",
  groups: ["CSS Box Model"],
  initial: "visible",
  appliesto: "allElements",
  computed: "asSpecified",
  order: "uniqueOrder",
  status: "standard",
  mdn_url: "https://developer.mozilla.org/docs/Web/CSS/visibility",
};
const widows$1 = {
  syntax: "<integer>",
  media: "visual",
  inherited: true,
  animationType: "discrete",
  percentages: "no",
  groups: ["CSS Fragmentation"],
  initial: "2",
  appliesto: "blockContainerElements",
  computed: "asSpecified",
  order: "perGrammar",
  status: "standard",
  mdn_url: "https://developer.mozilla.org/docs/Web/CSS/widows",
};
const width$1 = {
  syntax:
    "auto | <length> | <percentage> | min-content | max-content | fit-content | fit-content(<length-percentage>)",
  media: "visual",
  inherited: false,
  animationType: "lpc",
  percentages: "referToWidthOfContainingBlock",
  groups: ["CSS Box Model"],
  initial: "auto",
  appliesto: "allElementsButNonReplacedAndTableRows",
  computed: "percentageAutoOrAbsoluteLength",
  order: "lengthOrPercentageBeforeKeywordIfBothPresent",
  status: "standard",
  mdn_url: "https://developer.mozilla.org/docs/Web/CSS/width",
};
const zoom$1 = {
  syntax: "normal | reset | <number> | <percentage>",
  media: "visual",
  inherited: false,
  animationType: "integer",
  percentages: "no",
  groups: ["Microsoft Extensions"],
  initial: "normal",
  appliesto: "allElements",
  computed: "asSpecified",
  order: "uniqueOrder",
  status: "nonstandard",
  mdn_url: "https://developer.mozilla.org/docs/Web/CSS/zoom",
};
const require$$2$1 = {
  "--*": {
    syntax: "<declaration-value>",
    media: "all",
    inherited: true,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Variables"],
    initial: "seeProse",
    appliesto: "allElements",
    computed: "asSpecifiedWithVarsSubstituted",
    order: "perGrammar",
    status: "experimental",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/--*",
  },
  "-ms-accelerator": {
    syntax: "false | true",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["Microsoft Extensions"],
    initial: "false",
    appliesto: "allElements",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "nonstandard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-accelerator",
  },
  "-ms-block-progression": {
    syntax: "tb | rl | bt | lr",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["Microsoft Extensions"],
    initial: "tb",
    appliesto: "allElements",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "nonstandard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-block-progression",
  },
  "-ms-content-zoom-chaining": {
    syntax: "none | chained",
    media: "interactive",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["Microsoft Extensions"],
    initial: "none",
    appliesto: "nonReplacedBlockAndInlineBlockElements",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "nonstandard",
    mdn_url:
      "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-chaining",
  },
  "-ms-content-zooming": {
    syntax: "none | zoom",
    media: "interactive",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["Microsoft Extensions"],
    initial: "zoomForTheTopLevelNoneForTheRest",
    appliesto: "nonReplacedBlockAndInlineBlockElements",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "nonstandard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zooming",
  },
  "-ms-content-zoom-limit": {
    syntax: "<'-ms-content-zoom-limit-min'> <'-ms-content-zoom-limit-max'>",
    media: "interactive",
    inherited: false,
    animationType: "discrete",
    percentages: ["-ms-content-zoom-limit-max", "-ms-content-zoom-limit-min"],
    groups: ["Microsoft Extensions"],
    initial: ["-ms-content-zoom-limit-max", "-ms-content-zoom-limit-min"],
    appliesto: "nonReplacedBlockAndInlineBlockElements",
    computed: ["-ms-content-zoom-limit-max", "-ms-content-zoom-limit-min"],
    order: "uniqueOrder",
    status: "nonstandard",
    mdn_url:
      "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-limit",
  },
  "-ms-content-zoom-limit-max": {
    syntax: "<percentage>",
    media: "interactive",
    inherited: false,
    animationType: "discrete",
    percentages: "maxZoomFactor",
    groups: ["Microsoft Extensions"],
    initial: "400%",
    appliesto: "nonReplacedBlockAndInlineBlockElements",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "nonstandard",
    mdn_url:
      "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-limit-max",
  },
  "-ms-content-zoom-limit-min": {
    syntax: "<percentage>",
    media: "interactive",
    inherited: false,
    animationType: "discrete",
    percentages: "minZoomFactor",
    groups: ["Microsoft Extensions"],
    initial: "100%",
    appliesto: "nonReplacedBlockAndInlineBlockElements",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "nonstandard",
    mdn_url:
      "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-limit-min",
  },
  "-ms-content-zoom-snap": {
    syntax:
      "<'-ms-content-zoom-snap-type'> || <'-ms-content-zoom-snap-points'>",
    media: "interactive",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["Microsoft Extensions"],
    initial: ["-ms-content-zoom-snap-type", "-ms-content-zoom-snap-points"],
    appliesto: "nonReplacedBlockAndInlineBlockElements",
    computed: ["-ms-content-zoom-snap-type", "-ms-content-zoom-snap-points"],
    order: "uniqueOrder",
    status: "nonstandard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-snap",
  },
  "-ms-content-zoom-snap-points": {
    syntax:
      "snapInterval( <percentage>, <percentage> ) | snapList( <percentage># )",
    media: "interactive",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["Microsoft Extensions"],
    initial: "snapInterval(0%, 100%)",
    appliesto: "nonReplacedBlockAndInlineBlockElements",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "nonstandard",
    mdn_url:
      "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-snap-points",
  },
  "-ms-content-zoom-snap-type": {
    syntax: "none | proximity | mandatory",
    media: "interactive",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["Microsoft Extensions"],
    initial: "none",
    appliesto: "nonReplacedBlockAndInlineBlockElements",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "nonstandard",
    mdn_url:
      "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-snap-type",
  },
  "-ms-filter": {
    syntax: "<string>",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["Microsoft Extensions"],
    initial: '""',
    appliesto: "allElements",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "nonstandard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-filter",
  },
  "-ms-flow-from": {
    syntax: "[ none | <custom-ident> ]#",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["Microsoft Extensions"],
    initial: "none",
    appliesto: "nonReplacedElements",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "nonstandard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-flow-from",
  },
  "-ms-flow-into": {
    syntax: "[ none | <custom-ident> ]#",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["Microsoft Extensions"],
    initial: "none",
    appliesto: "iframeElements",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "nonstandard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-flow-into",
  },
  "-ms-grid-columns": {
    syntax: "none | <track-list> | <auto-track-list>",
    media: "visual",
    inherited: false,
    animationType: "simpleListOfLpcDifferenceLpc",
    percentages: "referToDimensionOfContentArea",
    groups: ["CSS Grid Layout"],
    initial: "none",
    appliesto: "gridContainers",
    computed: "asSpecifiedRelativeToAbsoluteLengths",
    order: "uniqueOrder",
    status: "nonstandard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-grid-columns",
  },
  "-ms-grid-rows": {
    syntax: "none | <track-list> | <auto-track-list>",
    media: "visual",
    inherited: false,
    animationType: "simpleListOfLpcDifferenceLpc",
    percentages: "referToDimensionOfContentArea",
    groups: ["CSS Grid Layout"],
    initial: "none",
    appliesto: "gridContainers",
    computed: "asSpecifiedRelativeToAbsoluteLengths",
    order: "uniqueOrder",
    status: "nonstandard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-grid-rows",
  },
  "-ms-high-contrast-adjust": {
    syntax: "auto | none",
    media: "visual",
    inherited: true,
    animationType: "discrete",
    percentages: "no",
    groups: ["Microsoft Extensions"],
    initial: "auto",
    appliesto: "allElements",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "nonstandard",
    mdn_url:
      "https://developer.mozilla.org/docs/Web/CSS/-ms-high-contrast-adjust",
  },
  "-ms-hyphenate-limit-chars": {
    syntax: "auto | <integer>{1,3}",
    media: "visual",
    inherited: true,
    animationType: "discrete",
    percentages: "no",
    groups: ["Microsoft Extensions"],
    initial: "auto",
    appliesto: "allElements",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "nonstandard",
    mdn_url:
      "https://developer.mozilla.org/docs/Web/CSS/-ms-hyphenate-limit-chars",
  },
  "-ms-hyphenate-limit-lines": {
    syntax: "no-limit | <integer>",
    media: "visual",
    inherited: true,
    animationType: "discrete",
    percentages: "no",
    groups: ["Microsoft Extensions"],
    initial: "no-limit",
    appliesto: "blockContainerElements",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "nonstandard",
    mdn_url:
      "https://developer.mozilla.org/docs/Web/CSS/-ms-hyphenate-limit-lines",
  },
  "-ms-hyphenate-limit-zone": {
    syntax: "<percentage> | <length>",
    media: "visual",
    inherited: true,
    animationType: "discrete",
    percentages: "referToLineBoxWidth",
    groups: ["Microsoft Extensions"],
    initial: "0",
    appliesto: "blockContainerElements",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "nonstandard",
    mdn_url:
      "https://developer.mozilla.org/docs/Web/CSS/-ms-hyphenate-limit-zone",
  },
  "-ms-ime-align": {
    syntax: "auto | after",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["Microsoft Extensions"],
    initial: "auto",
    appliesto: "allElements",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "nonstandard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-ime-align",
  },
  "-ms-overflow-style": {
    syntax: "auto | none | scrollbar | -ms-autohiding-scrollbar",
    media: "interactive",
    inherited: true,
    animationType: "discrete",
    percentages: "no",
    groups: ["Microsoft Extensions"],
    initial: "auto",
    appliesto: "nonReplacedBlockAndInlineBlockElements",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "nonstandard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-overflow-style",
  },
  "-ms-scrollbar-3dlight-color": {
    syntax: "<color>",
    media: "visual",
    inherited: true,
    animationType: "discrete",
    percentages: "no",
    groups: ["Microsoft Extensions"],
    initial: "dependsOnUserAgent",
    appliesto: "allElements",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "nonstandard",
    mdn_url:
      "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-3dlight-color",
  },
  "-ms-scrollbar-arrow-color": {
    syntax: "<color>",
    media: "visual",
    inherited: true,
    animationType: "discrete",
    percentages: "no",
    groups: ["Microsoft Extensions"],
    initial: "ButtonText",
    appliesto: "allElements",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "nonstandard",
    mdn_url:
      "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-arrow-color",
  },
  "-ms-scrollbar-base-color": {
    syntax: "<color>",
    media: "visual",
    inherited: true,
    animationType: "discrete",
    percentages: "no",
    groups: ["Microsoft Extensions"],
    initial: "dependsOnUserAgent",
    appliesto: "allElements",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "nonstandard",
    mdn_url:
      "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-base-color",
  },
  "-ms-scrollbar-darkshadow-color": {
    syntax: "<color>",
    media: "visual",
    inherited: true,
    animationType: "discrete",
    percentages: "no",
    groups: ["Microsoft Extensions"],
    initial: "ThreeDDarkShadow",
    appliesto: "allElements",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "nonstandard",
    mdn_url:
      "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-darkshadow-color",
  },
  "-ms-scrollbar-face-color": {
    syntax: "<color>",
    media: "visual",
    inherited: true,
    animationType: "discrete",
    percentages: "no",
    groups: ["Microsoft Extensions"],
    initial: "ThreeDFace",
    appliesto: "allElements",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "nonstandard",
    mdn_url:
      "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-face-color",
  },
  "-ms-scrollbar-highlight-color": {
    syntax: "<color>",
    media: "visual",
    inherited: true,
    animationType: "discrete",
    percentages: "no",
    groups: ["Microsoft Extensions"],
    initial: "ThreeDHighlight",
    appliesto: "allElements",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "nonstandard",
    mdn_url:
      "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-highlight-color",
  },
  "-ms-scrollbar-shadow-color": {
    syntax: "<color>",
    media: "visual",
    inherited: true,
    animationType: "discrete",
    percentages: "no",
    groups: ["Microsoft Extensions"],
    initial: "ThreeDDarkShadow",
    appliesto: "allElements",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "nonstandard",
    mdn_url:
      "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-shadow-color",
  },
  "-ms-scrollbar-track-color": {
    syntax: "<color>",
    media: "visual",
    inherited: true,
    animationType: "discrete",
    percentages: "no",
    groups: ["Microsoft Extensions"],
    initial: "Scrollbar",
    appliesto: "allElements",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "nonstandard",
    mdn_url:
      "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-track-color",
  },
  "-ms-scroll-chaining": {
    syntax: "chained | none",
    media: "interactive",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["Microsoft Extensions"],
    initial: "chained",
    appliesto: "nonReplacedBlockAndInlineBlockElements",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "nonstandard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-chaining",
  },
  "-ms-scroll-limit": {
    syntax:
      "<'-ms-scroll-limit-x-min'> <'-ms-scroll-limit-y-min'> <'-ms-scroll-limit-x-max'> <'-ms-scroll-limit-y-max'>",
    media: "interactive",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["Microsoft Extensions"],
    initial: [
      "-ms-scroll-limit-x-min",
      "-ms-scroll-limit-y-min",
      "-ms-scroll-limit-x-max",
      "-ms-scroll-limit-y-max",
    ],
    appliesto: "nonReplacedBlockAndInlineBlockElements",
    computed: [
      "-ms-scroll-limit-x-min",
      "-ms-scroll-limit-y-min",
      "-ms-scroll-limit-x-max",
      "-ms-scroll-limit-y-max",
    ],
    order: "uniqueOrder",
    status: "nonstandard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit",
  },
  "-ms-scroll-limit-x-max": {
    syntax: "auto | <length>",
    media: "interactive",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["Microsoft Extensions"],
    initial: "auto",
    appliesto: "nonReplacedBlockAndInlineBlockElements",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "nonstandard",
    mdn_url:
      "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit-x-max",
  },
  "-ms-scroll-limit-x-min": {
    syntax: "<length>",
    media: "interactive",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["Microsoft Extensions"],
    initial: "0",
    appliesto: "nonReplacedBlockAndInlineBlockElements",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "nonstandard",
    mdn_url:
      "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit-x-min",
  },
  "-ms-scroll-limit-y-max": {
    syntax: "auto | <length>",
    media: "interactive",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["Microsoft Extensions"],
    initial: "auto",
    appliesto: "nonReplacedBlockAndInlineBlockElements",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "nonstandard",
    mdn_url:
      "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit-y-max",
  },
  "-ms-scroll-limit-y-min": {
    syntax: "<length>",
    media: "interactive",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["Microsoft Extensions"],
    initial: "0",
    appliesto: "nonReplacedBlockAndInlineBlockElements",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "nonstandard",
    mdn_url:
      "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit-y-min",
  },
  "-ms-scroll-rails": {
    syntax: "none | railed",
    media: "interactive",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["Microsoft Extensions"],
    initial: "railed",
    appliesto: "nonReplacedBlockAndInlineBlockElements",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "nonstandard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-rails",
  },
  "-ms-scroll-snap-points-x": {
    syntax:
      "snapInterval( <length-percentage>, <length-percentage> ) | snapList( <length-percentage># )",
    media: "interactive",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["Microsoft Extensions"],
    initial: "snapInterval(0px, 100%)",
    appliesto: "nonReplacedBlockAndInlineBlockElements",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "nonstandard",
    mdn_url:
      "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-points-x",
  },
  "-ms-scroll-snap-points-y": {
    syntax:
      "snapInterval( <length-percentage>, <length-percentage> ) | snapList( <length-percentage># )",
    media: "interactive",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["Microsoft Extensions"],
    initial: "snapInterval(0px, 100%)",
    appliesto: "nonReplacedBlockAndInlineBlockElements",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "nonstandard",
    mdn_url:
      "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-points-y",
  },
  "-ms-scroll-snap-type": {
    syntax: "none | proximity | mandatory",
    media: "interactive",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["Microsoft Extensions"],
    initial: "none",
    appliesto: "nonReplacedBlockAndInlineBlockElements",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "nonstandard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-type",
  },
  "-ms-scroll-snap-x": {
    syntax: "<'-ms-scroll-snap-type'> <'-ms-scroll-snap-points-x'>",
    media: "interactive",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["Microsoft Extensions"],
    initial: ["-ms-scroll-snap-type", "-ms-scroll-snap-points-x"],
    appliesto: "nonReplacedBlockAndInlineBlockElements",
    computed: ["-ms-scroll-snap-type", "-ms-scroll-snap-points-x"],
    order: "uniqueOrder",
    status: "nonstandard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-x",
  },
  "-ms-scroll-snap-y": {
    syntax: "<'-ms-scroll-snap-type'> <'-ms-scroll-snap-points-y'>",
    media: "interactive",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["Microsoft Extensions"],
    initial: ["-ms-scroll-snap-type", "-ms-scroll-snap-points-y"],
    appliesto: "nonReplacedBlockAndInlineBlockElements",
    computed: ["-ms-scroll-snap-type", "-ms-scroll-snap-points-y"],
    order: "uniqueOrder",
    status: "nonstandard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-y",
  },
  "-ms-scroll-translation": {
    syntax: "none | vertical-to-horizontal",
    media: "interactive",
    inherited: true,
    animationType: "discrete",
    percentages: "no",
    groups: ["Microsoft Extensions"],
    initial: "none",
    appliesto: "allElements",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "nonstandard",
    mdn_url:
      "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-translation",
  },
  "-ms-text-autospace": {
    syntax:
      "none | ideograph-alpha | ideograph-numeric | ideograph-parenthesis | ideograph-space",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["Microsoft Extensions"],
    initial: "none",
    appliesto: "allElements",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "nonstandard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-text-autospace",
  },
  "-ms-touch-select": {
    syntax: "grippers | none",
    media: "interactive",
    inherited: true,
    animationType: "discrete",
    percentages: "no",
    groups: ["Microsoft Extensions"],
    initial: "grippers",
    appliesto: "allElements",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "nonstandard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-touch-select",
  },
  "-ms-user-select": {
    syntax: "none | element | text",
    media: "interactive",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["Microsoft Extensions"],
    initial: "text",
    appliesto: "nonReplacedElements",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "nonstandard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-user-select",
  },
  "-ms-wrap-flow": {
    syntax: "auto | both | start | end | maximum | clear",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["Microsoft Extensions"],
    initial: "auto",
    appliesto: "blockLevelElements",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "nonstandard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-wrap-flow",
  },
  "-ms-wrap-margin": {
    syntax: "<length>",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["Microsoft Extensions"],
    initial: "0",
    appliesto: "exclusionElements",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "nonstandard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-wrap-margin",
  },
  "-ms-wrap-through": {
    syntax: "wrap | none",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["Microsoft Extensions"],
    initial: "wrap",
    appliesto: "blockLevelElements",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "nonstandard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-wrap-through",
  },
  "-moz-appearance": {
    syntax:
      "none | button | button-arrow-down | button-arrow-next | button-arrow-previous | button-arrow-up | button-bevel | button-focus | caret | checkbox | checkbox-container | checkbox-label | checkmenuitem | dualbutton | groupbox | listbox | listitem | menuarrow | menubar | menucheckbox | menuimage | menuitem | menuitemtext | menulist | menulist-button | menulist-text | menulist-textfield | menupopup | menuradio | menuseparator | meterbar | meterchunk | progressbar | progressbar-vertical | progresschunk | progresschunk-vertical | radio | radio-container | radio-label | radiomenuitem | range | range-thumb | resizer | resizerpanel | scale-horizontal | scalethumbend | scalethumb-horizontal | scalethumbstart | scalethumbtick | scalethumb-vertical | scale-vertical | scrollbarbutton-down | scrollbarbutton-left | scrollbarbutton-right | scrollbarbutton-up | scrollbarthumb-horizontal | scrollbarthumb-vertical | scrollbartrack-horizontal | scrollbartrack-vertical | searchfield | separator | sheet | spinner | spinner-downbutton | spinner-textfield | spinner-upbutton | splitter | statusbar | statusbarpanel | tab | tabpanel | tabpanels | tab-scroll-arrow-back | tab-scroll-arrow-forward | textfield | textfield-multiline | toolbar | toolbarbutton | toolbarbutton-dropdown | toolbargripper | toolbox | tooltip | treeheader | treeheadercell | treeheadersortarrow | treeitem | treeline | treetwisty | treetwistyopen | treeview | -moz-mac-unified-toolbar | -moz-win-borderless-glass | -moz-win-browsertabbar-toolbox | -moz-win-communicationstext | -moz-win-communications-toolbox | -moz-win-exclude-glass | -moz-win-glass | -moz-win-mediatext | -moz-win-media-toolbox | -moz-window-button-box | -moz-window-button-box-maximized | -moz-window-button-close | -moz-window-button-maximize | -moz-window-button-minimize | -moz-window-button-restore | -moz-window-frame-bottom | -moz-window-frame-left | -moz-window-frame-right | -moz-window-titlebar | -moz-window-titlebar-maximized",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["Mozilla Extensions", "WebKit Extensions"],
    initial: "noneButOverriddenInUserAgentCSS",
    appliesto: "allElements",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "nonstandard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/appearance",
  },
  "-moz-binding": {
    syntax: "<url> | none",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["Mozilla Extensions"],
    initial: "none",
    appliesto: "allElementsExceptGeneratedContentOrPseudoElements",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "nonstandard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-binding",
  },
  "-moz-border-bottom-colors": {
    syntax: "<color>+ | none",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["Mozilla Extensions"],
    initial: "none",
    appliesto: "allElements",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "nonstandard",
    mdn_url:
      "https://developer.mozilla.org/docs/Web/CSS/-moz-border-bottom-colors",
  },
  "-moz-border-left-colors": {
    syntax: "<color>+ | none",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["Mozilla Extensions"],
    initial: "none",
    appliesto: "allElements",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "nonstandard",
    mdn_url:
      "https://developer.mozilla.org/docs/Web/CSS/-moz-border-left-colors",
  },
  "-moz-border-right-colors": {
    syntax: "<color>+ | none",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["Mozilla Extensions"],
    initial: "none",
    appliesto: "allElements",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "nonstandard",
    mdn_url:
      "https://developer.mozilla.org/docs/Web/CSS/-moz-border-right-colors",
  },
  "-moz-border-top-colors": {
    syntax: "<color>+ | none",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["Mozilla Extensions"],
    initial: "none",
    appliesto: "allElements",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "nonstandard",
    mdn_url:
      "https://developer.mozilla.org/docs/Web/CSS/-moz-border-top-colors",
  },
  "-moz-context-properties": {
    syntax: "none | [ fill | fill-opacity | stroke | stroke-opacity ]#",
    media: "visual",
    inherited: true,
    animationType: "discrete",
    percentages: "no",
    groups: ["Mozilla Extensions"],
    initial: "none",
    appliesto: "allElementsThatCanReferenceImages",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "nonstandard",
    mdn_url:
      "https://developer.mozilla.org/docs/Web/CSS/-moz-context-properties",
  },
  "-moz-float-edge": {
    syntax: "border-box | content-box | margin-box | padding-box",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["Mozilla Extensions"],
    initial: "content-box",
    appliesto: "allElements",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "nonstandard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-float-edge",
  },
  "-moz-force-broken-image-icon": {
    syntax: "0 | 1",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["Mozilla Extensions"],
    initial: "0",
    appliesto: "images",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "nonstandard",
    mdn_url:
      "https://developer.mozilla.org/docs/Web/CSS/-moz-force-broken-image-icon",
  },
  "-moz-image-region": {
    syntax: "<shape> | auto",
    media: "visual",
    inherited: true,
    animationType: "discrete",
    percentages: "no",
    groups: ["Mozilla Extensions"],
    initial: "auto",
    appliesto: "xulImageElements",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "nonstandard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-image-region",
  },
  "-moz-orient": {
    syntax: "inline | block | horizontal | vertical",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["Mozilla Extensions"],
    initial: "inline",
    appliesto: "anyElementEffectOnProgressAndMeter",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "nonstandard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-orient",
  },
  "-moz-outline-radius": {
    syntax: "<outline-radius>{1,4} [ / <outline-radius>{1,4} ]?",
    media: "visual",
    inherited: false,
    animationType: [
      "-moz-outline-radius-topleft",
      "-moz-outline-radius-topright",
      "-moz-outline-radius-bottomright",
      "-moz-outline-radius-bottomleft",
    ],
    percentages: [
      "-moz-outline-radius-topleft",
      "-moz-outline-radius-topright",
      "-moz-outline-radius-bottomright",
      "-moz-outline-radius-bottomleft",
    ],
    groups: ["Mozilla Extensions"],
    initial: [
      "-moz-outline-radius-topleft",
      "-moz-outline-radius-topright",
      "-moz-outline-radius-bottomright",
      "-moz-outline-radius-bottomleft",
    ],
    appliesto: "allElements",
    computed: [
      "-moz-outline-radius-topleft",
      "-moz-outline-radius-topright",
      "-moz-outline-radius-bottomright",
      "-moz-outline-radius-bottomleft",
    ],
    order: "uniqueOrder",
    status: "nonstandard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius",
  },
  "-moz-outline-radius-bottomleft": {
    syntax: "<outline-radius>",
    media: "visual",
    inherited: false,
    animationType: "lpc",
    percentages: "referToDimensionOfBorderBox",
    groups: ["Mozilla Extensions"],
    initial: "0",
    appliesto: "allElements",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "nonstandard",
    mdn_url:
      "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius-bottomleft",
  },
  "-moz-outline-radius-bottomright": {
    syntax: "<outline-radius>",
    media: "visual",
    inherited: false,
    animationType: "lpc",
    percentages: "referToDimensionOfBorderBox",
    groups: ["Mozilla Extensions"],
    initial: "0",
    appliesto: "allElements",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "nonstandard",
    mdn_url:
      "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius-bottomright",
  },
  "-moz-outline-radius-topleft": {
    syntax: "<outline-radius>",
    media: "visual",
    inherited: false,
    animationType: "lpc",
    percentages: "referToDimensionOfBorderBox",
    groups: ["Mozilla Extensions"],
    initial: "0",
    appliesto: "allElements",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "nonstandard",
    mdn_url:
      "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius-topleft",
  },
  "-moz-outline-radius-topright": {
    syntax: "<outline-radius>",
    media: "visual",
    inherited: false,
    animationType: "lpc",
    percentages: "referToDimensionOfBorderBox",
    groups: ["Mozilla Extensions"],
    initial: "0",
    appliesto: "allElements",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "nonstandard",
    mdn_url:
      "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius-topright",
  },
  "-moz-stack-sizing": {
    syntax: "ignore | stretch-to-fit",
    media: "visual",
    inherited: true,
    animationType: "discrete",
    percentages: "no",
    groups: ["Mozilla Extensions"],
    initial: "stretch-to-fit",
    appliesto: "allElements",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "nonstandard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-stack-sizing",
  },
  "-moz-text-blink": {
    syntax: "none | blink",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["Mozilla Extensions"],
    initial: "none",
    appliesto: "allElements",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "nonstandard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-text-blink",
  },
  "-moz-user-focus": {
    syntax:
      "ignore | normal | select-after | select-before | select-menu | select-same | select-all | none",
    media: "interactive",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["Mozilla Extensions"],
    initial: "none",
    appliesto: "allElements",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "nonstandard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-user-focus",
  },
  "-moz-user-input": {
    syntax: "auto | none | enabled | disabled",
    media: "visual",
    inherited: true,
    animationType: "discrete",
    percentages: "no",
    groups: ["Mozilla Extensions"],
    initial: "auto",
    appliesto: "allElements",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "nonstandard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-user-input",
  },
  "-moz-user-modify": {
    syntax: "read-only | read-write | write-only",
    media: "interactive",
    inherited: true,
    animationType: "discrete",
    percentages: "no",
    groups: ["Mozilla Extensions"],
    initial: "read-only",
    appliesto: "allElements",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "nonstandard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-user-modify",
  },
  "-moz-window-dragging": {
    syntax: "drag | no-drag",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["Mozilla Extensions"],
    initial: "drag",
    appliesto: "allElementsCreatingNativeWindows",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "nonstandard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-window-dragging",
  },
  "-moz-window-shadow": {
    syntax: "default | menu | tooltip | sheet | none",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["Mozilla Extensions"],
    initial: "default",
    appliesto: "allElementsCreatingNativeWindows",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "nonstandard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-window-shadow",
  },
  "-webkit-appearance": {
    syntax:
      "none | button | button-bevel | caret | checkbox | default-button | inner-spin-button | listbox | listitem | media-controls-background | media-controls-fullscreen-background | media-current-time-display | media-enter-fullscreen-button | media-exit-fullscreen-button | media-fullscreen-button | media-mute-button | media-overlay-play-button | media-play-button | media-seek-back-button | media-seek-forward-button | media-slider | media-sliderthumb | media-time-remaining-display | media-toggle-closed-captions-button | media-volume-slider | media-volume-slider-container | media-volume-sliderthumb | menulist | menulist-button | menulist-text | menulist-textfield | meter | progress-bar | progress-bar-value | push-button | radio | searchfield | searchfield-cancel-button | searchfield-decoration | searchfield-results-button | searchfield-results-decoration | slider-horizontal | slider-vertical | sliderthumb-horizontal | sliderthumb-vertical | square-button | textarea | textfield | -apple-pay-button",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["WebKit Extensions"],
    initial: "noneButOverriddenInUserAgentCSS",
    appliesto: "allElements",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "nonstandard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/appearance",
  },
  "-webkit-border-before": {
    syntax: "<'border-width'> || <'border-style'> || <color>",
    media: "visual",
    inherited: true,
    animationType: "discrete",
    percentages: ["-webkit-border-before-width"],
    groups: ["WebKit Extensions"],
    initial: ["border-width", "border-style", "color"],
    appliesto: "allElements",
    computed: ["border-width", "border-style", "color"],
    order: "uniqueOrder",
    status: "nonstandard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-border-before",
  },
  "-webkit-border-before-color": {
    syntax: "<color>",
    media: "visual",
    inherited: true,
    animationType: "discrete",
    percentages: "no",
    groups: ["WebKit Extensions"],
    initial: "currentcolor",
    appliesto: "allElements",
    computed: "computedColor",
    order: "uniqueOrder",
    status: "nonstandard",
  },
  "-webkit-border-before-style": {
    syntax: "<'border-style'>",
    media: "visual",
    inherited: true,
    animationType: "discrete",
    percentages: "no",
    groups: ["WebKit Extensions"],
    initial: "none",
    appliesto: "allElements",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "nonstandard",
  },
  "-webkit-border-before-width": {
    syntax: "<'border-width'>",
    media: "visual",
    inherited: true,
    animationType: "discrete",
    percentages: "logicalWidthOfContainingBlock",
    groups: ["WebKit Extensions"],
    initial: "medium",
    appliesto: "allElements",
    computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
    order: "uniqueOrder",
    status: "nonstandard",
  },
  "-webkit-box-reflect": {
    syntax: "[ above | below | right | left ]? <length>? <image>?",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["WebKit Extensions"],
    initial: "none",
    appliesto: "allElements",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "nonstandard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-box-reflect",
  },
  "-webkit-line-clamp": {
    syntax: "none | <integer>",
    media: "visual",
    inherited: false,
    animationType: "byComputedValueType",
    percentages: "no",
    groups: ["WebKit Extensions", "CSS Overflow"],
    initial: "none",
    appliesto: "allElements",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-line-clamp",
  },
  "-webkit-mask": {
    syntax:
      "[ <mask-reference> || <position> [ / <bg-size> ]? || <repeat-style> || [ <box> | border | padding | content | text ] || [ <box> | border | padding | content ] ]#",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["WebKit Extensions"],
    initial: [
      "-webkit-mask-image",
      "-webkit-mask-repeat",
      "-webkit-mask-attachment",
      "-webkit-mask-position",
      "-webkit-mask-origin",
      "-webkit-mask-clip",
    ],
    appliesto: "allElements",
    computed: [
      "-webkit-mask-image",
      "-webkit-mask-repeat",
      "-webkit-mask-attachment",
      "-webkit-mask-position",
      "-webkit-mask-origin",
      "-webkit-mask-clip",
    ],
    order: "uniqueOrder",
    status: "nonstandard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask",
  },
  "-webkit-mask-attachment": {
    syntax: "<attachment>#",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["WebKit Extensions"],
    initial: "scroll",
    appliesto: "allElements",
    computed: "asSpecified",
    order: "orderOfAppearance",
    status: "nonstandard",
    mdn_url:
      "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-attachment",
  },
  "-webkit-mask-clip": {
    syntax: "[ <box> | border | padding | content | text ]#",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["WebKit Extensions"],
    initial: "border",
    appliesto: "allElements",
    computed: "asSpecified",
    order: "orderOfAppearance",
    status: "nonstandard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-clip",
  },
  "-webkit-mask-composite": {
    syntax: "<composite-style>#",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["WebKit Extensions"],
    initial: "source-over",
    appliesto: "allElements",
    computed: "asSpecified",
    order: "orderOfAppearance",
    status: "nonstandard",
    mdn_url:
      "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-composite",
  },
  "-webkit-mask-image": {
    syntax: "<mask-reference>#",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["WebKit Extensions"],
    initial: "none",
    appliesto: "allElements",
    computed: "absoluteURIOrNone",
    order: "orderOfAppearance",
    status: "nonstandard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-image",
  },
  "-webkit-mask-origin": {
    syntax: "[ <box> | border | padding | content ]#",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["WebKit Extensions"],
    initial: "padding",
    appliesto: "allElements",
    computed: "asSpecified",
    order: "orderOfAppearance",
    status: "nonstandard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-origin",
  },
  "-webkit-mask-position": {
    syntax: "<position>#",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "referToSizeOfElement",
    groups: ["WebKit Extensions"],
    initial: "0% 0%",
    appliesto: "allElements",
    computed: "absoluteLengthOrPercentage",
    order: "orderOfAppearance",
    status: "nonstandard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-position",
  },
  "-webkit-mask-position-x": {
    syntax: "[ <length-percentage> | left | center | right ]#",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "referToSizeOfElement",
    groups: ["WebKit Extensions"],
    initial: "0%",
    appliesto: "allElements",
    computed: "absoluteLengthOrPercentage",
    order: "orderOfAppearance",
    status: "nonstandard",
    mdn_url:
      "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-position-x",
  },
  "-webkit-mask-position-y": {
    syntax: "[ <length-percentage> | top | center | bottom ]#",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "referToSizeOfElement",
    groups: ["WebKit Extensions"],
    initial: "0%",
    appliesto: "allElements",
    computed: "absoluteLengthOrPercentage",
    order: "orderOfAppearance",
    status: "nonstandard",
    mdn_url:
      "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-position-y",
  },
  "-webkit-mask-repeat": {
    syntax: "<repeat-style>#",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["WebKit Extensions"],
    initial: "repeat",
    appliesto: "allElements",
    computed: "asSpecified",
    order: "orderOfAppearance",
    status: "nonstandard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-repeat",
  },
  "-webkit-mask-repeat-x": {
    syntax: "repeat | no-repeat | space | round",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["WebKit Extensions"],
    initial: "repeat",
    appliesto: "allElements",
    computed: "asSpecified",
    order: "orderOfAppearance",
    status: "nonstandard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-repeat-x",
  },
  "-webkit-mask-repeat-y": {
    syntax: "repeat | no-repeat | space | round",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["WebKit Extensions"],
    initial: "repeat",
    appliesto: "allElements",
    computed: "absoluteLengthOrPercentage",
    order: "orderOfAppearance",
    status: "nonstandard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-repeat-y",
  },
  "-webkit-mask-size": {
    syntax: "<bg-size>#",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "relativeToBackgroundPositioningArea",
    groups: ["WebKit Extensions"],
    initial: "auto auto",
    appliesto: "allElements",
    computed: "asSpecified",
    order: "orderOfAppearance",
    status: "nonstandard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-size",
  },
  "-webkit-overflow-scrolling": {
    syntax: "auto | touch",
    media: "visual",
    inherited: true,
    animationType: "discrete",
    percentages: "no",
    groups: ["WebKit Extensions"],
    initial: "auto",
    appliesto: "scrollingBoxes",
    computed: "asSpecified",
    order: "orderOfAppearance",
    status: "nonstandard",
    mdn_url:
      "https://developer.mozilla.org/docs/Web/CSS/-webkit-overflow-scrolling",
  },
  "-webkit-tap-highlight-color": {
    syntax: "<color>",
    media: "visual",
    inherited: true,
    animationType: "discrete",
    percentages: "no",
    groups: ["WebKit Extensions"],
    initial: "black",
    appliesto: "allElements",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "nonstandard",
    mdn_url:
      "https://developer.mozilla.org/docs/Web/CSS/-webkit-tap-highlight-color",
  },
  "-webkit-text-fill-color": {
    syntax: "<color>",
    media: "visual",
    inherited: true,
    animationType: "color",
    percentages: "no",
    groups: ["WebKit Extensions"],
    initial: "currentcolor",
    appliesto: "allElements",
    computed: "computedColor",
    order: "uniqueOrder",
    status: "nonstandard",
    mdn_url:
      "https://developer.mozilla.org/docs/Web/CSS/-webkit-text-fill-color",
  },
  "-webkit-text-stroke": {
    syntax: "<length> || <color>",
    media: "visual",
    inherited: true,
    animationType: ["-webkit-text-stroke-width", "-webkit-text-stroke-color"],
    percentages: "no",
    groups: ["WebKit Extensions"],
    initial: ["-webkit-text-stroke-width", "-webkit-text-stroke-color"],
    appliesto: "allElements",
    computed: ["-webkit-text-stroke-width", "-webkit-text-stroke-color"],
    order: "canonicalOrder",
    status: "nonstandard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-text-stroke",
  },
  "-webkit-text-stroke-color": {
    syntax: "<color>",
    media: "visual",
    inherited: true,
    animationType: "color",
    percentages: "no",
    groups: ["WebKit Extensions"],
    initial: "currentcolor",
    appliesto: "allElements",
    computed: "computedColor",
    order: "uniqueOrder",
    status: "nonstandard",
    mdn_url:
      "https://developer.mozilla.org/docs/Web/CSS/-webkit-text-stroke-color",
  },
  "-webkit-text-stroke-width": {
    syntax: "<length>",
    media: "visual",
    inherited: true,
    animationType: "discrete",
    percentages: "no",
    groups: ["WebKit Extensions"],
    initial: "0",
    appliesto: "allElements",
    computed: "absoluteLength",
    order: "uniqueOrder",
    status: "nonstandard",
    mdn_url:
      "https://developer.mozilla.org/docs/Web/CSS/-webkit-text-stroke-width",
  },
  "-webkit-touch-callout": {
    syntax: "default | none",
    media: "visual",
    inherited: true,
    animationType: "discrete",
    percentages: "no",
    groups: ["WebKit Extensions"],
    initial: "default",
    appliesto: "allElements",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "nonstandard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-touch-callout",
  },
  "-webkit-user-modify": {
    syntax: "read-only | read-write | read-write-plaintext-only",
    media: "interactive",
    inherited: true,
    animationType: "discrete",
    percentages: "no",
    groups: ["WebKit Extensions"],
    initial: "read-only",
    appliesto: "allElements",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "nonstandard",
  },
  "accent-color": {
    syntax: "auto | <color>",
    media: "interactive",
    inherited: true,
    animationType: "byComputedValueType",
    percentages: "no",
    groups: ["CSS Basic User Interface"],
    initial: "auto",
    appliesto: "allElements",
    computed: "asAutoOrColor",
    order: "perGrammar",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/accent-color",
  },
  "align-content": {
    syntax:
      "normal | <baseline-position> | <content-distribution> | <overflow-position>? <content-position>",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Box Alignment"],
    initial: "normal",
    appliesto: "multilineFlexContainers",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/align-content",
  },
  "align-items": {
    syntax:
      "normal | stretch | <baseline-position> | [ <overflow-position>? <self-position> ]",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Box Alignment"],
    initial: "normal",
    appliesto: "allElements",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/align-items",
  },
  "align-self": {
    syntax:
      "auto | normal | stretch | <baseline-position> | <overflow-position>? <self-position>",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Box Alignment"],
    initial: "auto",
    appliesto: "flexItemsGridItemsAndAbsolutelyPositionedBoxes",
    computed: "autoOnAbsolutelyPositionedElementsValueOfAlignItemsOnParent",
    order: "uniqueOrder",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/align-self",
  },
  "align-tracks": {
    syntax:
      "[ normal | <baseline-position> | <content-distribution> | <overflow-position>? <content-position> ]#",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Grid Layout"],
    initial: "normal",
    appliesto: "gridContainersWithMasonryLayoutInTheirBlockAxis",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "experimental",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/align-tracks",
  },
  all: all$1,
  animation: animation$1,
  "animation-composition": {
    syntax: "<single-animation-composition>#",
    media: "visual",
    inherited: false,
    animationType: "notAnimatable",
    percentages: "no",
    groups: ["CSS Animations"],
    initial: "replace",
    appliesto: "allElements",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "experimental",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-composition",
  },
  "animation-delay": {
    syntax: "<time>#",
    media: "visual",
    inherited: false,
    animationType: "notAnimatable",
    percentages: "no",
    groups: ["CSS Animations"],
    initial: "0s",
    appliesto: "allElementsAndPseudos",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-delay",
  },
  "animation-direction": {
    syntax: "<single-animation-direction>#",
    media: "visual",
    inherited: false,
    animationType: "notAnimatable",
    percentages: "no",
    groups: ["CSS Animations"],
    initial: "normal",
    appliesto: "allElementsAndPseudos",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-direction",
  },
  "animation-duration": {
    syntax: "<time>#",
    media: "visual",
    inherited: false,
    animationType: "notAnimatable",
    percentages: "no",
    groups: ["CSS Animations"],
    initial: "0s",
    appliesto: "allElementsAndPseudos",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-duration",
  },
  "animation-fill-mode": {
    syntax: "<single-animation-fill-mode>#",
    media: "visual",
    inherited: false,
    animationType: "notAnimatable",
    percentages: "no",
    groups: ["CSS Animations"],
    initial: "none",
    appliesto: "allElementsAndPseudos",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-fill-mode",
  },
  "animation-iteration-count": {
    syntax: "<single-animation-iteration-count>#",
    media: "visual",
    inherited: false,
    animationType: "notAnimatable",
    percentages: "no",
    groups: ["CSS Animations"],
    initial: "1",
    appliesto: "allElementsAndPseudos",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "standard",
    mdn_url:
      "https://developer.mozilla.org/docs/Web/CSS/animation-iteration-count",
  },
  "animation-name": {
    syntax: "[ none | <keyframes-name> ]#",
    media: "visual",
    inherited: false,
    animationType: "notAnimatable",
    percentages: "no",
    groups: ["CSS Animations"],
    initial: "none",
    appliesto: "allElementsAndPseudos",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-name",
  },
  "animation-play-state": {
    syntax: "<single-animation-play-state>#",
    media: "visual",
    inherited: false,
    animationType: "notAnimatable",
    percentages: "no",
    groups: ["CSS Animations"],
    initial: "running",
    appliesto: "allElementsAndPseudos",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-play-state",
  },
  "animation-timing-function": {
    syntax: "<easing-function>#",
    media: "visual",
    inherited: false,
    animationType: "notAnimatable",
    percentages: "no",
    groups: ["CSS Animations"],
    initial: "ease",
    appliesto: "allElementsAndPseudos",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "standard",
    mdn_url:
      "https://developer.mozilla.org/docs/Web/CSS/animation-timing-function",
  },
  "animation-timeline": {
    syntax: "<single-animation-timeline>#",
    media: "visual",
    inherited: false,
    animationType: "notAnimatable",
    percentages: "no",
    groups: ["CSS Animations"],
    initial: "auto",
    appliesto: "allElements",
    computed: "listEachItemIdentifyerOrNoneAuto",
    order: "uniqueOrder",
    status: "experimental",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-timeline",
  },
  appearance: appearance$1,
  "aspect-ratio": {
    syntax: "auto | <ratio>",
    media: "all",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Basic User Interface"],
    initial: "auto",
    appliesto: "allElementsExceptInlineBoxesAndInternalRubyOrTableBoxes",
    computed: "asSpecified",
    order: "perGrammar",
    status: "experimental",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/aspect-ratio",
  },
  azimuth: azimuth$1,
  "backdrop-filter": {
    syntax: "none | <filter-function-list>",
    media: "visual",
    inherited: false,
    animationType: "filterList",
    percentages: "no",
    groups: ["Filter Effects"],
    initial: "none",
    appliesto: "allElementsSVGContainerElements",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/backdrop-filter",
  },
  "backface-visibility": {
    syntax: "visible | hidden",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Transforms"],
    initial: "visible",
    appliesto: "transformableElements",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/backface-visibility",
  },
  background: background$3,
  "background-attachment": {
    syntax: "<attachment>#",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Backgrounds and Borders"],
    initial: "scroll",
    appliesto: "allElements",
    computed: "asSpecified",
    order: "uniqueOrder",
    alsoAppliesTo: ["::first-letter", "::first-line", "::placeholder"],
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-attachment",
  },
  "background-blend-mode": {
    syntax: "<blend-mode>#",
    media: "none",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["Compositing and Blending"],
    initial: "normal",
    appliesto: "allElementsSVGContainerGraphicsAndGraphicsReferencingElements",
    computed: "asSpecified",
    order: "uniqueOrder",
    alsoAppliesTo: ["::first-letter", "::first-line", "::placeholder"],
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-blend-mode",
  },
  "background-clip": {
    syntax: "<box>#",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Backgrounds and Borders"],
    initial: "border-box",
    appliesto: "allElements",
    computed: "asSpecified",
    order: "uniqueOrder",
    alsoAppliesTo: ["::first-letter", "::first-line", "::placeholder"],
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-clip",
  },
  "background-color": {
    syntax: "<color>",
    media: "visual",
    inherited: false,
    animationType: "color",
    percentages: "no",
    groups: ["CSS Backgrounds and Borders"],
    initial: "transparent",
    appliesto: "allElements",
    computed: "computedColor",
    order: "uniqueOrder",
    alsoAppliesTo: ["::first-letter", "::first-line", "::placeholder"],
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-color",
  },
  "background-image": {
    syntax: "<bg-image>#",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Backgrounds and Borders"],
    initial: "none",
    appliesto: "allElements",
    computed: "asSpecifiedURLsAbsolute",
    order: "uniqueOrder",
    alsoAppliesTo: ["::first-letter", "::first-line", "::placeholder"],
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-image",
  },
  "background-origin": {
    syntax: "<box>#",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Backgrounds and Borders"],
    initial: "padding-box",
    appliesto: "allElements",
    computed: "asSpecified",
    order: "uniqueOrder",
    alsoAppliesTo: ["::first-letter", "::first-line", "::placeholder"],
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-origin",
  },
  "background-position": {
    syntax: "<bg-position>#",
    media: "visual",
    inherited: false,
    animationType: "repeatableListOfSimpleListOfLpc",
    percentages:
      "referToSizeOfBackgroundPositioningAreaMinusBackgroundImageSize",
    groups: ["CSS Backgrounds and Borders"],
    initial: "0% 0%",
    appliesto: "allElements",
    computed: ["background-position-x", "background-position-y"],
    order: "uniqueOrder",
    alsoAppliesTo: ["::first-letter", "::first-line", "::placeholder"],
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-position",
  },
  "background-position-x": {
    syntax:
      "[ center | [ [ left | right | x-start | x-end ]? <length-percentage>? ]! ]#",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages:
      "referToWidthOfBackgroundPositioningAreaMinusBackgroundImageHeight",
    groups: ["CSS Backgrounds and Borders"],
    initial: "0%",
    appliesto: "allElements",
    computed: "listEachItemConsistingOfAbsoluteLengthPercentageAndOrigin",
    order: "uniqueOrder",
    status: "experimental",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-position-x",
  },
  "background-position-y": {
    syntax:
      "[ center | [ [ top | bottom | y-start | y-end ]? <length-percentage>? ]! ]#",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages:
      "referToHeightOfBackgroundPositioningAreaMinusBackgroundImageHeight",
    groups: ["CSS Backgrounds and Borders"],
    initial: "0%",
    appliesto: "allElements",
    computed: "listEachItemConsistingOfAbsoluteLengthPercentageAndOrigin",
    order: "uniqueOrder",
    status: "experimental",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-position-y",
  },
  "background-repeat": {
    syntax: "<repeat-style>#",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Backgrounds and Borders"],
    initial: "repeat",
    appliesto: "allElements",
    computed: "listEachItemHasTwoKeywordsOnePerDimension",
    order: "uniqueOrder",
    alsoAppliesTo: ["::first-letter", "::first-line", "::placeholder"],
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-repeat",
  },
  "background-size": {
    syntax: "<bg-size>#",
    media: "visual",
    inherited: false,
    animationType: "repeatableListOfSimpleListOfLpc",
    percentages: "relativeToBackgroundPositioningArea",
    groups: ["CSS Backgrounds and Borders"],
    initial: "auto auto",
    appliesto: "allElements",
    computed: "asSpecifiedRelativeToAbsoluteLengths",
    order: "uniqueOrder",
    alsoAppliesTo: ["::first-letter", "::first-line", "::placeholder"],
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-size",
  },
  "block-overflow": {
    syntax: "clip | ellipsis | <string>",
    media: "visual",
    inherited: true,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Overflow"],
    initial: "clip",
    appliesto: "blockContainers",
    computed: "asSpecified",
    order: "perGrammar",
    status: "experimental",
  },
  "block-size": {
    syntax: "<'width'>",
    media: "visual",
    inherited: false,
    animationType: "lpc",
    percentages: "blockSizeOfContainingBlock",
    groups: ["CSS Logical Properties"],
    initial: "auto",
    appliesto: "sameAsWidthAndHeight",
    computed: "sameAsWidthAndHeight",
    order: "uniqueOrder",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/block-size",
  },
  border: border$3,
  "border-block": {
    syntax: "<'border-top-width'> || <'border-top-style'> || <color>",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Logical Properties"],
    initial: ["border-top-width", "border-top-style", "border-top-color"],
    appliesto: "allElements",
    computed: ["border-top-width", "border-top-style", "border-top-color"],
    order: "uniqueOrder",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block",
  },
  "border-block-color": {
    syntax: "<'border-top-color'>{1,2}",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Logical Properties"],
    initial: "currentcolor",
    appliesto: "allElements",
    computed: "computedColor",
    order: "uniqueOrder",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-color",
  },
  "border-block-style": {
    syntax: "<'border-top-style'>",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Logical Properties"],
    initial: "none",
    appliesto: "allElements",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-style",
  },
  "border-block-width": {
    syntax: "<'border-top-width'>",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "logicalWidthOfContainingBlock",
    groups: ["CSS Logical Properties"],
    initial: "medium",
    appliesto: "allElements",
    computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
    order: "uniqueOrder",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-width",
  },
  "border-block-end": {
    syntax: "<'border-top-width'> || <'border-top-style'> || <color>",
    media: "visual",
    inherited: false,
    animationType: [
      "border-block-end-color",
      "border-block-end-style",
      "border-block-end-width",
    ],
    percentages: "no",
    groups: ["CSS Logical Properties"],
    initial: ["border-top-width", "border-top-style", "border-top-color"],
    appliesto: "allElements",
    computed: ["border-top-width", "border-top-style", "border-top-color"],
    order: "uniqueOrder",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-end",
  },
  "border-block-end-color": {
    syntax: "<'border-top-color'>",
    media: "visual",
    inherited: false,
    animationType: "color",
    percentages: "no",
    groups: ["CSS Logical Properties"],
    initial: "currentcolor",
    appliesto: "allElements",
    computed: "computedColor",
    order: "uniqueOrder",
    status: "standard",
    mdn_url:
      "https://developer.mozilla.org/docs/Web/CSS/border-block-end-color",
  },
  "border-block-end-style": {
    syntax: "<'border-top-style'>",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Logical Properties"],
    initial: "none",
    appliesto: "allElements",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "standard",
    mdn_url:
      "https://developer.mozilla.org/docs/Web/CSS/border-block-end-style",
  },
  "border-block-end-width": {
    syntax: "<'border-top-width'>",
    media: "visual",
    inherited: false,
    animationType: "length",
    percentages: "logicalWidthOfContainingBlock",
    groups: ["CSS Logical Properties"],
    initial: "medium",
    appliesto: "allElements",
    computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
    order: "uniqueOrder",
    status: "standard",
    mdn_url:
      "https://developer.mozilla.org/docs/Web/CSS/border-block-end-width",
  },
  "border-block-start": {
    syntax: "<'border-top-width'> || <'border-top-style'> || <color>",
    media: "visual",
    inherited: false,
    animationType: [
      "border-block-start-color",
      "border-block-start-style",
      "border-block-start-width",
    ],
    percentages: "no",
    groups: ["CSS Logical Properties"],
    initial: ["border-width", "border-style", "color"],
    appliesto: "allElements",
    computed: ["border-width", "border-style", "border-block-start-color"],
    order: "uniqueOrder",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-start",
  },
  "border-block-start-color": {
    syntax: "<'border-top-color'>",
    media: "visual",
    inherited: false,
    animationType: "color",
    percentages: "no",
    groups: ["CSS Logical Properties"],
    initial: "currentcolor",
    appliesto: "allElements",
    computed: "computedColor",
    order: "uniqueOrder",
    status: "standard",
    mdn_url:
      "https://developer.mozilla.org/docs/Web/CSS/border-block-start-color",
  },
  "border-block-start-style": {
    syntax: "<'border-top-style'>",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Logical Properties"],
    initial: "none",
    appliesto: "allElements",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "standard",
    mdn_url:
      "https://developer.mozilla.org/docs/Web/CSS/border-block-start-style",
  },
  "border-block-start-width": {
    syntax: "<'border-top-width'>",
    media: "visual",
    inherited: false,
    animationType: "length",
    percentages: "logicalWidthOfContainingBlock",
    groups: ["CSS Logical Properties"],
    initial: "medium",
    appliesto: "allElements",
    computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
    order: "uniqueOrder",
    status: "standard",
    mdn_url:
      "https://developer.mozilla.org/docs/Web/CSS/border-block-start-width",
  },
  "border-bottom": {
    syntax: "<line-width> || <line-style> || <color>",
    media: "visual",
    inherited: false,
    animationType: [
      "border-bottom-color",
      "border-bottom-style",
      "border-bottom-width",
    ],
    percentages: "no",
    groups: ["CSS Backgrounds and Borders"],
    initial: [
      "border-bottom-width",
      "border-bottom-style",
      "border-bottom-color",
    ],
    appliesto: "allElements",
    computed: [
      "border-bottom-width",
      "border-bottom-style",
      "border-bottom-color",
    ],
    order: "orderOfAppearance",
    alsoAppliesTo: ["::first-letter"],
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom",
  },
  "border-bottom-color": {
    syntax: "<'border-top-color'>",
    media: "visual",
    inherited: false,
    animationType: "color",
    percentages: "no",
    groups: ["CSS Backgrounds and Borders"],
    initial: "currentcolor",
    appliesto: "allElements",
    computed: "computedColor",
    order: "uniqueOrder",
    alsoAppliesTo: ["::first-letter"],
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-color",
  },
  "border-bottom-left-radius": {
    syntax: "<length-percentage>{1,2}",
    media: "visual",
    inherited: false,
    animationType: "lpc",
    percentages: "referToDimensionOfBorderBox",
    groups: ["CSS Backgrounds and Borders"],
    initial: "0",
    appliesto: "allElementsUAsNotRequiredWhenCollapse",
    computed: "twoAbsoluteLengthOrPercentages",
    order: "uniqueOrder",
    alsoAppliesTo: ["::first-letter"],
    status: "standard",
    mdn_url:
      "https://developer.mozilla.org/docs/Web/CSS/border-bottom-left-radius",
  },
  "border-bottom-right-radius": {
    syntax: "<length-percentage>{1,2}",
    media: "visual",
    inherited: false,
    animationType: "lpc",
    percentages: "referToDimensionOfBorderBox",
    groups: ["CSS Backgrounds and Borders"],
    initial: "0",
    appliesto: "allElementsUAsNotRequiredWhenCollapse",
    computed: "twoAbsoluteLengthOrPercentages",
    order: "uniqueOrder",
    alsoAppliesTo: ["::first-letter"],
    status: "standard",
    mdn_url:
      "https://developer.mozilla.org/docs/Web/CSS/border-bottom-right-radius",
  },
  "border-bottom-style": {
    syntax: "<line-style>",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Backgrounds and Borders"],
    initial: "none",
    appliesto: "allElements",
    computed: "asSpecified",
    order: "uniqueOrder",
    alsoAppliesTo: ["::first-letter"],
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-style",
  },
  "border-bottom-width": {
    syntax: "<line-width>",
    media: "visual",
    inherited: false,
    animationType: "length",
    percentages: "no",
    groups: ["CSS Backgrounds and Borders"],
    initial: "medium",
    appliesto: "allElements",
    computed: "absoluteLengthOr0IfBorderBottomStyleNoneOrHidden",
    order: "uniqueOrder",
    alsoAppliesTo: ["::first-letter"],
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-width",
  },
  "border-collapse": {
    syntax: "collapse | separate",
    media: "visual",
    inherited: true,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Table"],
    initial: "separate",
    appliesto: "tableElements",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-collapse",
  },
  "border-color": {
    syntax: "<color>{1,4}",
    media: "visual",
    inherited: false,
    animationType: [
      "border-bottom-color",
      "border-left-color",
      "border-right-color",
      "border-top-color",
    ],
    percentages: "no",
    groups: ["CSS Backgrounds and Borders"],
    initial: [
      "border-top-color",
      "border-right-color",
      "border-bottom-color",
      "border-left-color",
    ],
    appliesto: "allElements",
    computed: [
      "border-bottom-color",
      "border-left-color",
      "border-right-color",
      "border-top-color",
    ],
    order: "uniqueOrder",
    alsoAppliesTo: ["::first-letter"],
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-color",
  },
  "border-end-end-radius": {
    syntax: "<length-percentage>{1,2}",
    media: "visual",
    inherited: false,
    animationType: "lpc",
    percentages: "referToDimensionOfBorderBox",
    groups: ["CSS Logical Properties"],
    initial: "0",
    appliesto: "allElementsUAsNotRequiredWhenCollapse",
    computed: "twoAbsoluteLengthOrPercentages",
    order: "uniqueOrder",
    alsoAppliesTo: ["::first-letter"],
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-end-end-radius",
  },
  "border-end-start-radius": {
    syntax: "<length-percentage>{1,2}",
    media: "visual",
    inherited: false,
    animationType: "lpc",
    percentages: "referToDimensionOfBorderBox",
    groups: ["CSS Logical Properties"],
    initial: "0",
    appliesto: "allElementsUAsNotRequiredWhenCollapse",
    computed: "twoAbsoluteLengthOrPercentages",
    order: "uniqueOrder",
    alsoAppliesTo: ["::first-letter"],
    status: "standard",
    mdn_url:
      "https://developer.mozilla.org/docs/Web/CSS/border-end-start-radius",
  },
  "border-image": {
    syntax:
      "<'border-image-source'> || <'border-image-slice'> [ / <'border-image-width'> | / <'border-image-width'>? / <'border-image-outset'> ]? || <'border-image-repeat'>",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: ["border-image-slice", "border-image-width"],
    groups: ["CSS Backgrounds and Borders"],
    initial: [
      "border-image-source",
      "border-image-slice",
      "border-image-width",
      "border-image-outset",
      "border-image-repeat",
    ],
    appliesto: "allElementsExceptTableElementsWhenCollapse",
    computed: [
      "border-image-outset",
      "border-image-repeat",
      "border-image-slice",
      "border-image-source",
      "border-image-width",
    ],
    order: "uniqueOrder",
    alsoAppliesTo: ["::first-letter"],
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image",
  },
  "border-image-outset": {
    syntax: "[ <length> | <number> ]{1,4}",
    media: "visual",
    inherited: false,
    animationType: "byComputedValueType",
    percentages: "no",
    groups: ["CSS Backgrounds and Borders"],
    initial: "0",
    appliesto: "allElementsExceptTableElementsWhenCollapse",
    computed: "asSpecifiedRelativeToAbsoluteLengths",
    order: "uniqueOrder",
    alsoAppliesTo: ["::first-letter"],
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-outset",
  },
  "border-image-repeat": {
    syntax: "[ stretch | repeat | round | space ]{1,2}",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Backgrounds and Borders"],
    initial: "stretch",
    appliesto: "allElementsExceptTableElementsWhenCollapse",
    computed: "asSpecified",
    order: "uniqueOrder",
    alsoAppliesTo: ["::first-letter"],
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-repeat",
  },
  "border-image-slice": {
    syntax: "<number-percentage>{1,4} && fill?",
    media: "visual",
    inherited: false,
    animationType: "byComputedValueType",
    percentages: "referToSizeOfBorderImage",
    groups: ["CSS Backgrounds and Borders"],
    initial: "100%",
    appliesto: "allElementsExceptTableElementsWhenCollapse",
    computed: "oneToFourPercentagesOrAbsoluteLengthsPlusFill",
    order: "percentagesOrLengthsFollowedByFill",
    alsoAppliesTo: ["::first-letter"],
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-slice",
  },
  "border-image-source": {
    syntax: "none | <image>",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Backgrounds and Borders"],
    initial: "none",
    appliesto: "allElementsExceptTableElementsWhenCollapse",
    computed: "noneOrImageWithAbsoluteURI",
    order: "uniqueOrder",
    alsoAppliesTo: ["::first-letter"],
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-source",
  },
  "border-image-width": {
    syntax: "[ <length-percentage> | <number> | auto ]{1,4}",
    media: "visual",
    inherited: false,
    animationType: "byComputedValueType",
    percentages: "referToWidthOrHeightOfBorderImageArea",
    groups: ["CSS Backgrounds and Borders"],
    initial: "1",
    appliesto: "allElementsExceptTableElementsWhenCollapse",
    computed: "asSpecifiedRelativeToAbsoluteLengths",
    order: "uniqueOrder",
    alsoAppliesTo: ["::first-letter"],
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-width",
  },
  "border-inline": {
    syntax: "<'border-top-width'> || <'border-top-style'> || <color>",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Logical Properties"],
    initial: ["border-top-width", "border-top-style", "border-top-color"],
    appliesto: "allElements",
    computed: ["border-top-width", "border-top-style", "border-top-color"],
    order: "uniqueOrder",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline",
  },
  "border-inline-end": {
    syntax: "<'border-top-width'> || <'border-top-style'> || <color>",
    media: "visual",
    inherited: false,
    animationType: [
      "border-inline-end-color",
      "border-inline-end-style",
      "border-inline-end-width",
    ],
    percentages: "no",
    groups: ["CSS Logical Properties"],
    initial: ["border-width", "border-style", "color"],
    appliesto: "allElements",
    computed: ["border-width", "border-style", "border-inline-end-color"],
    order: "uniqueOrder",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-end",
  },
  "border-inline-color": {
    syntax: "<'border-top-color'>{1,2}",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Logical Properties"],
    initial: "currentcolor",
    appliesto: "allElements",
    computed: "computedColor",
    order: "uniqueOrder",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-color",
  },
  "border-inline-style": {
    syntax: "<'border-top-style'>",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Logical Properties"],
    initial: "none",
    appliesto: "allElements",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-style",
  },
  "border-inline-width": {
    syntax: "<'border-top-width'>",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "logicalWidthOfContainingBlock",
    groups: ["CSS Logical Properties"],
    initial: "medium",
    appliesto: "allElements",
    computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
    order: "uniqueOrder",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-width",
  },
  "border-inline-end-color": {
    syntax: "<'border-top-color'>",
    media: "visual",
    inherited: false,
    animationType: "color",
    percentages: "no",
    groups: ["CSS Logical Properties"],
    initial: "currentcolor",
    appliesto: "allElements",
    computed: "computedColor",
    order: "uniqueOrder",
    status: "standard",
    mdn_url:
      "https://developer.mozilla.org/docs/Web/CSS/border-inline-end-color",
  },
  "border-inline-end-style": {
    syntax: "<'border-top-style'>",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Logical Properties"],
    initial: "none",
    appliesto: "allElements",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "standard",
    mdn_url:
      "https://developer.mozilla.org/docs/Web/CSS/border-inline-end-style",
  },
  "border-inline-end-width": {
    syntax: "<'border-top-width'>",
    media: "visual",
    inherited: false,
    animationType: "length",
    percentages: "logicalWidthOfContainingBlock",
    groups: ["CSS Logical Properties"],
    initial: "medium",
    appliesto: "allElements",
    computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
    order: "uniqueOrder",
    status: "standard",
    mdn_url:
      "https://developer.mozilla.org/docs/Web/CSS/border-inline-end-width",
  },
  "border-inline-start": {
    syntax: "<'border-top-width'> || <'border-top-style'> || <color>",
    media: "visual",
    inherited: false,
    animationType: [
      "border-inline-start-color",
      "border-inline-start-style",
      "border-inline-start-width",
    ],
    percentages: "no",
    groups: ["CSS Logical Properties"],
    initial: ["border-width", "border-style", "color"],
    appliesto: "allElements",
    computed: ["border-width", "border-style", "border-inline-start-color"],
    order: "uniqueOrder",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-start",
  },
  "border-inline-start-color": {
    syntax: "<'border-top-color'>",
    media: "visual",
    inherited: false,
    animationType: "color",
    percentages: "no",
    groups: ["CSS Logical Properties"],
    initial: "currentcolor",
    appliesto: "allElements",
    computed: "computedColor",
    order: "uniqueOrder",
    status: "standard",
    mdn_url:
      "https://developer.mozilla.org/docs/Web/CSS/border-inline-start-color",
  },
  "border-inline-start-style": {
    syntax: "<'border-top-style'>",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Logical Properties"],
    initial: "none",
    appliesto: "allElements",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "standard",
    mdn_url:
      "https://developer.mozilla.org/docs/Web/CSS/border-inline-start-style",
  },
  "border-inline-start-width": {
    syntax: "<'border-top-width'>",
    media: "visual",
    inherited: false,
    animationType: "length",
    percentages: "logicalWidthOfContainingBlock",
    groups: ["CSS Logical Properties"],
    initial: "medium",
    appliesto: "allElements",
    computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
    order: "uniqueOrder",
    status: "standard",
    mdn_url:
      "https://developer.mozilla.org/docs/Web/CSS/border-inline-start-width",
  },
  "border-left": {
    syntax: "<line-width> || <line-style> || <color>",
    media: "visual",
    inherited: false,
    animationType: [
      "border-left-color",
      "border-left-style",
      "border-left-width",
    ],
    percentages: "no",
    groups: ["CSS Backgrounds and Borders"],
    initial: ["border-left-width", "border-left-style", "border-left-color"],
    appliesto: "allElements",
    computed: ["border-left-width", "border-left-style", "border-left-color"],
    order: "orderOfAppearance",
    alsoAppliesTo: ["::first-letter"],
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-left",
  },
  "border-left-color": {
    syntax: "<color>",
    media: "visual",
    inherited: false,
    animationType: "color",
    percentages: "no",
    groups: ["CSS Backgrounds and Borders"],
    initial: "currentcolor",
    appliesto: "allElements",
    computed: "computedColor",
    order: "uniqueOrder",
    alsoAppliesTo: ["::first-letter"],
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-left-color",
  },
  "border-left-style": {
    syntax: "<line-style>",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Backgrounds and Borders"],
    initial: "none",
    appliesto: "allElements",
    computed: "asSpecified",
    order: "uniqueOrder",
    alsoAppliesTo: ["::first-letter"],
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-left-style",
  },
  "border-left-width": {
    syntax: "<line-width>",
    media: "visual",
    inherited: false,
    animationType: "length",
    percentages: "no",
    groups: ["CSS Backgrounds and Borders"],
    initial: "medium",
    appliesto: "allElements",
    computed: "absoluteLengthOr0IfBorderLeftStyleNoneOrHidden",
    order: "uniqueOrder",
    alsoAppliesTo: ["::first-letter"],
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-left-width",
  },
  "border-radius": {
    syntax: "<length-percentage>{1,4} [ / <length-percentage>{1,4} ]?",
    media: "visual",
    inherited: false,
    animationType: [
      "border-top-left-radius",
      "border-top-right-radius",
      "border-bottom-right-radius",
      "border-bottom-left-radius",
    ],
    percentages: "referToDimensionOfBorderBox",
    groups: ["CSS Backgrounds and Borders"],
    initial: [
      "border-top-left-radius",
      "border-top-right-radius",
      "border-bottom-right-radius",
      "border-bottom-left-radius",
    ],
    appliesto: "allElementsUAsNotRequiredWhenCollapse",
    computed: [
      "border-bottom-left-radius",
      "border-bottom-right-radius",
      "border-top-left-radius",
      "border-top-right-radius",
    ],
    order: "uniqueOrder",
    alsoAppliesTo: ["::first-letter"],
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-radius",
  },
  "border-right": {
    syntax: "<line-width> || <line-style> || <color>",
    media: "visual",
    inherited: false,
    animationType: [
      "border-right-color",
      "border-right-style",
      "border-right-width",
    ],
    percentages: "no",
    groups: ["CSS Backgrounds and Borders"],
    initial: ["border-right-width", "border-right-style", "border-right-color"],
    appliesto: "allElements",
    computed: [
      "border-right-width",
      "border-right-style",
      "border-right-color",
    ],
    order: "orderOfAppearance",
    alsoAppliesTo: ["::first-letter"],
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-right",
  },
  "border-right-color": {
    syntax: "<color>",
    media: "visual",
    inherited: false,
    animationType: "color",
    percentages: "no",
    groups: ["CSS Backgrounds and Borders"],
    initial: "currentcolor",
    appliesto: "allElements",
    computed: "computedColor",
    order: "uniqueOrder",
    alsoAppliesTo: ["::first-letter"],
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-right-color",
  },
  "border-right-style": {
    syntax: "<line-style>",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Backgrounds and Borders"],
    initial: "none",
    appliesto: "allElements",
    computed: "asSpecified",
    order: "uniqueOrder",
    alsoAppliesTo: ["::first-letter"],
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-right-style",
  },
  "border-right-width": {
    syntax: "<line-width>",
    media: "visual",
    inherited: false,
    animationType: "length",
    percentages: "no",
    groups: ["CSS Backgrounds and Borders"],
    initial: "medium",
    appliesto: "allElements",
    computed: "absoluteLengthOr0IfBorderRightStyleNoneOrHidden",
    order: "uniqueOrder",
    alsoAppliesTo: ["::first-letter"],
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-right-width",
  },
  "border-spacing": {
    syntax: "<length> <length>?",
    media: "visual",
    inherited: true,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Table"],
    initial: "0",
    appliesto: "tableElements",
    computed: "twoAbsoluteLengths",
    order: "uniqueOrder",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-spacing",
  },
  "border-start-end-radius": {
    syntax: "<length-percentage>{1,2}",
    media: "visual",
    inherited: false,
    animationType: "lpc",
    percentages: "referToDimensionOfBorderBox",
    groups: ["CSS Logical Properties"],
    initial: "0",
    appliesto: "allElementsUAsNotRequiredWhenCollapse",
    computed: "twoAbsoluteLengthOrPercentages",
    order: "uniqueOrder",
    alsoAppliesTo: ["::first-letter"],
    status: "standard",
    mdn_url:
      "https://developer.mozilla.org/docs/Web/CSS/border-start-end-radius",
  },
  "border-start-start-radius": {
    syntax: "<length-percentage>{1,2}",
    media: "visual",
    inherited: false,
    animationType: "lpc",
    percentages: "referToDimensionOfBorderBox",
    groups: ["CSS Logical Properties"],
    initial: "0",
    appliesto: "allElementsUAsNotRequiredWhenCollapse",
    computed: "twoAbsoluteLengthOrPercentages",
    order: "uniqueOrder",
    alsoAppliesTo: ["::first-letter"],
    status: "standard",
    mdn_url:
      "https://developer.mozilla.org/docs/Web/CSS/border-start-start-radius",
  },
  "border-style": {
    syntax: "<line-style>{1,4}",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Backgrounds and Borders"],
    initial: [
      "border-top-style",
      "border-right-style",
      "border-bottom-style",
      "border-left-style",
    ],
    appliesto: "allElements",
    computed: [
      "border-bottom-style",
      "border-left-style",
      "border-right-style",
      "border-top-style",
    ],
    order: "uniqueOrder",
    alsoAppliesTo: ["::first-letter"],
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-style",
  },
  "border-top": {
    syntax: "<line-width> || <line-style> || <color>",
    media: "visual",
    inherited: false,
    animationType: ["border-top-color", "border-top-style", "border-top-width"],
    percentages: "no",
    groups: ["CSS Backgrounds and Borders"],
    initial: ["border-top-width", "border-top-style", "border-top-color"],
    appliesto: "allElements",
    computed: ["border-top-width", "border-top-style", "border-top-color"],
    order: "orderOfAppearance",
    alsoAppliesTo: ["::first-letter"],
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top",
  },
  "border-top-color": {
    syntax: "<color>",
    media: "visual",
    inherited: false,
    animationType: "color",
    percentages: "no",
    groups: ["CSS Backgrounds and Borders"],
    initial: "currentcolor",
    appliesto: "allElements",
    computed: "computedColor",
    order: "uniqueOrder",
    alsoAppliesTo: ["::first-letter"],
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-color",
  },
  "border-top-left-radius": {
    syntax: "<length-percentage>{1,2}",
    media: "visual",
    inherited: false,
    animationType: "lpc",
    percentages: "referToDimensionOfBorderBox",
    groups: ["CSS Backgrounds and Borders"],
    initial: "0",
    appliesto: "allElementsUAsNotRequiredWhenCollapse",
    computed: "twoAbsoluteLengthOrPercentages",
    order: "uniqueOrder",
    alsoAppliesTo: ["::first-letter"],
    status: "standard",
    mdn_url:
      "https://developer.mozilla.org/docs/Web/CSS/border-top-left-radius",
  },
  "border-top-right-radius": {
    syntax: "<length-percentage>{1,2}",
    media: "visual",
    inherited: false,
    animationType: "lpc",
    percentages: "referToDimensionOfBorderBox",
    groups: ["CSS Backgrounds and Borders"],
    initial: "0",
    appliesto: "allElementsUAsNotRequiredWhenCollapse",
    computed: "twoAbsoluteLengthOrPercentages",
    order: "uniqueOrder",
    alsoAppliesTo: ["::first-letter"],
    status: "standard",
    mdn_url:
      "https://developer.mozilla.org/docs/Web/CSS/border-top-right-radius",
  },
  "border-top-style": {
    syntax: "<line-style>",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Backgrounds and Borders"],
    initial: "none",
    appliesto: "allElements",
    computed: "asSpecified",
    order: "uniqueOrder",
    alsoAppliesTo: ["::first-letter"],
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-style",
  },
  "border-top-width": {
    syntax: "<line-width>",
    media: "visual",
    inherited: false,
    animationType: "length",
    percentages: "no",
    groups: ["CSS Backgrounds and Borders"],
    initial: "medium",
    appliesto: "allElements",
    computed: "absoluteLengthOr0IfBorderTopStyleNoneOrHidden",
    order: "uniqueOrder",
    alsoAppliesTo: ["::first-letter"],
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-width",
  },
  "border-width": {
    syntax: "<line-width>{1,4}",
    media: "visual",
    inherited: false,
    animationType: [
      "border-bottom-width",
      "border-left-width",
      "border-right-width",
      "border-top-width",
    ],
    percentages: "no",
    groups: ["CSS Backgrounds and Borders"],
    initial: [
      "border-top-width",
      "border-right-width",
      "border-bottom-width",
      "border-left-width",
    ],
    appliesto: "allElements",
    computed: [
      "border-bottom-width",
      "border-left-width",
      "border-right-width",
      "border-top-width",
    ],
    order: "uniqueOrder",
    alsoAppliesTo: ["::first-letter"],
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-width",
  },
  bottom: bottom$1,
  "box-align": {
    syntax: "start | center | end | baseline | stretch",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["Mozilla Extensions", "WebKit Extensions"],
    initial: "stretch",
    appliesto: "elementsWithDisplayBoxOrInlineBox",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "nonstandard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-align",
  },
  "box-decoration-break": {
    syntax: "slice | clone",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Fragmentation"],
    initial: "slice",
    appliesto: "allElements",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-decoration-break",
  },
  "box-direction": {
    syntax: "normal | reverse | inherit",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["Mozilla Extensions", "WebKit Extensions"],
    initial: "normal",
    appliesto: "elementsWithDisplayBoxOrInlineBox",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "nonstandard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-direction",
  },
  "box-flex": {
    syntax: "<number>",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["Mozilla Extensions", "WebKit Extensions"],
    initial: "0",
    appliesto: "directChildrenOfElementsWithDisplayMozBoxMozInlineBox",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "nonstandard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-flex",
  },
  "box-flex-group": {
    syntax: "<integer>",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["Mozilla Extensions", "WebKit Extensions"],
    initial: "1",
    appliesto: "inFlowChildrenOfBoxElements",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "nonstandard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-flex-group",
  },
  "box-lines": {
    syntax: "single | multiple",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["Mozilla Extensions", "WebKit Extensions"],
    initial: "single",
    appliesto: "boxElements",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "nonstandard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-lines",
  },
  "box-ordinal-group": {
    syntax: "<integer>",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["Mozilla Extensions", "WebKit Extensions"],
    initial: "1",
    appliesto: "childrenOfBoxElements",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "nonstandard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-ordinal-group",
  },
  "box-orient": {
    syntax: "horizontal | vertical | inline-axis | block-axis | inherit",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["Mozilla Extensions", "WebKit Extensions"],
    initial: "inlineAxisHorizontalInXUL",
    appliesto: "elementsWithDisplayBoxOrInlineBox",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "nonstandard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-orient",
  },
  "box-pack": {
    syntax: "start | center | end | justify",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["Mozilla Extensions", "WebKit Extensions"],
    initial: "start",
    appliesto: "elementsWithDisplayMozBoxMozInlineBox",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "nonstandard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-pack",
  },
  "box-shadow": {
    syntax: "none | <shadow>#",
    media: "visual",
    inherited: false,
    animationType: "shadowList",
    percentages: "no",
    groups: ["CSS Backgrounds and Borders"],
    initial: "none",
    appliesto: "allElements",
    computed: "absoluteLengthsSpecifiedColorAsSpecified",
    order: "uniqueOrder",
    alsoAppliesTo: ["::first-letter"],
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-shadow",
  },
  "box-sizing": {
    syntax: "content-box | border-box",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Box Model"],
    initial: "content-box",
    appliesto: "allElementsAcceptingWidthOrHeight",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-sizing",
  },
  "break-after": {
    syntax:
      "auto | avoid | always | all | avoid-page | page | left | right | recto | verso | avoid-column | column | avoid-region | region",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Fragmentation"],
    initial: "auto",
    appliesto: "blockLevelElements",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/break-after",
  },
  "break-before": {
    syntax:
      "auto | avoid | always | all | avoid-page | page | left | right | recto | verso | avoid-column | column | avoid-region | region",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Fragmentation"],
    initial: "auto",
    appliesto: "blockLevelElements",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/break-before",
  },
  "break-inside": {
    syntax: "auto | avoid | avoid-page | avoid-column | avoid-region",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Fragmentation"],
    initial: "auto",
    appliesto: "blockLevelElements",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/break-inside",
  },
  "caption-side": {
    syntax:
      "top | bottom | block-start | block-end | inline-start | inline-end",
    media: "visual",
    inherited: true,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Table"],
    initial: "top",
    appliesto: "tableCaptionElements",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/caption-side",
  },
  caret: caret,
  "caret-color": {
    syntax: "auto | <color>",
    media: "interactive",
    inherited: true,
    animationType: "color",
    percentages: "no",
    groups: ["CSS Basic User Interface"],
    initial: "auto",
    appliesto: "allElements",
    computed: "asAutoOrColor",
    order: "perGrammar",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/caret-color",
  },
  "caret-shape": {
    syntax: "auto | bar | block | underscore",
    media: "interactive",
    inherited: true,
    animationType: "byComputedValueType",
    percentages: "no",
    groups: ["CSS Basic User Interface"],
    initial: "auto",
    appliesto: "elementsThatAcceptInput",
    computed: "asSpecified",
    order: "perGrammar",
    status: "standard",
  },
  clear: clear$1,
  clip: clip$1,
  "clip-path": {
    syntax: "<clip-source> | [ <basic-shape> || <geometry-box> ] | none",
    media: "visual",
    inherited: false,
    animationType: "basicShapeOtherwiseNo",
    percentages: "referToReferenceBoxWhenSpecifiedOtherwiseBorderBox",
    groups: ["CSS Masking"],
    initial: "none",
    appliesto: "allElementsSVGContainerElements",
    computed: "asSpecifiedURLsAbsolute",
    order: "uniqueOrder",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/clip-path",
  },
  color: color$5,
  "print-color-adjust": {
    syntax: "economy | exact",
    media: "visual",
    inherited: true,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Color"],
    initial: "economy",
    appliesto: "allElements",
    computed: "asSpecified",
    order: "perGrammar",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/print-color-adjust",
  },
  "color-scheme": {
    syntax: "normal | [ light | dark | <custom-ident> ]+ && only?",
    media: "visual",
    inherited: true,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Color"],
    initial: "normal",
    appliesto: "allElementsAndText",
    computed: "asSpecified",
    order: "perGrammar",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/color-scheme",
  },
  "column-count": {
    syntax: "<integer> | auto",
    media: "visual",
    inherited: false,
    animationType: "integer",
    percentages: "no",
    groups: ["CSS Columns"],
    initial: "auto",
    appliesto: "blockContainersExceptTableWrappers",
    computed: "asSpecified",
    order: "perGrammar",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-count",
  },
  "column-fill": {
    syntax: "auto | balance | balance-all",
    media: "visualInContinuousMediaNoEffectInOverflowColumns",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Columns"],
    initial: "balance",
    appliesto: "multicolElements",
    computed: "asSpecified",
    order: "perGrammar",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-fill",
  },
  "column-gap": {
    syntax: "normal | <length-percentage>",
    media: "visual",
    inherited: false,
    animationType: "lpc",
    percentages: "referToDimensionOfContentArea",
    groups: ["CSS Box Alignment"],
    initial: "normal",
    appliesto: "multiColumnElementsFlexContainersGridContainers",
    computed:
      "asSpecifiedWithLengthsAbsoluteAndNormalComputingToZeroExceptMultiColumn",
    order: "perGrammar",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-gap",
  },
  "column-rule": {
    syntax:
      "<'column-rule-width'> || <'column-rule-style'> || <'column-rule-color'>",
    media: "visual",
    inherited: false,
    animationType: [
      "column-rule-color",
      "column-rule-style",
      "column-rule-width",
    ],
    percentages: "no",
    groups: ["CSS Columns"],
    initial: ["column-rule-width", "column-rule-style", "column-rule-color"],
    appliesto: "multicolElements",
    computed: ["column-rule-color", "column-rule-style", "column-rule-width"],
    order: "perGrammar",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-rule",
  },
  "column-rule-color": {
    syntax: "<color>",
    media: "visual",
    inherited: false,
    animationType: "color",
    percentages: "no",
    groups: ["CSS Columns"],
    initial: "currentcolor",
    appliesto: "multicolElements",
    computed: "computedColor",
    order: "perGrammar",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-rule-color",
  },
  "column-rule-style": {
    syntax: "<'border-style'>",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Columns"],
    initial: "none",
    appliesto: "multicolElements",
    computed: "asSpecified",
    order: "perGrammar",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-rule-style",
  },
  "column-rule-width": {
    syntax: "<'border-width'>",
    media: "visual",
    inherited: false,
    animationType: "length",
    percentages: "no",
    groups: ["CSS Columns"],
    initial: "medium",
    appliesto: "multicolElements",
    computed: "absoluteLength0IfColumnRuleStyleNoneOrHidden",
    order: "perGrammar",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-rule-width",
  },
  "column-span": {
    syntax: "none | all",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Columns"],
    initial: "none",
    appliesto: "inFlowBlockLevelElements",
    computed: "asSpecified",
    order: "perGrammar",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-span",
  },
  "column-width": {
    syntax: "<length> | auto",
    media: "visual",
    inherited: false,
    animationType: "length",
    percentages: "no",
    groups: ["CSS Columns"],
    initial: "auto",
    appliesto: "blockContainersExceptTableWrappers",
    computed: "absoluteLengthZeroOrLarger",
    order: "perGrammar",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-width",
  },
  columns: columns$1,
  contain: contain$1,
  "contain-intrinsic-size": {
    syntax: "[ none | <length> | auto <length> ]{1,2}",
    media: "visual",
    inherited: false,
    animationType: ["contain-intrinsic-width", "contain-intrinsic-height"],
    percentages: ["contain-intrinsic-width", "contain-intrinsic-height"],
    groups: ["CSS Containment"],
    initial: ["contain-intrinsic-width", "contain-intrinsic-height"],
    appliesto: "elementsForWhichSizeContainmentCanApply",
    computed: ["contain-intrinsic-width", "contain-intrinsic-height"],
    order: "perGrammar",
    status: "experimental",
    mdn_url:
      "https://developer.mozilla.org/docs/Web/CSS/contain-intrinsic-size",
  },
  "contain-intrinsic-block-size": {
    syntax: "none | <length> | auto <length>",
    inherited: false,
    animationType: "byComputedValueType",
    percentages: "no",
    groups: ["CSS Containment"],
    initial: "none",
    appliesto: "elementsForWhichSizeContainmentCanApply",
    computed: "asSpecifiedWithLengthValuesComputed",
    order: "perGrammar",
    status: "experimental",
    mdn_url:
      "https://developer.mozilla.org/docs/Web/CSS/contain-intrinsic-block-size",
  },
  "contain-intrinsic-height": {
    syntax: "none | <length> | auto <length>",
    inherited: false,
    animationType: "byComputedValueType",
    percentages: "no",
    groups: ["CSS Containment"],
    initial: "none",
    appliesto: "elementsForWhichSizeContainmentCanApply",
    computed: "asSpecifiedWithLengthValuesComputed",
    order: "perGrammar",
    status: "experimental",
    mdn_url:
      "https://developer.mozilla.org/docs/Web/CSS/contain-intrinsic-height",
  },
  "contain-intrinsic-inline-size": {
    syntax: "none | <length> | auto <length>",
    inherited: false,
    animationType: "byComputedValueType",
    percentages: "no",
    groups: ["CSS Containment"],
    initial: "none",
    appliesto: "elementsForWhichSizeContainmentCanApply",
    computed: "asSpecifiedWithLengthValuesComputed",
    order: "perGrammar",
    status: "experimental",
    mdn_url:
      "https://developer.mozilla.org/docs/Web/CSS/contain-intrinsic-inline-size",
  },
  "contain-intrinsic-width": {
    syntax: "none | <length> | auto <length>",
    media: "visual",
    inherited: false,
    animationType: "byComputedValueType",
    percentages: "no",
    groups: ["CSS Containment"],
    initial: "none",
    appliesto: "elementsForWhichSizeContainmentCanApply",
    computed: "asSpecifiedWithLengthValuesComputed",
    order: "perGrammar",
    status: "experimental",
    mdn_url:
      "https://developer.mozilla.org/docs/Web/CSS/contain-intrinsic-width",
  },
  content: content$1,
  "content-visibility": {
    syntax: "visible | auto | hidden",
    media: "all",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Containment"],
    initial: "visible",
    appliesto: "elementsForWhichLayoutContainmentCanApply",
    computed: "asSpecified",
    order: "perGrammar",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/content-visibility",
  },
  "counter-increment": {
    syntax: "[ <counter-name> <integer>? ]+ | none",
    media: "all",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Counter Styles"],
    initial: "none",
    appliesto: "allElements",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/counter-increment",
  },
  "counter-reset": {
    syntax:
      "[ <counter-name> <integer>? | <reversed-counter-name> <integer>? ]+ | none",
    media: "all",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Counter Styles"],
    initial: "none",
    appliesto: "allElements",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/counter-reset",
  },
  "counter-set": {
    syntax: "[ <counter-name> <integer>? ]+ | none",
    media: "all",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Counter Styles"],
    initial: "none",
    appliesto: "allElements",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/counter-set",
  },
  cursor: cursor$1,
  direction: direction$1,
  display: display$1,
  "empty-cells": {
    syntax: "show | hide",
    media: "visual",
    inherited: true,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Table"],
    initial: "show",
    appliesto: "tableCellElements",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/empty-cells",
  },
  filter: filter$1,
  flex: flex$1,
  "flex-basis": {
    syntax: "content | <'width'>",
    media: "visual",
    inherited: false,
    animationType: "lpc",
    percentages: "referToFlexContainersInnerMainSize",
    groups: ["CSS Flexible Box Layout"],
    initial: "auto",
    appliesto: "flexItemsAndInFlowPseudos",
    computed: "asSpecifiedRelativeToAbsoluteLengths",
    order: "lengthOrPercentageBeforeKeywordIfBothPresent",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-basis",
  },
  "flex-direction": {
    syntax: "row | row-reverse | column | column-reverse",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Flexible Box Layout"],
    initial: "row",
    appliesto: "flexContainers",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-direction",
  },
  "flex-flow": {
    syntax: "<'flex-direction'> || <'flex-wrap'>",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Flexible Box Layout"],
    initial: ["flex-direction", "flex-wrap"],
    appliesto: "flexContainers",
    computed: ["flex-direction", "flex-wrap"],
    order: "orderOfAppearance",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-flow",
  },
  "flex-grow": {
    syntax: "<number>",
    media: "visual",
    inherited: false,
    animationType: "number",
    percentages: "no",
    groups: ["CSS Flexible Box Layout"],
    initial: "0",
    appliesto: "flexItemsAndInFlowPseudos",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-grow",
  },
  "flex-shrink": {
    syntax: "<number>",
    media: "visual",
    inherited: false,
    animationType: "number",
    percentages: "no",
    groups: ["CSS Flexible Box Layout"],
    initial: "1",
    appliesto: "flexItemsAndInFlowPseudos",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-shrink",
  },
  "flex-wrap": {
    syntax: "nowrap | wrap | wrap-reverse",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Flexible Box Layout"],
    initial: "nowrap",
    appliesto: "flexContainers",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-wrap",
  },
  float: float$1,
  font: font$3,
  "font-family": {
    syntax: "[ <family-name> | <generic-family> ]#",
    media: "visual",
    inherited: true,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Fonts"],
    initial: "dependsOnUserAgent",
    appliesto: "allElements",
    computed: "asSpecified",
    order: "uniqueOrder",
    alsoAppliesTo: ["::first-letter", "::first-line", "::placeholder"],
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-family",
  },
  "font-feature-settings": {
    syntax: "normal | <feature-tag-value>#",
    media: "visual",
    inherited: true,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Fonts"],
    initial: "normal",
    appliesto: "allElements",
    computed: "asSpecified",
    order: "uniqueOrder",
    alsoAppliesTo: ["::first-letter", "::first-line", "::placeholder"],
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-feature-settings",
  },
  "font-kerning": {
    syntax: "auto | normal | none",
    media: "visual",
    inherited: true,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Fonts"],
    initial: "auto",
    appliesto: "allElements",
    computed: "asSpecified",
    order: "uniqueOrder",
    alsoAppliesTo: ["::first-letter", "::first-line", "::placeholder"],
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-kerning",
  },
  "font-language-override": {
    syntax: "normal | <string>",
    media: "visual",
    inherited: true,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Fonts"],
    initial: "normal",
    appliesto: "allElements",
    computed: "asSpecified",
    order: "uniqueOrder",
    alsoAppliesTo: ["::first-letter", "::first-line", "::placeholder"],
    status: "standard",
    mdn_url:
      "https://developer.mozilla.org/docs/Web/CSS/font-language-override",
  },
  "font-optical-sizing": {
    syntax: "auto | none",
    media: "visual",
    inherited: true,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Fonts"],
    initial: "auto",
    appliesto: "allElements",
    computed: "asSpecified",
    order: "perGrammar",
    alsoAppliesTo: ["::first-letter", "::first-line", "::placeholder"],
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-optical-sizing",
  },
  "font-variation-settings": {
    syntax: "normal | [ <string> <number> ]#",
    media: "visual",
    inherited: true,
    animationType: "transform",
    percentages: "no",
    groups: ["CSS Fonts"],
    initial: "normal",
    appliesto: "allElements",
    computed: "asSpecified",
    order: "perGrammar",
    alsoAppliesTo: ["::first-letter", "::first-line", "::placeholder"],
    status: "standard",
    mdn_url:
      "https://developer.mozilla.org/docs/Web/CSS/font-variation-settings",
  },
  "font-size": {
    syntax: "<absolute-size> | <relative-size> | <length-percentage>",
    media: "visual",
    inherited: true,
    animationType: "length",
    percentages: "referToParentElementsFontSize",
    groups: ["CSS Fonts"],
    initial: "medium",
    appliesto: "allElements",
    computed: "asSpecifiedRelativeToAbsoluteLengths",
    order: "uniqueOrder",
    alsoAppliesTo: ["::first-letter", "::first-line", "::placeholder"],
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-size",
  },
  "font-size-adjust": {
    syntax:
      "none | [ ex-height | cap-height | ch-width | ic-width | ic-height ]? [ from-font | <number> ]",
    media: "visual",
    inherited: true,
    animationType: "number",
    percentages: "no",
    groups: ["CSS Fonts"],
    initial: "none",
    appliesto: "allElements",
    computed: "asSpecified",
    order: "uniqueOrder",
    alsoAppliesTo: ["::first-letter", "::first-line", "::placeholder"],
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-size-adjust",
  },
  "font-smooth": {
    syntax: "auto | never | always | <absolute-size> | <length>",
    media: "visual",
    inherited: true,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Fonts"],
    initial: "auto",
    appliesto: "allElements",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "nonstandard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-smooth",
  },
  "font-stretch": {
    syntax: "<font-stretch-absolute>",
    media: "visual",
    inherited: true,
    animationType: "fontStretch",
    percentages: "no",
    groups: ["CSS Fonts"],
    initial: "normal",
    appliesto: "allElements",
    computed: "asSpecified",
    order: "uniqueOrder",
    alsoAppliesTo: ["::first-letter", "::first-line", "::placeholder"],
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-stretch",
  },
  "font-style": {
    syntax: "normal | italic | oblique <angle>?",
    media: "visual",
    inherited: true,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Fonts"],
    initial: "normal",
    appliesto: "allElements",
    computed: "asSpecified",
    order: "uniqueOrder",
    alsoAppliesTo: ["::first-letter", "::first-line", "::placeholder"],
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-style",
  },
  "font-synthesis": {
    syntax: "none | [ weight || style || small-caps ]",
    media: "visual",
    inherited: true,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Fonts"],
    initial: "weight style",
    appliesto: "allElements",
    computed: "asSpecified",
    order: "orderOfAppearance",
    alsoAppliesTo: ["::first-letter", "::first-line", "::placeholder"],
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-synthesis",
  },
  "font-variant": {
    syntax:
      "normal | none | [ <common-lig-values> || <discretionary-lig-values> || <historical-lig-values> || <contextual-alt-values> || stylistic( <feature-value-name> ) || historical-forms || styleset( <feature-value-name># ) || character-variant( <feature-value-name># ) || swash( <feature-value-name> ) || ornaments( <feature-value-name> ) || annotation( <feature-value-name> ) || [ small-caps | all-small-caps | petite-caps | all-petite-caps | unicase | titling-caps ] || <numeric-figure-values> || <numeric-spacing-values> || <numeric-fraction-values> || ordinal || slashed-zero || <east-asian-variant-values> || <east-asian-width-values> || ruby ]",
    media: "visual",
    inherited: true,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Fonts"],
    initial: "normal",
    appliesto: "allElements",
    computed: "asSpecified",
    order: "uniqueOrder",
    alsoAppliesTo: ["::first-letter", "::first-line", "::placeholder"],
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant",
  },
  "font-variant-alternates": {
    syntax:
      "normal | [ stylistic( <feature-value-name> ) || historical-forms || styleset( <feature-value-name># ) || character-variant( <feature-value-name># ) || swash( <feature-value-name> ) || ornaments( <feature-value-name> ) || annotation( <feature-value-name> ) ]",
    media: "visual",
    inherited: true,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Fonts"],
    initial: "normal",
    appliesto: "allElements",
    computed: "asSpecified",
    order: "orderOfAppearance",
    alsoAppliesTo: ["::first-letter", "::first-line", "::placeholder"],
    status: "standard",
    mdn_url:
      "https://developer.mozilla.org/docs/Web/CSS/font-variant-alternates",
  },
  "font-variant-caps": {
    syntax:
      "normal | small-caps | all-small-caps | petite-caps | all-petite-caps | unicase | titling-caps",
    media: "visual",
    inherited: true,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Fonts"],
    initial: "normal",
    appliesto: "allElements",
    computed: "asSpecified",
    order: "uniqueOrder",
    alsoAppliesTo: ["::first-letter", "::first-line", "::placeholder"],
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-caps",
  },
  "font-variant-east-asian": {
    syntax:
      "normal | [ <east-asian-variant-values> || <east-asian-width-values> || ruby ]",
    media: "visual",
    inherited: true,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Fonts"],
    initial: "normal",
    appliesto: "allElements",
    computed: "asSpecified",
    order: "orderOfAppearance",
    alsoAppliesTo: ["::first-letter", "::first-line", "::placeholder"],
    status: "standard",
    mdn_url:
      "https://developer.mozilla.org/docs/Web/CSS/font-variant-east-asian",
  },
  "font-variant-ligatures": {
    syntax:
      "normal | none | [ <common-lig-values> || <discretionary-lig-values> || <historical-lig-values> || <contextual-alt-values> ]",
    media: "visual",
    inherited: true,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Fonts"],
    initial: "normal",
    appliesto: "allElements",
    computed: "asSpecified",
    order: "orderOfAppearance",
    alsoAppliesTo: ["::first-letter", "::first-line", "::placeholder"],
    status: "standard",
    mdn_url:
      "https://developer.mozilla.org/docs/Web/CSS/font-variant-ligatures",
  },
  "font-variant-numeric": {
    syntax:
      "normal | [ <numeric-figure-values> || <numeric-spacing-values> || <numeric-fraction-values> || ordinal || slashed-zero ]",
    media: "visual",
    inherited: true,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Fonts"],
    initial: "normal",
    appliesto: "allElements",
    computed: "asSpecified",
    order: "orderOfAppearance",
    alsoAppliesTo: ["::first-letter", "::first-line", "::placeholder"],
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-numeric",
  },
  "font-variant-position": {
    syntax: "normal | sub | super",
    media: "visual",
    inherited: true,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Fonts"],
    initial: "normal",
    appliesto: "allElements",
    computed: "asSpecified",
    order: "uniqueOrder",
    alsoAppliesTo: ["::first-letter", "::first-line", "::placeholder"],
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-position",
  },
  "font-weight": {
    syntax: "<font-weight-absolute> | bolder | lighter",
    media: "visual",
    inherited: true,
    animationType: "fontWeight",
    percentages: "no",
    groups: ["CSS Fonts"],
    initial: "normal",
    appliesto: "allElements",
    computed: "keywordOrNumericalValueBolderLighterTransformedToRealValue",
    order: "uniqueOrder",
    alsoAppliesTo: ["::first-letter", "::first-line", "::placeholder"],
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-weight",
  },
  "forced-color-adjust": {
    syntax: "auto | none",
    media: "visual",
    inherited: true,
    animationType: "notAnimatable",
    percentages: "no",
    groups: ["CSS Color"],
    initial: "auto",
    appliesto: "allElementsAndText",
    computed: "asSpecified",
    order: "perGrammar",
    status: "experimental",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/forced-color-adjust",
  },
  gap: gap$1,
  grid: grid$1,
  "grid-area": {
    syntax: "<grid-line> [ / <grid-line> ]{0,3}",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Grid Layout"],
    initial: [
      "grid-row-start",
      "grid-column-start",
      "grid-row-end",
      "grid-column-end",
    ],
    appliesto: "gridItemsAndBoxesWithinGridContainer",
    computed: [
      "grid-row-start",
      "grid-column-start",
      "grid-row-end",
      "grid-column-end",
    ],
    order: "uniqueOrder",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-area",
  },
  "grid-auto-columns": {
    syntax: "<track-size>+",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "referToDimensionOfContentArea",
    groups: ["CSS Grid Layout"],
    initial: "auto",
    appliesto: "gridContainers",
    computed: "percentageAsSpecifiedOrAbsoluteLength",
    order: "uniqueOrder",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-auto-columns",
  },
  "grid-auto-flow": {
    syntax: "[ row | column ] || dense",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Grid Layout"],
    initial: "row",
    appliesto: "gridContainers",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-auto-flow",
  },
  "grid-auto-rows": {
    syntax: "<track-size>+",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "referToDimensionOfContentArea",
    groups: ["CSS Grid Layout"],
    initial: "auto",
    appliesto: "gridContainers",
    computed: "percentageAsSpecifiedOrAbsoluteLength",
    order: "uniqueOrder",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-auto-rows",
  },
  "grid-column": {
    syntax: "<grid-line> [ / <grid-line> ]?",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Grid Layout"],
    initial: ["grid-column-start", "grid-column-end"],
    appliesto: "gridItemsAndBoxesWithinGridContainer",
    computed: ["grid-column-start", "grid-column-end"],
    order: "uniqueOrder",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-column",
  },
  "grid-column-end": {
    syntax: "<grid-line>",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Grid Layout"],
    initial: "auto",
    appliesto: "gridItemsAndBoxesWithinGridContainer",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-column-end",
  },
  "grid-column-gap": {
    syntax: "<length-percentage>",
    media: "visual",
    inherited: false,
    animationType: "length",
    percentages: "referToDimensionOfContentArea",
    groups: ["CSS Grid Layout"],
    initial: "0",
    appliesto: "gridContainers",
    computed: "percentageAsSpecifiedOrAbsoluteLength",
    order: "uniqueOrder",
    status: "obsolete",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-gap",
  },
  "grid-column-start": {
    syntax: "<grid-line>",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Grid Layout"],
    initial: "auto",
    appliesto: "gridItemsAndBoxesWithinGridContainer",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-column-start",
  },
  "grid-gap": {
    syntax: "<'grid-row-gap'> <'grid-column-gap'>?",
    media: "visual",
    inherited: false,
    animationType: ["grid-row-gap", "grid-column-gap"],
    percentages: "no",
    groups: ["CSS Grid Layout"],
    initial: ["grid-row-gap", "grid-column-gap"],
    appliesto: "gridContainers",
    computed: ["grid-row-gap", "grid-column-gap"],
    order: "uniqueOrder",
    status: "obsolete",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/gap",
  },
  "grid-row": {
    syntax: "<grid-line> [ / <grid-line> ]?",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Grid Layout"],
    initial: ["grid-row-start", "grid-row-end"],
    appliesto: "gridItemsAndBoxesWithinGridContainer",
    computed: ["grid-row-start", "grid-row-end"],
    order: "uniqueOrder",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-row",
  },
  "grid-row-end": {
    syntax: "<grid-line>",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Grid Layout"],
    initial: "auto",
    appliesto: "gridItemsAndBoxesWithinGridContainer",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-row-end",
  },
  "grid-row-gap": {
    syntax: "<length-percentage>",
    media: "visual",
    inherited: false,
    animationType: "length",
    percentages: "referToDimensionOfContentArea",
    groups: ["CSS Grid Layout"],
    initial: "0",
    appliesto: "gridContainers",
    computed: "percentageAsSpecifiedOrAbsoluteLength",
    order: "uniqueOrder",
    status: "obsolete",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/row-gap",
  },
  "grid-row-start": {
    syntax: "<grid-line>",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Grid Layout"],
    initial: "auto",
    appliesto: "gridItemsAndBoxesWithinGridContainer",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-row-start",
  },
  "grid-template": {
    syntax:
      "none | [ <'grid-template-rows'> / <'grid-template-columns'> ] | [ <line-names>? <string> <track-size>? <line-names>? ]+ [ / <explicit-track-list> ]?",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: ["grid-template-columns", "grid-template-rows"],
    groups: ["CSS Grid Layout"],
    initial: [
      "grid-template-columns",
      "grid-template-rows",
      "grid-template-areas",
    ],
    appliesto: "gridContainers",
    computed: [
      "grid-template-columns",
      "grid-template-rows",
      "grid-template-areas",
    ],
    order: "uniqueOrder",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-template",
  },
  "grid-template-areas": {
    syntax: "none | <string>+",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Grid Layout"],
    initial: "none",
    appliesto: "gridContainers",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-template-areas",
  },
  "grid-template-columns": {
    syntax:
      "none | <track-list> | <auto-track-list> | subgrid <line-name-list>?",
    media: "visual",
    inherited: false,
    animationType: "simpleListOfLpcDifferenceLpc",
    percentages: "referToDimensionOfContentArea",
    groups: ["CSS Grid Layout"],
    initial: "none",
    appliesto: "gridContainers",
    computed: "asSpecifiedRelativeToAbsoluteLengths",
    order: "uniqueOrder",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-template-columns",
  },
  "grid-template-rows": {
    syntax:
      "none | <track-list> | <auto-track-list> | subgrid <line-name-list>?",
    media: "visual",
    inherited: false,
    animationType: "simpleListOfLpcDifferenceLpc",
    percentages: "referToDimensionOfContentArea",
    groups: ["CSS Grid Layout"],
    initial: "none",
    appliesto: "gridContainers",
    computed: "asSpecifiedRelativeToAbsoluteLengths",
    order: "uniqueOrder",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-template-rows",
  },
  "hanging-punctuation": {
    syntax: "none | [ first || [ force-end | allow-end ] || last ]",
    media: "visual",
    inherited: true,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Text"],
    initial: "none",
    appliesto: "allElements",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/hanging-punctuation",
  },
  height: height$1,
  "hyphenate-character": {
    syntax: "auto | <string>",
    media: "visual",
    inherited: true,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Text"],
    initial: "auto",
    appliesto: "allElements",
    computed: "asSpecified",
    order: "perGrammar",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/hyphenate-character",
  },
  hyphens: hyphens$1,
  "image-orientation": {
    syntax: "from-image | <angle> | [ <angle>? flip ]",
    media: "visual",
    inherited: true,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Images"],
    initial: "from-image",
    appliesto: "allElements",
    computed: "angleRoundedToNextQuarter",
    order: "uniqueOrder",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/image-orientation",
  },
  "image-rendering": {
    syntax: "auto | crisp-edges | pixelated",
    media: "visual",
    inherited: true,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Images"],
    initial: "auto",
    appliesto: "allElements",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/image-rendering",
  },
  "image-resolution": {
    syntax: "[ from-image || <resolution> ] && snap?",
    media: "visual",
    inherited: true,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Images"],
    initial: "1dppx",
    appliesto: "allElements",
    computed: "asSpecifiedWithExceptionOfResolution",
    order: "uniqueOrder",
    status: "experimental",
  },
  "ime-mode": {
    syntax: "auto | normal | active | inactive | disabled",
    media: "interactive",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Basic User Interface"],
    initial: "auto",
    appliesto: "textFields",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "obsolete",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/ime-mode",
  },
  "initial-letter": {
    syntax: "normal | [ <number> <integer>? ]",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Inline"],
    initial: "normal",
    appliesto: "firstLetterPseudoElementsAndInlineLevelFirstChildren",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "experimental",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/initial-letter",
  },
  "initial-letter-align": {
    syntax: "[ auto | alphabetic | hanging | ideographic ]",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Inline"],
    initial: "auto",
    appliesto: "firstLetterPseudoElementsAndInlineLevelFirstChildren",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "experimental",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/initial-letter-align",
  },
  "inline-size": {
    syntax: "<'width'>",
    media: "visual",
    inherited: false,
    animationType: "lpc",
    percentages: "inlineSizeOfContainingBlock",
    groups: ["CSS Logical Properties"],
    initial: "auto",
    appliesto: "sameAsWidthAndHeight",
    computed: "sameAsWidthAndHeight",
    order: "uniqueOrder",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inline-size",
  },
  "input-security": {
    syntax: "auto | none",
    media: "interactive",
    inherited: false,
    animationType: "byComputedValueType",
    percentages: "no",
    groups: ["CSS Basic User Interface"],
    initial: "auto",
    appliesto: "sensitiveTextInputs",
    computed: "asSpecified",
    order: "perGrammar",
    status: "standard",
  },
  inset: inset$1,
  "inset-block": {
    syntax: "<'top'>{1,2}",
    media: "visual",
    inherited: false,
    animationType: "lpc",
    percentages: "logicalHeightOfContainingBlock",
    groups: ["CSS Logical Properties"],
    initial: ["inset-block-start", "inset-block-end"],
    appliesto: "positionedElements",
    computed: ["inset-block-start", "inset-block-end"],
    order: "uniqueOrder",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-block",
  },
  "inset-block-end": {
    syntax: "<'top'>",
    media: "visual",
    inherited: false,
    animationType: "lpc",
    percentages: "logicalHeightOfContainingBlock",
    groups: ["CSS Logical Properties"],
    initial: "auto",
    appliesto: "positionedElements",
    computed: "sameAsBoxOffsets",
    order: "uniqueOrder",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-block-end",
  },
  "inset-block-start": {
    syntax: "<'top'>",
    media: "visual",
    inherited: false,
    animationType: "lpc",
    percentages: "logicalHeightOfContainingBlock",
    groups: ["CSS Logical Properties"],
    initial: "auto",
    appliesto: "positionedElements",
    computed: "sameAsBoxOffsets",
    order: "uniqueOrder",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-block-start",
  },
  "inset-inline": {
    syntax: "<'top'>{1,2}",
    media: "visual",
    inherited: false,
    animationType: "lpc",
    percentages: "logicalWidthOfContainingBlock",
    groups: ["CSS Logical Properties"],
    initial: ["inset-inline-start", "inset-inline-end"],
    appliesto: "positionedElements",
    computed: ["inset-inline-start", "inset-inline-end"],
    order: "uniqueOrder",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-inline",
  },
  "inset-inline-end": {
    syntax: "<'top'>",
    media: "visual",
    inherited: false,
    animationType: "lpc",
    percentages: "logicalWidthOfContainingBlock",
    groups: ["CSS Logical Properties"],
    initial: "auto",
    appliesto: "positionedElements",
    computed: "sameAsBoxOffsets",
    order: "uniqueOrder",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-inline-end",
  },
  "inset-inline-start": {
    syntax: "<'top'>",
    media: "visual",
    inherited: false,
    animationType: "lpc",
    percentages: "logicalWidthOfContainingBlock",
    groups: ["CSS Logical Properties"],
    initial: "auto",
    appliesto: "positionedElements",
    computed: "sameAsBoxOffsets",
    order: "uniqueOrder",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-inline-start",
  },
  isolation: isolation$1,
  "justify-content": {
    syntax:
      "normal | <content-distribution> | <overflow-position>? [ <content-position> | left | right ]",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Box Alignment"],
    initial: "normal",
    appliesto: "flexContainers",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/justify-content",
  },
  "justify-items": {
    syntax:
      "normal | stretch | <baseline-position> | <overflow-position>? [ <self-position> | left | right ] | legacy | legacy && [ left | right | center ]",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Box Alignment"],
    initial: "legacy",
    appliesto: "allElements",
    computed: "asSpecified",
    order: "perGrammar",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/justify-items",
  },
  "justify-self": {
    syntax:
      "auto | normal | stretch | <baseline-position> | <overflow-position>? [ <self-position> | left | right ]",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Box Alignment"],
    initial: "auto",
    appliesto: "blockLevelBoxesAndAbsolutelyPositionedBoxesAndGridItems",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/justify-self",
  },
  "justify-tracks": {
    syntax:
      "[ normal | <content-distribution> | <overflow-position>? [ <content-position> | left | right ] ]#",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Grid Layout"],
    initial: "normal",
    appliesto: "gridContainersWithMasonryLayoutInTheirInlineAxis",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "experimental",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/justify-tracks",
  },
  left: left$1,
  "letter-spacing": {
    syntax: "normal | <length>",
    media: "visual",
    inherited: true,
    animationType: "length",
    percentages: "no",
    groups: ["CSS Text"],
    initial: "normal",
    appliesto: "allElements",
    computed: "optimumValueOfAbsoluteLengthOrNormal",
    order: "uniqueOrder",
    alsoAppliesTo: ["::first-letter", "::first-line"],
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/letter-spacing",
  },
  "line-break": {
    syntax: "auto | loose | normal | strict | anywhere",
    media: "visual",
    inherited: true,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Text"],
    initial: "auto",
    appliesto: "allElements",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/line-break",
  },
  "line-clamp": {
    syntax: "none | <integer>",
    media: "visual",
    inherited: false,
    animationType: "integer",
    percentages: "no",
    groups: ["CSS Overflow"],
    initial: "none",
    appliesto: "blockContainersExceptMultiColumnContainers",
    computed: "asSpecified",
    order: "perGrammar",
    status: "experimental",
  },
  "line-height": {
    syntax: "normal | <number> | <length> | <percentage>",
    media: "visual",
    inherited: true,
    animationType: "numberOrLength",
    percentages: "referToElementFontSize",
    groups: ["CSS Fonts"],
    initial: "normal",
    appliesto: "allElements",
    computed: "absoluteLengthOrAsSpecified",
    order: "uniqueOrder",
    alsoAppliesTo: ["::first-letter", "::first-line", "::placeholder"],
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/line-height",
  },
  "line-height-step": {
    syntax: "<length>",
    media: "visual",
    inherited: true,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Fonts"],
    initial: "0",
    appliesto: "blockContainers",
    computed: "absoluteLength",
    order: "perGrammar",
    status: "experimental",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/line-height-step",
  },
  "list-style": {
    syntax:
      "<'list-style-type'> || <'list-style-position'> || <'list-style-image'>",
    media: "visual",
    inherited: true,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Lists and Counters"],
    initial: ["list-style-type", "list-style-position", "list-style-image"],
    appliesto: "listItems",
    computed: ["list-style-image", "list-style-position", "list-style-type"],
    order: "orderOfAppearance",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/list-style",
  },
  "list-style-image": {
    syntax: "<image> | none",
    media: "visual",
    inherited: true,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Lists and Counters"],
    initial: "none",
    appliesto: "listItems",
    computed: "theKeywordListStyleImageNoneOrComputedValue",
    order: "uniqueOrder",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/list-style-image",
  },
  "list-style-position": {
    syntax: "inside | outside",
    media: "visual",
    inherited: true,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Lists and Counters"],
    initial: "outside",
    appliesto: "listItems",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/list-style-position",
  },
  "list-style-type": {
    syntax: "<counter-style> | <string> | none",
    media: "visual",
    inherited: true,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Lists and Counters"],
    initial: "disc",
    appliesto: "listItems",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/list-style-type",
  },
  margin: margin$1,
  "margin-block": {
    syntax: "<'margin-left'>{1,2}",
    media: "visual",
    inherited: false,
    animationType: "length",
    percentages: "dependsOnLayoutModel",
    groups: ["CSS Logical Properties"],
    initial: ["margin-block-start", "margin-block-end"],
    appliesto: "sameAsMargin",
    computed: ["margin-block-start", "margin-block-end"],
    order: "uniqueOrder",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-block",
  },
  "margin-block-end": {
    syntax: "<'margin-left'>",
    media: "visual",
    inherited: false,
    animationType: "length",
    percentages: "dependsOnLayoutModel",
    groups: ["CSS Logical Properties"],
    initial: "0",
    appliesto: "sameAsMargin",
    computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
    order: "uniqueOrder",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-block-end",
  },
  "margin-block-start": {
    syntax: "<'margin-left'>",
    media: "visual",
    inherited: false,
    animationType: "length",
    percentages: "dependsOnLayoutModel",
    groups: ["CSS Logical Properties"],
    initial: "0",
    appliesto: "sameAsMargin",
    computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
    order: "uniqueOrder",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-block-start",
  },
  "margin-bottom": {
    syntax: "<length> | <percentage> | auto",
    media: "visual",
    inherited: false,
    animationType: "length",
    percentages: "referToWidthOfContainingBlock",
    groups: ["CSS Box Model"],
    initial: "0",
    appliesto: "allElementsExceptTableDisplayTypes",
    computed: "percentageAsSpecifiedOrAbsoluteLength",
    order: "uniqueOrder",
    alsoAppliesTo: ["::first-letter", "::first-line"],
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-bottom",
  },
  "margin-inline": {
    syntax: "<'margin-left'>{1,2}",
    media: "visual",
    inherited: false,
    animationType: "length",
    percentages: "dependsOnLayoutModel",
    groups: ["CSS Logical Properties"],
    initial: ["margin-inline-start", "margin-inline-end"],
    appliesto: "sameAsMargin",
    computed: ["margin-inline-start", "margin-inline-end"],
    order: "uniqueOrder",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-inline",
  },
  "margin-inline-end": {
    syntax: "<'margin-left'>",
    media: "visual",
    inherited: false,
    animationType: "length",
    percentages: "dependsOnLayoutModel",
    groups: ["CSS Logical Properties"],
    initial: "0",
    appliesto: "sameAsMargin",
    computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
    order: "uniqueOrder",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-inline-end",
  },
  "margin-inline-start": {
    syntax: "<'margin-left'>",
    media: "visual",
    inherited: false,
    animationType: "length",
    percentages: "dependsOnLayoutModel",
    groups: ["CSS Logical Properties"],
    initial: "0",
    appliesto: "sameAsMargin",
    computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
    order: "uniqueOrder",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-inline-start",
  },
  "margin-left": {
    syntax: "<length> | <percentage> | auto",
    media: "visual",
    inherited: false,
    animationType: "length",
    percentages: "referToWidthOfContainingBlock",
    groups: ["CSS Box Model"],
    initial: "0",
    appliesto: "allElementsExceptTableDisplayTypes",
    computed: "percentageAsSpecifiedOrAbsoluteLength",
    order: "uniqueOrder",
    alsoAppliesTo: ["::first-letter", "::first-line"],
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-left",
  },
  "margin-right": {
    syntax: "<length> | <percentage> | auto",
    media: "visual",
    inherited: false,
    animationType: "length",
    percentages: "referToWidthOfContainingBlock",
    groups: ["CSS Box Model"],
    initial: "0",
    appliesto: "allElementsExceptTableDisplayTypes",
    computed: "percentageAsSpecifiedOrAbsoluteLength",
    order: "uniqueOrder",
    alsoAppliesTo: ["::first-letter", "::first-line"],
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-right",
  },
  "margin-top": {
    syntax: "<length> | <percentage> | auto",
    media: "visual",
    inherited: false,
    animationType: "length",
    percentages: "referToWidthOfContainingBlock",
    groups: ["CSS Box Model"],
    initial: "0",
    appliesto: "allElementsExceptTableDisplayTypes",
    computed: "percentageAsSpecifiedOrAbsoluteLength",
    order: "uniqueOrder",
    alsoAppliesTo: ["::first-letter", "::first-line"],
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-top",
  },
  "margin-trim": {
    syntax: "none | in-flow | all",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Box Model"],
    initial: "none",
    appliesto: "blockContainersAndMultiColumnContainers",
    computed: "asSpecified",
    order: "perGrammar",
    alsoAppliesTo: ["::first-letter", "::first-line"],
    status: "experimental",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-trim",
  },
  mask: mask$1,
  "mask-border": {
    syntax:
      "<'mask-border-source'> || <'mask-border-slice'> [ / <'mask-border-width'>? [ / <'mask-border-outset'> ]? ]? || <'mask-border-repeat'> || <'mask-border-mode'>",
    media: "visual",
    inherited: false,
    animationType: [
      "mask-border-mode",
      "mask-border-outset",
      "mask-border-repeat",
      "mask-border-slice",
      "mask-border-source",
      "mask-border-width",
    ],
    percentages: ["mask-border-slice", "mask-border-width"],
    groups: ["CSS Masking"],
    initial: [
      "mask-border-mode",
      "mask-border-outset",
      "mask-border-repeat",
      "mask-border-slice",
      "mask-border-source",
      "mask-border-width",
    ],
    appliesto: "allElementsSVGContainerElements",
    computed: [
      "mask-border-mode",
      "mask-border-outset",
      "mask-border-repeat",
      "mask-border-slice",
      "mask-border-source",
      "mask-border-width",
    ],
    order: "perGrammar",
    stacking: true,
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border",
  },
  "mask-border-mode": {
    syntax: "luminance | alpha",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Masking"],
    initial: "alpha",
    appliesto: "allElementsSVGContainerElements",
    computed: "asSpecified",
    order: "perGrammar",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-mode",
  },
  "mask-border-outset": {
    syntax: "[ <length> | <number> ]{1,4}",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Masking"],
    initial: "0",
    appliesto: "allElementsSVGContainerElements",
    computed: "asSpecifiedRelativeToAbsoluteLengths",
    order: "perGrammar",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-outset",
  },
  "mask-border-repeat": {
    syntax: "[ stretch | repeat | round | space ]{1,2}",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Masking"],
    initial: "stretch",
    appliesto: "allElementsSVGContainerElements",
    computed: "asSpecified",
    order: "perGrammar",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-repeat",
  },
  "mask-border-slice": {
    syntax: "<number-percentage>{1,4} fill?",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "referToSizeOfMaskBorderImage",
    groups: ["CSS Masking"],
    initial: "0",
    appliesto: "allElementsSVGContainerElements",
    computed: "asSpecified",
    order: "perGrammar",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-slice",
  },
  "mask-border-source": {
    syntax: "none | <image>",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Masking"],
    initial: "none",
    appliesto: "allElementsSVGContainerElements",
    computed: "asSpecifiedURLsAbsolute",
    order: "perGrammar",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-source",
  },
  "mask-border-width": {
    syntax: "[ <length-percentage> | <number> | auto ]{1,4}",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "relativeToMaskBorderImageArea",
    groups: ["CSS Masking"],
    initial: "auto",
    appliesto: "allElementsSVGContainerElements",
    computed: "asSpecifiedRelativeToAbsoluteLengths",
    order: "perGrammar",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-width",
  },
  "mask-clip": {
    syntax: "[ <geometry-box> | no-clip ]#",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Masking"],
    initial: "border-box",
    appliesto: "allElementsSVGContainerElements",
    computed: "asSpecified",
    order: "perGrammar",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-clip",
  },
  "mask-composite": {
    syntax: "<compositing-operator>#",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Masking"],
    initial: "add",
    appliesto: "allElementsSVGContainerElements",
    computed: "asSpecified",
    order: "perGrammar",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-composite",
  },
  "mask-image": {
    syntax: "<mask-reference>#",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Masking"],
    initial: "none",
    appliesto: "allElementsSVGContainerElements",
    computed: "asSpecifiedURLsAbsolute",
    order: "perGrammar",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-image",
  },
  "mask-mode": {
    syntax: "<masking-mode>#",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Masking"],
    initial: "match-source",
    appliesto: "allElementsSVGContainerElements",
    computed: "asSpecified",
    order: "perGrammar",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-mode",
  },
  "mask-origin": {
    syntax: "<geometry-box>#",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Masking"],
    initial: "border-box",
    appliesto: "allElementsSVGContainerElements",
    computed: "asSpecified",
    order: "perGrammar",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-origin",
  },
  "mask-position": {
    syntax: "<position>#",
    media: "visual",
    inherited: false,
    animationType: "repeatableListOfSimpleListOfLpc",
    percentages: "referToSizeOfMaskPaintingArea",
    groups: ["CSS Masking"],
    initial: "center",
    appliesto: "allElementsSVGContainerElements",
    computed: "consistsOfTwoKeywordsForOriginAndOffsets",
    order: "perGrammar",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-position",
  },
  "mask-repeat": {
    syntax: "<repeat-style>#",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Masking"],
    initial: "repeat",
    appliesto: "allElementsSVGContainerElements",
    computed: "consistsOfTwoDimensionKeywords",
    order: "perGrammar",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-repeat",
  },
  "mask-size": {
    syntax: "<bg-size>#",
    media: "visual",
    inherited: false,
    animationType: "repeatableListOfSimpleListOfLpc",
    percentages: "no",
    groups: ["CSS Masking"],
    initial: "auto",
    appliesto: "allElementsSVGContainerElements",
    computed: "asSpecifiedRelativeToAbsoluteLengths",
    order: "perGrammar",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-size",
  },
  "mask-type": {
    syntax: "luminance | alpha",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Masking"],
    initial: "luminance",
    appliesto: "maskElements",
    computed: "asSpecified",
    order: "perGrammar",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-type",
  },
  "masonry-auto-flow": {
    syntax: "[ pack | next ] || [ definite-first | ordered ]",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Grid Layout"],
    initial: "pack",
    appliesto: "gridContainersWithMasonryLayout",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "experimental",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/masonry-auto-flow",
  },
  "math-depth": {
    syntax: "auto-add | add(<integer>) | <integer>",
    media: "visual",
    inherited: true,
    animationType: "notAnimatable",
    percentages: "no",
    groups: ["MathML"],
    initial: "0",
    appliesto: "allElements",
    computed: "asSpecified",
    order: "perGrammar",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/math-depth",
  },
  "math-shift": {
    syntax: "normal | compact",
    media: "visual",
    inherited: true,
    animationType: "notAnimatable",
    percentages: "no",
    groups: ["MathML"],
    initial: "normal",
    appliesto: "allElements",
    computed: "asSpecified",
    order: "perGrammar",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/math-shift",
  },
  "math-style": {
    syntax: "normal | compact",
    media: "visual",
    inherited: true,
    animationType: "notAnimatable",
    percentages: "no",
    groups: ["MathML"],
    initial: "normal",
    appliesto: "allElements",
    computed: "asSpecified",
    order: "perGrammar",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/math-style",
  },
  "max-block-size": {
    syntax: "<'max-width'>",
    media: "visual",
    inherited: false,
    animationType: "lpc",
    percentages: "blockSizeOfContainingBlock",
    groups: ["CSS Logical Properties"],
    initial: "none",
    appliesto: "sameAsWidthAndHeight",
    computed: "sameAsMaxWidthAndMaxHeight",
    order: "uniqueOrder",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/max-block-size",
  },
  "max-height": {
    syntax:
      "none | <length-percentage> | min-content | max-content | fit-content | fit-content(<length-percentage>)",
    media: "visual",
    inherited: false,
    animationType: "lpc",
    percentages: "regardingHeightOfGeneratedBoxContainingBlockPercentagesNone",
    groups: ["CSS Box Model"],
    initial: "none",
    appliesto: "allElementsButNonReplacedAndTableColumns",
    computed: "percentageAsSpecifiedAbsoluteLengthOrNone",
    order: "uniqueOrder",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/max-height",
  },
  "max-inline-size": {
    syntax: "<'max-width'>",
    media: "visual",
    inherited: false,
    animationType: "lpc",
    percentages: "inlineSizeOfContainingBlock",
    groups: ["CSS Logical Properties"],
    initial: "none",
    appliesto: "sameAsWidthAndHeight",
    computed: "sameAsMaxWidthAndMaxHeight",
    order: "uniqueOrder",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/max-inline-size",
  },
  "max-lines": {
    syntax: "none | <integer>",
    media: "visual",
    inherited: false,
    animationType: "integer",
    percentages: "no",
    groups: ["CSS Overflow"],
    initial: "none",
    appliesto: "blockContainersExceptMultiColumnContainers",
    computed: "asSpecified",
    order: "perGrammar",
    status: "experimental",
  },
  "max-width": {
    syntax:
      "none | <length-percentage> | min-content | max-content | fit-content | fit-content(<length-percentage>)",
    media: "visual",
    inherited: false,
    animationType: "lpc",
    percentages: "referToWidthOfContainingBlock",
    groups: ["CSS Box Model"],
    initial: "none",
    appliesto: "allElementsButNonReplacedAndTableRows",
    computed: "percentageAsSpecifiedAbsoluteLengthOrNone",
    order: "uniqueOrder",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/max-width",
  },
  "min-block-size": {
    syntax: "<'min-width'>",
    media: "visual",
    inherited: false,
    animationType: "lpc",
    percentages: "blockSizeOfContainingBlock",
    groups: ["CSS Logical Properties"],
    initial: "0",
    appliesto: "sameAsWidthAndHeight",
    computed: "sameAsMinWidthAndMinHeight",
    order: "uniqueOrder",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/min-block-size",
  },
  "min-height": {
    syntax:
      "auto | <length> | <percentage> | min-content | max-content | fit-content | fit-content(<length-percentage>)",
    media: "visual",
    inherited: false,
    animationType: "lpc",
    percentages: "regardingHeightOfGeneratedBoxContainingBlockPercentages0",
    groups: ["CSS Box Model"],
    initial: "auto",
    appliesto: "allElementsButNonReplacedAndTableColumns",
    computed: "percentageAsSpecifiedOrAbsoluteLength",
    order: "uniqueOrder",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/min-height",
  },
  "min-inline-size": {
    syntax: "<'min-width'>",
    media: "visual",
    inherited: false,
    animationType: "lpc",
    percentages: "inlineSizeOfContainingBlock",
    groups: ["CSS Logical Properties"],
    initial: "0",
    appliesto: "sameAsWidthAndHeight",
    computed: "sameAsMinWidthAndMinHeight",
    order: "uniqueOrder",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/min-inline-size",
  },
  "min-width": {
    syntax:
      "auto | <length> | <percentage> | min-content | max-content | fit-content | fit-content(<length-percentage>)",
    media: "visual",
    inherited: false,
    animationType: "lpc",
    percentages: "referToWidthOfContainingBlock",
    groups: ["CSS Box Model"],
    initial: "auto",
    appliesto: "allElementsButNonReplacedAndTableRows",
    computed: "percentageAsSpecifiedOrAbsoluteLength",
    order: "uniqueOrder",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/min-width",
  },
  "mix-blend-mode": {
    syntax: "<blend-mode> | plus-lighter",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["Compositing and Blending"],
    initial: "normal",
    appliesto: "allElements",
    computed: "asSpecified",
    order: "uniqueOrder",
    stacking: true,
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mix-blend-mode",
  },
  "object-fit": {
    syntax: "fill | contain | cover | none | scale-down",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Images"],
    initial: "fill",
    appliesto: "replacedElements",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/object-fit",
  },
  "object-position": {
    syntax: "<position>",
    media: "visual",
    inherited: true,
    animationType: "repeatableListOfSimpleListOfLpc",
    percentages: "referToWidthAndHeightOfElement",
    groups: ["CSS Images"],
    initial: "50% 50%",
    appliesto: "replacedElements",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/object-position",
  },
  offset: offset$1,
  "offset-anchor": {
    syntax: "auto | <position>",
    media: "visual",
    inherited: false,
    animationType: "position",
    percentages: "relativeToWidthAndHeight",
    groups: ["CSS Motion Path"],
    initial: "auto",
    appliesto: "transformableElements",
    computed: "forLengthAbsoluteValueOtherwisePercentage",
    order: "perGrammar",
    status: "standard",
  },
  "offset-distance": {
    syntax: "<length-percentage>",
    media: "visual",
    inherited: false,
    animationType: "lpc",
    percentages: "referToTotalPathLength",
    groups: ["CSS Motion Path"],
    initial: "0",
    appliesto: "transformableElements",
    computed: "forLengthAbsoluteValueOtherwisePercentage",
    order: "perGrammar",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/offset-distance",
  },
  "offset-path": {
    syntax:
      "none | ray( [ <angle> && <size> && contain? ] ) | <path()> | <url> | [ <basic-shape> || <geometry-box> ]",
    media: "visual",
    inherited: false,
    animationType: "angleOrBasicShapeOrPath",
    percentages: "no",
    groups: ["CSS Motion Path"],
    initial: "none",
    appliesto: "transformableElements",
    computed: "asSpecified",
    order: "perGrammar",
    stacking: true,
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/offset-path",
  },
  "offset-position": {
    syntax: "auto | <position>",
    media: "visual",
    inherited: false,
    animationType: "position",
    percentages: "referToSizeOfContainingBlock",
    groups: ["CSS Motion Path"],
    initial: "auto",
    appliesto: "transformableElements",
    computed: "forLengthAbsoluteValueOtherwisePercentage",
    order: "perGrammar",
    status: "experimental",
  },
  "offset-rotate": {
    syntax: "[ auto | reverse ] || <angle>",
    media: "visual",
    inherited: false,
    animationType: "angleOrBasicShapeOrPath",
    percentages: "no",
    groups: ["CSS Motion Path"],
    initial: "auto",
    appliesto: "transformableElements",
    computed: "asSpecified",
    order: "perGrammar",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/offset-rotate",
  },
  opacity: opacity$1,
  order: order$1,
  orphans: orphans$1,
  outline: outline$1,
  "outline-color": {
    syntax: "<color> | invert",
    media: ["visual", "interactive"],
    inherited: false,
    animationType: "color",
    percentages: "no",
    groups: ["CSS Basic User Interface"],
    initial: "invertOrCurrentColor",
    appliesto: "allElements",
    computed: "invertForTranslucentColorRGBAOtherwiseRGB",
    order: "uniqueOrder",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline-color",
  },
  "outline-offset": {
    syntax: "<length>",
    media: ["visual", "interactive"],
    inherited: false,
    animationType: "length",
    percentages: "no",
    groups: ["CSS Basic User Interface"],
    initial: "0",
    appliesto: "allElements",
    computed: "asSpecifiedRelativeToAbsoluteLengths",
    order: "uniqueOrder",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline-offset",
  },
  "outline-style": {
    syntax: "auto | <'border-style'>",
    media: ["visual", "interactive"],
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Basic User Interface"],
    initial: "none",
    appliesto: "allElements",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline-style",
  },
  "outline-width": {
    syntax: "<line-width>",
    media: ["visual", "interactive"],
    inherited: false,
    animationType: "length",
    percentages: "no",
    groups: ["CSS Basic User Interface"],
    initial: "medium",
    appliesto: "allElements",
    computed: "absoluteLength0ForNone",
    order: "uniqueOrder",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline-width",
  },
  overflow: overflow$1,
  "overflow-anchor": {
    syntax: "auto | none",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Scroll Anchoring"],
    initial: "auto",
    appliesto: "allElements",
    computed: "asSpecified",
    order: "perGrammar",
    status: "standard",
  },
  "overflow-block": {
    syntax: "visible | hidden | clip | scroll | auto",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Overflow"],
    initial: "auto",
    appliesto: "blockContainersFlexContainersGridContainers",
    computed:
      "asSpecifiedButVisibleOrClipReplacedToAutoOrHiddenIfOtherValueDifferent",
    order: "perGrammar",
    status: "standard",
  },
  "overflow-clip-box": {
    syntax: "padding-box | content-box",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["Mozilla Extensions"],
    initial: "padding-box",
    appliesto: "allElements",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "nonstandard",
    mdn_url: "https://developer.mozilla.org/docs/Mozilla/CSS/overflow-clip-box",
  },
  "overflow-clip-margin": {
    syntax: "<visual-box> || <length [0,]>",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Overflow"],
    initial: "0px",
    appliesto: "allElements",
    computed: "theComputedLength",
    order: "perGrammar",
    status: "standard",
  },
  "overflow-inline": {
    syntax: "visible | hidden | clip | scroll | auto",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Overflow"],
    initial: "auto",
    appliesto: "blockContainersFlexContainersGridContainers",
    computed:
      "asSpecifiedButVisibleOrClipReplacedToAutoOrHiddenIfOtherValueDifferent",
    order: "perGrammar",
    status: "standard",
  },
  "overflow-wrap": {
    syntax: "normal | break-word | anywhere",
    media: "visual",
    inherited: true,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Text"],
    initial: "normal",
    appliesto: "nonReplacedInlineElements",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow-wrap",
  },
  "overflow-x": {
    syntax: "visible | hidden | clip | scroll | auto",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Overflow"],
    initial: "visible",
    appliesto: "blockContainersFlexContainersGridContainers",
    computed:
      "asSpecifiedButVisibleOrClipReplacedToAutoOrHiddenIfOtherValueDifferent",
    order: "uniqueOrder",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow-x",
  },
  "overflow-y": {
    syntax: "visible | hidden | clip | scroll | auto",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Overflow"],
    initial: "visible",
    appliesto: "blockContainersFlexContainersGridContainers",
    computed:
      "asSpecifiedButVisibleOrClipReplacedToAutoOrHiddenIfOtherValueDifferent",
    order: "uniqueOrder",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow-y",
  },
  "overscroll-behavior": {
    syntax: "[ contain | none | auto ]{1,2}",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Box Model"],
    initial: "auto",
    appliesto: "nonReplacedBlockAndInlineBlockElements",
    computed: ["overscroll-behavior-x", "overscroll-behavior-y"],
    order: "uniqueOrder",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overscroll-behavior",
  },
  "overscroll-behavior-block": {
    syntax: "contain | none | auto",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Box Model"],
    initial: "auto",
    appliesto: "nonReplacedBlockAndInlineBlockElements",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "standard",
    mdn_url:
      "https://developer.mozilla.org/docs/Web/CSS/overscroll-behavior-block",
  },
  "overscroll-behavior-inline": {
    syntax: "contain | none | auto",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Box Model"],
    initial: "auto",
    appliesto: "nonReplacedBlockAndInlineBlockElements",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "standard",
    mdn_url:
      "https://developer.mozilla.org/docs/Web/CSS/overscroll-behavior-inline",
  },
  "overscroll-behavior-x": {
    syntax: "contain | none | auto",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Box Model"],
    initial: "auto",
    appliesto: "nonReplacedBlockAndInlineBlockElements",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overscroll-behavior-x",
  },
  "overscroll-behavior-y": {
    syntax: "contain | none | auto",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Box Model"],
    initial: "auto",
    appliesto: "nonReplacedBlockAndInlineBlockElements",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overscroll-behavior-y",
  },
  padding: padding$1,
  "padding-block": {
    syntax: "<'padding-left'>{1,2}",
    media: "visual",
    inherited: false,
    animationType: "length",
    percentages: "logicalWidthOfContainingBlock",
    groups: ["CSS Logical Properties"],
    initial: ["padding-block-start", "padding-block-end"],
    appliesto: "allElementsExceptInternalTableDisplayTypes",
    computed: ["padding-block-start", "padding-block-end"],
    order: "uniqueOrder",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-block",
  },
  "padding-block-end": {
    syntax: "<'padding-left'>",
    media: "visual",
    inherited: false,
    animationType: "length",
    percentages: "logicalWidthOfContainingBlock",
    groups: ["CSS Logical Properties"],
    initial: "0",
    appliesto: "allElementsExceptInternalTableDisplayTypes",
    computed: "asLength",
    order: "uniqueOrder",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-block-end",
  },
  "padding-block-start": {
    syntax: "<'padding-left'>",
    media: "visual",
    inherited: false,
    animationType: "length",
    percentages: "logicalWidthOfContainingBlock",
    groups: ["CSS Logical Properties"],
    initial: "0",
    appliesto: "allElementsExceptInternalTableDisplayTypes",
    computed: "asLength",
    order: "uniqueOrder",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-block-start",
  },
  "padding-bottom": {
    syntax: "<length> | <percentage>",
    media: "visual",
    inherited: false,
    animationType: "length",
    percentages: "referToWidthOfContainingBlock",
    groups: ["CSS Box Model"],
    initial: "0",
    appliesto: "allElementsExceptInternalTableDisplayTypes",
    computed: "percentageAsSpecifiedOrAbsoluteLength",
    order: "uniqueOrder",
    alsoAppliesTo: ["::first-letter", "::first-line"],
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-bottom",
  },
  "padding-inline": {
    syntax: "<'padding-left'>{1,2}",
    media: "visual",
    inherited: false,
    animationType: "length",
    percentages: "logicalWidthOfContainingBlock",
    groups: ["CSS Logical Properties"],
    initial: ["padding-inline-start", "padding-inline-end"],
    appliesto: "allElementsExceptInternalTableDisplayTypes",
    computed: ["padding-inline-start", "padding-inline-end"],
    order: "uniqueOrder",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-inline",
  },
  "padding-inline-end": {
    syntax: "<'padding-left'>",
    media: "visual",
    inherited: false,
    animationType: "length",
    percentages: "logicalWidthOfContainingBlock",
    groups: ["CSS Logical Properties"],
    initial: "0",
    appliesto: "allElementsExceptInternalTableDisplayTypes",
    computed: "asLength",
    order: "uniqueOrder",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-inline-end",
  },
  "padding-inline-start": {
    syntax: "<'padding-left'>",
    media: "visual",
    inherited: false,
    animationType: "length",
    percentages: "logicalWidthOfContainingBlock",
    groups: ["CSS Logical Properties"],
    initial: "0",
    appliesto: "allElementsExceptInternalTableDisplayTypes",
    computed: "asLength",
    order: "uniqueOrder",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-inline-start",
  },
  "padding-left": {
    syntax: "<length> | <percentage>",
    media: "visual",
    inherited: false,
    animationType: "length",
    percentages: "referToWidthOfContainingBlock",
    groups: ["CSS Box Model"],
    initial: "0",
    appliesto: "allElementsExceptInternalTableDisplayTypes",
    computed: "percentageAsSpecifiedOrAbsoluteLength",
    order: "uniqueOrder",
    alsoAppliesTo: ["::first-letter", "::first-line"],
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-left",
  },
  "padding-right": {
    syntax: "<length> | <percentage>",
    media: "visual",
    inherited: false,
    animationType: "length",
    percentages: "referToWidthOfContainingBlock",
    groups: ["CSS Box Model"],
    initial: "0",
    appliesto: "allElementsExceptInternalTableDisplayTypes",
    computed: "percentageAsSpecifiedOrAbsoluteLength",
    order: "uniqueOrder",
    alsoAppliesTo: ["::first-letter", "::first-line"],
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-right",
  },
  "padding-top": {
    syntax: "<length> | <percentage>",
    media: "visual",
    inherited: false,
    animationType: "length",
    percentages: "referToWidthOfContainingBlock",
    groups: ["CSS Box Model"],
    initial: "0",
    appliesto: "allElementsExceptInternalTableDisplayTypes",
    computed: "percentageAsSpecifiedOrAbsoluteLength",
    order: "uniqueOrder",
    alsoAppliesTo: ["::first-letter", "::first-line"],
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-top",
  },
  "page-break-after": {
    syntax: "auto | always | avoid | left | right | recto | verso",
    media: ["visual", "paged"],
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Pages"],
    initial: "auto",
    appliesto: "blockElementsInNormalFlow",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/page-break-after",
  },
  "page-break-before": {
    syntax: "auto | always | avoid | left | right | recto | verso",
    media: ["visual", "paged"],
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Pages"],
    initial: "auto",
    appliesto: "blockElementsInNormalFlow",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/page-break-before",
  },
  "page-break-inside": {
    syntax: "auto | avoid",
    media: ["visual", "paged"],
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Pages"],
    initial: "auto",
    appliesto: "blockElementsInNormalFlow",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/page-break-inside",
  },
  "paint-order": {
    syntax: "normal | [ fill || stroke || markers ]",
    media: "visual",
    inherited: true,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Text"],
    initial: "normal",
    appliesto: "textElements",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/paint-order",
  },
  perspective: perspective$1,
  "perspective-origin": {
    syntax: "<position>",
    media: "visual",
    inherited: false,
    animationType: "simpleListOfLpc",
    percentages: "referToSizeOfBoundingBox",
    groups: ["CSS Transforms"],
    initial: "50% 50%",
    appliesto: "transformableElements",
    computed: "forLengthAbsoluteValueOtherwisePercentage",
    order: "oneOrTwoValuesLengthAbsoluteKeywordsPercentages",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/perspective-origin",
  },
  "place-content": {
    syntax: "<'align-content'> <'justify-content'>?",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Box Alignment"],
    initial: ["align-content", "justify-content"],
    appliesto: "multilineFlexContainers",
    computed: ["align-content", "justify-content"],
    order: "uniqueOrder",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/place-content",
  },
  "place-items": {
    syntax: "<'align-items'> <'justify-items'>?",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Box Alignment"],
    initial: ["align-items", "justify-items"],
    appliesto: "allElements",
    computed: ["align-items", "justify-items"],
    order: "uniqueOrder",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/place-items",
  },
  "place-self": {
    syntax: "<'align-self'> <'justify-self'>?",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Box Alignment"],
    initial: ["align-self", "justify-self"],
    appliesto: "blockLevelBoxesAndAbsolutelyPositionedBoxesAndGridItems",
    computed: ["align-self", "justify-self"],
    order: "uniqueOrder",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/place-self",
  },
  "pointer-events": {
    syntax:
      "auto | none | visiblePainted | visibleFill | visibleStroke | visible | painted | fill | stroke | all | inherit",
    media: "visual",
    inherited: true,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Basic User Interface"],
    initial: "auto",
    appliesto: "allElements",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/pointer-events",
  },
  position: position$3,
  quotes: quotes$1,
  resize: resize$1,
  right: right$1,
  rotate: rotate$1,
  "row-gap": {
    syntax: "normal | <length-percentage>",
    media: "visual",
    inherited: false,
    animationType: "lpc",
    percentages: "referToDimensionOfContentArea",
    groups: ["CSS Box Alignment"],
    initial: "normal",
    appliesto: "multiColumnElementsFlexContainersGridContainers",
    computed:
      "asSpecifiedWithLengthsAbsoluteAndNormalComputingToZeroExceptMultiColumn",
    order: "perGrammar",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/row-gap",
  },
  "ruby-align": {
    syntax: "start | center | space-between | space-around",
    media: "visual",
    inherited: true,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Ruby"],
    initial: "space-around",
    appliesto: "rubyBasesAnnotationsBaseAnnotationContainers",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "experimental",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/ruby-align",
  },
  "ruby-merge": {
    syntax: "separate | collapse | auto",
    media: "visual",
    inherited: true,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Ruby"],
    initial: "separate",
    appliesto: "rubyAnnotationsContainers",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "experimental",
  },
  "ruby-position": {
    syntax: "[ alternate || [ over | under ] ] | inter-character",
    media: "visual",
    inherited: true,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Ruby"],
    initial: "alternate",
    appliesto: "rubyAnnotationsContainers",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "experimental",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/ruby-position",
  },
  scale: scale$1,
  "scrollbar-color": {
    syntax: "auto | <color>{2}",
    media: "visual",
    inherited: true,
    animationType: "color",
    percentages: "no",
    groups: ["CSS Scrollbars"],
    initial: "auto",
    appliesto: "scrollingBoxes",
    computed: "asSpecified",
    order: "perGrammar",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scrollbar-color",
  },
  "scrollbar-gutter": {
    syntax: "auto | stable && both-edges?",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Overflow"],
    initial: "auto",
    appliesto: "scrollingBoxes",
    computed: "asSpecified",
    order: "perGrammar",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scrollbar-gutter",
  },
  "scrollbar-width": {
    syntax: "auto | thin | none",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Scrollbars"],
    initial: "auto",
    appliesto: "scrollingBoxes",
    computed: "asSpecified",
    order: "perGrammar",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scrollbar-width",
  },
  "scroll-behavior": {
    syntax: "auto | smooth",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSSOM View"],
    initial: "auto",
    appliesto: "scrollingBoxes",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-behavior",
  },
  "scroll-margin": {
    syntax: "<length>{1,4}",
    media: "visual",
    inherited: false,
    animationType: "byComputedValueType",
    percentages: "no",
    groups: ["CSS Scroll Snap"],
    initial: [
      "scroll-margin-bottom",
      "scroll-margin-left",
      "scroll-margin-right",
      "scroll-margin-top",
    ],
    appliesto: "allElements",
    computed: [
      "scroll-margin-bottom",
      "scroll-margin-left",
      "scroll-margin-right",
      "scroll-margin-top",
    ],
    order: "perGrammar",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin",
  },
  "scroll-margin-block": {
    syntax: "<length>{1,2}",
    media: "visual",
    inherited: false,
    animationType: "byComputedValueType",
    percentages: "no",
    groups: ["CSS Scroll Snap"],
    initial: ["scroll-margin-block-start", "scroll-margin-block-end"],
    appliesto: "allElements",
    computed: ["scroll-margin-block-start", "scroll-margin-block-end"],
    order: "perGrammar",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-block",
  },
  "scroll-margin-block-start": {
    syntax: "<length>",
    media: "visual",
    inherited: false,
    animationType: "byComputedValueType",
    percentages: "no",
    groups: ["CSS Scroll Snap"],
    initial: "0",
    appliesto: "allElements",
    computed: "asSpecified",
    order: "perGrammar",
    status: "standard",
    mdn_url:
      "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-block-start",
  },
  "scroll-margin-block-end": {
    syntax: "<length>",
    media: "visual",
    inherited: false,
    animationType: "byComputedValueType",
    percentages: "no",
    groups: ["CSS Scroll Snap"],
    initial: "0",
    appliesto: "allElements",
    computed: "asSpecified",
    order: "perGrammar",
    status: "standard",
    mdn_url:
      "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-block-end",
  },
  "scroll-margin-bottom": {
    syntax: "<length>",
    media: "visual",
    inherited: false,
    animationType: "byComputedValueType",
    percentages: "no",
    groups: ["CSS Scroll Snap"],
    initial: "0",
    appliesto: "allElements",
    computed: "asSpecified",
    order: "perGrammar",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-bottom",
  },
  "scroll-margin-inline": {
    syntax: "<length>{1,2}",
    media: "visual",
    inherited: false,
    animationType: "byComputedValueType",
    percentages: "no",
    groups: ["CSS Scroll Snap"],
    initial: ["scroll-margin-inline-start", "scroll-margin-inline-end"],
    appliesto: "allElements",
    computed: ["scroll-margin-inline-start", "scroll-margin-inline-end"],
    order: "perGrammar",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-inline",
  },
  "scroll-margin-inline-start": {
    syntax: "<length>",
    media: "visual",
    inherited: false,
    animationType: "byComputedValueType",
    percentages: "no",
    groups: ["CSS Scroll Snap"],
    initial: "0",
    appliesto: "allElements",
    computed: "asSpecified",
    order: "perGrammar",
    status: "standard",
    mdn_url:
      "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-inline-start",
  },
  "scroll-margin-inline-end": {
    syntax: "<length>",
    media: "visual",
    inherited: false,
    animationType: "byComputedValueType",
    percentages: "no",
    groups: ["CSS Scroll Snap"],
    initial: "0",
    appliesto: "allElements",
    computed: "asSpecified",
    order: "perGrammar",
    status: "standard",
    mdn_url:
      "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-inline-end",
  },
  "scroll-margin-left": {
    syntax: "<length>",
    media: "visual",
    inherited: false,
    animationType: "byComputedValueType",
    percentages: "no",
    groups: ["CSS Scroll Snap"],
    initial: "0",
    appliesto: "allElements",
    computed: "asSpecified",
    order: "perGrammar",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-left",
  },
  "scroll-margin-right": {
    syntax: "<length>",
    media: "visual",
    inherited: false,
    animationType: "byComputedValueType",
    percentages: "no",
    groups: ["CSS Scroll Snap"],
    initial: "0",
    appliesto: "allElements",
    computed: "asSpecified",
    order: "perGrammar",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-right",
  },
  "scroll-margin-top": {
    syntax: "<length>",
    media: "visual",
    inherited: false,
    animationType: "byComputedValueType",
    percentages: "no",
    groups: ["CSS Scroll Snap"],
    initial: "0",
    appliesto: "allElements",
    computed: "asSpecified",
    order: "perGrammar",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-top",
  },
  "scroll-padding": {
    syntax: "[ auto | <length-percentage> ]{1,4}",
    media: "visual",
    inherited: false,
    animationType: "byComputedValueType",
    percentages: "relativeToTheScrollContainersScrollport",
    groups: ["CSS Scroll Snap"],
    initial: [
      "scroll-padding-bottom",
      "scroll-padding-left",
      "scroll-padding-right",
      "scroll-padding-top",
    ],
    appliesto: "scrollContainers",
    computed: [
      "scroll-padding-bottom",
      "scroll-padding-left",
      "scroll-padding-right",
      "scroll-padding-top",
    ],
    order: "perGrammar",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding",
  },
  "scroll-padding-block": {
    syntax: "[ auto | <length-percentage> ]{1,2}",
    media: "visual",
    inherited: false,
    animationType: "byComputedValueType",
    percentages: "relativeToTheScrollContainersScrollport",
    groups: ["CSS Scroll Snap"],
    initial: ["scroll-padding-block-start", "scroll-padding-block-end"],
    appliesto: "scrollContainers",
    computed: ["scroll-padding-block-start", "scroll-padding-block-end"],
    order: "perGrammar",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-block",
  },
  "scroll-padding-block-start": {
    syntax: "auto | <length-percentage>",
    media: "visual",
    inherited: false,
    animationType: "byComputedValueType",
    percentages: "relativeToTheScrollContainersScrollport",
    groups: ["CSS Scroll Snap"],
    initial: "auto",
    appliesto: "scrollContainers",
    computed: "asSpecified",
    order: "perGrammar",
    status: "standard",
    mdn_url:
      "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-block-start",
  },
  "scroll-padding-block-end": {
    syntax: "auto | <length-percentage>",
    media: "visual",
    inherited: false,
    animationType: "byComputedValueType",
    percentages: "relativeToTheScrollContainersScrollport",
    groups: ["CSS Scroll Snap"],
    initial: "auto",
    appliesto: "scrollContainers",
    computed: "asSpecified",
    order: "perGrammar",
    status: "standard",
    mdn_url:
      "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-block-end",
  },
  "scroll-padding-bottom": {
    syntax: "auto | <length-percentage>",
    media: "visual",
    inherited: false,
    animationType: "byComputedValueType",
    percentages: "relativeToTheScrollContainersScrollport",
    groups: ["CSS Scroll Snap"],
    initial: "auto",
    appliesto: "scrollContainers",
    computed: "asSpecified",
    order: "perGrammar",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-bottom",
  },
  "scroll-padding-inline": {
    syntax: "[ auto | <length-percentage> ]{1,2}",
    media: "visual",
    inherited: false,
    animationType: "byComputedValueType",
    percentages: "relativeToTheScrollContainersScrollport",
    groups: ["CSS Scroll Snap"],
    initial: ["scroll-padding-inline-start", "scroll-padding-inline-end"],
    appliesto: "scrollContainers",
    computed: ["scroll-padding-inline-start", "scroll-padding-inline-end"],
    order: "perGrammar",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-inline",
  },
  "scroll-padding-inline-start": {
    syntax: "auto | <length-percentage>",
    media: "visual",
    inherited: false,
    animationType: "byComputedValueType",
    percentages: "relativeToTheScrollContainersScrollport",
    groups: ["CSS Scroll Snap"],
    initial: "auto",
    appliesto: "scrollContainers",
    computed: "asSpecified",
    order: "perGrammar",
    status: "standard",
    mdn_url:
      "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-inline-start",
  },
  "scroll-padding-inline-end": {
    syntax: "auto | <length-percentage>",
    media: "visual",
    inherited: false,
    animationType: "byComputedValueType",
    percentages: "relativeToTheScrollContainersScrollport",
    groups: ["CSS Scroll Snap"],
    initial: "auto",
    appliesto: "scrollContainers",
    computed: "asSpecified",
    order: "perGrammar",
    status: "standard",
    mdn_url:
      "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-inline-end",
  },
  "scroll-padding-left": {
    syntax: "auto | <length-percentage>",
    media: "visual",
    inherited: false,
    animationType: "byComputedValueType",
    percentages: "relativeToTheScrollContainersScrollport",
    groups: ["CSS Scroll Snap"],
    initial: "auto",
    appliesto: "scrollContainers",
    computed: "asSpecified",
    order: "perGrammar",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-left",
  },
  "scroll-padding-right": {
    syntax: "auto | <length-percentage>",
    media: "visual",
    inherited: false,
    animationType: "byComputedValueType",
    percentages: "relativeToTheScrollContainersScrollport",
    groups: ["CSS Scroll Snap"],
    initial: "auto",
    appliesto: "scrollContainers",
    computed: "asSpecified",
    order: "perGrammar",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-right",
  },
  "scroll-padding-top": {
    syntax: "auto | <length-percentage>",
    media: "visual",
    inherited: false,
    animationType: "byComputedValueType",
    percentages: "relativeToTheScrollContainersScrollport",
    groups: ["CSS Scroll Snap"],
    initial: "auto",
    appliesto: "scrollContainers",
    computed: "asSpecified",
    order: "perGrammar",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-top",
  },
  "scroll-snap-align": {
    syntax: "[ none | start | end | center ]{1,2}",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Scroll Snap"],
    initial: "none",
    appliesto: "allElements",
    computed: "asSpecified",
    order: "perGrammar",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-align",
  },
  "scroll-snap-coordinate": {
    syntax: "none | <position>#",
    media: "interactive",
    inherited: false,
    animationType: "position",
    percentages: "referToBorderBox",
    groups: ["CSS Scroll Snap"],
    initial: "none",
    appliesto: "allElements",
    computed: "asSpecifiedRelativeToAbsoluteLengths",
    order: "uniqueOrder",
    status: "obsolete",
    mdn_url:
      "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-coordinate",
  },
  "scroll-snap-destination": {
    syntax: "<position>",
    media: "interactive",
    inherited: false,
    animationType: "position",
    percentages: "relativeToScrollContainerPaddingBoxAxis",
    groups: ["CSS Scroll Snap"],
    initial: "0px 0px",
    appliesto: "scrollContainers",
    computed: "asSpecifiedRelativeToAbsoluteLengths",
    order: "uniqueOrder",
    status: "obsolete",
    mdn_url:
      "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-destination",
  },
  "scroll-snap-points-x": {
    syntax: "none | repeat( <length-percentage> )",
    media: "interactive",
    inherited: false,
    animationType: "discrete",
    percentages: "relativeToScrollContainerPaddingBoxAxis",
    groups: ["CSS Scroll Snap"],
    initial: "none",
    appliesto: "scrollContainers",
    computed: "asSpecifiedRelativeToAbsoluteLengths",
    order: "uniqueOrder",
    status: "obsolete",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-points-x",
  },
  "scroll-snap-points-y": {
    syntax: "none | repeat( <length-percentage> )",
    media: "interactive",
    inherited: false,
    animationType: "discrete",
    percentages: "relativeToScrollContainerPaddingBoxAxis",
    groups: ["CSS Scroll Snap"],
    initial: "none",
    appliesto: "scrollContainers",
    computed: "asSpecifiedRelativeToAbsoluteLengths",
    order: "uniqueOrder",
    status: "obsolete",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-points-y",
  },
  "scroll-snap-stop": {
    syntax: "normal | always",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Scroll Snap"],
    initial: "normal",
    appliesto: "allElements",
    computed: "asSpecified",
    order: "perGrammar",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-stop",
  },
  "scroll-snap-type": {
    syntax:
      "none | [ x | y | block | inline | both ] [ mandatory | proximity ]?",
    media: "interactive",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Scroll Snap"],
    initial: "none",
    appliesto: "allElements",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-type",
  },
  "scroll-snap-type-x": {
    syntax: "none | mandatory | proximity",
    media: "interactive",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Scroll Snap"],
    initial: "none",
    appliesto: "scrollContainers",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "obsolete",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-type-x",
  },
  "scroll-snap-type-y": {
    syntax: "none | mandatory | proximity",
    media: "interactive",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Scroll Snap"],
    initial: "none",
    appliesto: "scrollContainers",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "obsolete",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-type-y",
  },
  "scroll-timeline": {
    syntax: "<scroll-timeline-name> || <scroll-timeline-axis>",
    media: "visual",
    inherited: false,
    animationType: ["scroll-timeline-name", "scroll-timeline-axis"],
    percentages: "no",
    groups: ["CSS Animations"],
    initial: ["scroll-timeline-name", "scroll-timeline-axis"],
    appliesto: "scrollContainers",
    computed: ["scroll-timeline-name", "scroll-timeline-axis"],
    order: "perGrammar",
    status: "experimental",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-timeline",
  },
  "scroll-timeline-axis": {
    syntax: "block | inline | vertical | horizontal",
    media: "interactive",
    inherited: false,
    animationType: "notAnimatable",
    percentages: "no",
    groups: ["CSS Animations"],
    initial: "block",
    appliesto: "scrollContainers",
    computed: "asSpecified",
    order: "perGrammar",
    status: "experimental",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-timeline-axis",
  },
  "scroll-timeline-name": {
    syntax: "none | <custom-ident>",
    media: "interactive",
    inherited: false,
    animationType: "notAnimatable",
    percentages: "no",
    groups: ["CSS Animations"],
    initial: "none",
    appliesto: "scrollContainers",
    computed: "asSpecified",
    order: "perGrammar",
    status: "experimental",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-timeline-name",
  },
  "shape-image-threshold": {
    syntax: "<alpha-value>",
    media: "visual",
    inherited: false,
    animationType: "number",
    percentages: "no",
    groups: ["CSS Shapes"],
    initial: "0.0",
    appliesto: "floats",
    computed: "specifiedValueNumberClipped0To1",
    order: "uniqueOrder",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/shape-image-threshold",
  },
  "shape-margin": {
    syntax: "<length-percentage>",
    media: "visual",
    inherited: false,
    animationType: "lpc",
    percentages: "referToWidthOfContainingBlock",
    groups: ["CSS Shapes"],
    initial: "0",
    appliesto: "floats",
    computed: "asSpecifiedRelativeToAbsoluteLengths",
    order: "uniqueOrder",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/shape-margin",
  },
  "shape-outside": {
    syntax: "none | [ <shape-box> || <basic-shape> ] | <image>",
    media: "visual",
    inherited: false,
    animationType: "basicShapeOtherwiseNo",
    percentages: "no",
    groups: ["CSS Shapes"],
    initial: "none",
    appliesto: "floats",
    computed: "asDefinedForBasicShapeWithAbsoluteURIOtherwiseAsSpecified",
    order: "uniqueOrder",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/shape-outside",
  },
  "tab-size": {
    syntax: "<integer> | <length>",
    media: "visual",
    inherited: true,
    animationType: "length",
    percentages: "no",
    groups: ["CSS Text"],
    initial: "8",
    appliesto: "blockContainers",
    computed: "specifiedIntegerOrAbsoluteLength",
    order: "uniqueOrder",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/tab-size",
  },
  "table-layout": {
    syntax: "auto | fixed",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Table"],
    initial: "auto",
    appliesto: "tableElements",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/table-layout",
  },
  "text-align": {
    syntax: "start | end | left | right | center | justify | match-parent",
    media: "visual",
    inherited: true,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Text"],
    initial: "startOrNamelessValueIfLTRRightIfRTL",
    appliesto: "blockContainers",
    computed: "asSpecifiedExceptMatchParent",
    order: "orderOfAppearance",
    alsoAppliesTo: ["::placeholder"],
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-align",
  },
  "text-align-last": {
    syntax: "auto | start | end | left | right | center | justify",
    media: "visual",
    inherited: true,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Text"],
    initial: "auto",
    appliesto: "blockContainers",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-align-last",
  },
  "text-combine-upright": {
    syntax: "none | all | [ digits <integer>? ]",
    media: "visual",
    inherited: true,
    animationType: "notAnimatable",
    percentages: "no",
    groups: ["CSS Writing Modes"],
    initial: "none",
    appliesto: "nonReplacedInlineElements",
    computed: "keywordPlusIntegerIfDigits",
    order: "uniqueOrder",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-combine-upright",
  },
  "text-decoration": {
    syntax:
      "<'text-decoration-line'> || <'text-decoration-style'> || <'text-decoration-color'> || <'text-decoration-thickness'>",
    media: "visual",
    inherited: false,
    animationType: [
      "text-decoration-color",
      "text-decoration-style",
      "text-decoration-line",
      "text-decoration-thickness",
    ],
    percentages: "no",
    groups: ["CSS Text Decoration"],
    initial: [
      "text-decoration-color",
      "text-decoration-style",
      "text-decoration-line",
    ],
    appliesto: "allElements",
    computed: [
      "text-decoration-line",
      "text-decoration-style",
      "text-decoration-color",
      "text-decoration-thickness",
    ],
    order: "orderOfAppearance",
    alsoAppliesTo: ["::first-letter", "::first-line", "::placeholder"],
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration",
  },
  "text-decoration-color": {
    syntax: "<color>",
    media: "visual",
    inherited: false,
    animationType: "color",
    percentages: "no",
    groups: ["CSS Text Decoration"],
    initial: "currentcolor",
    appliesto: "allElements",
    computed: "computedColor",
    order: "uniqueOrder",
    alsoAppliesTo: ["::first-letter", "::first-line", "::placeholder"],
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-color",
  },
  "text-decoration-line": {
    syntax:
      "none | [ underline || overline || line-through || blink ] | spelling-error | grammar-error",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Text Decoration"],
    initial: "none",
    appliesto: "allElements",
    computed: "asSpecified",
    order: "orderOfAppearance",
    alsoAppliesTo: ["::first-letter", "::first-line", "::placeholder"],
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-line",
  },
  "text-decoration-skip": {
    syntax:
      "none | [ objects || [ spaces | [ leading-spaces || trailing-spaces ] ] || edges || box-decoration ]",
    media: "visual",
    inherited: true,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Text Decoration"],
    initial: "objects",
    appliesto: "allElements",
    computed: "asSpecified",
    order: "orderOfAppearance",
    status: "experimental",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-skip",
  },
  "text-decoration-skip-ink": {
    syntax: "auto | all | none",
    media: "visual",
    inherited: true,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Text Decoration"],
    initial: "auto",
    appliesto: "allElements",
    computed: "asSpecified",
    order: "orderOfAppearance",
    status: "standard",
    mdn_url:
      "https://developer.mozilla.org/docs/Web/CSS/text-decoration-skip-ink",
  },
  "text-decoration-style": {
    syntax: "solid | double | dotted | dashed | wavy",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Text Decoration"],
    initial: "solid",
    appliesto: "allElements",
    computed: "asSpecified",
    order: "uniqueOrder",
    alsoAppliesTo: ["::first-letter", "::first-line", "::placeholder"],
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-style",
  },
  "text-decoration-thickness": {
    syntax: "auto | from-font | <length> | <percentage> ",
    media: "visual",
    inherited: false,
    animationType: "byComputedValueType",
    percentages: "referToElementFontSize",
    groups: ["CSS Text Decoration"],
    initial: "auto",
    appliesto: "allElements",
    computed: "asSpecified",
    order: "uniqueOrder",
    alsoAppliesTo: ["::first-letter", "::first-line", "::placeholder"],
    status: "standard",
    mdn_url:
      "https://developer.mozilla.org/docs/Web/CSS/text-decoration-thickness",
  },
  "text-emphasis": {
    syntax: "<'text-emphasis-style'> || <'text-emphasis-color'>",
    media: "visual",
    inherited: false,
    animationType: ["text-emphasis-color", "text-emphasis-style"],
    percentages: "no",
    groups: ["CSS Text Decoration"],
    initial: ["text-emphasis-style", "text-emphasis-color"],
    appliesto: "allElements",
    computed: ["text-emphasis-style", "text-emphasis-color"],
    order: "orderOfAppearance",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-emphasis",
  },
  "text-emphasis-color": {
    syntax: "<color>",
    media: "visual",
    inherited: false,
    animationType: "color",
    percentages: "no",
    groups: ["CSS Text Decoration"],
    initial: "currentcolor",
    appliesto: "allElements",
    computed: "computedColor",
    order: "uniqueOrder",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-emphasis-color",
  },
  "text-emphasis-position": {
    syntax: "[ over | under ] && [ right | left ]",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Text Decoration"],
    initial: "over right",
    appliesto: "allElements",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "standard",
    mdn_url:
      "https://developer.mozilla.org/docs/Web/CSS/text-emphasis-position",
  },
  "text-emphasis-style": {
    syntax:
      "none | [ [ filled | open ] || [ dot | circle | double-circle | triangle | sesame ] ] | <string>",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Text Decoration"],
    initial: "none",
    appliesto: "allElements",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-emphasis-style",
  },
  "text-indent": {
    syntax: "<length-percentage> && hanging? && each-line?",
    media: "visual",
    inherited: true,
    animationType: "lpc",
    percentages: "referToWidthOfContainingBlock",
    groups: ["CSS Text"],
    initial: "0",
    appliesto: "blockContainers",
    computed: "percentageOrAbsoluteLengthPlusKeywords",
    order: "lengthOrPercentageBeforeKeywords",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-indent",
  },
  "text-justify": {
    syntax: "auto | inter-character | inter-word | none",
    media: "visual",
    inherited: true,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Text"],
    initial: "auto",
    appliesto: "inlineLevelAndTableCellElements",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-justify",
  },
  "text-orientation": {
    syntax: "mixed | upright | sideways",
    media: "visual",
    inherited: true,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Writing Modes"],
    initial: "mixed",
    appliesto: "allElementsExceptTableRowGroupsRowsColumnGroupsAndColumns",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-orientation",
  },
  "text-overflow": {
    syntax: "[ clip | ellipsis | <string> ]{1,2}",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Basic User Interface"],
    initial: "clip",
    appliesto: "blockContainerElements",
    computed: "asSpecified",
    order: "uniqueOrder",
    alsoAppliesTo: ["::placeholder"],
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-overflow",
  },
  "text-rendering": {
    syntax: "auto | optimizeSpeed | optimizeLegibility | geometricPrecision",
    media: "visual",
    inherited: true,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Miscellaneous"],
    initial: "auto",
    appliesto: "textElements",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-rendering",
  },
  "text-shadow": {
    syntax: "none | <shadow-t>#",
    media: "visual",
    inherited: true,
    animationType: "shadowList",
    percentages: "no",
    groups: ["CSS Text Decoration"],
    initial: "none",
    appliesto: "allElements",
    computed: "colorPlusThreeAbsoluteLengths",
    order: "uniqueOrder",
    alsoAppliesTo: ["::first-letter", "::first-line", "::placeholder"],
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-shadow",
  },
  "text-size-adjust": {
    syntax: "none | auto | <percentage>",
    media: "visual",
    inherited: true,
    animationType: "discrete",
    percentages: "referToSizeOfFont",
    groups: ["CSS Text"],
    initial: "autoForSmartphoneBrowsersSupportingInflation",
    appliesto: "allElements",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "experimental",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-size-adjust",
  },
  "text-transform": {
    syntax:
      "none | capitalize | uppercase | lowercase | full-width | full-size-kana",
    media: "visual",
    inherited: true,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Text"],
    initial: "none",
    appliesto: "allElements",
    computed: "asSpecified",
    order: "uniqueOrder",
    alsoAppliesTo: ["::first-letter", "::first-line", "::placeholder"],
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-transform",
  },
  "text-underline-offset": {
    syntax: "auto | <length> | <percentage> ",
    media: "visual",
    inherited: true,
    animationType: "byComputedValueType",
    percentages: "referToElementFontSize",
    groups: ["CSS Text Decoration"],
    initial: "auto",
    appliesto: "allElements",
    computed: "asSpecified",
    order: "uniqueOrder",
    alsoAppliesTo: ["::first-letter", "::first-line", "::placeholder"],
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-underline-offset",
  },
  "text-underline-position": {
    syntax: "auto | from-font | [ under || [ left | right ] ]",
    media: "visual",
    inherited: true,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Text Decoration"],
    initial: "auto",
    appliesto: "allElements",
    computed: "asSpecified",
    order: "orderOfAppearance",
    status: "standard",
    mdn_url:
      "https://developer.mozilla.org/docs/Web/CSS/text-underline-position",
  },
  top: top$1,
  "touch-action": {
    syntax:
      "auto | none | [ [ pan-x | pan-left | pan-right ] || [ pan-y | pan-up | pan-down ] || pinch-zoom ] | manipulation",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["Pointer Events"],
    initial: "auto",
    appliesto:
      "allElementsExceptNonReplacedInlineElementsTableRowsColumnsRowColumnGroups",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/touch-action",
  },
  transform: transform$1,
  "transform-box": {
    syntax: "content-box | border-box | fill-box | stroke-box | view-box",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Transforms"],
    initial: "view-box",
    appliesto: "transformableElements",
    computed: "asSpecified",
    order: "perGrammar",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transform-box",
  },
  "transform-origin": {
    syntax:
      "[ <length-percentage> | left | center | right | top | bottom ] | [ [ <length-percentage> | left | center | right ] && [ <length-percentage> | top | center | bottom ] ] <length>?",
    media: "visual",
    inherited: false,
    animationType: "simpleListOfLpc",
    percentages: "referToSizeOfBoundingBox",
    groups: ["CSS Transforms"],
    initial: "50% 50% 0",
    appliesto: "transformableElements",
    computed: "forLengthAbsoluteValueOtherwisePercentage",
    order: "oneOrTwoValuesLengthAbsoluteKeywordsPercentages",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transform-origin",
  },
  "transform-style": {
    syntax: "flat | preserve-3d",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Transforms"],
    initial: "flat",
    appliesto: "transformableElements",
    computed: "asSpecified",
    order: "uniqueOrder",
    stacking: true,
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transform-style",
  },
  transition: transition$1,
  "transition-delay": {
    syntax: "<time>#",
    media: "interactive",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Transitions"],
    initial: "0s",
    appliesto: "allElementsAndPseudos",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition-delay",
  },
  "transition-duration": {
    syntax: "<time>#",
    media: "interactive",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Transitions"],
    initial: "0s",
    appliesto: "allElementsAndPseudos",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition-duration",
  },
  "transition-property": {
    syntax: "none | <single-transition-property>#",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Transitions"],
    initial: "all",
    appliesto: "allElementsAndPseudos",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition-property",
  },
  "transition-timing-function": {
    syntax: "<easing-function>#",
    media: "interactive",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Transitions"],
    initial: "ease",
    appliesto: "allElementsAndPseudos",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "standard",
    mdn_url:
      "https://developer.mozilla.org/docs/Web/CSS/transition-timing-function",
  },
  translate: translate$1,
  "unicode-bidi": {
    syntax:
      "normal | embed | isolate | bidi-override | isolate-override | plaintext",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Writing Modes"],
    initial: "normal",
    appliesto: "allElementsSomeValuesNoEffectOnNonInlineElements",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/unicode-bidi",
  },
  "user-select": {
    syntax: "auto | text | none | contain | all",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Basic User Interface"],
    initial: "auto",
    appliesto: "allElements",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/user-select",
  },
  "vertical-align": {
    syntax:
      "baseline | sub | super | text-top | text-bottom | middle | top | bottom | <percentage> | <length>",
    media: "visual",
    inherited: false,
    animationType: "length",
    percentages: "referToLineHeight",
    groups: ["CSS Table"],
    initial: "baseline",
    appliesto: "inlineLevelAndTableCellElements",
    computed: "absoluteLengthOrKeyword",
    order: "uniqueOrder",
    alsoAppliesTo: ["::first-letter", "::first-line", "::placeholder"],
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/vertical-align",
  },
  visibility: visibility$1,
  "white-space": {
    syntax: "normal | pre | nowrap | pre-wrap | pre-line | break-spaces",
    media: "visual",
    inherited: true,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Text"],
    initial: "normal",
    appliesto: "allElements",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/white-space",
  },
  widows: widows$1,
  width: width$1,
  "will-change": {
    syntax: "auto | <animateable-feature>#",
    media: "all",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Will Change"],
    initial: "auto",
    appliesto: "allElements",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/will-change",
  },
  "word-break": {
    syntax: "normal | break-all | keep-all | break-word",
    media: "visual",
    inherited: true,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Text"],
    initial: "normal",
    appliesto: "allElements",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/word-break",
  },
  "word-spacing": {
    syntax: "normal | <length>",
    media: "visual",
    inherited: true,
    animationType: "length",
    percentages: "referToWidthOfAffectedGlyph",
    groups: ["CSS Text"],
    initial: "normal",
    appliesto: "allElements",
    computed: "absoluteLength",
    order: "uniqueOrder",
    alsoAppliesTo: ["::first-letter", "::first-line", "::placeholder"],
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/word-spacing",
  },
  "word-wrap": {
    syntax: "normal | break-word",
    media: "visual",
    inherited: true,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Text"],
    initial: "normal",
    appliesto: "nonReplacedInlineElements",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow-wrap",
  },
  "writing-mode": {
    syntax:
      "horizontal-tb | vertical-rl | vertical-lr | sideways-rl | sideways-lr",
    media: "visual",
    inherited: true,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Writing Modes"],
    initial: "horizontal-tb",
    appliesto: "allElementsExceptTableRowColumnGroupsTableRowsColumns",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/writing-mode",
  },
  "z-index": {
    syntax: "auto | <integer>",
    media: "visual",
    inherited: false,
    animationType: "integer",
    percentages: "no",
    groups: ["CSS Positioning"],
    initial: "auto",
    appliesto: "positionedElements",
    computed: "asSpecified",
    order: "uniqueOrder",
    stacking: true,
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/z-index",
  },
  zoom: zoom$1,
};

const attachment$1 = {
  syntax: "scroll | fixed | local",
};
const axis = {
  syntax: "block | inline | vertical | horizontal",
};
const box$1 = {
  syntax: "border-box | padding-box | content-box",
};
const color$4 = {
  syntax:
    "<rgb()> | <rgba()> | <hsl()> | <hsla()> | <hwb()> | <lab()> | <lch()> | <hex-color> | <named-color> | currentcolor | <deprecated-system-color>",
};
const combinator$1 = {
  syntax: "'>' | '+' | '~' | [ '||' ]",
};
const counter$1 = {
  syntax: "<counter()> | <counters()>",
};
const gradient$1 = {
  syntax:
    "<linear-gradient()> | <repeating-linear-gradient()> | <radial-gradient()> | <repeating-radial-gradient()> | <conic-gradient()> | <repeating-conic-gradient()>",
};
const hue$1 = {
  syntax: "<number> | <angle>",
};
const image$1 = {
  syntax:
    "<url> | <image()> | <image-set()> | <element()> | <paint()> | <cross-fade()> | <gradient>",
};
const nth$3 = {
  syntax: "<an-plus-b> | even | odd",
};
const position$2 = {
  syntax:
    "[ [ left | center | right ] || [ top | center | bottom ] | [ left | center | right | <length-percentage> ] [ top | center | bottom | <length-percentage> ]? | [ [ left | right ] <length-percentage> ] && [ [ top | bottom ] <length-percentage> ] ]",
};
const quote$1 = {
  syntax: "open-quote | close-quote | no-open-quote | no-close-quote",
};
const ratio = {
  syntax: "<number [0,]> [ / <number [0,]> ]?",
};
const scroller = {
  syntax: "root | nearest",
};
const shadow$1 = {
  syntax: "inset? && <length>{2,4} && <color>?",
};
const shape$2 = {
  syntax: "rect(<top>, <right>, <bottom>, <left>)",
};
const size$1 = {
  syntax:
    "closest-side | farthest-side | closest-corner | farthest-corner | <length> | <length-percentage>{2}",
};
const symbol$1 = {
  syntax: "<string> | <image> | <custom-ident>",
};
const target$1 = {
  syntax: "<target-counter()> | <target-counters()> | <target-text()>",
};
const require$$3$1 = {
  "abs()": {
    syntax: "abs( <calc-sum> )",
  },
  "absolute-size": {
    syntax:
      "xx-small | x-small | small | medium | large | x-large | xx-large | xxx-large",
  },
  "acos()": {
    syntax: "acos( <calc-sum> )",
  },
  "alpha-value": {
    syntax: "<number> | <percentage>",
  },
  "angle-percentage": {
    syntax: "<angle> | <percentage>",
  },
  "angular-color-hint": {
    syntax: "<angle-percentage>",
  },
  "angular-color-stop": {
    syntax: "<color> && <color-stop-angle>?",
  },
  "angular-color-stop-list": {
    syntax:
      "[ <angular-color-stop> [, <angular-color-hint>]? ]# , <angular-color-stop>",
  },
  "animateable-feature": {
    syntax: "scroll-position | contents | <custom-ident>",
  },
  "asin()": {
    syntax: "asin( <calc-sum> )",
  },
  "atan()": {
    syntax: "atan( <calc-sum> )",
  },
  "atan2()": {
    syntax: "atan2( <calc-sum>, <calc-sum> )",
  },
  attachment: attachment$1,
  "attr()": {
    syntax: "attr( <attr-name> <type-or-unit>? [, <attr-fallback> ]? )",
  },
  "attr-matcher": {
    syntax: "[ '~' | '|' | '^' | '$' | '*' ]? '='",
  },
  "attr-modifier": {
    syntax: "i | s",
  },
  "attribute-selector": {
    syntax:
      "'[' <wq-name> ']' | '[' <wq-name> <attr-matcher> [ <string-token> | <ident-token> ] <attr-modifier>? ']'",
  },
  "auto-repeat": {
    syntax:
      "repeat( [ auto-fill | auto-fit ] , [ <line-names>? <fixed-size> ]+ <line-names>? )",
  },
  "auto-track-list": {
    syntax:
      "[ <line-names>? [ <fixed-size> | <fixed-repeat> ] ]* <line-names>? <auto-repeat>\n[ <line-names>? [ <fixed-size> | <fixed-repeat> ] ]* <line-names>?",
  },
  axis: axis,
  "baseline-position": {
    syntax: "[ first | last ]? baseline",
  },
  "basic-shape": {
    syntax: "<inset()> | <circle()> | <ellipse()> | <polygon()> | <path()>",
  },
  "bg-image": {
    syntax: "none | <image>",
  },
  "bg-layer": {
    syntax:
      "<bg-image> || <bg-position> [ / <bg-size> ]? || <repeat-style> || <attachment> || <box> || <box>",
  },
  "bg-position": {
    syntax:
      "[ [ left | center | right | top | bottom | <length-percentage> ] | [ left | center | right | <length-percentage> ] [ top | center | bottom | <length-percentage> ] | [ center | [ left | right ] <length-percentage>? ] && [ center | [ top | bottom ] <length-percentage>? ] ]",
  },
  "bg-size": {
    syntax: "[ <length-percentage> | auto ]{1,2} | cover | contain",
  },
  "blur()": {
    syntax: "blur( <length> )",
  },
  "blend-mode": {
    syntax:
      "normal | multiply | screen | overlay | darken | lighten | color-dodge | color-burn | hard-light | soft-light | difference | exclusion | hue | saturation | color | luminosity",
  },
  box: box$1,
  "brightness()": {
    syntax: "brightness( <number-percentage> )",
  },
  "calc()": {
    syntax: "calc( <calc-sum> )",
  },
  "calc-sum": {
    syntax: "<calc-product> [ [ '+' | '-' ] <calc-product> ]*",
  },
  "calc-product": {
    syntax: "<calc-value> [ '*' <calc-value> | '/' <number> ]*",
  },
  "calc-value": {
    syntax:
      "<number> | <dimension> | <percentage> | <calc-constant> | ( <calc-sum> )",
  },
  "calc-constant": {
    syntax: "e | pi | infinity | -infinity | NaN",
  },
  "cf-final-image": {
    syntax: "<image> | <color>",
  },
  "cf-mixing-image": {
    syntax: "<percentage>? && <image>",
  },
  "circle()": {
    syntax: "circle( [ <shape-radius> ]? [ at <position> ]? )",
  },
  "clamp()": {
    syntax: "clamp( <calc-sum>#{3} )",
  },
  "class-selector": {
    syntax: "'.' <ident-token>",
  },
  "clip-source": {
    syntax: "<url>",
  },
  color: color$4,
  "color-stop": {
    syntax: "<color-stop-length> | <color-stop-angle>",
  },
  "color-stop-angle": {
    syntax: "<angle-percentage>{1,2}",
  },
  "color-stop-length": {
    syntax: "<length-percentage>{1,2}",
  },
  "color-stop-list": {
    syntax:
      "[ <linear-color-stop> [, <linear-color-hint>]? ]# , <linear-color-stop>",
  },
  combinator: combinator$1,
  "common-lig-values": {
    syntax: "[ common-ligatures | no-common-ligatures ]",
  },
  "compat-auto": {
    syntax:
      "searchfield | textarea | push-button | slider-horizontal | checkbox | radio | square-button | menulist | listbox | meter | progress-bar | button",
  },
  "composite-style": {
    syntax:
      "clear | copy | source-over | source-in | source-out | source-atop | destination-over | destination-in | destination-out | destination-atop | xor",
  },
  "compositing-operator": {
    syntax: "add | subtract | intersect | exclude",
  },
  "compound-selector": {
    syntax:
      "[ <type-selector>? <subclass-selector>* [ <pseudo-element-selector> <pseudo-class-selector>* ]* ]!",
  },
  "compound-selector-list": {
    syntax: "<compound-selector>#",
  },
  "complex-selector": {
    syntax: "<compound-selector> [ <combinator>? <compound-selector> ]*",
  },
  "complex-selector-list": {
    syntax: "<complex-selector>#",
  },
  "conic-gradient()": {
    syntax:
      "conic-gradient( [ from <angle> ]? [ at <position> ]?, <angular-color-stop-list> )",
  },
  "contextual-alt-values": {
    syntax: "[ contextual | no-contextual ]",
  },
  "content-distribution": {
    syntax: "space-between | space-around | space-evenly | stretch",
  },
  "content-list": {
    syntax:
      "[ <string> | contents | <image> | <counter> | <quote> | <target> | <leader()> ]+",
  },
  "content-position": {
    syntax: "center | start | end | flex-start | flex-end",
  },
  "content-replacement": {
    syntax: "<image>",
  },
  "contrast()": {
    syntax: "contrast( [ <number-percentage> ] )",
  },
  "cos()": {
    syntax: "cos( <calc-sum> )",
  },
  counter: counter$1,
  "counter()": {
    syntax: "counter( <counter-name>, <counter-style>? )",
  },
  "counter-name": {
    syntax: "<custom-ident>",
  },
  "counter-style": {
    syntax: "<counter-style-name> | symbols()",
  },
  "counter-style-name": {
    syntax: "<custom-ident>",
  },
  "counters()": {
    syntax: "counters( <counter-name>, <string>, <counter-style>? )",
  },
  "cross-fade()": {
    syntax: "cross-fade( <cf-mixing-image> , <cf-final-image>? )",
  },
  "cubic-bezier-timing-function": {
    syntax:
      "ease | ease-in | ease-out | ease-in-out | cubic-bezier(<number [0,1]>, <number>, <number [0,1]>, <number>)",
  },
  "deprecated-system-color": {
    syntax:
      "ActiveBorder | ActiveCaption | AppWorkspace | Background | ButtonFace | ButtonHighlight | ButtonShadow | ButtonText | CaptionText | GrayText | Highlight | HighlightText | InactiveBorder | InactiveCaption | InactiveCaptionText | InfoBackground | InfoText | Menu | MenuText | Scrollbar | ThreeDDarkShadow | ThreeDFace | ThreeDHighlight | ThreeDLightShadow | ThreeDShadow | Window | WindowFrame | WindowText",
  },
  "discretionary-lig-values": {
    syntax: "[ discretionary-ligatures | no-discretionary-ligatures ]",
  },
  "display-box": {
    syntax: "contents | none",
  },
  "display-inside": {
    syntax: "flow | flow-root | table | flex | grid | ruby",
  },
  "display-internal": {
    syntax:
      "table-row-group | table-header-group | table-footer-group | table-row | table-cell | table-column-group | table-column | table-caption | ruby-base | ruby-text | ruby-base-container | ruby-text-container",
  },
  "display-legacy": {
    syntax:
      "inline-block | inline-list-item | inline-table | inline-flex | inline-grid",
  },
  "display-listitem": {
    syntax: "<display-outside>? && [ flow | flow-root ]? && list-item",
  },
  "display-outside": {
    syntax: "block | inline | run-in",
  },
  "drop-shadow()": {
    syntax: "drop-shadow( <length>{2,3} <color>? )",
  },
  "east-asian-variant-values": {
    syntax: "[ jis78 | jis83 | jis90 | jis04 | simplified | traditional ]",
  },
  "east-asian-width-values": {
    syntax: "[ full-width | proportional-width ]",
  },
  "element()": {
    syntax: "element( <id-selector> )",
  },
  "ellipse()": {
    syntax: "ellipse( [ <shape-radius>{2} ]? [ at <position> ]? )",
  },
  "ending-shape": {
    syntax: "circle | ellipse",
  },
  "env()": {
    syntax: "env( <custom-ident> , <declaration-value>? )",
  },
  "exp()": {
    syntax: "exp( <calc-sum> )",
  },
  "explicit-track-list": {
    syntax: "[ <line-names>? <track-size> ]+ <line-names>?",
  },
  "family-name": {
    syntax: "<string> | <custom-ident>+",
  },
  "feature-tag-value": {
    syntax: "<string> [ <integer> | on | off ]?",
  },
  "feature-type": {
    syntax:
      "@stylistic | @historical-forms | @styleset | @character-variant | @swash | @ornaments | @annotation",
  },
  "feature-value-block": {
    syntax: "<feature-type> '{' <feature-value-declaration-list> '}'",
  },
  "feature-value-block-list": {
    syntax: "<feature-value-block>+",
  },
  "feature-value-declaration": {
    syntax: "<custom-ident>: <integer>+;",
  },
  "feature-value-declaration-list": {
    syntax: "<feature-value-declaration>",
  },
  "feature-value-name": {
    syntax: "<custom-ident>",
  },
  "fill-rule": {
    syntax: "nonzero | evenodd",
  },
  "filter-function": {
    syntax:
      "<blur()> | <brightness()> | <contrast()> | <drop-shadow()> | <grayscale()> | <hue-rotate()> | <invert()> | <opacity()> | <saturate()> | <sepia()>",
  },
  "filter-function-list": {
    syntax: "[ <filter-function> | <url> ]+",
  },
  "final-bg-layer": {
    syntax:
      "<'background-color'> || <bg-image> || <bg-position> [ / <bg-size> ]? || <repeat-style> || <attachment> || <box> || <box>",
  },
  "fixed-breadth": {
    syntax: "<length-percentage>",
  },
  "fixed-repeat": {
    syntax:
      "repeat( [ <integer [1,]> ] , [ <line-names>? <fixed-size> ]+ <line-names>? )",
  },
  "fixed-size": {
    syntax:
      "<fixed-breadth> | minmax( <fixed-breadth> , <track-breadth> ) | minmax( <inflexible-breadth> , <fixed-breadth> )",
  },
  "font-stretch-absolute": {
    syntax:
      "normal | ultra-condensed | extra-condensed | condensed | semi-condensed | semi-expanded | expanded | extra-expanded | ultra-expanded | <percentage>",
  },
  "font-variant-css21": {
    syntax: "[ normal | small-caps ]",
  },
  "font-weight-absolute": {
    syntax: "normal | bold | <number [1,1000]>",
  },
  "frequency-percentage": {
    syntax: "<frequency> | <percentage>",
  },
  "general-enclosed": {
    syntax: "[ <function-token> <any-value> ) ] | ( <ident> <any-value> )",
  },
  "generic-family": {
    syntax: "serif | sans-serif | cursive | fantasy | monospace",
  },
  "generic-name": {
    syntax: "serif | sans-serif | cursive | fantasy | monospace",
  },
  "geometry-box": {
    syntax: "<shape-box> | fill-box | stroke-box | view-box",
  },
  gradient: gradient$1,
  "grayscale()": {
    syntax: "grayscale( <number-percentage> )",
  },
  "grid-line": {
    syntax:
      "auto | <custom-ident> | [ <integer> && <custom-ident>? ] | [ span && [ <integer> || <custom-ident> ] ]",
  },
  "historical-lig-values": {
    syntax: "[ historical-ligatures | no-historical-ligatures ]",
  },
  "hsl()": {
    syntax:
      "hsl( <hue> <percentage> <percentage> [ / <alpha-value> ]? ) | hsl( <hue>, <percentage>, <percentage>, <alpha-value>? )",
  },
  "hsla()": {
    syntax:
      "hsla( <hue> <percentage> <percentage> [ / <alpha-value> ]? ) | hsla( <hue>, <percentage>, <percentage>, <alpha-value>? )",
  },
  hue: hue$1,
  "hue-rotate()": {
    syntax: "hue-rotate( <angle> )",
  },
  "hwb()": {
    syntax:
      "hwb( [<hue> | none] [<percentage> | none] [<percentage> | none] [ / [<alpha-value> | none] ]? )",
  },
  "hypot()": {
    syntax: "hypot( <calc-sum># )",
  },
  "id-selector": {
    syntax: "<hash-token>",
  },
  image: image$1,
  "image()": {
    syntax: "image( <image-tags>? [ <image-src>? , <color>? ]! )",
  },
  "image-set()": {
    syntax: "image-set( <image-set-option># )",
  },
  "image-set-option": {
    syntax: "[ <image> | <string> ] [ <resolution> || type(<string>) ]",
  },
  "image-src": {
    syntax: "<url> | <string>",
  },
  "image-tags": {
    syntax: "ltr | rtl",
  },
  "inflexible-breadth": {
    syntax: "<length-percentage> | min-content | max-content | auto",
  },
  "inset()": {
    syntax: "inset( <length-percentage>{1,4} [ round <'border-radius'> ]? )",
  },
  "invert()": {
    syntax: "invert( <number-percentage> )",
  },
  "keyframes-name": {
    syntax: "<custom-ident> | <string>",
  },
  "keyframe-block": {
    syntax: "<keyframe-selector># {\n  <declaration-list>\n}",
  },
  "keyframe-block-list": {
    syntax: "<keyframe-block>+",
  },
  "keyframe-selector": {
    syntax: "from | to | <percentage>",
  },
  "lab()": {
    syntax:
      "lab( [<percentage> | <number> | none] [ <percentage> | <number> | none] [ <percentage> | <number> | none] [ / [<alpha-value> | none] ]? )",
  },
  "layer()": {
    syntax: "layer( <layer-name> )",
  },
  "layer-name": {
    syntax: "<ident> [ '.' <ident> ]*",
  },
  "lch()": {
    syntax:
      "lch( [<percentage> | <number> | none] [ <percentage> | <number> | none] [ <hue> | none] [ / [<alpha-value> | none] ]? )",
  },
  "leader()": {
    syntax: "leader( <leader-type> )",
  },
  "leader-type": {
    syntax: "dotted | solid | space | <string>",
  },
  "length-percentage": {
    syntax: "<length> | <percentage>",
  },
  "line-names": {
    syntax: "'[' <custom-ident>* ']'",
  },
  "line-name-list": {
    syntax: "[ <line-names> | <name-repeat> ]+",
  },
  "line-style": {
    syntax:
      "none | hidden | dotted | dashed | solid | double | groove | ridge | inset | outset",
  },
  "line-width": {
    syntax: "<length> | thin | medium | thick",
  },
  "linear-color-hint": {
    syntax: "<length-percentage>",
  },
  "linear-color-stop": {
    syntax: "<color> <color-stop-length>?",
  },
  "linear-gradient()": {
    syntax:
      "linear-gradient( [ <angle> | to <side-or-corner> ]? , <color-stop-list> )",
  },
  "log()": {
    syntax: "log( <calc-sum>, <calc-sum>? )",
  },
  "mask-layer": {
    syntax:
      "<mask-reference> || <position> [ / <bg-size> ]? || <repeat-style> || <geometry-box> || [ <geometry-box> | no-clip ] || <compositing-operator> || <masking-mode>",
  },
  "mask-position": {
    syntax:
      "[ <length-percentage> | left | center | right ] [ <length-percentage> | top | center | bottom ]?",
  },
  "mask-reference": {
    syntax: "none | <image> | <mask-source>",
  },
  "mask-source": {
    syntax: "<url>",
  },
  "masking-mode": {
    syntax: "alpha | luminance | match-source",
  },
  "matrix()": {
    syntax: "matrix( <number>#{6} )",
  },
  "matrix3d()": {
    syntax: "matrix3d( <number>#{16} )",
  },
  "max()": {
    syntax: "max( <calc-sum># )",
  },
  "media-and": {
    syntax: "<media-in-parens> [ and <media-in-parens> ]+",
  },
  "media-condition": {
    syntax: "<media-not> | <media-and> | <media-or> | <media-in-parens>",
  },
  "media-condition-without-or": {
    syntax: "<media-not> | <media-and> | <media-in-parens>",
  },
  "media-feature": {
    syntax: "( [ <mf-plain> | <mf-boolean> | <mf-range> ] )",
  },
  "media-in-parens": {
    syntax: "( <media-condition> ) | <media-feature> | <general-enclosed>",
  },
  "media-not": {
    syntax: "not <media-in-parens>",
  },
  "media-or": {
    syntax: "<media-in-parens> [ or <media-in-parens> ]+",
  },
  "media-query": {
    syntax:
      "<media-condition> | [ not | only ]? <media-type> [ and <media-condition-without-or> ]?",
  },
  "media-query-list": {
    syntax: "<media-query>#",
  },
  "media-type": {
    syntax: "<ident>",
  },
  "mf-boolean": {
    syntax: "<mf-name>",
  },
  "mf-name": {
    syntax: "<ident>",
  },
  "mf-plain": {
    syntax: "<mf-name> : <mf-value>",
  },
  "mf-range": {
    syntax:
      "<mf-name> [ '<' | '>' ]? '='? <mf-value>\n| <mf-value> [ '<' | '>' ]? '='? <mf-name>\n| <mf-value> '<' '='? <mf-name> '<' '='? <mf-value>\n| <mf-value> '>' '='? <mf-name> '>' '='? <mf-value>",
  },
  "mf-value": {
    syntax: "<number> | <dimension> | <ident> | <ratio>",
  },
  "min()": {
    syntax: "min( <calc-sum># )",
  },
  "minmax()": {
    syntax:
      "minmax( [ <length-percentage> | min-content | max-content | auto ] , [ <length-percentage> | <flex> | min-content | max-content | auto ] )",
  },
  "mod()": {
    syntax: "mod( <calc-sum>, <calc-sum> )",
  },
  "name-repeat": {
    syntax: "repeat( [ <integer [1,]> | auto-fill ], <line-names>+ )",
  },
  "named-color": {
    syntax:
      "transparent | aliceblue | antiquewhite | aqua | aquamarine | azure | beige | bisque | black | blanchedalmond | blue | blueviolet | brown | burlywood | cadetblue | chartreuse | chocolate | coral | cornflowerblue | cornsilk | crimson | cyan | darkblue | darkcyan | darkgoldenrod | darkgray | darkgreen | darkgrey | darkkhaki | darkmagenta | darkolivegreen | darkorange | darkorchid | darkred | darksalmon | darkseagreen | darkslateblue | darkslategray | darkslategrey | darkturquoise | darkviolet | deeppink | deepskyblue | dimgray | dimgrey | dodgerblue | firebrick | floralwhite | forestgreen | fuchsia | gainsboro | ghostwhite | gold | goldenrod | gray | green | greenyellow | grey | honeydew | hotpink | indianred | indigo | ivory | khaki | lavender | lavenderblush | lawngreen | lemonchiffon | lightblue | lightcoral | lightcyan | lightgoldenrodyellow | lightgray | lightgreen | lightgrey | lightpink | lightsalmon | lightseagreen | lightskyblue | lightslategray | lightslategrey | lightsteelblue | lightyellow | lime | limegreen | linen | magenta | maroon | mediumaquamarine | mediumblue | mediumorchid | mediumpurple | mediumseagreen | mediumslateblue | mediumspringgreen | mediumturquoise | mediumvioletred | midnightblue | mintcream | mistyrose | moccasin | navajowhite | navy | oldlace | olive | olivedrab | orange | orangered | orchid | palegoldenrod | palegreen | paleturquoise | palevioletred | papayawhip | peachpuff | peru | pink | plum | powderblue | purple | rebeccapurple | red | rosybrown | royalblue | saddlebrown | salmon | sandybrown | seagreen | seashell | sienna | silver | skyblue | slateblue | slategray | slategrey | snow | springgreen | steelblue | tan | teal | thistle | tomato | turquoise | violet | wheat | white | whitesmoke | yellow | yellowgreen",
  },
  "namespace-prefix": {
    syntax: "<ident>",
  },
  "ns-prefix": {
    syntax: "[ <ident-token> | '*' ]? '|'",
  },
  "number-percentage": {
    syntax: "<number> | <percentage>",
  },
  "numeric-figure-values": {
    syntax: "[ lining-nums | oldstyle-nums ]",
  },
  "numeric-fraction-values": {
    syntax: "[ diagonal-fractions | stacked-fractions ]",
  },
  "numeric-spacing-values": {
    syntax: "[ proportional-nums | tabular-nums ]",
  },
  nth: nth$3,
  "opacity()": {
    syntax: "opacity( [ <number-percentage> ] )",
  },
  "overflow-position": {
    syntax: "unsafe | safe",
  },
  "outline-radius": {
    syntax: "<length> | <percentage>",
  },
  "page-body": {
    syntax: "<declaration>? [ ; <page-body> ]? | <page-margin-box> <page-body>",
  },
  "page-margin-box": {
    syntax: "<page-margin-box-type> '{' <declaration-list> '}'",
  },
  "page-margin-box-type": {
    syntax:
      "@top-left-corner | @top-left | @top-center | @top-right | @top-right-corner | @bottom-left-corner | @bottom-left | @bottom-center | @bottom-right | @bottom-right-corner | @left-top | @left-middle | @left-bottom | @right-top | @right-middle | @right-bottom",
  },
  "page-selector-list": {
    syntax: "[ <page-selector># ]?",
  },
  "page-selector": {
    syntax: "<pseudo-page>+ | <ident> <pseudo-page>*",
  },
  "page-size": {
    syntax:
      "A5 | A4 | A3 | B5 | B4 | JIS-B5 | JIS-B4 | letter | legal | ledger",
  },
  "path()": {
    syntax: "path( [ <fill-rule>, ]? <string> )",
  },
  "paint()": {
    syntax: "paint( <ident>, <declaration-value>? )",
  },
  "perspective()": {
    syntax: "perspective( [ <length [0,]> | none ] )",
  },
  "polygon()": {
    syntax:
      "polygon( <fill-rule>? , [ <length-percentage> <length-percentage> ]# )",
  },
  position: position$2,
  "pow()": {
    syntax: "pow( <calc-sum>, <calc-sum> )",
  },
  "pseudo-class-selector": {
    syntax: "':' <ident-token> | ':' <function-token> <any-value> ')'",
  },
  "pseudo-element-selector": {
    syntax: "':' <pseudo-class-selector>",
  },
  "pseudo-page": {
    syntax: ": [ left | right | first | blank ]",
  },
  quote: quote$1,
  "radial-gradient()": {
    syntax:
      "radial-gradient( [ <ending-shape> || <size> ]? [ at <position> ]? , <color-stop-list> )",
  },
  ratio: ratio,
  "relative-selector": {
    syntax: "<combinator>? <complex-selector>",
  },
  "relative-selector-list": {
    syntax: "<relative-selector>#",
  },
  "relative-size": {
    syntax: "larger | smaller",
  },
  "rem()": {
    syntax: "rem( <calc-sum>, <calc-sum> )",
  },
  "repeat-style": {
    syntax: "repeat-x | repeat-y | [ repeat | space | round | no-repeat ]{1,2}",
  },
  "repeating-conic-gradient()": {
    syntax:
      "repeating-conic-gradient( [ from <angle> ]? [ at <position> ]?, <angular-color-stop-list> )",
  },
  "repeating-linear-gradient()": {
    syntax:
      "repeating-linear-gradient( [ <angle> | to <side-or-corner> ]? , <color-stop-list> )",
  },
  "repeating-radial-gradient()": {
    syntax:
      "repeating-radial-gradient( [ <ending-shape> || <size> ]? [ at <position> ]? , <color-stop-list> )",
  },
  "reversed-counter-name": {
    syntax: "reversed( <counter-name> )",
  },
  "rgb()": {
    syntax:
      "rgb( <percentage>{3} [ / <alpha-value> ]? ) | rgb( <number>{3} [ / <alpha-value> ]? ) | rgb( <percentage>#{3} , <alpha-value>? ) | rgb( <number>#{3} , <alpha-value>? )",
  },
  "rgba()": {
    syntax:
      "rgba( <percentage>{3} [ / <alpha-value> ]? ) | rgba( <number>{3} [ / <alpha-value> ]? ) | rgba( <percentage>#{3} , <alpha-value>? ) | rgba( <number>#{3} , <alpha-value>? )",
  },
  "rotate()": {
    syntax: "rotate( [ <angle> | <zero> ] )",
  },
  "rotate3d()": {
    syntax: "rotate3d( <number> , <number> , <number> , [ <angle> | <zero> ] )",
  },
  "rotateX()": {
    syntax: "rotateX( [ <angle> | <zero> ] )",
  },
  "rotateY()": {
    syntax: "rotateY( [ <angle> | <zero> ] )",
  },
  "rotateZ()": {
    syntax: "rotateZ( [ <angle> | <zero> ] )",
  },
  "round()": {
    syntax: "round( <rounding-strategy>?, <calc-sum>, <calc-sum> )",
  },
  "rounding-strategy": {
    syntax: "nearest | up | down | to-zero",
  },
  "saturate()": {
    syntax: "saturate( <number-percentage> )",
  },
  "scale()": {
    syntax: "scale( [ <number> | <percentage> ]#{1,2} )",
  },
  "scale3d()": {
    syntax: "scale3d( [ <number> | <percentage> ]#{3} )",
  },
  "scaleX()": {
    syntax: "scaleX( [ <number> | <percentage> ] )",
  },
  "scaleY()": {
    syntax: "scaleY( [ <number> | <percentage> ] )",
  },
  "scaleZ()": {
    syntax: "scaleZ( [ <number> | <percentage> ] )",
  },
  scroller: scroller,
  "self-position": {
    syntax:
      "center | start | end | self-start | self-end | flex-start | flex-end",
  },
  "shape-radius": {
    syntax: "<length-percentage> | closest-side | farthest-side",
  },
  "sign()": {
    syntax: "sign( <calc-sum> )",
  },
  "skew()": {
    syntax: "skew( [ <angle> | <zero> ] , [ <angle> | <zero> ]? )",
  },
  "skewX()": {
    syntax: "skewX( [ <angle> | <zero> ] )",
  },
  "skewY()": {
    syntax: "skewY( [ <angle> | <zero> ] )",
  },
  "sepia()": {
    syntax: "sepia( <number-percentage> )",
  },
  shadow: shadow$1,
  "shadow-t": {
    syntax: "[ <length>{2,3} && <color>? ]",
  },
  shape: shape$2,
  "shape-box": {
    syntax: "<box> | margin-box",
  },
  "side-or-corner": {
    syntax: "[ left | right ] || [ top | bottom ]",
  },
  "sin()": {
    syntax: "sin( <calc-sum> )",
  },
  "single-animation": {
    syntax:
      "<time> || <easing-function> || <time> || <single-animation-iteration-count> || <single-animation-direction> || <single-animation-fill-mode> || <single-animation-play-state> || [ none | <keyframes-name> ]",
  },
  "single-animation-direction": {
    syntax: "normal | reverse | alternate | alternate-reverse",
  },
  "single-animation-fill-mode": {
    syntax: "none | forwards | backwards | both",
  },
  "single-animation-iteration-count": {
    syntax: "infinite | <number>",
  },
  "single-animation-play-state": {
    syntax: "running | paused",
  },
  "single-animation-timeline": {
    syntax: "auto | none | <timeline-name> | scroll(<axis>? <scroller>?)",
  },
  "single-transition": {
    syntax:
      "[ none | <single-transition-property> ] || <time> || <easing-function> || <time>",
  },
  "single-transition-property": {
    syntax: "all | <custom-ident>",
  },
  size: size$1,
  "sqrt()": {
    syntax: "sqrt( <calc-sum> )",
  },
  "step-position": {
    syntax: "jump-start | jump-end | jump-none | jump-both | start | end",
  },
  "step-timing-function": {
    syntax: "step-start | step-end | steps(<integer>[, <step-position>]?)",
  },
  "subclass-selector": {
    syntax:
      "<id-selector> | <class-selector> | <attribute-selector> | <pseudo-class-selector>",
  },
  "supports-condition": {
    syntax:
      "not <supports-in-parens> | <supports-in-parens> [ and <supports-in-parens> ]* | <supports-in-parens> [ or <supports-in-parens> ]*",
  },
  "supports-in-parens": {
    syntax:
      "( <supports-condition> ) | <supports-feature> | <general-enclosed>",
  },
  "supports-feature": {
    syntax: "<supports-decl> | <supports-selector-fn>",
  },
  "supports-decl": {
    syntax: "( <declaration> )",
  },
  "supports-selector-fn": {
    syntax: "selector( <complex-selector> )",
  },
  symbol: symbol$1,
  "tan()": {
    syntax: "tan( <calc-sum> )",
  },
  target: target$1,
  "target-counter()": {
    syntax:
      "target-counter( [ <string> | <url> ] , <custom-ident> , <counter-style>? )",
  },
  "target-counters()": {
    syntax:
      "target-counters( [ <string> | <url> ] , <custom-ident> , <string> , <counter-style>? )",
  },
  "target-text()": {
    syntax:
      "target-text( [ <string> | <url> ] , [ content | before | after | first-letter ]? )",
  },
  "time-percentage": {
    syntax: "<time> | <percentage>",
  },
  "timeline-name": {
    syntax: "<custom-ident> | <string>",
  },
  "easing-function": {
    syntax: "linear | <cubic-bezier-timing-function> | <step-timing-function>",
  },
  "track-breadth": {
    syntax: "<length-percentage> | <flex> | min-content | max-content | auto",
  },
  "track-list": {
    syntax:
      "[ <line-names>? [ <track-size> | <track-repeat> ] ]+ <line-names>?",
  },
  "track-repeat": {
    syntax:
      "repeat( [ <integer [1,]> ] , [ <line-names>? <track-size> ]+ <line-names>? )",
  },
  "track-size": {
    syntax:
      "<track-breadth> | minmax( <inflexible-breadth> , <track-breadth> ) | fit-content( <length-percentage> )",
  },
  "transform-function": {
    syntax:
      "<matrix()> | <translate()> | <translateX()> | <translateY()> | <scale()> | <scaleX()> | <scaleY()> | <rotate()> | <skew()> | <skewX()> | <skewY()> | <matrix3d()> | <translate3d()> | <translateZ()> | <scale3d()> | <scaleZ()> | <rotate3d()> | <rotateX()> | <rotateY()> | <rotateZ()> | <perspective()>",
  },
  "transform-list": {
    syntax: "<transform-function>+",
  },
  "translate()": {
    syntax: "translate( <length-percentage> , <length-percentage>? )",
  },
  "translate3d()": {
    syntax:
      "translate3d( <length-percentage> , <length-percentage> , <length> )",
  },
  "translateX()": {
    syntax: "translateX( <length-percentage> )",
  },
  "translateY()": {
    syntax: "translateY( <length-percentage> )",
  },
  "translateZ()": {
    syntax: "translateZ( <length> )",
  },
  "type-or-unit": {
    syntax:
      "string | color | url | integer | number | length | angle | time | frequency | cap | ch | em | ex | ic | lh | rlh | rem | vb | vi | vw | vh | vmin | vmax | mm | Q | cm | in | pt | pc | px | deg | grad | rad | turn | ms | s | Hz | kHz | %",
  },
  "type-selector": {
    syntax: "<wq-name> | <ns-prefix>? '*'",
  },
  "var()": {
    syntax: "var( <custom-property-name> , <declaration-value>? )",
  },
  "viewport-length": {
    syntax: "auto | <length-percentage>",
  },
  "visual-box": {
    syntax: "content-box | padding-box | border-box",
  },
  "wq-name": {
    syntax: "<ns-prefix>? <ident-token>",
  },
};

const dataPatch$2 = dataPatch$3;

const mdnAtrules$1 = require$$1$1;
const mdnProperties$1 = require$$2$1;
const mdnSyntaxes$1 = require$$3$1;

const extendSyntax$1 = /^\s*\|\s*/;

function preprocessAtrules$1(dict) {
  const result = Object.create(null);

  for (const atruleName in dict) {
    const atrule = dict[atruleName];
    let descriptors = null;

    if (atrule.descriptors) {
      descriptors = Object.create(null);

      for (const descriptor in atrule.descriptors) {
        descriptors[descriptor] = atrule.descriptors[descriptor].syntax;
      }
    }

    result[atruleName.substr(1)] = {
      prelude:
        atrule.syntax
          .trim()
          .replace(/\{(.|\s)+\}/, "")
          .match(/^@\S+\s+([^;\{]*)/)[1]
          .trim() || null,
      descriptors,
    };
  }

  return result;
}

function patchDictionary$1(dict, patchDict) {
  const result = {};

  // copy all syntaxes for an original dict
  for (const key in dict) {
    result[key] = dict[key].syntax || dict[key];
  }

  // apply a patch
  for (const key in patchDict) {
    if (key in dict) {
      if (patchDict[key].syntax) {
        result[key] = extendSyntax$1.test(patchDict[key].syntax)
          ? result[key] + " " + patchDict[key].syntax.trim()
          : patchDict[key].syntax;
      } else {
        delete result[key];
      }
    } else {
      if (patchDict[key].syntax) {
        result[key] = patchDict[key].syntax.replace(extendSyntax$1, "");
      }
    }
  }

  return result;
}

function patchAtrules$1(dict, patchDict) {
  const result = {};

  // copy all syntaxes for an original dict
  for (const key in dict) {
    const atrulePatch = patchDict[key] || {};

    result[key] = {
      prelude:
        key in patchDict && "prelude" in atrulePatch
          ? atrulePatch.prelude
          : dict[key].prelude || null,
      descriptors: patchDictionary$1(
        dict[key].descriptors || {},
        atrulePatch.descriptors || {},
      ),
    };
  }

  // apply a patch
  for (const key in patchDict) {
    if (!hasOwnProperty.call(dict, key)) {
      const atrulePatch = patchDict[key] || {};

      result[key] = {
        prelude: atrulePatch.prelude || null,
        descriptors:
          atrulePatch.descriptors &&
          patchDictionary$1({}, atrulePatch.descriptors),
      };
    }
  }

  return result;
}

const definitions$1 = {
  types: patchDictionary$1(mdnSyntaxes$1, dataPatch$2.types),
  atrules: patchAtrules$1(
    preprocessAtrules$1(mdnAtrules$1),
    dataPatch$2.atrules,
  ),
  properties: patchDictionary$1(mdnProperties$1, dataPatch$2.properties),
};

var data$3 = definitions$1;

var node$1 = {};

var AnPlusB$5 = {};

const types$1A = types$1M;
const charCodeDefinitions$i = charCodeDefinitions$p;

const PLUSSIGN$f = 0x002b; // U+002B PLUS SIGN (+)
const HYPHENMINUS$9 = 0x002d; // U+002D HYPHEN-MINUS (-)
const N$5 = 0x006e; // U+006E LATIN SMALL LETTER N (n)
const DISALLOW_SIGN$2 = true;
const ALLOW_SIGN$2 = false;

function checkInteger$2(offset, disallowSign) {
  let pos = this.tokenStart + offset;
  const code = this.charCodeAt(pos);

  if (code === PLUSSIGN$f || code === HYPHENMINUS$9) {
    if (disallowSign) {
      this.error("Number sign is not allowed");
    }
    pos++;
  }

  for (; pos < this.tokenEnd; pos++) {
    if (!charCodeDefinitions$i.isDigit(this.charCodeAt(pos))) {
      this.error("Integer is expected", pos);
    }
  }
}

function checkTokenIsInteger$1(disallowSign) {
  return checkInteger$2.call(this, 0, disallowSign);
}

function expectCharCode$1(offset, code) {
  if (!this.cmpChar(this.tokenStart + offset, code)) {
    let msg = "";

    switch (code) {
      case N$5:
        msg = "N is expected";
        break;
      case HYPHENMINUS$9:
        msg = "HyphenMinus is expected";
        break;
    }

    this.error(msg, this.tokenStart + offset);
  }
}

// ... <signed-integer>
// ... ['+' | '-'] <signless-integer>
function consumeB$2() {
  let offset = 0;
  let sign = 0;
  let type = this.tokenType;

  while (type === types$1A.WhiteSpace || type === types$1A.Comment) {
    type = this.lookupType(++offset);
  }

  if (type !== types$1A.Number) {
    if (
      this.isDelim(PLUSSIGN$f, offset) ||
      this.isDelim(HYPHENMINUS$9, offset)
    ) {
      sign = this.isDelim(PLUSSIGN$f, offset) ? PLUSSIGN$f : HYPHENMINUS$9;

      do {
        type = this.lookupType(++offset);
      } while (type === types$1A.WhiteSpace || type === types$1A.Comment);

      if (type !== types$1A.Number) {
        this.skip(offset);
        checkTokenIsInteger$1.call(this, DISALLOW_SIGN$2);
      }
    } else {
      return null;
    }
  }

  if (offset > 0) {
    this.skip(offset);
  }

  if (sign === 0) {
    type = this.charCodeAt(this.tokenStart);
    if (type !== PLUSSIGN$f && type !== HYPHENMINUS$9) {
      this.error("Number sign is expected");
    }
  }

  checkTokenIsInteger$1.call(this, sign !== 0);
  return sign === HYPHENMINUS$9
    ? "-" + this.consume(types$1A.Number)
    : this.consume(types$1A.Number);
}

// An+B microsyntax https://www.w3.org/TR/css-syntax-3/#anb
const name$1j = "AnPlusB";
const structure$1i = {
  a: [String, null],
  b: [String, null],
};

function parse$1u() {
  /* eslint-disable brace-style*/
  const start = this.tokenStart;
  let a = null;
  let b = null;

  // <integer>
  if (this.tokenType === types$1A.Number) {
    checkTokenIsInteger$1.call(this, ALLOW_SIGN$2);
    b = this.consume(types$1A.Number);
  }

  // -n
  // -n <signed-integer>
  // -n ['+' | '-'] <signless-integer>
  // -n- <signless-integer>
  // <dashndashdigit-ident>
  else if (
    this.tokenType === types$1A.Ident &&
    this.cmpChar(this.tokenStart, HYPHENMINUS$9)
  ) {
    a = "-1";

    expectCharCode$1.call(this, 1, N$5);

    switch (this.tokenEnd - this.tokenStart) {
      // -n
      // -n <signed-integer>
      // -n ['+' | '-'] <signless-integer>
      case 2:
        this.next();
        b = consumeB$2.call(this);
        break;

      // -n- <signless-integer>
      case 3:
        expectCharCode$1.call(this, 2, HYPHENMINUS$9);

        this.next();
        this.skipSC();

        checkTokenIsInteger$1.call(this, DISALLOW_SIGN$2);

        b = "-" + this.consume(types$1A.Number);
        break;

      // <dashndashdigit-ident>
      default:
        expectCharCode$1.call(this, 2, HYPHENMINUS$9);
        checkInteger$2.call(this, 3, DISALLOW_SIGN$2);
        this.next();

        b = this.substrToCursor(start + 2);
    }
  }

  // '+'? n
  // '+'? n <signed-integer>
  // '+'? n ['+' | '-'] <signless-integer>
  // '+'? n- <signless-integer>
  // '+'? <ndashdigit-ident>
  else if (
    this.tokenType === types$1A.Ident ||
    (this.isDelim(PLUSSIGN$f) && this.lookupType(1) === types$1A.Ident)
  ) {
    let sign = 0;
    a = "1";

    // just ignore a plus
    if (this.isDelim(PLUSSIGN$f)) {
      sign = 1;
      this.next();
    }

    expectCharCode$1.call(this, 0, N$5);

    switch (this.tokenEnd - this.tokenStart) {
      // '+'? n
      // '+'? n <signed-integer>
      // '+'? n ['+' | '-'] <signless-integer>
      case 1:
        this.next();
        b = consumeB$2.call(this);
        break;

      // '+'? n- <signless-integer>
      case 2:
        expectCharCode$1.call(this, 1, HYPHENMINUS$9);

        this.next();
        this.skipSC();

        checkTokenIsInteger$1.call(this, DISALLOW_SIGN$2);

        b = "-" + this.consume(types$1A.Number);
        break;

      // '+'? <ndashdigit-ident>
      default:
        expectCharCode$1.call(this, 1, HYPHENMINUS$9);
        checkInteger$2.call(this, 2, DISALLOW_SIGN$2);
        this.next();

        b = this.substrToCursor(start + sign + 1);
    }
  }

  // <ndashdigit-dimension>
  // <ndash-dimension> <signless-integer>
  // <n-dimension>
  // <n-dimension> <signed-integer>
  // <n-dimension> ['+' | '-'] <signless-integer>
  else if (this.tokenType === types$1A.Dimension) {
    const code = this.charCodeAt(this.tokenStart);
    const sign = code === PLUSSIGN$f || code === HYPHENMINUS$9;
    let i = this.tokenStart + sign;

    for (; i < this.tokenEnd; i++) {
      if (!charCodeDefinitions$i.isDigit(this.charCodeAt(i))) {
        break;
      }
    }

    if (i === this.tokenStart + sign) {
      this.error("Integer is expected", this.tokenStart + sign);
    }

    expectCharCode$1.call(this, i - this.tokenStart, N$5);
    a = this.substring(start, i);

    // <n-dimension>
    // <n-dimension> <signed-integer>
    // <n-dimension> ['+' | '-'] <signless-integer>
    if (i + 1 === this.tokenEnd) {
      this.next();
      b = consumeB$2.call(this);
    } else {
      expectCharCode$1.call(this, i - this.tokenStart + 1, HYPHENMINUS$9);

      // <ndash-dimension> <signless-integer>
      if (i + 2 === this.tokenEnd) {
        this.next();
        this.skipSC();
        checkTokenIsInteger$1.call(this, DISALLOW_SIGN$2);
        b = "-" + this.consume(types$1A.Number);
      }
      // <ndashdigit-dimension>
      else {
        checkInteger$2.call(this, i - this.tokenStart + 2, DISALLOW_SIGN$2);
        this.next();
        b = this.substrToCursor(i + 1);
      }
    }
  } else {
    this.error();
  }

  if (a !== null && a.charCodeAt(0) === PLUSSIGN$f) {
    a = a.substr(1);
  }

  if (b !== null && b.charCodeAt(0) === PLUSSIGN$f) {
    b = b.substr(1);
  }

  return {
    type: "AnPlusB",
    loc: this.getLocation(start, this.tokenStart),
    a,
    b,
  };
}

function generate$1q(node) {
  if (node.a) {
    const a =
      (node.a === "+1" && "n") ||
      (node.a === "1" && "n") ||
      (node.a === "-1" && "-n") ||
      node.a + "n";

    if (node.b) {
      const b = node.b[0] === "-" || node.b[0] === "+" ? node.b : "+" + node.b;
      this.tokenize(a + b);
    } else {
      this.tokenize(a);
    }
  } else {
    this.tokenize(node.b);
  }
}

AnPlusB$5.generate = generate$1q;
AnPlusB$5.name = name$1j;
AnPlusB$5.parse = parse$1u;
AnPlusB$5.structure = structure$1i;

var Atrule$9 = {};

const types$1z = types$1M;

function consumeRaw$b(startToken) {
  return this.Raw(
    startToken,
    this.consumeUntilLeftCurlyBracketOrSemicolon,
    true,
  );
}

function isDeclarationBlockAtrule$1() {
  for (let offset = 1, type; (type = this.lookupType(offset)); offset++) {
    if (type === types$1z.RightCurlyBracket) {
      return true;
    }

    if (type === types$1z.LeftCurlyBracket || type === types$1z.AtKeyword) {
      return false;
    }
  }

  return false;
}

const name$1i = "Atrule";
const walkContext$j = "atrule";
const structure$1h = {
  name: String,
  prelude: ["AtrulePrelude", "Raw", null],
  block: ["Block", null],
};

function parse$1t(isDeclaration = false) {
  const start = this.tokenStart;
  let name;
  let nameLowerCase;
  let prelude = null;
  let block = null;

  this.eat(types$1z.AtKeyword);

  name = this.substrToCursor(start + 1);
  nameLowerCase = name.toLowerCase();
  this.skipSC();

  // parse prelude
  if (
    this.eof === false &&
    this.tokenType !== types$1z.LeftCurlyBracket &&
    this.tokenType !== types$1z.Semicolon
  ) {
    if (this.parseAtrulePrelude) {
      prelude = this.parseWithFallback(
        this.AtrulePrelude.bind(this, name, isDeclaration),
        consumeRaw$b,
      );
    } else {
      prelude = consumeRaw$b.call(this, this.tokenIndex);
    }

    this.skipSC();
  }

  switch (this.tokenType) {
    case types$1z.Semicolon:
      this.next();
      break;

    case types$1z.LeftCurlyBracket:
      if (
        hasOwnProperty.call(this.atrule, nameLowerCase) &&
        typeof this.atrule[nameLowerCase].block === "function"
      ) {
        block = this.atrule[nameLowerCase].block.call(this, isDeclaration);
      } else {
        // TODO: should consume block content as Raw?
        block = this.Block(isDeclarationBlockAtrule$1.call(this));
      }

      break;
  }

  return {
    type: "Atrule",
    loc: this.getLocation(start, this.tokenStart),
    name,
    prelude,
    block,
  };
}

function generate$1p(node) {
  this.token(types$1z.AtKeyword, "@" + node.name);

  if (node.prelude !== null) {
    this.node(node.prelude);
  }

  if (node.block) {
    this.node(node.block);
  } else {
    this.token(types$1z.Semicolon, ";");
  }
}

Atrule$9.generate = generate$1p;
Atrule$9.name = name$1i;
Atrule$9.parse = parse$1t;
Atrule$9.structure = structure$1h;
Atrule$9.walkContext = walkContext$j;

var AtrulePrelude$5 = {};

const types$1y = types$1M;

const name$1h = "AtrulePrelude";
const walkContext$i = "atrulePrelude";
const structure$1g = {
  children: [[]],
};

function parse$1s(name) {
  let children = null;

  if (name !== null) {
    name = name.toLowerCase();
  }

  this.skipSC();

  if (
    hasOwnProperty.call(this.atrule, name) &&
    typeof this.atrule[name].prelude === "function"
  ) {
    // custom consumer
    children = this.atrule[name].prelude.call(this);
  } else {
    // default consumer
    children = this.readSequence(this.scope.AtrulePrelude);
  }

  this.skipSC();

  if (
    this.eof !== true &&
    this.tokenType !== types$1y.LeftCurlyBracket &&
    this.tokenType !== types$1y.Semicolon
  ) {
    this.error("Semicolon or block is expected");
  }

  return {
    type: "AtrulePrelude",
    loc: this.getLocationFromList(children),
    children,
  };
}

function generate$1o(node) {
  this.children(node);
}

AtrulePrelude$5.generate = generate$1o;
AtrulePrelude$5.name = name$1h;
AtrulePrelude$5.parse = parse$1s;
AtrulePrelude$5.structure = structure$1g;
AtrulePrelude$5.walkContext = walkContext$i;

var AttributeSelector$7 = {};

const types$1x = types$1M;

const DOLLARSIGN$3 = 0x0024; // U+0024 DOLLAR SIGN ($)
const ASTERISK$c = 0x002a; // U+002A ASTERISK (*)
const EQUALSSIGN$1 = 0x003d; // U+003D EQUALS SIGN (=)
const CIRCUMFLEXACCENT$1 = 0x005e; // U+005E (^)
const VERTICALLINE$6 = 0x007c; // U+007C VERTICAL LINE (|)
const TILDE$5 = 0x007e; // U+007E TILDE (~)

function getAttributeName$1() {
  if (this.eof) {
    this.error("Unexpected end of input");
  }

  const start = this.tokenStart;
  let expectIdent = false;

  if (this.isDelim(ASTERISK$c)) {
    expectIdent = true;
    this.next();
  } else if (!this.isDelim(VERTICALLINE$6)) {
    this.eat(types$1x.Ident);
  }

  if (this.isDelim(VERTICALLINE$6)) {
    if (this.charCodeAt(this.tokenStart + 1) !== EQUALSSIGN$1) {
      this.next();
      this.eat(types$1x.Ident);
    } else if (expectIdent) {
      this.error("Identifier is expected", this.tokenEnd);
    }
  } else if (expectIdent) {
    this.error("Vertical line is expected");
  }

  return {
    type: "Identifier",
    loc: this.getLocation(start, this.tokenStart),
    name: this.substrToCursor(start),
  };
}

function getOperator$1() {
  const start = this.tokenStart;
  const code = this.charCodeAt(start);

  if (
    code !== EQUALSSIGN$1 && // =
    code !== TILDE$5 && // ~=
    code !== CIRCUMFLEXACCENT$1 && // ^=
    code !== DOLLARSIGN$3 && // $=
    code !== ASTERISK$c && // *=
    code !== VERTICALLINE$6 // |=
  ) {
    this.error("Attribute selector (=, ~=, ^=, $=, *=, |=) is expected");
  }

  this.next();

  if (code !== EQUALSSIGN$1) {
    if (!this.isDelim(EQUALSSIGN$1)) {
      this.error("Equal sign is expected");
    }

    this.next();
  }

  return this.substrToCursor(start);
}

// '[' <wq-name> ']'
// '[' <wq-name> <attr-matcher> [ <string-token> | <ident-token> ] <attr-modifier>? ']'
const name$1g = "AttributeSelector";
const structure$1f = {
  name: "Identifier",
  matcher: [String, null],
  value: ["String", "Identifier", null],
  flags: [String, null],
};

function parse$1r() {
  const start = this.tokenStart;
  let name;
  let matcher = null;
  let value = null;
  let flags = null;

  this.eat(types$1x.LeftSquareBracket);
  this.skipSC();

  name = getAttributeName$1.call(this);
  this.skipSC();

  if (this.tokenType !== types$1x.RightSquareBracket) {
    // avoid case `[name i]`
    if (this.tokenType !== types$1x.Ident) {
      matcher = getOperator$1.call(this);

      this.skipSC();

      value =
        this.tokenType === types$1x.String ? this.String() : this.Identifier();

      this.skipSC();
    }

    // attribute flags
    if (this.tokenType === types$1x.Ident) {
      flags = this.consume(types$1x.Ident);

      this.skipSC();
    }
  }

  this.eat(types$1x.RightSquareBracket);

  return {
    type: "AttributeSelector",
    loc: this.getLocation(start, this.tokenStart),
    name,
    matcher,
    value,
    flags,
  };
}

function generate$1n(node) {
  this.token(types$1x.Delim, "[");
  this.node(node.name);

  if (node.matcher !== null) {
    this.tokenize(node.matcher);
    this.node(node.value);
  }

  if (node.flags !== null) {
    this.token(types$1x.Ident, node.flags);
  }

  this.token(types$1x.Delim, "]");
}

AttributeSelector$7.generate = generate$1n;
AttributeSelector$7.name = name$1g;
AttributeSelector$7.parse = parse$1r;
AttributeSelector$7.structure = structure$1f;

var Block$5 = {};

const types$1w = types$1M;

const AMPERSAND$6 = 0x0026; // U+0026 AMPERSAND (&)

function consumeRaw$a(startToken) {
  return this.Raw(startToken, null, true);
}
function consumeRule$1() {
  return this.parseWithFallback(this.Rule, consumeRaw$a);
}
function consumeRawDeclaration$1(startToken) {
  return this.Raw(startToken, this.consumeUntilSemicolonIncluded, true);
}
function consumeDeclaration$1() {
  if (this.tokenType === types$1w.Semicolon) {
    return consumeRawDeclaration$1.call(this, this.tokenIndex);
  }

  const node = this.parseWithFallback(
    this.Declaration,
    consumeRawDeclaration$1,
  );

  if (this.tokenType === types$1w.Semicolon) {
    this.next();
  }

  return node;
}

const name$1f = "Block";
const walkContext$h = "block";
const structure$1e = {
  children: [["Atrule", "Rule", "Declaration"]],
};

function parse$1q(isStyleBlock) {
  const consumer = isStyleBlock ? consumeDeclaration$1 : consumeRule$1;
  const start = this.tokenStart;
  let children = this.createList();

  this.eat(types$1w.LeftCurlyBracket);

  scan: while (!this.eof) {
    switch (this.tokenType) {
      case types$1w.RightCurlyBracket:
        break scan;

      case types$1w.WhiteSpace:
      case types$1w.Comment:
        this.next();
        break;

      case types$1w.AtKeyword:
        children.push(
          this.parseWithFallback(
            this.Atrule.bind(this, isStyleBlock),
            consumeRaw$a,
          ),
        );
        break;

      default:
        if (isStyleBlock && this.isDelim(AMPERSAND$6)) {
          children.push(consumeRule$1.call(this));
        } else {
          children.push(consumer.call(this));
        }
    }
  }

  if (!this.eof) {
    this.eat(types$1w.RightCurlyBracket);
  }

  return {
    type: "Block",
    loc: this.getLocation(start, this.tokenStart),
    children,
  };
}

function generate$1m(node) {
  this.token(types$1w.LeftCurlyBracket, "{");
  this.children(node, (prev) => {
    if (prev.type === "Declaration") {
      this.token(types$1w.Semicolon, ";");
    }
  });
  this.token(types$1w.RightCurlyBracket, "}");
}

Block$5.generate = generate$1m;
Block$5.name = name$1f;
Block$5.parse = parse$1q;
Block$5.structure = structure$1e;
Block$5.walkContext = walkContext$h;

var Brackets$5 = {};

const types$1v = types$1M;

const name$1e = "Brackets";
const structure$1d = {
  children: [[]],
};

function parse$1p(readSequence, recognizer) {
  const start = this.tokenStart;
  let children = null;

  this.eat(types$1v.LeftSquareBracket);

  children = readSequence.call(this, recognizer);

  if (!this.eof) {
    this.eat(types$1v.RightSquareBracket);
  }

  return {
    type: "Brackets",
    loc: this.getLocation(start, this.tokenStart),
    children,
  };
}

function generate$1l(node) {
  this.token(types$1v.Delim, "[");
  this.children(node);
  this.token(types$1v.Delim, "]");
}

Brackets$5.generate = generate$1l;
Brackets$5.name = name$1e;
Brackets$5.parse = parse$1p;
Brackets$5.structure = structure$1d;

var CDC$6 = {};

const types$1u = types$1M;

const name$1d = "CDC";
const structure$1c = [];

function parse$1o() {
  const start = this.tokenStart;

  this.eat(types$1u.CDC); // -->

  return {
    type: "CDC",
    loc: this.getLocation(start, this.tokenStart),
  };
}

function generate$1k() {
  this.token(types$1u.CDC, "-->");
}

CDC$6.generate = generate$1k;
CDC$6.name = name$1d;
CDC$6.parse = parse$1o;
CDC$6.structure = structure$1c;

var CDO$6 = {};

const types$1t = types$1M;

const name$1c = "CDO";
const structure$1b = [];

function parse$1n() {
  const start = this.tokenStart;

  this.eat(types$1t.CDO); // <!--

  return {
    type: "CDO",
    loc: this.getLocation(start, this.tokenStart),
  };
}

function generate$1j() {
  this.token(types$1t.CDO, "<!--");
}

CDO$6.generate = generate$1j;
CDO$6.name = name$1c;
CDO$6.parse = parse$1n;
CDO$6.structure = structure$1b;

var ClassSelector$5 = {};

const types$1s = types$1M;

const FULLSTOP$5 = 0x002e; // U+002E FULL STOP (.)

// '.' ident
const name$1b = "ClassSelector";
const structure$1a = {
  name: String,
};

function parse$1m() {
  this.eatDelim(FULLSTOP$5);

  return {
    type: "ClassSelector",
    loc: this.getLocation(this.tokenStart - 1, this.tokenEnd),
    name: this.consume(types$1s.Ident),
  };
}

function generate$1i(node) {
  this.token(types$1s.Delim, ".");
  this.token(types$1s.Ident, node.name);
}

ClassSelector$5.generate = generate$1i;
ClassSelector$5.name = name$1b;
ClassSelector$5.parse = parse$1m;
ClassSelector$5.structure = structure$1a;

var Combinator$5 = {};

const types$1r = types$1M;

const PLUSSIGN$e = 0x002b; // U+002B PLUS SIGN (+)
const SOLIDUS$b = 0x002f; // U+002F SOLIDUS (/)
const GREATERTHANSIGN$4 = 0x003e; // U+003E GREATER-THAN SIGN (>)
const TILDE$4 = 0x007e; // U+007E TILDE (~)

const name$1a = "Combinator";
const structure$19 = {
  name: String,
};

// + | > | ~ | /deep/
function parse$1l() {
  const start = this.tokenStart;
  let name;

  switch (this.tokenType) {
    case types$1r.WhiteSpace:
      name = " ";
      break;

    case types$1r.Delim:
      switch (this.charCodeAt(this.tokenStart)) {
        case GREATERTHANSIGN$4:
        case PLUSSIGN$e:
        case TILDE$4:
          this.next();
          break;

        case SOLIDUS$b:
          this.next();
          this.eatIdent("deep");
          this.eatDelim(SOLIDUS$b);
          break;

        default:
          this.error("Combinator is expected");
      }

      name = this.substrToCursor(start);
      break;
  }

  return {
    type: "Combinator",
    loc: this.getLocation(start, this.tokenStart),
    name,
  };
}

function generate$1h(node) {
  this.tokenize(node.name);
}

Combinator$5.generate = generate$1h;
Combinator$5.name = name$1a;
Combinator$5.parse = parse$1l;
Combinator$5.structure = structure$19;

var Comment$8 = {};

const types$1q = types$1M;

const ASTERISK$b = 0x002a; // U+002A ASTERISK (*)
const SOLIDUS$a = 0x002f; // U+002F SOLIDUS (/)

const name$19 = "Comment";
const structure$18 = {
  value: String,
};

function parse$1k() {
  const start = this.tokenStart;
  let end = this.tokenEnd;

  this.eat(types$1q.Comment);

  if (
    end - start + 2 >= 2 &&
    this.charCodeAt(end - 2) === ASTERISK$b &&
    this.charCodeAt(end - 1) === SOLIDUS$a
  ) {
    end -= 2;
  }

  return {
    type: "Comment",
    loc: this.getLocation(start, this.tokenStart),
    value: this.substring(start + 2, end),
  };
}

function generate$1g(node) {
  this.token(types$1q.Comment, "/*" + node.value + "*/");
}

Comment$8.generate = generate$1g;
Comment$8.name = name$19;
Comment$8.parse = parse$1k;
Comment$8.structure = structure$18;

var Declaration$7 = {};

const names$a = names$c;
const types$1p = types$1M;

const EXCLAMATIONMARK$5 = 0x0021; // U+0021 EXCLAMATION MARK (!)
const NUMBERSIGN$7 = 0x0023; // U+0023 NUMBER SIGN (#)
const DOLLARSIGN$2 = 0x0024; // U+0024 DOLLAR SIGN ($)
const AMPERSAND$5 = 0x0026; // U+0026 AMPERSAND (&)
const ASTERISK$a = 0x002a; // U+002A ASTERISK (*)
const PLUSSIGN$d = 0x002b; // U+002B PLUS SIGN (+)
const SOLIDUS$9 = 0x002f; // U+002F SOLIDUS (/)

function consumeValueRaw$1(startToken) {
  return this.Raw(
    startToken,
    this.consumeUntilExclamationMarkOrSemicolon,
    true,
  );
}

function consumeCustomPropertyRaw$1(startToken) {
  return this.Raw(
    startToken,
    this.consumeUntilExclamationMarkOrSemicolon,
    false,
  );
}

function consumeValue$1() {
  const startValueToken = this.tokenIndex;
  const value = this.Value();

  if (
    value.type !== "Raw" &&
    this.eof === false &&
    this.tokenType !== types$1p.Semicolon &&
    this.isDelim(EXCLAMATIONMARK$5) === false &&
    this.isBalanceEdge(startValueToken) === false
  ) {
    this.error();
  }

  return value;
}

const name$18 = "Declaration";
const walkContext$g = "declaration";
const structure$17 = {
  important: [Boolean, String],
  property: String,
  value: ["Value", "Raw"],
};

function parse$1j() {
  const start = this.tokenStart;
  const startToken = this.tokenIndex;
  const property = readProperty$2.call(this);
  const customProperty = names$a.isCustomProperty(property);
  const parseValue = customProperty
    ? this.parseCustomProperty
    : this.parseValue;
  const consumeRaw = customProperty
    ? consumeCustomPropertyRaw$1
    : consumeValueRaw$1;
  let important = false;
  let value;

  this.skipSC();
  this.eat(types$1p.Colon);

  const valueStart = this.tokenIndex;

  if (!customProperty) {
    this.skipSC();
  }

  if (parseValue) {
    value = this.parseWithFallback(consumeValue$1, consumeRaw);
  } else {
    value = consumeRaw.call(this, this.tokenIndex);
  }

  if (customProperty && value.type === "Value" && value.children.isEmpty) {
    for (let offset = valueStart - this.tokenIndex; offset <= 0; offset++) {
      if (this.lookupType(offset) === types$1p.WhiteSpace) {
        value.children.appendData({
          type: "WhiteSpace",
          loc: null,
          value: " ",
        });
        break;
      }
    }
  }

  if (this.isDelim(EXCLAMATIONMARK$5)) {
    important = getImportant$1.call(this);
    this.skipSC();
  }

  // Do not include semicolon to range per spec
  // https://drafts.csswg.org/css-syntax/#declaration-diagram

  if (
    this.eof === false &&
    this.tokenType !== types$1p.Semicolon &&
    this.isBalanceEdge(startToken) === false
  ) {
    this.error();
  }

  return {
    type: "Declaration",
    loc: this.getLocation(start, this.tokenStart),
    important,
    property,
    value,
  };
}

function generate$1f(node) {
  this.token(types$1p.Ident, node.property);
  this.token(types$1p.Colon, ":");
  this.node(node.value);

  if (node.important) {
    this.token(types$1p.Delim, "!");
    this.token(
      types$1p.Ident,
      node.important === true ? "important" : node.important,
    );
  }
}

function readProperty$2() {
  const start = this.tokenStart;

  // hacks
  if (this.tokenType === types$1p.Delim) {
    switch (this.charCodeAt(this.tokenStart)) {
      case ASTERISK$a:
      case DOLLARSIGN$2:
      case PLUSSIGN$d:
      case NUMBERSIGN$7:
      case AMPERSAND$5:
        this.next();
        break;

      // TODO: not sure we should support this hack
      case SOLIDUS$9:
        this.next();
        if (this.isDelim(SOLIDUS$9)) {
          this.next();
        }
        break;
    }
  }

  if (this.tokenType === types$1p.Hash) {
    this.eat(types$1p.Hash);
  } else {
    this.eat(types$1p.Ident);
  }

  return this.substrToCursor(start);
}

// ! ws* important
function getImportant$1() {
  this.eat(types$1p.Delim);
  this.skipSC();

  const important = this.consume(types$1p.Ident);

  // store original value in case it differ from `important`
  // for better original source restoring and hacks like `!ie` support
  return important === "important" ? true : important;
}

Declaration$7.generate = generate$1f;
Declaration$7.name = name$18;
Declaration$7.parse = parse$1j;
Declaration$7.structure = structure$17;
Declaration$7.walkContext = walkContext$g;

var DeclarationList$5 = {};

const types$1o = types$1M;

const AMPERSAND$4 = 0x0026; // U+0026 AMPERSAND (&)

function consumeRaw$9(startToken) {
  return this.Raw(startToken, this.consumeUntilSemicolonIncluded, true);
}

const name$17 = "DeclarationList";
const structure$16 = {
  children: [["Declaration", "Atrule", "Rule"]],
};

function parse$1i() {
  const children = this.createList();

  while (!this.eof) {
    switch (this.tokenType) {
      case types$1o.WhiteSpace:
      case types$1o.Comment:
      case types$1o.Semicolon:
        this.next();
        break;

      case types$1o.AtKeyword:
        children.push(
          this.parseWithFallback(this.Atrule.bind(this, true), consumeRaw$9),
        );
        break;

      default:
        if (this.isDelim(AMPERSAND$4)) {
          children.push(this.parseWithFallback(this.Rule, consumeRaw$9));
        } else {
          children.push(this.parseWithFallback(this.Declaration, consumeRaw$9));
        }
    }
  }

  return {
    type: "DeclarationList",
    loc: this.getLocationFromList(children),
    children,
  };
}

function generate$1e(node) {
  this.children(node, (prev) => {
    if (prev.type === "Declaration") {
      this.token(types$1o.Semicolon, ";");
    }
  });
}

DeclarationList$5.generate = generate$1e;
DeclarationList$5.name = name$17;
DeclarationList$5.parse = parse$1i;
DeclarationList$5.structure = structure$16;

var Dimension$8 = {};

const types$1n = types$1M;

const name$16 = "Dimension";
const structure$15 = {
  value: String,
  unit: String,
};

function parse$1h() {
  const start = this.tokenStart;
  const value = this.consumeNumber(types$1n.Dimension);

  return {
    type: "Dimension",
    loc: this.getLocation(start, this.tokenStart),
    value,
    unit: this.substring(start + value.length, this.tokenStart),
  };
}

function generate$1d(node) {
  this.token(types$1n.Dimension, node.value + node.unit);
}

Dimension$8.generate = generate$1d;
Dimension$8.name = name$16;
Dimension$8.parse = parse$1h;
Dimension$8.structure = structure$15;

var _Function$1 = {};

const types$1m = types$1M;

const name$15 = "Function";
const walkContext$f = "function";
const structure$14 = {
  name: String,
  children: [[]],
};

// <function-token> <sequence> )
function parse$1g(readSequence, recognizer) {
  const start = this.tokenStart;
  const name = this.consumeFunctionName();
  const nameLowerCase = name.toLowerCase();
  let children;

  children = recognizer.hasOwnProperty(nameLowerCase)
    ? recognizer[nameLowerCase].call(this, recognizer)
    : readSequence.call(this, recognizer);

  if (!this.eof) {
    this.eat(types$1m.RightParenthesis);
  }

  return {
    type: "Function",
    loc: this.getLocation(start, this.tokenStart),
    name,
    children,
  };
}

function generate$1c(node) {
  this.token(types$1m.Function, node.name + "(");
  this.children(node);
  this.token(types$1m.RightParenthesis, ")");
}

_Function$1.generate = generate$1c;
_Function$1.name = name$15;
_Function$1.parse = parse$1g;
_Function$1.structure = structure$14;
_Function$1.walkContext = walkContext$f;

var Hash$6 = {};

const types$1l = types$1M;

// '#' ident
const xxx$1 = "XXX";
const name$14 = "Hash";
const structure$13 = {
  value: String,
};
function parse$1f() {
  const start = this.tokenStart;

  this.eat(types$1l.Hash);

  return {
    type: "Hash",
    loc: this.getLocation(start, this.tokenStart),
    value: this.substrToCursor(start + 1),
  };
}
function generate$1b(node) {
  this.token(types$1l.Hash, "#" + node.value);
}

Hash$6.generate = generate$1b;
Hash$6.name = name$14;
Hash$6.parse = parse$1f;
Hash$6.structure = structure$13;
Hash$6.xxx = xxx$1;

var Identifier$5 = {};

const types$1k = types$1M;

const name$13 = "Identifier";
const structure$12 = {
  name: String,
};

function parse$1e() {
  return {
    type: "Identifier",
    loc: this.getLocation(this.tokenStart, this.tokenEnd),
    name: this.consume(types$1k.Ident),
  };
}

function generate$1a(node) {
  this.token(types$1k.Ident, node.name);
}

Identifier$5.generate = generate$1a;
Identifier$5.name = name$13;
Identifier$5.parse = parse$1e;
Identifier$5.structure = structure$12;

var IdSelector$5 = {};

const types$1j = types$1M;

const name$12 = "IdSelector";
const structure$11 = {
  name: String,
};

function parse$1d() {
  const start = this.tokenStart;

  // TODO: check value is an ident
  this.eat(types$1j.Hash);

  return {
    type: "IdSelector",
    loc: this.getLocation(start, this.tokenStart),
    name: this.substrToCursor(start + 1),
  };
}

function generate$19(node) {
  // Using Delim instead of Hash is a hack to avoid for a whitespace between ident and id-selector
  // in safe mode (e.g. "a#id"), because IE11 doesn't allow a sequence <ident-token> <hash-token>
  // without a whitespace in values (e.g. "1px solid#000")
  this.token(types$1j.Delim, "#" + node.name);
}

IdSelector$5.generate = generate$19;
IdSelector$5.name = name$12;
IdSelector$5.parse = parse$1d;
IdSelector$5.structure = structure$11;

var MediaFeature$5 = {};

const types$1i = types$1M;

const name$11 = "MediaFeature";
const structure$10 = {
  name: String,
  value: ["Identifier", "Number", "Dimension", "Ratio", null],
};

function parse$1c() {
  const start = this.tokenStart;
  let name;
  let value = null;

  this.eat(types$1i.LeftParenthesis);
  this.skipSC();

  name = this.consume(types$1i.Ident);
  this.skipSC();

  if (this.tokenType !== types$1i.RightParenthesis) {
    this.eat(types$1i.Colon);
    this.skipSC();

    switch (this.tokenType) {
      case types$1i.Number:
        if (this.lookupNonWSType(1) === types$1i.Delim) {
          value = this.Ratio();
        } else {
          value = this.Number();
        }

        break;

      case types$1i.Dimension:
        value = this.Dimension();
        break;

      case types$1i.Ident:
        value = this.Identifier();
        break;

      default:
        this.error("Number, dimension, ratio or identifier is expected");
    }

    this.skipSC();
  }

  this.eat(types$1i.RightParenthesis);

  return {
    type: "MediaFeature",
    loc: this.getLocation(start, this.tokenStart),
    name,
    value,
  };
}

function generate$18(node) {
  this.token(types$1i.LeftParenthesis, "(");
  this.token(types$1i.Ident, node.name);

  if (node.value !== null) {
    this.token(types$1i.Colon, ":");
    this.node(node.value);
  }

  this.token(types$1i.RightParenthesis, ")");
}

MediaFeature$5.generate = generate$18;
MediaFeature$5.name = name$11;
MediaFeature$5.parse = parse$1c;
MediaFeature$5.structure = structure$10;

var MediaQuery$5 = {};

const types$1h = types$1M;

const name$10 = "MediaQuery";
const structure$$ = {
  children: [["Identifier", "MediaFeature", "WhiteSpace"]],
};

function parse$1b() {
  const children = this.createList();
  let child = null;

  this.skipSC();

  scan: while (!this.eof) {
    switch (this.tokenType) {
      case types$1h.Comment:
      case types$1h.WhiteSpace:
        this.next();
        continue;

      case types$1h.Ident:
        child = this.Identifier();
        break;

      case types$1h.LeftParenthesis:
        child = this.MediaFeature();
        break;

      default:
        break scan;
    }

    children.push(child);
  }

  if (child === null) {
    this.error("Identifier or parenthesis is expected");
  }

  return {
    type: "MediaQuery",
    loc: this.getLocationFromList(children),
    children,
  };
}

function generate$17(node) {
  this.children(node);
}

MediaQuery$5.generate = generate$17;
MediaQuery$5.name = name$10;
MediaQuery$5.parse = parse$1b;
MediaQuery$5.structure = structure$$;

var MediaQueryList$5 = {};

const types$1g = types$1M;

const name$$ = "MediaQueryList";
const structure$_ = {
  children: [["MediaQuery"]],
};

function parse$1a() {
  const children = this.createList();

  this.skipSC();

  while (!this.eof) {
    children.push(this.MediaQuery());

    if (this.tokenType !== types$1g.Comma) {
      break;
    }

    this.next();
  }

  return {
    type: "MediaQueryList",
    loc: this.getLocationFromList(children),
    children,
  };
}

function generate$16(node) {
  this.children(node, () => this.token(types$1g.Comma, ","));
}

MediaQueryList$5.generate = generate$16;
MediaQueryList$5.name = name$$;
MediaQueryList$5.parse = parse$1a;
MediaQueryList$5.structure = structure$_;

var NestingSelector$2 = {};

const types$1f = types$1M;

const AMPERSAND$3 = 0x0026; // U+0026 AMPERSAND (&)

const name$_ = "NestingSelector";
const structure$Z = {};

function parse$19() {
  const start = this.tokenStart;

  this.eatDelim(AMPERSAND$3);

  return {
    type: "NestingSelector",
    loc: this.getLocation(start, this.tokenStart),
  };
}

function generate$15() {
  this.token(types$1f.Delim, "&");
}

NestingSelector$2.generate = generate$15;
NestingSelector$2.name = name$_;
NestingSelector$2.parse = parse$19;
NestingSelector$2.structure = structure$Z;

var Nth$5 = {};

const types$1e = types$1M;

const name$Z = "Nth";
const structure$Y = {
  nth: ["AnPlusB", "Identifier"],
  selector: ["SelectorList", null],
};

function parse$18() {
  this.skipSC();

  const start = this.tokenStart;
  let end = start;
  let selector = null;
  let nth;

  if (this.lookupValue(0, "odd") || this.lookupValue(0, "even")) {
    nth = this.Identifier();
  } else {
    nth = this.AnPlusB();
  }

  end = this.tokenStart;
  this.skipSC();

  if (this.lookupValue(0, "of")) {
    this.next();

    selector = this.SelectorList();
    end = this.tokenStart;
  }

  return {
    type: "Nth",
    loc: this.getLocation(start, end),
    nth,
    selector,
  };
}

function generate$14(node) {
  this.node(node.nth);
  if (node.selector !== null) {
    this.token(types$1e.Ident, "of");
    this.node(node.selector);
  }
}

Nth$5.generate = generate$14;
Nth$5.name = name$Z;
Nth$5.parse = parse$18;
Nth$5.structure = structure$Y;

var _Number$6 = {};

const types$1d = types$1M;

const name$Y = "Number";
const structure$X = {
  value: String,
};

function parse$17() {
  return {
    type: "Number",
    loc: this.getLocation(this.tokenStart, this.tokenEnd),
    value: this.consume(types$1d.Number),
  };
}

function generate$13(node) {
  this.token(types$1d.Number, node.value);
}

_Number$6.generate = generate$13;
_Number$6.name = name$Y;
_Number$6.parse = parse$17;
_Number$6.structure = structure$X;

var Operator$5 = {};

// '/' | '*' | ',' | ':' | '+' | '-'
const name$X = "Operator";
const structure$W = {
  value: String,
};

function parse$16() {
  const start = this.tokenStart;

  this.next();

  return {
    type: "Operator",
    loc: this.getLocation(start, this.tokenStart),
    value: this.substrToCursor(start),
  };
}

function generate$12(node) {
  this.tokenize(node.value);
}

Operator$5.generate = generate$12;
Operator$5.name = name$X;
Operator$5.parse = parse$16;
Operator$5.structure = structure$W;

var Parentheses$5 = {};

const types$1c = types$1M;

const name$W = "Parentheses";
const structure$V = {
  children: [[]],
};

function parse$15(readSequence, recognizer) {
  const start = this.tokenStart;
  let children = null;

  this.eat(types$1c.LeftParenthesis);

  children = readSequence.call(this, recognizer);

  if (!this.eof) {
    this.eat(types$1c.RightParenthesis);
  }

  return {
    type: "Parentheses",
    loc: this.getLocation(start, this.tokenStart),
    children,
  };
}

function generate$11(node) {
  this.token(types$1c.LeftParenthesis, "(");
  this.children(node);
  this.token(types$1c.RightParenthesis, ")");
}

Parentheses$5.generate = generate$11;
Parentheses$5.name = name$W;
Parentheses$5.parse = parse$15;
Parentheses$5.structure = structure$V;

var Percentage$8 = {};

const types$1b = types$1M;

const name$V = "Percentage";
const structure$U = {
  value: String,
};

function parse$14() {
  return {
    type: "Percentage",
    loc: this.getLocation(this.tokenStart, this.tokenEnd),
    value: this.consumeNumber(types$1b.Percentage),
  };
}

function generate$10(node) {
  this.token(types$1b.Percentage, node.value + "%");
}

Percentage$8.generate = generate$10;
Percentage$8.name = name$V;
Percentage$8.parse = parse$14;
Percentage$8.structure = structure$U;

var PseudoClassSelector$5 = {};

const types$1a = types$1M;

const name$U = "PseudoClassSelector";
const walkContext$e = "function";
const structure$T = {
  name: String,
  children: [["Raw"], null],
};

// : [ <ident> | <function-token> <any-value>? ) ]
function parse$13() {
  const start = this.tokenStart;
  let children = null;
  let name;
  let nameLowerCase;

  this.eat(types$1a.Colon);

  if (this.tokenType === types$1a.Function) {
    name = this.consumeFunctionName();
    nameLowerCase = name.toLowerCase();

    if (hasOwnProperty.call(this.pseudo, nameLowerCase)) {
      this.skipSC();
      children = this.pseudo[nameLowerCase].call(this);
      this.skipSC();
    } else {
      children = this.createList();
      children.push(this.Raw(this.tokenIndex, null, false));
    }

    this.eat(types$1a.RightParenthesis);
  } else {
    name = this.consume(types$1a.Ident);
  }

  return {
    type: "PseudoClassSelector",
    loc: this.getLocation(start, this.tokenStart),
    name,
    children,
  };
}

function generate$$(node) {
  this.token(types$1a.Colon, ":");

  if (node.children === null) {
    this.token(types$1a.Ident, node.name);
  } else {
    this.token(types$1a.Function, node.name + "(");
    this.children(node);
    this.token(types$1a.RightParenthesis, ")");
  }
}

PseudoClassSelector$5.generate = generate$$;
PseudoClassSelector$5.name = name$U;
PseudoClassSelector$5.parse = parse$13;
PseudoClassSelector$5.structure = structure$T;
PseudoClassSelector$5.walkContext = walkContext$e;

var PseudoElementSelector$5 = {};

const types$19 = types$1M;

const name$T = "PseudoElementSelector";
const walkContext$d = "function";
const structure$S = {
  name: String,
  children: [["Raw"], null],
};

// :: [ <ident> | <function-token> <any-value>? ) ]
function parse$12() {
  const start = this.tokenStart;
  let children = null;
  let name;
  let nameLowerCase;

  this.eat(types$19.Colon);
  this.eat(types$19.Colon);

  if (this.tokenType === types$19.Function) {
    name = this.consumeFunctionName();
    nameLowerCase = name.toLowerCase();

    if (hasOwnProperty.call(this.pseudo, nameLowerCase)) {
      this.skipSC();
      children = this.pseudo[nameLowerCase].call(this);
      this.skipSC();
    } else {
      children = this.createList();
      children.push(this.Raw(this.tokenIndex, null, false));
    }

    this.eat(types$19.RightParenthesis);
  } else {
    name = this.consume(types$19.Ident);
  }

  return {
    type: "PseudoElementSelector",
    loc: this.getLocation(start, this.tokenStart),
    name,
    children,
  };
}

function generate$_(node) {
  this.token(types$19.Colon, ":");
  this.token(types$19.Colon, ":");

  if (node.children === null) {
    this.token(types$19.Ident, node.name);
  } else {
    this.token(types$19.Function, node.name + "(");
    this.children(node);
    this.token(types$19.RightParenthesis, ")");
  }
}

PseudoElementSelector$5.generate = generate$_;
PseudoElementSelector$5.name = name$T;
PseudoElementSelector$5.parse = parse$12;
PseudoElementSelector$5.structure = structure$S;
PseudoElementSelector$5.walkContext = walkContext$d;

var Ratio$5 = {};

const types$18 = types$1M;
const charCodeDefinitions$h = charCodeDefinitions$p;

const SOLIDUS$8 = 0x002f; // U+002F SOLIDUS (/)
const FULLSTOP$4 = 0x002e; // U+002E FULL STOP (.)

// Terms of <ratio> should be a positive numbers (not zero or negative)
// (see https://drafts.csswg.org/mediaqueries-3/#values)
// However, -o-min-device-pixel-ratio takes fractional values as a ratio's term
// and this is using by various sites. Therefore we relax checking on parse
// to test a term is unsigned number without an exponent part.
// Additional checking may be applied on lexer validation.
function consumeNumber$2() {
  this.skipSC();

  const value = this.consume(types$18.Number);

  for (let i = 0; i < value.length; i++) {
    const code = value.charCodeAt(i);
    if (!charCodeDefinitions$h.isDigit(code) && code !== FULLSTOP$4) {
      this.error(
        "Unsigned number is expected",
        this.tokenStart - value.length + i,
      );
    }
  }

  if (Number(value) === 0) {
    this.error("Zero number is not allowed", this.tokenStart - value.length);
  }

  return value;
}

const name$S = "Ratio";
const structure$R = {
  left: String,
  right: String,
};

// <positive-integer> S* '/' S* <positive-integer>
function parse$11() {
  const start = this.tokenStart;
  const left = consumeNumber$2.call(this);
  let right;

  this.skipSC();
  this.eatDelim(SOLIDUS$8);
  right = consumeNumber$2.call(this);

  return {
    type: "Ratio",
    loc: this.getLocation(start, this.tokenStart),
    left,
    right,
  };
}

function generate$Z(node) {
  this.token(types$18.Number, node.left);
  this.token(types$18.Delim, "/");
  this.token(types$18.Number, node.right);
}

Ratio$5.generate = generate$Z;
Ratio$5.name = name$S;
Ratio$5.parse = parse$11;
Ratio$5.structure = structure$R;

var Raw$7 = {};

const types$17 = types$1M;

function getOffsetExcludeWS$1() {
  if (this.tokenIndex > 0) {
    if (this.lookupType(-1) === types$17.WhiteSpace) {
      return this.tokenIndex > 1
        ? this.getTokenStart(this.tokenIndex - 1)
        : this.firstCharOffset;
    }
  }

  return this.tokenStart;
}

const name$R = "Raw";
const structure$Q = {
  value: String,
};

function parse$10(startToken, consumeUntil, excludeWhiteSpace) {
  const startOffset = this.getTokenStart(startToken);
  let endOffset;

  this.skipUntilBalanced(
    startToken,
    consumeUntil || this.consumeUntilBalanceEnd,
  );

  if (excludeWhiteSpace && this.tokenStart > startOffset) {
    endOffset = getOffsetExcludeWS$1.call(this);
  } else {
    endOffset = this.tokenStart;
  }

  return {
    type: "Raw",
    loc: this.getLocation(startOffset, endOffset),
    value: this.substring(startOffset, endOffset),
  };
}

function generate$Y(node) {
  this.tokenize(node.value);
}

Raw$7.generate = generate$Y;
Raw$7.name = name$R;
Raw$7.parse = parse$10;
Raw$7.structure = structure$Q;

var Rule$7 = {};

const types$16 = types$1M;

function consumeRaw$8(startToken) {
  return this.Raw(startToken, this.consumeUntilLeftCurlyBracket, true);
}

function consumePrelude$1() {
  const prelude = this.SelectorList();

  if (
    prelude.type !== "Raw" &&
    this.eof === false &&
    this.tokenType !== types$16.LeftCurlyBracket
  ) {
    this.error();
  }

  return prelude;
}

const name$Q = "Rule";
const walkContext$c = "rule";
const structure$P = {
  prelude: ["SelectorList", "Raw"],
  block: ["Block"],
};

function parse$$() {
  const startToken = this.tokenIndex;
  const startOffset = this.tokenStart;
  let prelude;
  let block;

  if (this.parseRulePrelude) {
    prelude = this.parseWithFallback(consumePrelude$1, consumeRaw$8);
  } else {
    prelude = consumeRaw$8.call(this, startToken);
  }

  block = this.Block(true);

  return {
    type: "Rule",
    loc: this.getLocation(startOffset, this.tokenStart),
    prelude,
    block,
  };
}
function generate$X(node) {
  this.node(node.prelude);
  this.node(node.block);
}

Rule$7.generate = generate$X;
Rule$7.name = name$Q;
Rule$7.parse = parse$$;
Rule$7.structure = structure$P;
Rule$7.walkContext = walkContext$c;

var Selector$7 = {};

const name$P = "Selector";
const structure$O = {
  children: [
    [
      "TypeSelector",
      "IdSelector",
      "ClassSelector",
      "AttributeSelector",
      "PseudoClassSelector",
      "PseudoElementSelector",
      "Combinator",
      "WhiteSpace",
    ],
  ],
};

function parse$_() {
  const children = this.readSequence(this.scope.Selector);

  // nothing were consumed
  if (this.getFirstListNode(children) === null) {
    this.error("Selector is expected");
  }

  return {
    type: "Selector",
    loc: this.getLocationFromList(children),
    children,
  };
}

function generate$W(node) {
  this.children(node);
}

Selector$7.generate = generate$W;
Selector$7.name = name$P;
Selector$7.parse = parse$_;
Selector$7.structure = structure$O;

var SelectorList$5 = {};

const types$15 = types$1M;

const name$O = "SelectorList";
const walkContext$b = "selector";
const structure$N = {
  children: [["Selector", "Raw"]],
};

function parse$Z() {
  const children = this.createList();

  while (!this.eof) {
    children.push(this.Selector());

    if (this.tokenType === types$15.Comma) {
      this.next();
      continue;
    }

    break;
  }

  return {
    type: "SelectorList",
    loc: this.getLocationFromList(children),
    children,
  };
}

function generate$V(node) {
  this.children(node, () => this.token(types$15.Comma, ","));
}

SelectorList$5.generate = generate$V;
SelectorList$5.name = name$O;
SelectorList$5.parse = parse$Z;
SelectorList$5.structure = structure$N;
SelectorList$5.walkContext = walkContext$b;

var _String$1 = {};

var string$7 = {};

const charCodeDefinitions$g = charCodeDefinitions$p;
const utils$n = utils$u;

const REVERSE_SOLIDUS$5 = 0x005c; // U+005C REVERSE SOLIDUS (\)
const QUOTATION_MARK$3 = 0x0022; // "
const APOSTROPHE$4 = 0x0027; // '

function decode$5(str) {
  const len = str.length;
  const firstChar = str.charCodeAt(0);
  const start =
    firstChar === QUOTATION_MARK$3 || firstChar === APOSTROPHE$4 ? 1 : 0;
  const end =
    start === 1 && len > 1 && str.charCodeAt(len - 1) === firstChar
      ? len - 2
      : len - 1;
  let decoded = "";

  for (let i = start; i <= end; i++) {
    let code = str.charCodeAt(i);

    if (code === REVERSE_SOLIDUS$5) {
      // special case at the ending
      if (i === end) {
        // if the next input code point is EOF, do nothing
        // otherwise include last quote as escaped
        if (i !== len - 1) {
          decoded = str.substr(i + 1);
        }
        break;
      }

      code = str.charCodeAt(++i);

      // consume escaped
      if (charCodeDefinitions$g.isValidEscape(REVERSE_SOLIDUS$5, code)) {
        const escapeStart = i - 1;
        const escapeEnd = utils$n.consumeEscaped(str, escapeStart);

        i = escapeEnd - 1;
        decoded += utils$n.decodeEscaped(
          str.substring(escapeStart + 1, escapeEnd),
        );
      } else {
        // \r\n
        if (code === 0x000d && str.charCodeAt(i + 1) === 0x000a) {
          i++;
        }
      }
    } else {
      decoded += str[i];
    }
  }

  return decoded;
}

// https://drafts.csswg.org/cssom/#serialize-a-string
//  2.1. Common Serializing Idioms
function encode$6(str, apostrophe) {
  const quote = apostrophe ? "'" : '"';
  const quoteCode = apostrophe ? APOSTROPHE$4 : QUOTATION_MARK$3;
  let encoded = "";
  let wsBeforeHexIsNeeded = false;

  for (let i = 0; i < str.length; i++) {
    const code = str.charCodeAt(i);

    // If the character is NULL (U+0000), then the REPLACEMENT CHARACTER (U+FFFD).
    if (code === 0x0000) {
      encoded += "\uFFFD";
      continue;
    }

    // If the character is in the range [\1-\1f] (U+0001 to U+001F) or is U+007F,
    // the character escaped as code point.
    // Note: Do not compare with 0x0001 since 0x0000 is precessed before
    if (code <= 0x001f || code === 0x007f) {
      encoded += "\\" + code.toString(16);
      wsBeforeHexIsNeeded = true;
      continue;
    }

    // If the character is '"' (U+0022) or "\" (U+005C), the escaped character.
    if (code === quoteCode || code === REVERSE_SOLIDUS$5) {
      encoded += "\\" + str.charAt(i);
      wsBeforeHexIsNeeded = false;
    } else {
      if (
        wsBeforeHexIsNeeded &&
        (charCodeDefinitions$g.isHexDigit(code) ||
          charCodeDefinitions$g.isWhiteSpace(code))
      ) {
        encoded += " ";
      }

      // Otherwise, the character itself.
      encoded += str.charAt(i);
      wsBeforeHexIsNeeded = false;
    }
  }

  return quote + encoded + quote;
}

string$7.decode = decode$5;
string$7.encode = encode$6;

const string$6 = string$7;
const types$14 = types$1M;

const name$N = "String";
const structure$M = {
  value: String,
};

function parse$Y() {
  return {
    type: "String",
    loc: this.getLocation(this.tokenStart, this.tokenEnd),
    value: string$6.decode(this.consume(types$14.String)),
  };
}

function generate$U(node) {
  this.token(types$14.String, string$6.encode(node.value));
}

_String$1.generate = generate$U;
_String$1.name = name$N;
_String$1.parse = parse$Y;
_String$1.structure = structure$M;

var StyleSheet$5 = {};

const types$13 = types$1M;

const EXCLAMATIONMARK$4 = 0x0021; // U+0021 EXCLAMATION MARK (!)

function consumeRaw$7(startToken) {
  return this.Raw(startToken, null, false);
}

const name$M = "StyleSheet";
const walkContext$a = "stylesheet";
const structure$L = {
  children: [["Comment", "CDO", "CDC", "Atrule", "Rule", "Raw"]],
};

function parse$X() {
  const start = this.tokenStart;
  const children = this.createList();
  let child;

  while (!this.eof) {
    switch (this.tokenType) {
      case types$13.WhiteSpace:
        this.next();
        continue;

      case types$13.Comment:
        // ignore comments except exclamation comments (i.e. /*! .. */) on top level
        if (this.charCodeAt(this.tokenStart + 2) !== EXCLAMATIONMARK$4) {
          this.next();
          continue;
        }

        child = this.Comment();
        break;

      case types$13.CDO: // <!--
        child = this.CDO();
        break;

      case types$13.CDC: // -->
        child = this.CDC();
        break;

      // CSS Syntax Module Level 3
      // 2.2 Error handling
      // At the "top level" of a stylesheet, an <at-keyword-token> starts an at-rule.
      case types$13.AtKeyword:
        child = this.parseWithFallback(this.Atrule, consumeRaw$7);
        break;

      // Anything else starts a qualified rule ...
      default:
        child = this.parseWithFallback(this.Rule, consumeRaw$7);
    }

    children.push(child);
  }

  return {
    type: "StyleSheet",
    loc: this.getLocation(start, this.tokenStart),
    children,
  };
}

function generate$T(node) {
  this.children(node);
}

StyleSheet$5.generate = generate$T;
StyleSheet$5.name = name$M;
StyleSheet$5.parse = parse$X;
StyleSheet$5.structure = structure$L;
StyleSheet$5.walkContext = walkContext$a;

var TypeSelector$7 = {};

const types$12 = types$1M;

const ASTERISK$9 = 0x002a; // U+002A ASTERISK (*)
const VERTICALLINE$5 = 0x007c; // U+007C VERTICAL LINE (|)

function eatIdentifierOrAsterisk$1() {
  if (this.tokenType !== types$12.Ident && this.isDelim(ASTERISK$9) === false) {
    this.error("Identifier or asterisk is expected");
  }

  this.next();
}

const name$L = "TypeSelector";
const structure$K = {
  name: String,
};

// ident
// ident|ident
// ident|*
// *
// *|ident
// *|*
// |ident
// |*
function parse$W() {
  const start = this.tokenStart;

  if (this.isDelim(VERTICALLINE$5)) {
    this.next();
    eatIdentifierOrAsterisk$1.call(this);
  } else {
    eatIdentifierOrAsterisk$1.call(this);

    if (this.isDelim(VERTICALLINE$5)) {
      this.next();
      eatIdentifierOrAsterisk$1.call(this);
    }
  }

  return {
    type: "TypeSelector",
    loc: this.getLocation(start, this.tokenStart),
    name: this.substrToCursor(start),
  };
}

function generate$S(node) {
  this.tokenize(node.name);
}

TypeSelector$7.generate = generate$S;
TypeSelector$7.name = name$L;
TypeSelector$7.parse = parse$W;
TypeSelector$7.structure = structure$K;

var UnicodeRange$5 = {};

const types$11 = types$1M;
const charCodeDefinitions$f = charCodeDefinitions$p;

const PLUSSIGN$c = 0x002b; // U+002B PLUS SIGN (+)
const HYPHENMINUS$8 = 0x002d; // U+002D HYPHEN-MINUS (-)
const QUESTIONMARK$3 = 0x003f; // U+003F QUESTION MARK (?)

function eatHexSequence$1(offset, allowDash) {
  let len = 0;

  for (let pos = this.tokenStart + offset; pos < this.tokenEnd; pos++) {
    const code = this.charCodeAt(pos);

    if (code === HYPHENMINUS$8 && allowDash && len !== 0) {
      eatHexSequence$1.call(this, offset + len + 1, false);
      return -1;
    }

    if (!charCodeDefinitions$f.isHexDigit(code)) {
      this.error(
        allowDash && len !== 0
          ? "Hyphen minus" + (len < 6 ? " or hex digit" : "") + " is expected"
          : len < 6
            ? "Hex digit is expected"
            : "Unexpected input",
        pos,
      );
    }

    if (++len > 6) {
      this.error("Too many hex digits", pos);
    }
  }

  this.next();
  return len;
}

function eatQuestionMarkSequence$1(max) {
  let count = 0;

  while (this.isDelim(QUESTIONMARK$3)) {
    if (++count > max) {
      this.error("Too many question marks");
    }

    this.next();
  }
}

function startsWith$2(code) {
  if (this.charCodeAt(this.tokenStart) !== code) {
    this.error(
      (code === PLUSSIGN$c ? "Plus sign" : "Hyphen minus") + " is expected",
    );
  }
}

// https://drafts.csswg.org/css-syntax/#urange
// Informally, the <urange> production has three forms:
// U+0001
//      Defines a range consisting of a single code point, in this case the code point "1".
// U+0001-00ff
//      Defines a range of codepoints between the first and the second value, in this case
//      the range between "1" and "ff" (255 in decimal) inclusive.
// U+00??
//      Defines a range of codepoints where the "?" characters range over all hex digits,
//      in this case defining the same as the value U+0000-00ff.
// In each form, a maximum of 6 digits is allowed for each hexadecimal number (if you treat "?" as a hexadecimal digit).
//
// <urange> =
//   u '+' <ident-token> '?'* |
//   u <dimension-token> '?'* |
//   u <number-token> '?'* |
//   u <number-token> <dimension-token> |
//   u <number-token> <number-token> |
//   u '+' '?'+
function scanUnicodeRange$1() {
  let hexLength = 0;

  switch (this.tokenType) {
    case types$11.Number:
      // u <number-token> '?'*
      // u <number-token> <dimension-token>
      // u <number-token> <number-token>
      hexLength = eatHexSequence$1.call(this, 1, true);

      if (this.isDelim(QUESTIONMARK$3)) {
        eatQuestionMarkSequence$1.call(this, 6 - hexLength);
        break;
      }

      if (
        this.tokenType === types$11.Dimension ||
        this.tokenType === types$11.Number
      ) {
        startsWith$2.call(this, HYPHENMINUS$8);
        eatHexSequence$1.call(this, 1, false);
        break;
      }

      break;

    case types$11.Dimension:
      // u <dimension-token> '?'*
      hexLength = eatHexSequence$1.call(this, 1, true);

      if (hexLength > 0) {
        eatQuestionMarkSequence$1.call(this, 6 - hexLength);
      }

      break;

    default:
      // u '+' <ident-token> '?'*
      // u '+' '?'+
      this.eatDelim(PLUSSIGN$c);

      if (this.tokenType === types$11.Ident) {
        hexLength = eatHexSequence$1.call(this, 0, true);
        if (hexLength > 0) {
          eatQuestionMarkSequence$1.call(this, 6 - hexLength);
        }
        break;
      }

      if (this.isDelim(QUESTIONMARK$3)) {
        this.next();
        eatQuestionMarkSequence$1.call(this, 5);
        break;
      }

      this.error("Hex digit or question mark is expected");
  }
}

const name$K = "UnicodeRange";
const structure$J = {
  value: String,
};

function parse$V() {
  const start = this.tokenStart;

  // U or u
  this.eatIdent("u");
  scanUnicodeRange$1.call(this);

  return {
    type: "UnicodeRange",
    loc: this.getLocation(start, this.tokenStart),
    value: this.substrToCursor(start),
  };
}

function generate$R(node) {
  this.tokenize(node.value);
}

UnicodeRange$5.generate = generate$R;
UnicodeRange$5.name = name$K;
UnicodeRange$5.parse = parse$V;
UnicodeRange$5.structure = structure$J;

var Url$8 = {};

var url$5 = {};

const charCodeDefinitions$e = charCodeDefinitions$p;
const utils$m = utils$u;

const SPACE$5 = 0x0020; // U+0020 SPACE
const REVERSE_SOLIDUS$4 = 0x005c; // U+005C REVERSE SOLIDUS (\)
const QUOTATION_MARK$2 = 0x0022; // "
const APOSTROPHE$3 = 0x0027; // '
const LEFTPARENTHESIS$3 = 0x0028; // U+0028 LEFT PARENTHESIS (()
const RIGHTPARENTHESIS$3 = 0x0029; // U+0029 RIGHT PARENTHESIS ())

function decode$4(str) {
  const len = str.length;
  let start = 4; // length of "url("
  let end = str.charCodeAt(len - 1) === RIGHTPARENTHESIS$3 ? len - 2 : len - 1;
  let decoded = "";

  while (
    start < end &&
    charCodeDefinitions$e.isWhiteSpace(str.charCodeAt(start))
  ) {
    start++;
  }

  while (
    start < end &&
    charCodeDefinitions$e.isWhiteSpace(str.charCodeAt(end))
  ) {
    end--;
  }

  for (let i = start; i <= end; i++) {
    let code = str.charCodeAt(i);

    if (code === REVERSE_SOLIDUS$4) {
      // special case at the ending
      if (i === end) {
        // if the next input code point is EOF, do nothing
        // otherwise include last left parenthesis as escaped
        if (i !== len - 1) {
          decoded = str.substr(i + 1);
        }
        break;
      }

      code = str.charCodeAt(++i);

      // consume escaped
      if (charCodeDefinitions$e.isValidEscape(REVERSE_SOLIDUS$4, code)) {
        const escapeStart = i - 1;
        const escapeEnd = utils$m.consumeEscaped(str, escapeStart);

        i = escapeEnd - 1;
        decoded += utils$m.decodeEscaped(
          str.substring(escapeStart + 1, escapeEnd),
        );
      } else {
        // \r\n
        if (code === 0x000d && str.charCodeAt(i + 1) === 0x000a) {
          i++;
        }
      }
    } else {
      decoded += str[i];
    }
  }

  return decoded;
}

function encode$5(str) {
  let encoded = "";
  let wsBeforeHexIsNeeded = false;

  for (let i = 0; i < str.length; i++) {
    const code = str.charCodeAt(i);

    // If the character is NULL (U+0000), then the REPLACEMENT CHARACTER (U+FFFD).
    if (code === 0x0000) {
      encoded += "\uFFFD";
      continue;
    }

    // If the character is in the range [\1-\1f] (U+0001 to U+001F) or is U+007F,
    // the character escaped as code point.
    // Note: Do not compare with 0x0001 since 0x0000 is precessed before
    if (code <= 0x001f || code === 0x007f) {
      encoded += "\\" + code.toString(16);
      wsBeforeHexIsNeeded = true;
      continue;
    }

    if (
      code === SPACE$5 ||
      code === REVERSE_SOLIDUS$4 ||
      code === QUOTATION_MARK$2 ||
      code === APOSTROPHE$3 ||
      code === LEFTPARENTHESIS$3 ||
      code === RIGHTPARENTHESIS$3
    ) {
      encoded += "\\" + str.charAt(i);
      wsBeforeHexIsNeeded = false;
    } else {
      if (wsBeforeHexIsNeeded && charCodeDefinitions$e.isHexDigit(code)) {
        encoded += " ";
      }

      encoded += str.charAt(i);
      wsBeforeHexIsNeeded = false;
    }
  }

  return "url(" + encoded + ")";
}

url$5.decode = decode$4;
url$5.encode = encode$5;

const url$4 = url$5;
const string$5 = string$7;
const types$10 = types$1M;

const name$J = "Url";
const structure$I = {
  value: String,
};

// <url-token> | <function-token> <string> )
function parse$U() {
  const start = this.tokenStart;
  let value;

  switch (this.tokenType) {
    case types$10.Url:
      value = url$4.decode(this.consume(types$10.Url));
      break;

    case types$10.Function:
      if (!this.cmpStr(this.tokenStart, this.tokenEnd, "url(")) {
        this.error("Function name must be `url`");
      }

      this.eat(types$10.Function);
      this.skipSC();
      value = string$5.decode(this.consume(types$10.String));
      this.skipSC();
      if (!this.eof) {
        this.eat(types$10.RightParenthesis);
      }
      break;

    default:
      this.error("Url or Function is expected");
  }

  return {
    type: "Url",
    loc: this.getLocation(start, this.tokenStart),
    value,
  };
}

function generate$Q(node) {
  this.token(types$10.Url, url$4.encode(node.value));
}

Url$8.generate = generate$Q;
Url$8.name = name$J;
Url$8.parse = parse$U;
Url$8.structure = structure$I;

var Value$7 = {};

const name$I = "Value";
const structure$H = {
  children: [[]],
};

function parse$T() {
  const start = this.tokenStart;
  const children = this.readSequence(this.scope.Value);

  return {
    type: "Value",
    loc: this.getLocation(start, this.tokenStart),
    children,
  };
}

function generate$P(node) {
  this.children(node);
}

Value$7.generate = generate$P;
Value$7.name = name$I;
Value$7.parse = parse$T;
Value$7.structure = structure$H;

var WhiteSpace$8 = {};

const types$$ = types$1M;

const SPACE$4 = Object.freeze({
  type: "WhiteSpace",
  loc: null,
  value: " ",
});

const name$H = "WhiteSpace";
const structure$G = {
  value: String,
};

function parse$S() {
  this.eat(types$$.WhiteSpace);
  return SPACE$4;

  // return {
  //     type: 'WhiteSpace',
  //     loc: this.getLocation(this.tokenStart, this.tokenEnd),
  //     value: this.consume(WHITESPACE)
  // };
}

function generate$O(node) {
  this.token(types$$.WhiteSpace, node.value);
}

WhiteSpace$8.generate = generate$O;
WhiteSpace$8.name = name$H;
WhiteSpace$8.parse = parse$S;
WhiteSpace$8.structure = structure$G;

const AnPlusB$4 = AnPlusB$5;
const Atrule$8 = Atrule$9;
const AtrulePrelude$4 = AtrulePrelude$5;
const AttributeSelector$6 = AttributeSelector$7;
const Block$4 = Block$5;
const Brackets$4 = Brackets$5;
const CDC$5 = CDC$6;
const CDO$5 = CDO$6;
const ClassSelector$4 = ClassSelector$5;
const Combinator$4 = Combinator$5;
const Comment$7 = Comment$8;
const Declaration$6 = Declaration$7;
const DeclarationList$4 = DeclarationList$5;
const Dimension$7 = Dimension$8;
const Function$5 = _Function$1;
const Hash$5 = Hash$6;
const Identifier$4 = Identifier$5;
const IdSelector$4 = IdSelector$5;
const MediaFeature$4 = MediaFeature$5;
const MediaQuery$4 = MediaQuery$5;
const MediaQueryList$4 = MediaQueryList$5;
const NestingSelector$1 = NestingSelector$2;
const Nth$4 = Nth$5;
const Number$1$2 = _Number$6;
const Operator$4 = Operator$5;
const Parentheses$4 = Parentheses$5;
const Percentage$7 = Percentage$8;
const PseudoClassSelector$4 = PseudoClassSelector$5;
const PseudoElementSelector$4 = PseudoElementSelector$5;
const Ratio$4 = Ratio$5;
const Raw$6 = Raw$7;
const Rule$6 = Rule$7;
const Selector$6 = Selector$7;
const SelectorList$4 = SelectorList$5;
const String$1$2 = _String$1;
const StyleSheet$4 = StyleSheet$5;
const TypeSelector$6 = TypeSelector$7;
const UnicodeRange$4 = UnicodeRange$5;
const Url$7 = Url$8;
const Value$6 = Value$7;
const WhiteSpace$7 = WhiteSpace$8;

node$1.AnPlusB = AnPlusB$4;
node$1.Atrule = Atrule$8;
node$1.AtrulePrelude = AtrulePrelude$4;
node$1.AttributeSelector = AttributeSelector$6;
node$1.Block = Block$4;
node$1.Brackets = Brackets$4;
node$1.CDC = CDC$5;
node$1.CDO = CDO$5;
node$1.ClassSelector = ClassSelector$4;
node$1.Combinator = Combinator$4;
node$1.Comment = Comment$7;
node$1.Declaration = Declaration$6;
node$1.DeclarationList = DeclarationList$4;
node$1.Dimension = Dimension$7;
node$1.Function = Function$5;
node$1.Hash = Hash$5;
node$1.Identifier = Identifier$4;
node$1.IdSelector = IdSelector$4;
node$1.MediaFeature = MediaFeature$4;
node$1.MediaQuery = MediaQuery$4;
node$1.MediaQueryList = MediaQueryList$4;
node$1.NestingSelector = NestingSelector$1;
node$1.Nth = Nth$4;
node$1.Number = Number$1$2;
node$1.Operator = Operator$4;
node$1.Parentheses = Parentheses$4;
node$1.Percentage = Percentage$7;
node$1.PseudoClassSelector = PseudoClassSelector$4;
node$1.PseudoElementSelector = PseudoElementSelector$4;
node$1.Ratio = Ratio$4;
node$1.Raw = Raw$6;
node$1.Rule = Rule$6;
node$1.Selector = Selector$6;
node$1.SelectorList = SelectorList$4;
node$1.String = String$1$2;
node$1.StyleSheet = StyleSheet$4;
node$1.TypeSelector = TypeSelector$6;
node$1.UnicodeRange = UnicodeRange$4;
node$1.Url = Url$7;
node$1.Value = Value$6;
node$1.WhiteSpace = WhiteSpace$7;

const data$2 = data$3;
const index$f = node$1;

const lexerConfig$1 = {
  generic: true,
  ...data$2,
  node: index$f,
};

var lexer$6 = lexerConfig$1;

var scope$1 = {};

const types$_ = types$1M;

const NUMBERSIGN$6 = 0x0023; // U+0023 NUMBER SIGN (#)
const ASTERISK$8 = 0x002a; // U+002A ASTERISK (*)
const PLUSSIGN$b = 0x002b; // U+002B PLUS SIGN (+)
const HYPHENMINUS$7 = 0x002d; // U+002D HYPHEN-MINUS (-)
const SOLIDUS$7 = 0x002f; // U+002F SOLIDUS (/)
const U$2 = 0x0075; // U+0075 LATIN SMALL LETTER U (u)

function defaultRecognizer$1(context) {
  switch (this.tokenType) {
    case types$_.Hash:
      return this.Hash();

    case types$_.Comma:
      return this.Operator();

    case types$_.LeftParenthesis:
      return this.Parentheses(this.readSequence, context.recognizer);

    case types$_.LeftSquareBracket:
      return this.Brackets(this.readSequence, context.recognizer);

    case types$_.String:
      return this.String();

    case types$_.Dimension:
      return this.Dimension();

    case types$_.Percentage:
      return this.Percentage();

    case types$_.Number:
      return this.Number();

    case types$_.Function:
      return this.cmpStr(this.tokenStart, this.tokenEnd, "url(")
        ? this.Url()
        : this.Function(this.readSequence, context.recognizer);

    case types$_.Url:
      return this.Url();

    case types$_.Ident:
      // check for unicode range, it should start with u+ or U+
      if (
        this.cmpChar(this.tokenStart, U$2) &&
        this.cmpChar(this.tokenStart + 1, PLUSSIGN$b)
      ) {
        return this.UnicodeRange();
      } else {
        return this.Identifier();
      }

    case types$_.Delim: {
      const code = this.charCodeAt(this.tokenStart);

      if (
        code === SOLIDUS$7 ||
        code === ASTERISK$8 ||
        code === PLUSSIGN$b ||
        code === HYPHENMINUS$7
      ) {
        return this.Operator(); // TODO: replace with Delim
      }

      // TODO: produce a node with Delim node type

      if (code === NUMBERSIGN$6) {
        this.error("Hex or identifier is expected", this.tokenStart + 1);
      }

      break;
    }
  }
}

var _default$5 = defaultRecognizer$1;

const _default$4 = _default$5;

const atrulePrelude$3 = {
  getNode: _default$4,
};

var atrulePrelude_1$1 = atrulePrelude$3;

const types$Z = types$1M;

const NUMBERSIGN$5 = 0x0023; // U+0023 NUMBER SIGN (#)
const AMPERSAND$2 = 0x0026; // U+0026 AMPERSAND (&)
const ASTERISK$7 = 0x002a; // U+002A ASTERISK (*)
const PLUSSIGN$a = 0x002b; // U+002B PLUS SIGN (+)
const SOLIDUS$6 = 0x002f; // U+002F SOLIDUS (/)
const FULLSTOP$3 = 0x002e; // U+002E FULL STOP (.)
const GREATERTHANSIGN$3 = 0x003e; // U+003E GREATER-THAN SIGN (>)
const VERTICALLINE$4 = 0x007c; // U+007C VERTICAL LINE (|)
const TILDE$3 = 0x007e; // U+007E TILDE (~)

function onWhiteSpace$1(next, children) {
  if (
    children.last !== null &&
    children.last.type !== "Combinator" &&
    next !== null &&
    next.type !== "Combinator"
  ) {
    children.push({
      // FIXME: this.Combinator() should be used instead
      type: "Combinator",
      loc: null,
      name: " ",
    });
  }
}

function getNode$1() {
  switch (this.tokenType) {
    case types$Z.LeftSquareBracket:
      return this.AttributeSelector();

    case types$Z.Hash:
      return this.IdSelector();

    case types$Z.Colon:
      if (this.lookupType(1) === types$Z.Colon) {
        return this.PseudoElementSelector();
      } else {
        return this.PseudoClassSelector();
      }

    case types$Z.Ident:
      return this.TypeSelector();

    case types$Z.Number:
    case types$Z.Percentage:
      return this.Percentage();

    case types$Z.Dimension:
      // throws when .123ident
      if (this.charCodeAt(this.tokenStart) === FULLSTOP$3) {
        this.error("Identifier is expected", this.tokenStart + 1);
      }
      break;

    case types$Z.Delim: {
      const code = this.charCodeAt(this.tokenStart);

      switch (code) {
        case PLUSSIGN$a:
        case GREATERTHANSIGN$3:
        case TILDE$3:
        case SOLIDUS$6: // /deep/
          return this.Combinator();

        case FULLSTOP$3:
          return this.ClassSelector();

        case ASTERISK$7:
        case VERTICALLINE$4:
          return this.TypeSelector();

        case NUMBERSIGN$5:
          return this.IdSelector();

        case AMPERSAND$2:
          return this.NestingSelector();
      }

      break;
    }
  }
}
const Selector$5 = {
  onWhiteSpace: onWhiteSpace$1,
  getNode: getNode$1,
};

var selector$5 = Selector$5;

// legacy IE function
// expression( <any-value> )
function expressionFn$1() {
  return this.createSingleNodeList(this.Raw(this.tokenIndex, null, false));
}

var expression$3 = expressionFn$1;

const types$Y = types$1M;

// var( <ident> , <value>? )
function varFn$1() {
  const children = this.createList();

  this.skipSC();

  // NOTE: Don't check more than a first argument is an ident, rest checks are for lexer
  children.push(this.Identifier());

  this.skipSC();

  if (this.tokenType === types$Y.Comma) {
    children.push(this.Operator());

    const startIndex = this.tokenIndex;
    const value = this.parseCustomProperty
      ? this.Value(null)
      : this.Raw(
          this.tokenIndex,
          this.consumeUntilExclamationMarkOrSemicolon,
          false,
        );

    if (value.type === "Value" && value.children.isEmpty) {
      for (let offset = startIndex - this.tokenIndex; offset <= 0; offset++) {
        if (this.lookupType(offset) === types$Y.WhiteSpace) {
          value.children.appendData({
            type: "WhiteSpace",
            loc: null,
            value: " ",
          });
          break;
        }
      }
    }

    children.push(value);
  }

  return children;
}

var _var$3 = varFn$1;

const _default$3 = _default$5;
const expression$2 = expression$3;
const _var$2 = _var$3;

function isPlusMinusOperator$1(node) {
  return (
    node !== null &&
    node.type === "Operator" &&
    (node.value[node.value.length - 1] === "-" ||
      node.value[node.value.length - 1] === "+")
  );
}

const value$3 = {
  getNode: _default$3,
  onWhiteSpace(next, children) {
    if (isPlusMinusOperator$1(next)) {
      next.value = " " + next.value;
    }
    if (isPlusMinusOperator$1(children.last)) {
      children.last.value += " ";
    }
  },
  expression: expression$2,
  var: _var$2,
};

var value_1$1 = value$3;

const atrulePrelude$2 = atrulePrelude_1$1;
const selector$4 = selector$5;
const value$2 = value_1$1;

scope$1.AtrulePrelude = atrulePrelude$2;
scope$1.Selector = selector$4;
scope$1.Value = value$2;

const fontFace$3 = {
  parse: {
    prelude: null,
    block() {
      return this.Block(true);
    },
  },
};

var fontFace_1$1 = fontFace$3;

const types$X = types$1M;

const importAtrule$1 = {
  parse: {
    prelude() {
      const children = this.createList();

      this.skipSC();

      switch (this.tokenType) {
        case types$X.String:
          children.push(this.String());
          break;

        case types$X.Url:
        case types$X.Function:
          children.push(this.Url());
          break;

        default:
          this.error("String or url() is expected");
      }

      if (
        this.lookupNonWSType(0) === types$X.Ident ||
        this.lookupNonWSType(0) === types$X.LeftParenthesis
      ) {
        children.push(this.MediaQueryList());
      }

      return children;
    },
    block: null,
  },
};

var _import$3 = importAtrule$1;

const media$3 = {
  parse: {
    prelude() {
      return this.createSingleNodeList(this.MediaQueryList());
    },
    block(isStyleBlock = false) {
      return this.Block(isStyleBlock);
    },
  },
};

var media_1$1 = media$3;

const nest$1 = {
  parse: {
    prelude() {
      return this.createSingleNodeList(this.SelectorList());
    },
    block() {
      return this.Block(true);
    },
  },
};

var nest_1 = nest$1;

const page$3 = {
  parse: {
    prelude() {
      return this.createSingleNodeList(this.SelectorList());
    },
    block() {
      return this.Block(true);
    },
  },
};

var page_1$1 = page$3;

const types$W = types$1M;

function consumeRaw$6() {
  return this.createSingleNodeList(this.Raw(this.tokenIndex, null, false));
}

function parentheses$1() {
  this.skipSC();

  if (
    this.tokenType === types$W.Ident &&
    this.lookupNonWSType(1) === types$W.Colon
  ) {
    return this.createSingleNodeList(this.Declaration());
  }

  return readSequence$2.call(this);
}

function readSequence$2() {
  const children = this.createList();
  let child;

  this.skipSC();

  scan: while (!this.eof) {
    switch (this.tokenType) {
      case types$W.Comment:
      case types$W.WhiteSpace:
        this.next();
        continue;

      case types$W.Function:
        child = this.Function(consumeRaw$6, this.scope.AtrulePrelude);
        break;

      case types$W.Ident:
        child = this.Identifier();
        break;

      case types$W.LeftParenthesis:
        child = this.Parentheses(parentheses$1, this.scope.AtrulePrelude);
        break;

      default:
        break scan;
    }

    children.push(child);
  }

  return children;
}

const supports$3 = {
  parse: {
    prelude() {
      const children = readSequence$2.call(this);

      if (this.getFirstListNode(children) === null) {
        this.error("Condition is expected");
      }

      return children;
    },
    block(isStyleBlock = false) {
      return this.Block(isStyleBlock);
    },
  },
};

var supports_1$1 = supports$3;

const fontFace$2 = fontFace_1$1;
const _import$2 = _import$3;
const media$2 = media_1$1;
const nest = nest_1;
const page$2 = page_1$1;
const supports$2 = supports_1$1;

const atrule$1 = {
  "font-face": fontFace$2,
  import: _import$2,
  media: media$2,
  nest,
  page: page$2,
  supports: supports$2,
};

var atrule_1$1 = atrule$1;

const selectorList$1 = {
  parse() {
    return this.createSingleNodeList(this.SelectorList());
  },
};

const selector$3 = {
  parse() {
    return this.createSingleNodeList(this.Selector());
  },
};

const identList$1 = {
  parse() {
    return this.createSingleNodeList(this.Identifier());
  },
};

const nth$2 = {
  parse() {
    return this.createSingleNodeList(this.Nth());
  },
};

const pseudo$1 = {
  dir: identList$1,
  has: selectorList$1,
  lang: identList$1,
  matches: selectorList$1,
  is: selectorList$1,
  "-moz-any": selectorList$1,
  "-webkit-any": selectorList$1,
  where: selectorList$1,
  not: selectorList$1,
  "nth-child": nth$2,
  "nth-last-child": nth$2,
  "nth-last-of-type": nth$2,
  "nth-of-type": nth$2,
  slotted: selector$3,
  host: selector$3,
  "host-context": selector$3,
};

var pseudo_1$1 = pseudo$1;

var indexParse$3 = {};

const AnPlusB$3 = AnPlusB$5;
const Atrule$7 = Atrule$9;
const AtrulePrelude$3 = AtrulePrelude$5;
const AttributeSelector$5 = AttributeSelector$7;
const Block$3 = Block$5;
const Brackets$3 = Brackets$5;
const CDC$4 = CDC$6;
const CDO$4 = CDO$6;
const ClassSelector$3 = ClassSelector$5;
const Combinator$3 = Combinator$5;
const Comment$6 = Comment$8;
const Declaration$5 = Declaration$7;
const DeclarationList$3 = DeclarationList$5;
const Dimension$6 = Dimension$8;
const Function$4 = _Function$1;
const Hash$4 = Hash$6;
const Identifier$3 = Identifier$5;
const IdSelector$3 = IdSelector$5;
const MediaFeature$3 = MediaFeature$5;
const MediaQuery$3 = MediaQuery$5;
const MediaQueryList$3 = MediaQueryList$5;
const NestingSelector = NestingSelector$2;
const Nth$3 = Nth$5;
const Number$4 = _Number$6;
const Operator$3 = Operator$5;
const Parentheses$3 = Parentheses$5;
const Percentage$6 = Percentage$8;
const PseudoClassSelector$3 = PseudoClassSelector$5;
const PseudoElementSelector$3 = PseudoElementSelector$5;
const Ratio$3 = Ratio$5;
const Raw$5 = Raw$7;
const Rule$5 = Rule$7;
const Selector$4 = Selector$7;
const SelectorList$3 = SelectorList$5;
const String$3 = _String$1;
const StyleSheet$3 = StyleSheet$5;
const TypeSelector$5 = TypeSelector$7;
const UnicodeRange$3 = UnicodeRange$5;
const Url$6 = Url$8;
const Value$5 = Value$7;
const WhiteSpace$6 = WhiteSpace$8;

indexParse$3.AnPlusB = AnPlusB$3.parse;
indexParse$3.Atrule = Atrule$7.parse;
indexParse$3.AtrulePrelude = AtrulePrelude$3.parse;
indexParse$3.AttributeSelector = AttributeSelector$5.parse;
indexParse$3.Block = Block$3.parse;
indexParse$3.Brackets = Brackets$3.parse;
indexParse$3.CDC = CDC$4.parse;
indexParse$3.CDO = CDO$4.parse;
indexParse$3.ClassSelector = ClassSelector$3.parse;
indexParse$3.Combinator = Combinator$3.parse;
indexParse$3.Comment = Comment$6.parse;
indexParse$3.Declaration = Declaration$5.parse;
indexParse$3.DeclarationList = DeclarationList$3.parse;
indexParse$3.Dimension = Dimension$6.parse;
indexParse$3.Function = Function$4.parse;
indexParse$3.Hash = Hash$4.parse;
indexParse$3.Identifier = Identifier$3.parse;
indexParse$3.IdSelector = IdSelector$3.parse;
indexParse$3.MediaFeature = MediaFeature$3.parse;
indexParse$3.MediaQuery = MediaQuery$3.parse;
indexParse$3.MediaQueryList = MediaQueryList$3.parse;
indexParse$3.NestingSelector = NestingSelector.parse;
indexParse$3.Nth = Nth$3.parse;
indexParse$3.Number = Number$4.parse;
indexParse$3.Operator = Operator$3.parse;
indexParse$3.Parentheses = Parentheses$3.parse;
indexParse$3.Percentage = Percentage$6.parse;
indexParse$3.PseudoClassSelector = PseudoClassSelector$3.parse;
indexParse$3.PseudoElementSelector = PseudoElementSelector$3.parse;
indexParse$3.Ratio = Ratio$3.parse;
indexParse$3.Raw = Raw$5.parse;
indexParse$3.Rule = Rule$5.parse;
indexParse$3.Selector = Selector$4.parse;
indexParse$3.SelectorList = SelectorList$3.parse;
indexParse$3.String = String$3.parse;
indexParse$3.StyleSheet = StyleSheet$3.parse;
indexParse$3.TypeSelector = TypeSelector$5.parse;
indexParse$3.UnicodeRange = UnicodeRange$3.parse;
indexParse$3.Url = Url$6.parse;
indexParse$3.Value = Value$5.parse;
indexParse$3.WhiteSpace = WhiteSpace$6.parse;

const index$e = scope$1;
const index$1$4 = atrule_1$1;
const index$2$2 = pseudo_1$1;
const indexParse$2 = indexParse$3;

const config$3 = {
  parseContext: {
    default: "StyleSheet",
    stylesheet: "StyleSheet",
    atrule: "Atrule",
    atrulePrelude(options) {
      return this.AtrulePrelude(options.atrule ? String(options.atrule) : null);
    },
    mediaQueryList: "MediaQueryList",
    mediaQuery: "MediaQuery",
    rule: "Rule",
    selectorList: "SelectorList",
    selector: "Selector",
    block() {
      return this.Block(true);
    },
    declarationList: "DeclarationList",
    declaration: "Declaration",
    value: "Value",
  },
  scope: index$e,
  atrule: index$1$4,
  pseudo: index$2$2,
  node: indexParse$2,
};

var parser$3 = config$3;

const index$d = node$1;

const config$2 = {
  node: index$d,
};

var walker$3 = config$2;

const create$9 = create_1$1;
const lexer$5 = lexer$6;
const parser$2 = parser$3;
const walker$2 = walker$3;

const syntax$3 = create$9({
  ...lexer$5,
  ...parser$2,
  ...walker$2,
});

var syntax_1$1 = syntax$3;

var version$c = {};

const name$G = "css-tree";
const version$b = "2.3.1";
const description$2 =
  "A tool set for CSS: fast detailed parser (CSS  AST), walker (AST traversal), generator (AST  CSS) and lexer (validation and matching) based on specs and browser implementations";
const author$2 =
  "Roman Dvornov <rdvornov@gmail.com> (https://github.com/lahmatiy)";
const license$2 = "MIT";
const repository$2 = "csstree/csstree";
const keywords$3 = [
  "css",
  "ast",
  "tokenizer",
  "parser",
  "walker",
  "lexer",
  "generator",
  "utils",
  "syntax",
  "validation",
];
const type$2 = "module";
const module$2 = "./lib/index.js";
const main$2 = "./cjs/index.cjs";
const exports$2 = {
  ".": {
    import: "./lib/index.js",
    require: "./cjs/index.cjs",
  },
  "./dist/*": "./dist/*.js",
  "./package.json": "./package.json",
  "./tokenizer": {
    import: "./lib/tokenizer/index.js",
    require: "./cjs/tokenizer/index.cjs",
  },
  "./parser": {
    import: "./lib/parser/index.js",
    require: "./cjs/parser/index.cjs",
  },
  "./selector-parser": {
    import: "./lib/parser/parse-selector.js",
    require: "./cjs/parser/parse-selector.cjs",
  },
  "./generator": {
    import: "./lib/generator/index.js",
    require: "./cjs/generator/index.cjs",
  },
  "./walker": {
    import: "./lib/walker/index.js",
    require: "./cjs/walker/index.cjs",
  },
  "./convertor": {
    import: "./lib/convertor/index.js",
    require: "./cjs/convertor/index.cjs",
  },
  "./lexer": {
    import: "./lib/lexer/index.js",
    require: "./cjs/lexer/index.cjs",
  },
  "./definition-syntax": {
    import: "./lib/definition-syntax/index.js",
    require: "./cjs/definition-syntax/index.cjs",
  },
  "./definition-syntax-data": {
    import: "./lib/data.js",
    require: "./cjs/data.cjs",
  },
  "./definition-syntax-data-patch": {
    import: "./lib/data-patch.js",
    require: "./cjs/data-patch.cjs",
  },
  "./utils": {
    import: "./lib/utils/index.js",
    require: "./cjs/utils/index.cjs",
  },
};
const browser$2 = {
  "./cjs/data.cjs": "./dist/data.cjs",
  "./cjs/version.cjs": "./dist/version.cjs",
  "./lib/data.js": "./dist/data.js",
  "./lib/version.js": "./dist/version.js",
};
const unpkg$2 = "dist/csstree.esm.js";
const jsdelivr$2 = "dist/csstree.esm.js";
const scripts$2 = {
  watch: "npm run build -- --watch",
  build: "npm run bundle && npm run esm-to-cjs --",
  "build-and-test": "npm run build && npm run test:dist && npm run test:cjs",
  bundle: "node scripts/bundle",
  "bundle-and-test": "npm run bundle && npm run test:dist",
  "esm-to-cjs": "node scripts/esm-to-cjs.cjs",
  "esm-to-cjs-and-test": "npm run esm-to-cjs && npm run test:cjs",
  lint: "eslint lib scripts && node scripts/review-syntax-patch --lint && node scripts/update-docs --lint",
  "lint-and-test": "npm run lint && npm test",
  "update:docs": "node scripts/update-docs",
  "review:syntax-patch": "node scripts/review-syntax-patch",
  test: "mocha lib/__tests --reporter ${REPORTER:-progress}",
  "test:cjs": "mocha cjs/__tests --reporter ${REPORTER:-progress}",
  "test:dist": "mocha dist/__tests --reporter ${REPORTER:-progress}",
  coverage: "c8 --exclude lib/__tests --reporter=lcovonly npm test",
  prepublishOnly: "npm run lint-and-test && npm run build-and-test",
  hydrogen:
    "node --trace-hydrogen --trace-phase=Z --trace-deopt --code-comments --hydrogen-track-positions --redirect-code-traces --redirect-code-traces-to=code.asm --trace_hydrogen_file=code.cfg --print-opt-code bin/parse --stat -o /dev/null",
};
const dependencies$2 = {
  "mdn-data": "2.0.30",
  "source-map-js": "^1.0.1",
};
const devDependencies$2 = {
  c8: "^7.12.0",
  clap: "^2.0.1",
  esbuild: "^0.14.53",
  eslint: "^8.4.1",
  "json-to-ast": "^2.1.0",
  mocha: "^9.2.2",
  rollup: "^2.68.0",
};
const engines$2 = {
  node: "^10 || ^12.20.0 || ^14.13.0 || >=15.0.0",
};
const files$2 = ["data", "dist", "cjs", "!cjs/__tests", "lib", "!lib/__tests"];
const require$$0$3 = {
  name: name$G,
  version: version$b,
  description: description$2,
  author: author$2,
  license: license$2,
  repository: repository$2,
  keywords: keywords$3,
  type: type$2,
  module: module$2,
  main: main$2,
  exports: exports$2,
  browser: browser$2,
  unpkg: unpkg$2,
  jsdelivr: jsdelivr$2,
  scripts: scripts$2,
  dependencies: dependencies$2,
  devDependencies: devDependencies$2,
  engines: engines$2,
  files: files$2,
};

const { version: version$a } = require$$0$3;

version$c.version = version$a;

var definitionSyntax$1 = {};

const SyntaxError$6 = _SyntaxError$2;
const generate$N = generate$1u;
const parse$R = parse$1y;
const walk$7 = walk$a;

definitionSyntax$1.SyntaxError = SyntaxError$6.SyntaxError;
definitionSyntax$1.generate = generate$N.generate;
definitionSyntax$1.parse = parse$R.parse;
definitionSyntax$1.walk = walk$7.walk;

var clone$5 = {};

const List$9 = List$f;

function clone$4(node) {
  const result = {};

  for (const key in node) {
    let value = node[key];

    if (value) {
      if (Array.isArray(value) || value instanceof List$9.List) {
        value = value.map(clone$4);
      } else if (value.constructor === Object) {
        value = clone$4(value);
      }
    }

    result[key] = value;
  }

  return result;
}

clone$5.clone = clone$4;

var ident$3 = {};

const charCodeDefinitions$d = charCodeDefinitions$p;
const utils$l = utils$u;

const REVERSE_SOLIDUS$3 = 0x005c; // U+005C REVERSE SOLIDUS (\)

function decode$3(str) {
  const end = str.length - 1;
  let decoded = "";

  for (let i = 0; i < str.length; i++) {
    let code = str.charCodeAt(i);

    if (code === REVERSE_SOLIDUS$3) {
      // special case at the ending
      if (i === end) {
        // if the next input code point is EOF, do nothing
        break;
      }

      code = str.charCodeAt(++i);

      // consume escaped
      if (charCodeDefinitions$d.isValidEscape(REVERSE_SOLIDUS$3, code)) {
        const escapeStart = i - 1;
        const escapeEnd = utils$l.consumeEscaped(str, escapeStart);

        i = escapeEnd - 1;
        decoded += utils$l.decodeEscaped(
          str.substring(escapeStart + 1, escapeEnd),
        );
      } else {
        // \r\n
        if (code === 0x000d && str.charCodeAt(i + 1) === 0x000a) {
          i++;
        }
      }
    } else {
      decoded += str[i];
    }
  }

  return decoded;
}

// https://drafts.csswg.org/cssom/#serialize-an-identifier
//  2.1. Common Serializing Idioms
function encode$4(str) {
  let encoded = "";

  // If the character is the first character and is a "-" (U+002D),
  // and there is no second character, then the escaped character.
  // Note: That's means a single dash string "-" return as escaped dash,
  // so move the condition out of the main loop
  if (str.length === 1 && str.charCodeAt(0) === 0x002d) {
    return "\\-";
  }

  // To serialize an identifier means to create a string represented
  // by the concatenation of, for each character of the identifier:
  for (let i = 0; i < str.length; i++) {
    const code = str.charCodeAt(i);

    // If the character is NULL (U+0000), then the REPLACEMENT CHARACTER (U+FFFD).
    if (code === 0x0000) {
      encoded += "\uFFFD";
      continue;
    }

    if (
      // If the character is in the range [\1-\1f] (U+0001 to U+001F) or is U+007F ...
      // Note: Do not compare with 0x0001 since 0x0000 is precessed before
      code <= 0x001f ||
      code === 0x007f ||
      // [or] ... is in the range [0-9] (U+0030 to U+0039),
      (code >= 0x0030 &&
        code <= 0x0039 &&
        // If the character is the first character ...
        (i === 0 ||
          // If the character is the second character ... and the first character is a "-" (U+002D)
          (i === 1 && str.charCodeAt(0) === 0x002d)))
    ) {
      // ... then the character escaped as code point.
      encoded += "\\" + code.toString(16) + " ";
      continue;
    }

    // If the character is not handled by one of the above rules and is greater
    // than or equal to U+0080, is "-" (U+002D) or "_" (U+005F), or is in one
    // of the ranges [0-9] (U+0030 to U+0039), [A-Z] (U+0041 to U+005A),
    // or \[a-z] (U+0061 to U+007A), then the character itself.
    if (charCodeDefinitions$d.isName(code)) {
      encoded += str.charAt(i);
    } else {
      // Otherwise, the escaped character.
      encoded += "\\" + str.charAt(i);
    }
  }

  return encoded;
}

ident$3.decode = decode$3;
ident$3.encode = encode$4;

const index$1$3 = syntax_1$1;
const version$9 = version$c;
const create$8 = create_1$1;
const List$8 = List$f;
const Lexer$4 = Lexer$7;
const index$c = definitionSyntax$1;
const clone$3 = clone$5;
const names$1$1 = names$c;
const ident$2 = ident$3;
const string$4 = string$7;
const url$3 = url$5;
const types$V = types$1M;
const names$9 = names$g;
const TokenStream$5 = TokenStream$9;

const {
  tokenize: tokenize$3,
  parse: parse$Q,
  generate: generate$M,
  lexer: lexer$4,
  createLexer: createLexer$1,

  walk: walk$6,
  find: find$2,
  findLast: findLast$2,
  findAll: findAll$2,

  toPlainObject: toPlainObject$2,
  fromPlainObject: fromPlainObject$2,

  fork: fork$1,
} = index$1$3;

cjs$2.version = version$9.version;
cjs$2.createSyntax = create$8;
cjs$2.List = List$8.List;
cjs$2.Lexer = Lexer$4.Lexer;
cjs$2.definitionSyntax = index$c;
cjs$2.clone = clone$3.clone;
cjs$2.isCustomProperty = names$1$1.isCustomProperty;
cjs$2.keyword = names$1$1.keyword;
cjs$2.property = names$1$1.property;
cjs$2.vendorPrefix = names$1$1.vendorPrefix;
cjs$2.ident = ident$2;
cjs$2.string = string$4;
cjs$2.url = url$3;
cjs$2.tokenTypes = types$V;
cjs$2.tokenNames = names$9;
cjs$2.TokenStream = TokenStream$5.TokenStream;
cjs$2.createLexer = createLexer$1;
cjs$2.find = find$2;
cjs$2.findAll = findAll$2;
cjs$2.findLast = findLast$2;
cjs$2.fork = fork$1;
cjs$2.fromPlainObject = fromPlainObject$2;
cjs$2.generate = generate$M;
cjs$2.lexer = lexer$4;
cjs$2.parse = parse$Q;
cjs$2.toPlainObject = toPlainObject$2;
cjs$2.tokenize = tokenize$3;
cjs$2.walk = walk$6;

var cjs$1 = {};

var version$8 = {};

const name$F = "csso";
const version$7 = "5.0.5";
const description$1 = "CSS minifier with structural optimisations";
const author$1 =
  "Sergey Kryzhanovsky <skryzhanovsky@ya.ru> (https://github.com/afelix)";
const maintainers = [
  {
    name: "Roman Dvornov",
    email: "rdvornov@gmail.com",
    "github-username": "lahmatiy",
  },
];
const repository$1 = "css/csso";
const license$1 = "MIT";
const keywords$2 = [
  "css",
  "compress",
  "minifier",
  "minify",
  "optimise",
  "optimisation",
  "csstree",
];
const type$1 = "module";
const unpkg$1 = "dist/csso.esm.js";
const jsdelivr$1 = "dist/csso.esm.js";
const browser$1 = {
  "./cjs/version.cjs": "./dist/version.cjs",
  "./lib/version.js": "./dist/version.js",
};
const main$1 = "./cjs/index.cjs";
const module$1 = "./lib/index.js";
const exports$1 = {
  ".": {
    import: "./lib/index.js",
    require: "./cjs/index.cjs",
  },
  "./syntax": {
    import: "./lib/syntax.js",
    require: "./cjs/syntax.cjs",
  },
  "./dist/*": "./dist/*.js",
  "./package.json": "./package.json",
};
const scripts$1 = {
  test: "mocha test --reporter ${REPORTER:-progress}",
  "test:cjs": "mocha cjs-test --reporter ${REPORTER:-progress}",
  "test:dist": "mocha dist/test --reporter ${REPORTER:-progress}",
  lint: "eslint lib scripts test",
  "lint-and-test": "npm run lint && npm test",
  build: "npm run bundle && npm run esm-to-cjs",
  "build-and-test": "npm run build && npm run test:dist && npm run test:cjs",
  bundle: "node scripts/bundle",
  "bundle-and-test": "npm run bundle && npm run test:dist",
  "esm-to-cjs": "node scripts/esm-to-cjs.cjs",
  "esm-to-cjs-and-test": "npm run esm-to-cjs && npm run test:cjs",
  coverage: "c8 --reporter=lcovonly npm test",
  prepublishOnly: "npm run lint-and-test && npm run build-and-test",
  hydrogen:
    "node --trace-hydrogen --trace-phase=Z --trace-deopt --code-comments --hydrogen-track-positions --redirect-code-traces --redirect-code-traces-to=code.asm --trace_hydrogen_file=code.cfg --print-opt-code bin/csso --stat -o /dev/null",
};
const dependencies$1 = {
  "css-tree": "~2.2.0",
};
const devDependencies$1 = {
  c8: "^7.10.0",
  esbuild: "^0.14.54",
  eslint: "^7.24.0",
  mocha: "^9.2.2",
  rollup: "^2.60.2",
  "source-map-js": "^1.0.1",
};
const engines$1 = {
  node: "^10 || ^12.20.0 || ^14.13.0 || >=15.0.0",
  npm: ">=7.0.0",
};
const files$1 = ["dist", "!dist/test", "cjs", "lib"];
const require$$0$2 = {
  name: name$F,
  version: version$7,
  description: description$1,
  author: author$1,
  maintainers: maintainers,
  repository: repository$1,
  license: license$1,
  keywords: keywords$2,
  type: type$1,
  unpkg: unpkg$1,
  jsdelivr: jsdelivr$1,
  browser: browser$1,
  main: main$1,
  module: module$1,
  exports: exports$1,
  scripts: scripts$1,
  dependencies: dependencies$1,
  devDependencies: devDependencies$1,
  engines: engines$1,
  files: files$1,
};

const { version: version$6 } = require$$0$2;

version$8.version = version$6;

var syntax$2 = {};

var cjs = {};

var tokenizer$2 = {};

var types$U = {};

// CSS Syntax Module Level 3
// https://www.w3.org/TR/css-syntax-3/
const EOF$4 = 0; // <EOF-token>
const Ident = 1; // <ident-token>
const Function$3 = 2; // <function-token>
const AtKeyword = 3; // <at-keyword-token>
const Hash$3 = 4; // <hash-token>
const String$2 = 5; // <string-token>
const BadString = 6; // <bad-string-token>
const Url$5 = 7; // <url-token>
const BadUrl = 8; // <bad-url-token>
const Delim = 9; // <delim-token>
const Number$3 = 10; // <number-token>
const Percentage$5 = 11; // <percentage-token>
const Dimension$5 = 12; // <dimension-token>
const WhiteSpace$5 = 13; // <whitespace-token>
const CDO$3 = 14; // <CDO-token>
const CDC$3 = 15; // <CDC-token>
const Colon = 16; // <colon-token>     :
const Semicolon = 17; // <semicolon-token> ;
const Comma = 18; // <comma-token>     ,
const LeftSquareBracket = 19; // <[-token>
const RightSquareBracket = 20; // <]-token>
const LeftParenthesis = 21; // <(-token>
const RightParenthesis = 22; // <)-token>
const LeftCurlyBracket = 23; // <{-token>
const RightCurlyBracket = 24; // <}-token>
const Comment$5 = 25;

types$U.AtKeyword = AtKeyword;
types$U.BadString = BadString;
types$U.BadUrl = BadUrl;
types$U.CDC = CDC$3;
types$U.CDO = CDO$3;
types$U.Colon = Colon;
types$U.Comma = Comma;
types$U.Comment = Comment$5;
types$U.Delim = Delim;
types$U.Dimension = Dimension$5;
types$U.EOF = EOF$4;
types$U.Function = Function$3;
types$U.Hash = Hash$3;
types$U.Ident = Ident;
types$U.LeftCurlyBracket = LeftCurlyBracket;
types$U.LeftParenthesis = LeftParenthesis;
types$U.LeftSquareBracket = LeftSquareBracket;
types$U.Number = Number$3;
types$U.Percentage = Percentage$5;
types$U.RightCurlyBracket = RightCurlyBracket;
types$U.RightParenthesis = RightParenthesis;
types$U.RightSquareBracket = RightSquareBracket;
types$U.Semicolon = Semicolon;
types$U.String = String$2;
types$U.Url = Url$5;
types$U.WhiteSpace = WhiteSpace$5;

var charCodeDefinitions$c = {};

const EOF$3 = 0;

// https://drafts.csswg.org/css-syntax-3/
//  4.2. Definitions

// digit
// A code point between U+0030 DIGIT ZERO (0) and U+0039 DIGIT NINE (9).
function isDigit$1(code) {
  return code >= 0x0030 && code <= 0x0039;
}

// hex digit
// A digit, or a code point between U+0041 LATIN CAPITAL LETTER A (A) and U+0046 LATIN CAPITAL LETTER F (F),
// or a code point between U+0061 LATIN SMALL LETTER A (a) and U+0066 LATIN SMALL LETTER F (f).
function isHexDigit(code) {
  return (
    isDigit$1(code) || // 0 .. 9
    (code >= 0x0041 && code <= 0x0046) || // A .. F
    (code >= 0x0061 && code <= 0x0066) // a .. f
  );
}

// uppercase letter
// A code point between U+0041 LATIN CAPITAL LETTER A (A) and U+005A LATIN CAPITAL LETTER Z (Z).
function isUppercaseLetter(code) {
  return code >= 0x0041 && code <= 0x005a;
}

// lowercase letter
// A code point between U+0061 LATIN SMALL LETTER A (a) and U+007A LATIN SMALL LETTER Z (z).
function isLowercaseLetter(code) {
  return code >= 0x0061 && code <= 0x007a;
}

// letter
// An uppercase letter or a lowercase letter.
function isLetter(code) {
  return isUppercaseLetter(code) || isLowercaseLetter(code);
}

// non-ASCII code point
// A code point with a value equal to or greater than U+0080 <control>.
function isNonAscii(code) {
  return code >= 0x0080;
}

// name-start code point
// A letter, a non-ASCII code point, or U+005F LOW LINE (_).
function isNameStart(code) {
  return isLetter(code) || isNonAscii(code) || code === 0x005f;
}

// name code point
// A name-start code point, a digit, or U+002D HYPHEN-MINUS (-).
function isName(code) {
  return isNameStart(code) || isDigit$1(code) || code === 0x002d;
}

// non-printable code point
// A code point between U+0000 NULL and U+0008 BACKSPACE, or U+000B LINE TABULATION,
// or a code point between U+000E SHIFT OUT and U+001F INFORMATION SEPARATOR ONE, or U+007F DELETE.
function isNonPrintable(code) {
  return (
    (code >= 0x0000 && code <= 0x0008) ||
    code === 0x000b ||
    (code >= 0x000e && code <= 0x001f) ||
    code === 0x007f
  );
}

// newline
// U+000A LINE FEED. Note that U+000D CARRIAGE RETURN and U+000C FORM FEED are not included in this definition,
// as they are converted to U+000A LINE FEED during preprocessing.
// TODO: we doesn't do a preprocessing, so check a code point for U+000D CARRIAGE RETURN and U+000C FORM FEED
function isNewline(code) {
  return code === 0x000a || code === 0x000d || code === 0x000c;
}

// whitespace
// A newline, U+0009 CHARACTER TABULATION, or U+0020 SPACE.
function isWhiteSpace(code) {
  return isNewline(code) || code === 0x0020 || code === 0x0009;
}

//  4.3.8. Check if two code points are a valid escape
function isValidEscape(first, second) {
  // If the first code point is not U+005C REVERSE SOLIDUS (\), return false.
  if (first !== 0x005c) {
    return false;
  }

  // Otherwise, if the second code point is a newline or EOF, return false.
  if (isNewline(second) || second === EOF$3) {
    return false;
  }

  // Otherwise, return true.
  return true;
}

//  4.3.9. Check if three code points would start an identifier
function isIdentifierStart(first, second, third) {
  // Look at the first code point:

  // U+002D HYPHEN-MINUS
  if (first === 0x002d) {
    // If the second code point is a name-start code point or a U+002D HYPHEN-MINUS,
    // or the second and third code points are a valid escape, return true. Otherwise, return false.
    return (
      isNameStart(second) || second === 0x002d || isValidEscape(second, third)
    );
  }

  // name-start code point
  if (isNameStart(first)) {
    // Return true.
    return true;
  }

  // U+005C REVERSE SOLIDUS (\)
  if (first === 0x005c) {
    // If the first and second code points are a valid escape, return true. Otherwise, return false.
    return isValidEscape(first, second);
  }

  // anything else
  // Return false.
  return false;
}

//  4.3.10. Check if three code points would start a number
function isNumberStart(first, second, third) {
  // Look at the first code point:

  // U+002B PLUS SIGN (+)
  // U+002D HYPHEN-MINUS (-)
  if (first === 0x002b || first === 0x002d) {
    // If the second code point is a digit, return true.
    if (isDigit$1(second)) {
      return 2;
    }

    // Otherwise, if the second code point is a U+002E FULL STOP (.)
    // and the third code point is a digit, return true.
    // Otherwise, return false.
    return second === 0x002e && isDigit$1(third) ? 3 : 0;
  }

  // U+002E FULL STOP (.)
  if (first === 0x002e) {
    // If the second code point is a digit, return true. Otherwise, return false.
    return isDigit$1(second) ? 2 : 0;
  }

  // digit
  if (isDigit$1(first)) {
    // Return true.
    return 1;
  }

  // anything else
  // Return false.
  return 0;
}

//
// Misc
//

// detect BOM (https://en.wikipedia.org/wiki/Byte_order_mark)
function isBOM(code) {
  // UTF-16BE
  if (code === 0xfeff) {
    return 1;
  }

  // UTF-16LE
  if (code === 0xfffe) {
    return 1;
  }

  return 0;
}

// Fast code category
// Only ASCII code points has a special meaning, that's why we define a maps for 0..127 codes only
const CATEGORY = new Array(0x80);
const EofCategory = 0x80;
const WhiteSpaceCategory = 0x82;
const DigitCategory = 0x83;
const NameStartCategory = 0x84;
const NonPrintableCategory = 0x85;

for (let i = 0; i < CATEGORY.length; i++) {
  CATEGORY[i] =
    (isWhiteSpace(i) && WhiteSpaceCategory) ||
    (isDigit$1(i) && DigitCategory) ||
    (isNameStart(i) && NameStartCategory) ||
    (isNonPrintable(i) && NonPrintableCategory) ||
    i ||
    EofCategory;
}

function charCodeCategory(code) {
  return code < 0x80 ? CATEGORY[code] : NameStartCategory;
}

charCodeDefinitions$c.DigitCategory = DigitCategory;
charCodeDefinitions$c.EofCategory = EofCategory;
charCodeDefinitions$c.NameStartCategory = NameStartCategory;
charCodeDefinitions$c.NonPrintableCategory = NonPrintableCategory;
charCodeDefinitions$c.WhiteSpaceCategory = WhiteSpaceCategory;
charCodeDefinitions$c.charCodeCategory = charCodeCategory;
charCodeDefinitions$c.isBOM = isBOM;
charCodeDefinitions$c.isDigit = isDigit$1;
charCodeDefinitions$c.isHexDigit = isHexDigit;
charCodeDefinitions$c.isIdentifierStart = isIdentifierStart;
charCodeDefinitions$c.isLetter = isLetter;
charCodeDefinitions$c.isLowercaseLetter = isLowercaseLetter;
charCodeDefinitions$c.isName = isName;
charCodeDefinitions$c.isNameStart = isNameStart;
charCodeDefinitions$c.isNewline = isNewline;
charCodeDefinitions$c.isNonAscii = isNonAscii;
charCodeDefinitions$c.isNonPrintable = isNonPrintable;
charCodeDefinitions$c.isNumberStart = isNumberStart;
charCodeDefinitions$c.isUppercaseLetter = isUppercaseLetter;
charCodeDefinitions$c.isValidEscape = isValidEscape;
charCodeDefinitions$c.isWhiteSpace = isWhiteSpace;

var utils$k = {};

const charCodeDefinitions$b = charCodeDefinitions$c;

function getCharCode(source, offset) {
  return offset < source.length ? source.charCodeAt(offset) : 0;
}

function getNewlineLength(source, offset, code) {
  if (code === 13 /* \r */ && getCharCode(source, offset + 1) === 10 /* \n */) {
    return 2;
  }

  return 1;
}

function cmpChar(testStr, offset, referenceCode) {
  let code = testStr.charCodeAt(offset);

  // code.toLowerCase() for A..Z
  if (charCodeDefinitions$b.isUppercaseLetter(code)) {
    code = code | 32;
  }

  return code === referenceCode;
}

function cmpStr(testStr, start, end, referenceStr) {
  if (end - start !== referenceStr.length) {
    return false;
  }

  if (start < 0 || end > testStr.length) {
    return false;
  }

  for (let i = start; i < end; i++) {
    const referenceCode = referenceStr.charCodeAt(i - start);
    let testCode = testStr.charCodeAt(i);

    // testCode.toLowerCase() for A..Z
    if (charCodeDefinitions$b.isUppercaseLetter(testCode)) {
      testCode = testCode | 32;
    }

    if (testCode !== referenceCode) {
      return false;
    }
  }

  return true;
}

function findWhiteSpaceStart(source, offset) {
  for (; offset >= 0; offset--) {
    if (!charCodeDefinitions$b.isWhiteSpace(source.charCodeAt(offset))) {
      break;
    }
  }

  return offset + 1;
}

function findWhiteSpaceEnd(source, offset) {
  for (; offset < source.length; offset++) {
    if (!charCodeDefinitions$b.isWhiteSpace(source.charCodeAt(offset))) {
      break;
    }
  }

  return offset;
}

function findDecimalNumberEnd(source, offset) {
  for (; offset < source.length; offset++) {
    if (!charCodeDefinitions$b.isDigit(source.charCodeAt(offset))) {
      break;
    }
  }

  return offset;
}

//  4.3.7. Consume an escaped code point
function consumeEscaped(source, offset) {
  // It assumes that the U+005C REVERSE SOLIDUS (\) has already been consumed and
  // that the next input code point has already been verified to be part of a valid escape.
  offset += 2;

  // hex digit
  if (charCodeDefinitions$b.isHexDigit(getCharCode(source, offset - 1))) {
    // Consume as many hex digits as possible, but no more than 5.
    // Note that this means 1-6 hex digits have been consumed in total.
    for (
      const maxOffset = Math.min(source.length, offset + 5);
      offset < maxOffset;
      offset++
    ) {
      if (!charCodeDefinitions$b.isHexDigit(getCharCode(source, offset))) {
        break;
      }
    }

    // If the next input code point is whitespace, consume it as well.
    const code = getCharCode(source, offset);
    if (charCodeDefinitions$b.isWhiteSpace(code)) {
      offset += getNewlineLength(source, offset, code);
    }
  }

  return offset;
}

// 4.3.11. Consume a name
// Note: This algorithm does not do the verification of the first few code points that are necessary
// to ensure the returned code points would constitute an <ident-token>. If that is the intended use,
// ensure that the stream starts with an identifier before calling this algorithm.
function consumeName(source, offset) {
  // Let result initially be an empty string.
  // Repeatedly consume the next input code point from the stream:
  for (; offset < source.length; offset++) {
    const code = source.charCodeAt(offset);

    // name code point
    if (charCodeDefinitions$b.isName(code)) {
      // Append the code point to result.
      continue;
    }

    // the stream starts with a valid escape
    if (
      charCodeDefinitions$b.isValidEscape(code, getCharCode(source, offset + 1))
    ) {
      // Consume an escaped code point. Append the returned code point to result.
      offset = consumeEscaped(source, offset) - 1;
      continue;
    }

    // anything else
    // Reconsume the current input code point. Return result.
    break;
  }

  return offset;
}

// 4.3.12. Consume a number
function consumeNumber$1(source, offset) {
  let code = source.charCodeAt(offset);

  // 2. If the next input code point is U+002B PLUS SIGN (+) or U+002D HYPHEN-MINUS (-),
  // consume it and append it to repr.
  if (code === 0x002b || code === 0x002d) {
    code = source.charCodeAt((offset += 1));
  }

  // 3. While the next input code point is a digit, consume it and append it to repr.
  if (charCodeDefinitions$b.isDigit(code)) {
    offset = findDecimalNumberEnd(source, offset + 1);
    code = source.charCodeAt(offset);
  }

  // 4. If the next 2 input code points are U+002E FULL STOP (.) followed by a digit, then:
  if (
    code === 0x002e &&
    charCodeDefinitions$b.isDigit(source.charCodeAt(offset + 1))
  ) {
    // 4.1 Consume them.
    // 4.2 Append them to repr.
    offset += 2;

    // 4.3 Set type to "number".
    // TODO

    // 4.4 While the next input code point is a digit, consume it and append it to repr.

    offset = findDecimalNumberEnd(source, offset);
  }

  // 5. If the next 2 or 3 input code points are U+0045 LATIN CAPITAL LETTER E (E)
  // or U+0065 LATIN SMALL LETTER E (e), ... , followed by a digit, then:
  if (cmpChar(source, offset, 101 /* e */)) {
    let sign = 0;
    code = source.charCodeAt(offset + 1);

    // ... optionally followed by U+002D HYPHEN-MINUS (-) or U+002B PLUS SIGN (+) ...
    if (code === 0x002d || code === 0x002b) {
      sign = 1;
      code = source.charCodeAt(offset + 2);
    }

    // ... followed by a digit
    if (charCodeDefinitions$b.isDigit(code)) {
      // 5.1 Consume them.
      // 5.2 Append them to repr.

      // 5.3 Set type to "number".
      // TODO

      // 5.4 While the next input code point is a digit, consume it and append it to repr.
      offset = findDecimalNumberEnd(source, offset + 1 + sign + 1);
    }
  }

  return offset;
}

//  4.3.14. Consume the remnants of a bad url
// ... its sole use is to consume enough of the input stream to reach a recovery point
// where normal tokenizing can resume.
function consumeBadUrlRemnants(source, offset) {
  // Repeatedly consume the next input code point from the stream:
  for (; offset < source.length; offset++) {
    const code = source.charCodeAt(offset);

    // U+0029 RIGHT PARENTHESIS ())
    // EOF
    if (code === 0x0029) {
      // Return.
      offset++;
      break;
    }

    if (
      charCodeDefinitions$b.isValidEscape(code, getCharCode(source, offset + 1))
    ) {
      // Consume an escaped code point.
      // Note: This allows an escaped right parenthesis ("\)") to be encountered
      // without ending the <bad-url-token>. This is otherwise identical to
      // the "anything else" clause.
      offset = consumeEscaped(source, offset);
    }
  }

  return offset;
}

//  4.3.7. Consume an escaped code point
// Note: This algorithm assumes that escaped is valid without leading U+005C REVERSE SOLIDUS (\)
function decodeEscaped(escaped) {
  // Single char escaped that's not a hex digit
  if (
    escaped.length === 1 &&
    !charCodeDefinitions$b.isHexDigit(escaped.charCodeAt(0))
  ) {
    return escaped[0];
  }

  // Interpret the hex digits as a hexadecimal number.
  let code = parseInt(escaped, 16);

  if (
    code === 0 || // If this number is zero,
    (code >= 0xd800 && code <= 0xdfff) || // or is for a surrogate,
    code > 0x10ffff // or is greater than the maximum allowed code point
  ) {
    // ... return U+FFFD REPLACEMENT CHARACTER
    code = 0xfffd;
  }

  // Otherwise, return the code point with that value.
  return String.fromCodePoint(code);
}

utils$k.cmpChar = cmpChar;
utils$k.cmpStr = cmpStr;
utils$k.consumeBadUrlRemnants = consumeBadUrlRemnants;
utils$k.consumeEscaped = consumeEscaped;
utils$k.consumeName = consumeName;
utils$k.consumeNumber = consumeNumber$1;
utils$k.decodeEscaped = decodeEscaped;
utils$k.findDecimalNumberEnd = findDecimalNumberEnd;
utils$k.findWhiteSpaceEnd = findWhiteSpaceEnd;
utils$k.findWhiteSpaceStart = findWhiteSpaceStart;
utils$k.getNewlineLength = getNewlineLength;

const tokenNames = [
  "EOF-token",
  "ident-token",
  "function-token",
  "at-keyword-token",
  "hash-token",
  "string-token",
  "bad-string-token",
  "url-token",
  "bad-url-token",
  "delim-token",
  "number-token",
  "percentage-token",
  "dimension-token",
  "whitespace-token",
  "CDO-token",
  "CDC-token",
  "colon-token",
  "semicolon-token",
  "comma-token",
  "[-token",
  "]-token",
  "(-token",
  ")-token",
  "{-token",
  "}-token",
];

var names$8 = tokenNames;

var OffsetToLocation$3 = {};

var adoptBuffer$3 = {};

const MIN_SIZE = 16 * 1024;

function adoptBuffer$2(buffer = null, size) {
  if (buffer === null || buffer.length < size) {
    return new Uint32Array(Math.max(size + 1024, MIN_SIZE));
  }

  return buffer;
}

adoptBuffer$3.adoptBuffer = adoptBuffer$2;

const adoptBuffer$1 = adoptBuffer$3;
const charCodeDefinitions$a = charCodeDefinitions$c;

const N$4 = 10;
const F$2 = 12;
const R$2 = 13;

function computeLinesAndColumns(host) {
  const source = host.source;
  const sourceLength = source.length;
  const startOffset =
    source.length > 0 ? charCodeDefinitions$a.isBOM(source.charCodeAt(0)) : 0;
  const lines = adoptBuffer$1.adoptBuffer(host.lines, sourceLength);
  const columns = adoptBuffer$1.adoptBuffer(host.columns, sourceLength);
  let line = host.startLine;
  let column = host.startColumn;

  for (let i = startOffset; i < sourceLength; i++) {
    const code = source.charCodeAt(i);

    lines[i] = line;
    columns[i] = column++;

    if (code === N$4 || code === R$2 || code === F$2) {
      if (
        code === R$2 &&
        i + 1 < sourceLength &&
        source.charCodeAt(i + 1) === N$4
      ) {
        i++;
        lines[i] = line;
        columns[i] = column;
      }

      line++;
      column = 1;
    }
  }

  lines[sourceLength] = line;
  columns[sourceLength] = column;

  host.lines = lines;
  host.columns = columns;
  host.computed = true;
}

let OffsetToLocation$2 = class OffsetToLocation {
  constructor() {
    this.lines = null;
    this.columns = null;
    this.computed = false;
  }
  setSource(source, startOffset = 0, startLine = 1, startColumn = 1) {
    this.source = source;
    this.startOffset = startOffset;
    this.startLine = startLine;
    this.startColumn = startColumn;
    this.computed = false;
  }
  getLocation(offset, filename) {
    if (!this.computed) {
      computeLinesAndColumns(this);
    }

    return {
      source: filename,
      offset: this.startOffset + offset,
      line: this.lines[offset],
      column: this.columns[offset],
    };
  }
  getLocationRange(start, end, filename) {
    if (!this.computed) {
      computeLinesAndColumns(this);
    }

    return {
      source: filename,
      start: {
        offset: this.startOffset + start,
        line: this.lines[start],
        column: this.columns[start],
      },
      end: {
        offset: this.startOffset + end,
        line: this.lines[end],
        column: this.columns[end],
      },
    };
  }
};

OffsetToLocation$3.OffsetToLocation = OffsetToLocation$2;

var TokenStream$4 = {};

const adoptBuffer = adoptBuffer$3;
const utils$j = utils$k;
const names$7 = names$8;
const types$T = types$U;

const OFFSET_MASK = 0x00ffffff;
const TYPE_SHIFT = 24;
const balancePair$1 = new Map([
  [types$T.Function, types$T.RightParenthesis],
  [types$T.LeftParenthesis, types$T.RightParenthesis],
  [types$T.LeftSquareBracket, types$T.RightSquareBracket],
  [types$T.LeftCurlyBracket, types$T.RightCurlyBracket],
]);

let TokenStream$3 = class TokenStream {
  constructor(source, tokenize) {
    this.setSource(source, tokenize);
  }
  reset() {
    this.eof = false;
    this.tokenIndex = -1;
    this.tokenType = 0;
    this.tokenStart = this.firstCharOffset;
    this.tokenEnd = this.firstCharOffset;
  }
  setSource(source = "", tokenize = () => {}) {
    source = String(source || "");

    const sourceLength = source.length;
    const offsetAndType = adoptBuffer.adoptBuffer(
      this.offsetAndType,
      source.length + 1,
    ); // +1 because of eof-token
    const balance = adoptBuffer.adoptBuffer(this.balance, source.length + 1);
    let tokenCount = 0;
    let balanceCloseType = 0;
    let balanceStart = 0;
    let firstCharOffset = -1;

    // capture buffers
    this.offsetAndType = null;
    this.balance = null;

    tokenize(source, (type, start, end) => {
      switch (type) {
        default:
          balance[tokenCount] = sourceLength;
          break;

        case balanceCloseType: {
          let balancePrev = balanceStart & OFFSET_MASK;
          balanceStart = balance[balancePrev];
          balanceCloseType = balanceStart >> TYPE_SHIFT;
          balance[tokenCount] = balancePrev;
          balance[balancePrev++] = tokenCount;
          for (; balancePrev < tokenCount; balancePrev++) {
            if (balance[balancePrev] === sourceLength) {
              balance[balancePrev] = tokenCount;
            }
          }
          break;
        }

        case types$T.LeftParenthesis:
        case types$T.Function:
        case types$T.LeftSquareBracket:
        case types$T.LeftCurlyBracket:
          balance[tokenCount] = balanceStart;
          balanceCloseType = balancePair$1.get(type);
          balanceStart = (balanceCloseType << TYPE_SHIFT) | tokenCount;
          break;
      }

      offsetAndType[tokenCount++] = (type << TYPE_SHIFT) | end;
      if (firstCharOffset === -1) {
        firstCharOffset = start;
      }
    });

    // finalize buffers
    offsetAndType[tokenCount] = (types$T.EOF << TYPE_SHIFT) | sourceLength; // <EOF-token>
    balance[tokenCount] = sourceLength;
    balance[sourceLength] = sourceLength; // prevents false positive balance match with any token
    while (balanceStart !== 0) {
      const balancePrev = balanceStart & OFFSET_MASK;
      balanceStart = balance[balancePrev];
      balance[balancePrev] = sourceLength;
    }

    this.source = source;
    this.firstCharOffset = firstCharOffset === -1 ? 0 : firstCharOffset;
    this.tokenCount = tokenCount;
    this.offsetAndType = offsetAndType;
    this.balance = balance;

    this.reset();
    this.next();
  }

  lookupType(offset) {
    offset += this.tokenIndex;

    if (offset < this.tokenCount) {
      return this.offsetAndType[offset] >> TYPE_SHIFT;
    }

    return types$T.EOF;
  }
  lookupOffset(offset) {
    offset += this.tokenIndex;

    if (offset < this.tokenCount) {
      return this.offsetAndType[offset - 1] & OFFSET_MASK;
    }

    return this.source.length;
  }
  lookupValue(offset, referenceStr) {
    offset += this.tokenIndex;

    if (offset < this.tokenCount) {
      return utils$j.cmpStr(
        this.source,
        this.offsetAndType[offset - 1] & OFFSET_MASK,
        this.offsetAndType[offset] & OFFSET_MASK,
        referenceStr,
      );
    }

    return false;
  }
  getTokenStart(tokenIndex) {
    if (tokenIndex === this.tokenIndex) {
      return this.tokenStart;
    }

    if (tokenIndex > 0) {
      return tokenIndex < this.tokenCount
        ? this.offsetAndType[tokenIndex - 1] & OFFSET_MASK
        : this.offsetAndType[this.tokenCount] & OFFSET_MASK;
    }

    return this.firstCharOffset;
  }
  substrToCursor(start) {
    return this.source.substring(start, this.tokenStart);
  }

  isBalanceEdge(pos) {
    return this.balance[this.tokenIndex] < pos;
  }
  isDelim(code, offset) {
    if (offset) {
      return (
        this.lookupType(offset) === types$T.Delim &&
        this.source.charCodeAt(this.lookupOffset(offset)) === code
      );
    }

    return (
      this.tokenType === types$T.Delim &&
      this.source.charCodeAt(this.tokenStart) === code
    );
  }

  skip(tokenCount) {
    let next = this.tokenIndex + tokenCount;

    if (next < this.tokenCount) {
      this.tokenIndex = next;
      this.tokenStart = this.offsetAndType[next - 1] & OFFSET_MASK;
      next = this.offsetAndType[next];
      this.tokenType = next >> TYPE_SHIFT;
      this.tokenEnd = next & OFFSET_MASK;
    } else {
      this.tokenIndex = this.tokenCount;
      this.next();
    }
  }
  next() {
    let next = this.tokenIndex + 1;

    if (next < this.tokenCount) {
      this.tokenIndex = next;
      this.tokenStart = this.tokenEnd;
      next = this.offsetAndType[next];
      this.tokenType = next >> TYPE_SHIFT;
      this.tokenEnd = next & OFFSET_MASK;
    } else {
      this.eof = true;
      this.tokenIndex = this.tokenCount;
      this.tokenType = types$T.EOF;
      this.tokenStart = this.tokenEnd = this.source.length;
    }
  }
  skipSC() {
    while (
      this.tokenType === types$T.WhiteSpace ||
      this.tokenType === types$T.Comment
    ) {
      this.next();
    }
  }
  skipUntilBalanced(startToken, stopConsume) {
    let cursor = startToken;
    let balanceEnd;
    let offset;

    loop: for (; cursor < this.tokenCount; cursor++) {
      balanceEnd = this.balance[cursor];

      // stop scanning on balance edge that points to offset before start token
      if (balanceEnd < startToken) {
        break loop;
      }

      offset =
        cursor > 0
          ? this.offsetAndType[cursor - 1] & OFFSET_MASK
          : this.firstCharOffset;

      // check stop condition
      switch (stopConsume(this.source.charCodeAt(offset))) {
        case 1: // just stop
          break loop;

        case 2: // stop & included
          cursor++;
          break loop;

        default:
          // fast forward to the end of balanced block
          if (this.balance[balanceEnd] === cursor) {
            cursor = balanceEnd;
          }
      }
    }

    this.skip(cursor - this.tokenIndex);
  }

  forEachToken(fn) {
    for (let i = 0, offset = this.firstCharOffset; i < this.tokenCount; i++) {
      const start = offset;
      const item = this.offsetAndType[i];
      const end = item & OFFSET_MASK;
      const type = item >> TYPE_SHIFT;

      offset = end;

      fn(type, start, end, i);
    }
  }
  dump() {
    const tokens = new Array(this.tokenCount);

    this.forEachToken((type, start, end, index) => {
      tokens[index] = {
        idx: index,
        type: names$7[type],
        chunk: this.source.substring(start, end),
        balance: this.balance[index],
      };
    });

    return tokens;
  }
};

TokenStream$4.TokenStream = TokenStream$3;

const types$S = types$U;
const charCodeDefinitions$9 = charCodeDefinitions$c;
const utils$i = utils$k;
const names$6 = names$8;
const OffsetToLocation$1 = OffsetToLocation$3;
const TokenStream$2 = TokenStream$4;

function tokenize$2(source, onToken) {
  function getCharCode(offset) {
    return offset < sourceLength ? source.charCodeAt(offset) : 0;
  }

  //  4.3.3. Consume a numeric token
  function consumeNumericToken() {
    // Consume a number and let number be the result.
    offset = utils$i.consumeNumber(source, offset);

    // If the next 3 input code points would start an identifier, then:
    if (
      charCodeDefinitions$9.isIdentifierStart(
        getCharCode(offset),
        getCharCode(offset + 1),
        getCharCode(offset + 2),
      )
    ) {
      // Create a <dimension-token> with the same value and type flag as number, and a unit set initially to the empty string.
      // Consume a name. Set the <dimension-token>s unit to the returned value.
      // Return the <dimension-token>.
      type = types$S.Dimension;
      offset = utils$i.consumeName(source, offset);
      return;
    }

    // Otherwise, if the next input code point is U+0025 PERCENTAGE SIGN (%), consume it.
    if (getCharCode(offset) === 0x0025) {
      // Create a <percentage-token> with the same value as number, and return it.
      type = types$S.Percentage;
      offset++;
      return;
    }

    // Otherwise, create a <number-token> with the same value and type flag as number, and return it.
    type = types$S.Number;
  }

  //  4.3.4. Consume an ident-like token
  function consumeIdentLikeToken() {
    const nameStartOffset = offset;

    // Consume a name, and let string be the result.
    offset = utils$i.consumeName(source, offset);

    // If strings value is an ASCII case-insensitive match for "url",
    // and the next input code point is U+0028 LEFT PARENTHESIS ((), consume it.
    if (
      utils$i.cmpStr(source, nameStartOffset, offset, "url") &&
      getCharCode(offset) === 0x0028
    ) {
      // While the next two input code points are whitespace, consume the next input code point.
      offset = utils$i.findWhiteSpaceEnd(source, offset + 1);

      // If the next one or two input code points are U+0022 QUOTATION MARK ("), U+0027 APOSTROPHE ('),
      // or whitespace followed by U+0022 QUOTATION MARK (") or U+0027 APOSTROPHE ('),
      // then create a <function-token> with its value set to string and return it.
      if (getCharCode(offset) === 0x0022 || getCharCode(offset) === 0x0027) {
        type = types$S.Function;
        offset = nameStartOffset + 4;
        return;
      }

      // Otherwise, consume a url token, and return it.
      consumeUrlToken();
      return;
    }

    // Otherwise, if the next input code point is U+0028 LEFT PARENTHESIS ((), consume it.
    // Create a <function-token> with its value set to string and return it.
    if (getCharCode(offset) === 0x0028) {
      type = types$S.Function;
      offset++;
      return;
    }

    // Otherwise, create an <ident-token> with its value set to string and return it.
    type = types$S.Ident;
  }

  //  4.3.5. Consume a string token
  function consumeStringToken(endingCodePoint) {
    // This algorithm may be called with an ending code point, which denotes the code point
    // that ends the string. If an ending code point is not specified,
    // the current input code point is used.
    if (!endingCodePoint) {
      endingCodePoint = getCharCode(offset++);
    }

    // Initially create a <string-token> with its value set to the empty string.
    type = types$S.String;

    // Repeatedly consume the next input code point from the stream:
    for (; offset < source.length; offset++) {
      const code = source.charCodeAt(offset);

      switch (charCodeDefinitions$9.charCodeCategory(code)) {
        // ending code point
        case endingCodePoint:
          // Return the <string-token>.
          offset++;
          return;

        // EOF
        // case EofCategory:
        // This is a parse error. Return the <string-token>.
        // return;

        // newline
        case charCodeDefinitions$9.WhiteSpaceCategory:
          if (charCodeDefinitions$9.isNewline(code)) {
            // This is a parse error. Reconsume the current input code point,
            // create a <bad-string-token>, and return it.
            offset += utils$i.getNewlineLength(source, offset, code);
            type = types$S.BadString;
            return;
          }
          break;

        // U+005C REVERSE SOLIDUS (\)
        case 0x005c:
          // If the next input code point is EOF, do nothing.
          if (offset === source.length - 1) {
            break;
          }

          const nextCode = getCharCode(offset + 1);

          // Otherwise, if the next input code point is a newline, consume it.
          if (charCodeDefinitions$9.isNewline(nextCode)) {
            offset += utils$i.getNewlineLength(source, offset + 1, nextCode);
          } else if (charCodeDefinitions$9.isValidEscape(code, nextCode)) {
            // Otherwise, (the stream starts with a valid escape) consume
            // an escaped code point and append the returned code point to
            // the <string-token>s value.
            offset = utils$i.consumeEscaped(source, offset) - 1;
          }
          break;

        // anything else
        // Append the current input code point to the <string-token>s value.
      }
    }
  }

  //  4.3.6. Consume a url token
  // Note: This algorithm assumes that the initial "url(" has already been consumed.
  // This algorithm also assumes that its being called to consume an "unquoted" value, like url(foo).
  // A quoted value, like url("foo"), is parsed as a <function-token>. Consume an ident-like token
  // automatically handles this distinction; this algorithm shouldnt be called directly otherwise.
  function consumeUrlToken() {
    // Initially create a <url-token> with its value set to the empty string.
    type = types$S.Url;

    // Consume as much whitespace as possible.
    offset = utils$i.findWhiteSpaceEnd(source, offset);

    // Repeatedly consume the next input code point from the stream:
    for (; offset < source.length; offset++) {
      const code = source.charCodeAt(offset);

      switch (charCodeDefinitions$9.charCodeCategory(code)) {
        // U+0029 RIGHT PARENTHESIS ())
        case 0x0029:
          // Return the <url-token>.
          offset++;
          return;

        // EOF
        // case EofCategory:
        // This is a parse error. Return the <url-token>.
        // return;

        // whitespace
        case charCodeDefinitions$9.WhiteSpaceCategory:
          // Consume as much whitespace as possible.
          offset = utils$i.findWhiteSpaceEnd(source, offset);

          // If the next input code point is U+0029 RIGHT PARENTHESIS ()) or EOF,
          // consume it and return the <url-token>
          // (if EOF was encountered, this is a parse error);
          if (getCharCode(offset) === 0x0029 || offset >= source.length) {
            if (offset < source.length) {
              offset++;
            }
            return;
          }

          // otherwise, consume the remnants of a bad url, create a <bad-url-token>,
          // and return it.
          offset = utils$i.consumeBadUrlRemnants(source, offset);
          type = types$S.BadUrl;
          return;

        // U+0022 QUOTATION MARK (")
        // U+0027 APOSTROPHE (')
        // U+0028 LEFT PARENTHESIS (()
        // non-printable code point
        case 0x0022:
        case 0x0027:
        case 0x0028:
        case charCodeDefinitions$9.NonPrintableCategory:
          // This is a parse error. Consume the remnants of a bad url,
          // create a <bad-url-token>, and return it.
          offset = utils$i.consumeBadUrlRemnants(source, offset);
          type = types$S.BadUrl;
          return;

        // U+005C REVERSE SOLIDUS (\)
        case 0x005c:
          // If the stream starts with a valid escape, consume an escaped code point and
          // append the returned code point to the <url-token>s value.
          if (
            charCodeDefinitions$9.isValidEscape(code, getCharCode(offset + 1))
          ) {
            offset = utils$i.consumeEscaped(source, offset) - 1;
            break;
          }

          // Otherwise, this is a parse error. Consume the remnants of a bad url,
          // create a <bad-url-token>, and return it.
          offset = utils$i.consumeBadUrlRemnants(source, offset);
          type = types$S.BadUrl;
          return;

        // anything else
        // Append the current input code point to the <url-token>s value.
      }
    }
  }

  // ensure source is a string
  source = String(source || "");

  const sourceLength = source.length;
  let start = charCodeDefinitions$9.isBOM(getCharCode(0));
  let offset = start;
  let type;

  // https://drafts.csswg.org/css-syntax-3/#consume-token
  //  4.3.1. Consume a token
  while (offset < sourceLength) {
    const code = source.charCodeAt(offset);

    switch (charCodeDefinitions$9.charCodeCategory(code)) {
      // whitespace
      case charCodeDefinitions$9.WhiteSpaceCategory:
        // Consume as much whitespace as possible. Return a <whitespace-token>.
        type = types$S.WhiteSpace;
        offset = utils$i.findWhiteSpaceEnd(source, offset + 1);
        break;

      // U+0022 QUOTATION MARK (")
      case 0x0022:
        // Consume a string token and return it.
        consumeStringToken();
        break;

      // U+0023 NUMBER SIGN (#)
      case 0x0023:
        // If the next input code point is a name code point or the next two input code points are a valid escape, then:
        if (
          charCodeDefinitions$9.isName(getCharCode(offset + 1)) ||
          charCodeDefinitions$9.isValidEscape(
            getCharCode(offset + 1),
            getCharCode(offset + 2),
          )
        ) {
          // Create a <hash-token>.
          type = types$S.Hash;

          // If the next 3 input code points would start an identifier, set the <hash-token>s type flag to "id".
          // if (isIdentifierStart(getCharCode(offset + 1), getCharCode(offset + 2), getCharCode(offset + 3))) {
          //     // TODO: set id flag
          // }

          // Consume a name, and set the <hash-token>s value to the returned string.
          offset = utils$i.consumeName(source, offset + 1);

          // Return the <hash-token>.
        } else {
          // Otherwise, return a <delim-token> with its value set to the current input code point.
          type = types$S.Delim;
          offset++;
        }

        break;

      // U+0027 APOSTROPHE (')
      case 0x0027:
        // Consume a string token and return it.
        consumeStringToken();
        break;

      // U+0028 LEFT PARENTHESIS (()
      case 0x0028:
        // Return a <(-token>.
        type = types$S.LeftParenthesis;
        offset++;
        break;

      // U+0029 RIGHT PARENTHESIS ())
      case 0x0029:
        // Return a <)-token>.
        type = types$S.RightParenthesis;
        offset++;
        break;

      // U+002B PLUS SIGN (+)
      case 0x002b:
        // If the input stream starts with a number, ...
        if (
          charCodeDefinitions$9.isNumberStart(
            code,
            getCharCode(offset + 1),
            getCharCode(offset + 2),
          )
        ) {
          // ... reconsume the current input code point, consume a numeric token, and return it.
          consumeNumericToken();
        } else {
          // Otherwise, return a <delim-token> with its value set to the current input code point.
          type = types$S.Delim;
          offset++;
        }
        break;

      // U+002C COMMA (,)
      case 0x002c:
        // Return a <comma-token>.
        type = types$S.Comma;
        offset++;
        break;

      // U+002D HYPHEN-MINUS (-)
      case 0x002d:
        // If the input stream starts with a number, reconsume the current input code point, consume a numeric token, and return it.
        if (
          charCodeDefinitions$9.isNumberStart(
            code,
            getCharCode(offset + 1),
            getCharCode(offset + 2),
          )
        ) {
          consumeNumericToken();
        } else {
          // Otherwise, if the next 2 input code points are U+002D HYPHEN-MINUS U+003E GREATER-THAN SIGN (->), consume them and return a <CDC-token>.
          if (
            getCharCode(offset + 1) === 0x002d &&
            getCharCode(offset + 2) === 0x003e
          ) {
            type = types$S.CDC;
            offset = offset + 3;
          } else {
            // Otherwise, if the input stream starts with an identifier, ...
            if (
              charCodeDefinitions$9.isIdentifierStart(
                code,
                getCharCode(offset + 1),
                getCharCode(offset + 2),
              )
            ) {
              // ... reconsume the current input code point, consume an ident-like token, and return it.
              consumeIdentLikeToken();
            } else {
              // Otherwise, return a <delim-token> with its value set to the current input code point.
              type = types$S.Delim;
              offset++;
            }
          }
        }
        break;

      // U+002E FULL STOP (.)
      case 0x002e:
        // If the input stream starts with a number, ...
        if (
          charCodeDefinitions$9.isNumberStart(
            code,
            getCharCode(offset + 1),
            getCharCode(offset + 2),
          )
        ) {
          // ... reconsume the current input code point, consume a numeric token, and return it.
          consumeNumericToken();
        } else {
          // Otherwise, return a <delim-token> with its value set to the current input code point.
          type = types$S.Delim;
          offset++;
        }

        break;

      // U+002F SOLIDUS (/)
      case 0x002f:
        // If the next two input code point are U+002F SOLIDUS (/) followed by a U+002A ASTERISK (*),
        if (getCharCode(offset + 1) === 0x002a) {
          // ... consume them and all following code points up to and including the first U+002A ASTERISK (*)
          // followed by a U+002F SOLIDUS (/), or up to an EOF code point.
          type = types$S.Comment;
          offset = source.indexOf("*/", offset + 2);
          offset = offset === -1 ? source.length : offset + 2;
        } else {
          type = types$S.Delim;
          offset++;
        }
        break;

      // U+003A COLON (:)
      case 0x003a:
        // Return a <colon-token>.
        type = types$S.Colon;
        offset++;
        break;

      // U+003B SEMICOLON (;)
      case 0x003b:
        // Return a <semicolon-token>.
        type = types$S.Semicolon;
        offset++;
        break;

      // U+003C LESS-THAN SIGN (<)
      case 0x003c:
        // If the next 3 input code points are U+0021 EXCLAMATION MARK U+002D HYPHEN-MINUS U+002D HYPHEN-MINUS (!--), ...
        if (
          getCharCode(offset + 1) === 0x0021 &&
          getCharCode(offset + 2) === 0x002d &&
          getCharCode(offset + 3) === 0x002d
        ) {
          // ... consume them and return a <CDO-token>.
          type = types$S.CDO;
          offset = offset + 4;
        } else {
          // Otherwise, return a <delim-token> with its value set to the current input code point.
          type = types$S.Delim;
          offset++;
        }

        break;

      // U+0040 COMMERCIAL AT (@)
      case 0x0040:
        // If the next 3 input code points would start an identifier, ...
        if (
          charCodeDefinitions$9.isIdentifierStart(
            getCharCode(offset + 1),
            getCharCode(offset + 2),
            getCharCode(offset + 3),
          )
        ) {
          // ... consume a name, create an <at-keyword-token> with its value set to the returned value, and return it.
          type = types$S.AtKeyword;
          offset = utils$i.consumeName(source, offset + 1);
        } else {
          // Otherwise, return a <delim-token> with its value set to the current input code point.
          type = types$S.Delim;
          offset++;
        }

        break;

      // U+005B LEFT SQUARE BRACKET ([)
      case 0x005b:
        // Return a <[-token>.
        type = types$S.LeftSquareBracket;
        offset++;
        break;

      // U+005C REVERSE SOLIDUS (\)
      case 0x005c:
        // If the input stream starts with a valid escape, ...
        if (
          charCodeDefinitions$9.isValidEscape(code, getCharCode(offset + 1))
        ) {
          // ... reconsume the current input code point, consume an ident-like token, and return it.
          consumeIdentLikeToken();
        } else {
          // Otherwise, this is a parse error. Return a <delim-token> with its value set to the current input code point.
          type = types$S.Delim;
          offset++;
        }
        break;

      // U+005D RIGHT SQUARE BRACKET (])
      case 0x005d:
        // Return a <]-token>.
        type = types$S.RightSquareBracket;
        offset++;
        break;

      // U+007B LEFT CURLY BRACKET ({)
      case 0x007b:
        // Return a <{-token>.
        type = types$S.LeftCurlyBracket;
        offset++;
        break;

      // U+007D RIGHT CURLY BRACKET (})
      case 0x007d:
        // Return a <}-token>.
        type = types$S.RightCurlyBracket;
        offset++;
        break;

      // digit
      case charCodeDefinitions$9.DigitCategory:
        // Reconsume the current input code point, consume a numeric token, and return it.
        consumeNumericToken();
        break;

      // name-start code point
      case charCodeDefinitions$9.NameStartCategory:
        // Reconsume the current input code point, consume an ident-like token, and return it.
        consumeIdentLikeToken();
        break;

      // EOF
      // case EofCategory:
      // Return an <EOF-token>.
      // break;

      // anything else
      default:
        // Return a <delim-token> with its value set to the current input code point.
        type = types$S.Delim;
        offset++;
    }

    // put token to stream
    onToken(type, start, (start = offset));
  }
}

tokenizer$2.AtKeyword = types$S.AtKeyword;
tokenizer$2.BadString = types$S.BadString;
tokenizer$2.BadUrl = types$S.BadUrl;
tokenizer$2.CDC = types$S.CDC;
tokenizer$2.CDO = types$S.CDO;
tokenizer$2.Colon = types$S.Colon;
tokenizer$2.Comma = types$S.Comma;
tokenizer$2.Comment = types$S.Comment;
tokenizer$2.Delim = types$S.Delim;
tokenizer$2.Dimension = types$S.Dimension;
tokenizer$2.EOF = types$S.EOF;
tokenizer$2.Function = types$S.Function;
tokenizer$2.Hash = types$S.Hash;
tokenizer$2.Ident = types$S.Ident;
tokenizer$2.LeftCurlyBracket = types$S.LeftCurlyBracket;
tokenizer$2.LeftParenthesis = types$S.LeftParenthesis;
tokenizer$2.LeftSquareBracket = types$S.LeftSquareBracket;
tokenizer$2.Number = types$S.Number;
tokenizer$2.Percentage = types$S.Percentage;
tokenizer$2.RightCurlyBracket = types$S.RightCurlyBracket;
tokenizer$2.RightParenthesis = types$S.RightParenthesis;
tokenizer$2.RightSquareBracket = types$S.RightSquareBracket;
tokenizer$2.Semicolon = types$S.Semicolon;
tokenizer$2.String = types$S.String;
tokenizer$2.Url = types$S.Url;
tokenizer$2.WhiteSpace = types$S.WhiteSpace;
tokenizer$2.tokenTypes = types$S;
tokenizer$2.DigitCategory = charCodeDefinitions$9.DigitCategory;
tokenizer$2.EofCategory = charCodeDefinitions$9.EofCategory;
tokenizer$2.NameStartCategory = charCodeDefinitions$9.NameStartCategory;
tokenizer$2.NonPrintableCategory = charCodeDefinitions$9.NonPrintableCategory;
tokenizer$2.WhiteSpaceCategory = charCodeDefinitions$9.WhiteSpaceCategory;
tokenizer$2.charCodeCategory = charCodeDefinitions$9.charCodeCategory;
tokenizer$2.isBOM = charCodeDefinitions$9.isBOM;
tokenizer$2.isDigit = charCodeDefinitions$9.isDigit;
tokenizer$2.isHexDigit = charCodeDefinitions$9.isHexDigit;
tokenizer$2.isIdentifierStart = charCodeDefinitions$9.isIdentifierStart;
tokenizer$2.isLetter = charCodeDefinitions$9.isLetter;
tokenizer$2.isLowercaseLetter = charCodeDefinitions$9.isLowercaseLetter;
tokenizer$2.isName = charCodeDefinitions$9.isName;
tokenizer$2.isNameStart = charCodeDefinitions$9.isNameStart;
tokenizer$2.isNewline = charCodeDefinitions$9.isNewline;
tokenizer$2.isNonAscii = charCodeDefinitions$9.isNonAscii;
tokenizer$2.isNonPrintable = charCodeDefinitions$9.isNonPrintable;
tokenizer$2.isNumberStart = charCodeDefinitions$9.isNumberStart;
tokenizer$2.isUppercaseLetter = charCodeDefinitions$9.isUppercaseLetter;
tokenizer$2.isValidEscape = charCodeDefinitions$9.isValidEscape;
tokenizer$2.isWhiteSpace = charCodeDefinitions$9.isWhiteSpace;
tokenizer$2.cmpChar = utils$i.cmpChar;
tokenizer$2.cmpStr = utils$i.cmpStr;
tokenizer$2.consumeBadUrlRemnants = utils$i.consumeBadUrlRemnants;
tokenizer$2.consumeEscaped = utils$i.consumeEscaped;
tokenizer$2.consumeName = utils$i.consumeName;
tokenizer$2.consumeNumber = utils$i.consumeNumber;
tokenizer$2.decodeEscaped = utils$i.decodeEscaped;
tokenizer$2.findDecimalNumberEnd = utils$i.findDecimalNumberEnd;
tokenizer$2.findWhiteSpaceEnd = utils$i.findWhiteSpaceEnd;
tokenizer$2.findWhiteSpaceStart = utils$i.findWhiteSpaceStart;
tokenizer$2.getNewlineLength = utils$i.getNewlineLength;
tokenizer$2.tokenNames = names$6;
tokenizer$2.OffsetToLocation = OffsetToLocation$1.OffsetToLocation;
tokenizer$2.TokenStream = TokenStream$2.TokenStream;
tokenizer$2.tokenize = tokenize$2;

var create$7 = {};

var List$7 = {};

//
//                              list
//                            
//             head 
//                            tail
//                                         
//                                                 
//            item        item        item        item
//                      
//  null prev prev prev prev 
//           next next next next null
//                      
//           data      data      data      data 
//                      
//

let releasedCursors = null;

let List$6 = class List {
  static createItem(data) {
    return {
      prev: null,
      next: null,
      data,
    };
  }

  constructor() {
    this.head = null;
    this.tail = null;
    this.cursor = null;
  }
  createItem(data) {
    return List.createItem(data);
  }

  // cursor helpers
  allocateCursor(prev, next) {
    let cursor;

    if (releasedCursors !== null) {
      cursor = releasedCursors;
      releasedCursors = releasedCursors.cursor;
      cursor.prev = prev;
      cursor.next = next;
      cursor.cursor = this.cursor;
    } else {
      cursor = {
        prev,
        next,
        cursor: this.cursor,
      };
    }

    this.cursor = cursor;

    return cursor;
  }
  releaseCursor() {
    const { cursor } = this;

    this.cursor = cursor.cursor;
    cursor.prev = null;
    cursor.next = null;
    cursor.cursor = releasedCursors;
    releasedCursors = cursor;
  }
  updateCursors(prevOld, prevNew, nextOld, nextNew) {
    let { cursor } = this;

    while (cursor !== null) {
      if (cursor.prev === prevOld) {
        cursor.prev = prevNew;
      }

      if (cursor.next === nextOld) {
        cursor.next = nextNew;
      }

      cursor = cursor.cursor;
    }
  }
  *[Symbol.iterator]() {
    for (let cursor = this.head; cursor !== null; cursor = cursor.next) {
      yield cursor.data;
    }
  }

  // getters
  get size() {
    let size = 0;

    for (let cursor = this.head; cursor !== null; cursor = cursor.next) {
      size++;
    }

    return size;
  }
  get isEmpty() {
    return this.head === null;
  }
  get first() {
    return this.head && this.head.data;
  }
  get last() {
    return this.tail && this.tail.data;
  }

  // convertors
  fromArray(array) {
    let cursor = null;
    this.head = null;

    for (let data of array) {
      const item = List.createItem(data);

      if (cursor !== null) {
        cursor.next = item;
      } else {
        this.head = item;
      }

      item.prev = cursor;
      cursor = item;
    }

    this.tail = cursor;
    return this;
  }
  toArray() {
    return [...this];
  }
  toJSON() {
    return [...this];
  }

  // array-like methods
  forEach(fn, thisArg = this) {
    // push cursor
    const cursor = this.allocateCursor(null, this.head);

    while (cursor.next !== null) {
      const item = cursor.next;
      cursor.next = item.next;
      fn.call(thisArg, item.data, item, this);
    }

    // pop cursor
    this.releaseCursor();
  }
  forEachRight(fn, thisArg = this) {
    // push cursor
    const cursor = this.allocateCursor(this.tail, null);

    while (cursor.prev !== null) {
      const item = cursor.prev;
      cursor.prev = item.prev;
      fn.call(thisArg, item.data, item, this);
    }

    // pop cursor
    this.releaseCursor();
  }
  reduce(fn, initialValue, thisArg = this) {
    // push cursor
    let cursor = this.allocateCursor(null, this.head);
    let acc = initialValue;
    let item;

    while (cursor.next !== null) {
      item = cursor.next;
      cursor.next = item.next;

      acc = fn.call(thisArg, acc, item.data, item, this);
    }

    // pop cursor
    this.releaseCursor();

    return acc;
  }
  reduceRight(fn, initialValue, thisArg = this) {
    // push cursor
    let cursor = this.allocateCursor(this.tail, null);
    let acc = initialValue;
    let item;

    while (cursor.prev !== null) {
      item = cursor.prev;
      cursor.prev = item.prev;

      acc = fn.call(thisArg, acc, item.data, item, this);
    }

    // pop cursor
    this.releaseCursor();

    return acc;
  }
  some(fn, thisArg = this) {
    for (let cursor = this.head; cursor !== null; cursor = cursor.next) {
      if (fn.call(thisArg, cursor.data, cursor, this)) {
        return true;
      }
    }

    return false;
  }
  map(fn, thisArg = this) {
    const result = new List();

    for (let cursor = this.head; cursor !== null; cursor = cursor.next) {
      result.appendData(fn.call(thisArg, cursor.data, cursor, this));
    }

    return result;
  }
  filter(fn, thisArg = this) {
    const result = new List();

    for (let cursor = this.head; cursor !== null; cursor = cursor.next) {
      if (fn.call(thisArg, cursor.data, cursor, this)) {
        result.appendData(cursor.data);
      }
    }

    return result;
  }

  nextUntil(start, fn, thisArg = this) {
    if (start === null) {
      return;
    }

    // push cursor
    const cursor = this.allocateCursor(null, start);

    while (cursor.next !== null) {
      const item = cursor.next;
      cursor.next = item.next;
      if (fn.call(thisArg, item.data, item, this)) {
        break;
      }
    }

    // pop cursor
    this.releaseCursor();
  }
  prevUntil(start, fn, thisArg = this) {
    if (start === null) {
      return;
    }

    // push cursor
    const cursor = this.allocateCursor(start, null);

    while (cursor.prev !== null) {
      const item = cursor.prev;
      cursor.prev = item.prev;
      if (fn.call(thisArg, item.data, item, this)) {
        break;
      }
    }

    // pop cursor
    this.releaseCursor();
  }

  // mutation
  clear() {
    this.head = null;
    this.tail = null;
  }
  copy() {
    const result = new List();

    for (let data of this) {
      result.appendData(data);
    }

    return result;
  }
  prepend(item) {
    //      head
    //    ^
    // item
    this.updateCursors(null, item, this.head, item);

    // insert to the beginning of the list
    if (this.head !== null) {
      // new item <- first item
      this.head.prev = item;
      // new item -> first item
      item.next = this.head;
    } else {
      // if list has no head, then it also has no tail
      // in this case tail points to the new item
      this.tail = item;
    }

    // head always points to new item
    this.head = item;
    return this;
  }
  prependData(data) {
    return this.prepend(List.createItem(data));
  }
  append(item) {
    return this.insert(item);
  }
  appendData(data) {
    return this.insert(List.createItem(data));
  }
  insert(item, before = null) {
    if (before !== null) {
      // prev   before
      //      ^
      //     item
      this.updateCursors(before.prev, item, before, item);

      if (before.prev === null) {
        // insert to the beginning of list
        if (this.head !== before) {
          throw new Error("before doesn't belong to list");
        }
        // since head points to before therefore list doesn't empty
        // no need to check tail
        this.head = item;
        before.prev = item;
        item.next = before;
        this.updateCursors(null, item);
      } else {
        // insert between two items
        before.prev.next = item;
        item.prev = before.prev;
        before.prev = item;
        item.next = before;
      }
    } else {
      // tail
      //      ^
      //      item
      this.updateCursors(this.tail, item, null, item);

      // insert to the ending of the list
      if (this.tail !== null) {
        // last item -> new item
        this.tail.next = item;
        // last item <- new item
        item.prev = this.tail;
      } else {
        // if list has no tail, then it also has no head
        // in this case head points to new item
        this.head = item;
      }

      // tail always points to new item
      this.tail = item;
    }

    return this;
  }
  insertData(data, before) {
    return this.insert(List.createItem(data), before);
  }
  remove(item) {
    //      item
    //       ^
    // prev     next
    this.updateCursors(item, item.prev, item, item.next);

    if (item.prev !== null) {
      item.prev.next = item.next;
    } else {
      if (this.head !== item) {
        throw new Error("item doesn't belong to list");
      }

      this.head = item.next;
    }

    if (item.next !== null) {
      item.next.prev = item.prev;
    } else {
      if (this.tail !== item) {
        throw new Error("item doesn't belong to list");
      }

      this.tail = item.prev;
    }

    item.prev = null;
    item.next = null;

    return item;
  }
  push(data) {
    this.insert(List.createItem(data));
  }
  pop() {
    return this.tail !== null ? this.remove(this.tail) : null;
  }
  unshift(data) {
    this.prepend(List.createItem(data));
  }
  shift() {
    return this.head !== null ? this.remove(this.head) : null;
  }
  prependList(list) {
    return this.insertList(list, this.head);
  }
  appendList(list) {
    return this.insertList(list);
  }
  insertList(list, before) {
    // ignore empty lists
    if (list.head === null) {
      return this;
    }

    if (before !== undefined && before !== null) {
      this.updateCursors(before.prev, list.tail, before, list.head);

      // insert in the middle of dist list
      if (before.prev !== null) {
        // before.prev <-> list.head
        before.prev.next = list.head;
        list.head.prev = before.prev;
      } else {
        this.head = list.head;
      }

      before.prev = list.tail;
      list.tail.next = before;
    } else {
      this.updateCursors(this.tail, list.tail, null, list.head);

      // insert to end of the list
      if (this.tail !== null) {
        // if destination list has a tail, then it also has a head,
        // but head doesn't change
        // dest tail -> source head
        this.tail.next = list.head;
        // dest tail <- source head
        list.head.prev = this.tail;
      } else {
        // if list has no a tail, then it also has no a head
        // in this case points head to new item
        this.head = list.head;
      }

      // tail always start point to new item
      this.tail = list.tail;
    }

    list.head = null;
    list.tail = null;
    return this;
  }
  replace(oldItem, newItemOrList) {
    if ("head" in newItemOrList) {
      this.insertList(newItemOrList, oldItem);
    } else {
      this.insert(newItemOrList, oldItem);
    }

    this.remove(oldItem);
  }
};

List$7.List = List$6;

var _SyntaxError$1 = {};

var createCustomError$4 = {};

function createCustomError$3(name, message) {
  // use Object.create(), because some VMs prevent setting line/column otherwise
  // (iOS Safari 10 even throws an exception)
  const error = Object.create(SyntaxError.prototype);
  const errorStack = new Error();

  return Object.assign(error, {
    name,
    message,
    get stack() {
      return (errorStack.stack || "").replace(
        /^(.+\n){1,3}/,
        `${name}: ${message}\n`,
      );
    },
  });
}

createCustomError$4.createCustomError = createCustomError$3;

const createCustomError$2 = createCustomError$4;

const MAX_LINE_LENGTH = 100;
const OFFSET_CORRECTION = 60;
const TAB_REPLACEMENT = "    ";

function sourceFragment({ source, line, column }, extraLines) {
  function processLines(start, end) {
    return lines
      .slice(start, end)
      .map(
        (line, idx) =>
          String(start + idx + 1).padStart(maxNumLength) + " |" + line,
      )
      .join("\n");
  }

  const lines = source.split(/\r\n?|\n|\f/);
  const startLine = Math.max(1, line - extraLines) - 1;
  const endLine = Math.min(line + extraLines, lines.length + 1);
  const maxNumLength = Math.max(4, String(endLine).length) + 1;
  let cutLeft = 0;

  // column correction according to replaced tab before column
  column +=
    (TAB_REPLACEMENT.length - 1) *
    (lines[line - 1].substr(0, column - 1).match(/\t/g) || []).length;

  if (column > MAX_LINE_LENGTH) {
    cutLeft = column - OFFSET_CORRECTION + 3;
    column = OFFSET_CORRECTION - 2;
  }

  for (let i = startLine; i <= endLine; i++) {
    if (i >= 0 && i < lines.length) {
      lines[i] = lines[i].replace(/\t/g, TAB_REPLACEMENT);
      lines[i] =
        (cutLeft > 0 && lines[i].length > cutLeft ? "\u2026" : "") +
        lines[i].substr(cutLeft, MAX_LINE_LENGTH - 2) +
        (lines[i].length > cutLeft + MAX_LINE_LENGTH - 1 ? "\u2026" : "");
    }
  }

  return [
    processLines(startLine, line),
    new Array(column + maxNumLength + 2).join("-") + "^",
    processLines(line, endLine),
  ]
    .filter(Boolean)
    .join("\n");
}

function SyntaxError$5(message, source, offset, line, column) {
  const error = Object.assign(
    createCustomError$2.createCustomError("SyntaxError", message),
    {
      source,
      offset,
      line,
      column,
      sourceFragment(extraLines) {
        return sourceFragment(
          { source, line, column },
          isNaN(extraLines) ? 0 : extraLines,
        );
      },
      get formattedMessage() {
        return (
          `Parse error: ${message}\n` +
          sourceFragment({ source, line, column }, 2)
        );
      },
    },
  );

  return error;
}

_SyntaxError$1.SyntaxError = SyntaxError$5;

var sequence$1 = {};

const types$R = types$U;

function readSequence$1(recognizer) {
  const children = this.createList();
  let space = false;
  const context = {
    recognizer,
  };

  while (!this.eof) {
    switch (this.tokenType) {
      case types$R.Comment:
        this.next();
        continue;

      case types$R.WhiteSpace:
        space = true;
        this.next();
        continue;
    }

    let child = recognizer.getNode.call(this, context);

    if (child === undefined) {
      break;
    }

    if (space) {
      if (recognizer.onWhiteSpace) {
        recognizer.onWhiteSpace.call(this, child, children, context);
      }
      space = false;
    }

    children.push(child);
  }

  if (space && recognizer.onWhiteSpace) {
    recognizer.onWhiteSpace.call(this, null, children, context);
  }

  return children;
}

sequence$1.readSequence = readSequence$1;

const List$5 = List$7;
const SyntaxError$4 = _SyntaxError$1;
const index$b = tokenizer$2;
const sequence = sequence$1;
const OffsetToLocation = OffsetToLocation$3;
const TokenStream$1 = TokenStream$4;
const utils$h = utils$k;
const types$Q = types$U;
const names$5 = names$8;

const NOOP = () => {};
const EXCLAMATIONMARK$3 = 0x0021; // U+0021 EXCLAMATION MARK (!)
const NUMBERSIGN$4 = 0x0023; // U+0023 NUMBER SIGN (#)
const SEMICOLON = 0x003b; // U+003B SEMICOLON (;)
const LEFTCURLYBRACKET$1 = 0x007b; // U+007B LEFT CURLY BRACKET ({)
const NULL = 0;

function createParseContext(name) {
  return function () {
    return this[name]();
  };
}

function fetchParseValues(dict) {
  const result = Object.create(null);

  for (const name in dict) {
    const item = dict[name];
    const fn = item.parse || item;

    if (fn) {
      result[name] = fn;
    }
  }

  return result;
}

function processConfig(config) {
  const parseConfig = {
    context: Object.create(null),
    scope: Object.assign(Object.create(null), config.scope),
    atrule: fetchParseValues(config.atrule),
    pseudo: fetchParseValues(config.pseudo),
    node: fetchParseValues(config.node),
  };

  for (const name in config.parseContext) {
    switch (typeof config.parseContext[name]) {
      case "function":
        parseConfig.context[name] = config.parseContext[name];
        break;

      case "string":
        parseConfig.context[name] = createParseContext(
          config.parseContext[name],
        );
        break;
    }
  }

  return {
    config: parseConfig,
    ...parseConfig,
    ...parseConfig.node,
  };
}

function createParser(config) {
  let source = "";
  let filename = "<unknown>";
  let needPositions = false;
  let onParseError = NOOP;
  let onParseErrorThrow = false;

  const locationMap = new OffsetToLocation.OffsetToLocation();
  const parser = Object.assign(
    new TokenStream$1.TokenStream(),
    processConfig(config || {}),
    {
      parseAtrulePrelude: true,
      parseRulePrelude: true,
      parseValue: true,
      parseCustomProperty: false,

      readSequence: sequence.readSequence,

      consumeUntilBalanceEnd: () => 0,
      consumeUntilLeftCurlyBracket(code) {
        return code === LEFTCURLYBRACKET$1 ? 1 : 0;
      },
      consumeUntilLeftCurlyBracketOrSemicolon(code) {
        return code === LEFTCURLYBRACKET$1 || code === SEMICOLON ? 1 : 0;
      },
      consumeUntilExclamationMarkOrSemicolon(code) {
        return code === EXCLAMATIONMARK$3 || code === SEMICOLON ? 1 : 0;
      },
      consumeUntilSemicolonIncluded(code) {
        return code === SEMICOLON ? 2 : 0;
      },

      createList() {
        return new List$5.List();
      },
      createSingleNodeList(node) {
        return new List$5.List().appendData(node);
      },
      getFirstListNode(list) {
        return list && list.first;
      },
      getLastListNode(list) {
        return list && list.last;
      },

      parseWithFallback(consumer, fallback) {
        const startToken = this.tokenIndex;

        try {
          return consumer.call(this);
        } catch (e) {
          if (onParseErrorThrow) {
            throw e;
          }

          const fallbackNode = fallback.call(this, startToken);

          onParseErrorThrow = true;
          onParseError(e, fallbackNode);
          onParseErrorThrow = false;

          return fallbackNode;
        }
      },

      lookupNonWSType(offset) {
        let type;

        do {
          type = this.lookupType(offset++);
          if (type !== types$Q.WhiteSpace) {
            return type;
          }
        } while (type !== NULL);

        return NULL;
      },

      charCodeAt(offset) {
        return offset >= 0 && offset < source.length
          ? source.charCodeAt(offset)
          : 0;
      },
      substring(offsetStart, offsetEnd) {
        return source.substring(offsetStart, offsetEnd);
      },
      substrToCursor(start) {
        return this.source.substring(start, this.tokenStart);
      },

      cmpChar(offset, charCode) {
        return utils$h.cmpChar(source, offset, charCode);
      },
      cmpStr(offsetStart, offsetEnd, str) {
        return utils$h.cmpStr(source, offsetStart, offsetEnd, str);
      },

      consume(tokenType) {
        const start = this.tokenStart;

        this.eat(tokenType);

        return this.substrToCursor(start);
      },
      consumeFunctionName() {
        const name = source.substring(this.tokenStart, this.tokenEnd - 1);

        this.eat(types$Q.Function);

        return name;
      },
      consumeNumber(type) {
        const number = source.substring(
          this.tokenStart,
          utils$h.consumeNumber(source, this.tokenStart),
        );

        this.eat(type);

        return number;
      },

      eat(tokenType) {
        if (this.tokenType !== tokenType) {
          const tokenName = names$5[tokenType]
            .slice(0, -6)
            .replace(/-/g, " ")
            .replace(/^./, (m) => m.toUpperCase());
          let message = `${
            /[[\](){}]/.test(tokenName) ? `"${tokenName}"` : tokenName
          } is expected`;
          let offset = this.tokenStart;

          // tweak message and offset
          switch (tokenType) {
            case types$Q.Ident:
              // when identifier is expected but there is a function or url
              if (
                this.tokenType === types$Q.Function ||
                this.tokenType === types$Q.Url
              ) {
                offset = this.tokenEnd - 1;
                message = "Identifier is expected but function found";
              } else {
                message = "Identifier is expected";
              }
              break;

            case types$Q.Hash:
              if (this.isDelim(NUMBERSIGN$4)) {
                this.next();
                offset++;
                message = "Name is expected";
              }
              break;

            case types$Q.Percentage:
              if (this.tokenType === types$Q.Number) {
                offset = this.tokenEnd;
                message = "Percent sign is expected";
              }
              break;
          }

          this.error(message, offset);
        }

        this.next();
      },
      eatIdent(name) {
        if (
          this.tokenType !== types$Q.Ident ||
          this.lookupValue(0, name) === false
        ) {
          this.error(`Identifier "${name}" is expected`);
        }

        this.next();
      },
      eatDelim(code) {
        if (!this.isDelim(code)) {
          this.error(`Delim "${String.fromCharCode(code)}" is expected`);
        }

        this.next();
      },

      getLocation(start, end) {
        if (needPositions) {
          return locationMap.getLocationRange(start, end, filename);
        }

        return null;
      },
      getLocationFromList(list) {
        if (needPositions) {
          const head = this.getFirstListNode(list);
          const tail = this.getLastListNode(list);
          return locationMap.getLocationRange(
            head !== null
              ? head.loc.start.offset - locationMap.startOffset
              : this.tokenStart,
            tail !== null
              ? tail.loc.end.offset - locationMap.startOffset
              : this.tokenStart,
            filename,
          );
        }

        return null;
      },

      error(message, offset) {
        const location =
          typeof offset !== "undefined" && offset < source.length
            ? locationMap.getLocation(offset)
            : this.eof
              ? locationMap.getLocation(
                  utils$h.findWhiteSpaceStart(source, source.length - 1),
                )
              : locationMap.getLocation(this.tokenStart);

        throw new SyntaxError$4.SyntaxError(
          message || "Unexpected input",
          source,
          location.offset,
          location.line,
          location.column,
        );
      },
    },
  );

  const parse = function (source_, options) {
    source = source_;
    options = options || {};

    parser.setSource(source, index$b.tokenize);
    locationMap.setSource(source, options.offset, options.line, options.column);

    filename = options.filename || "<unknown>";
    needPositions = Boolean(options.positions);
    onParseError =
      typeof options.onParseError === "function" ? options.onParseError : NOOP;
    onParseErrorThrow = false;

    parser.parseAtrulePrelude =
      "parseAtrulePrelude" in options
        ? Boolean(options.parseAtrulePrelude)
        : true;
    parser.parseRulePrelude =
      "parseRulePrelude" in options ? Boolean(options.parseRulePrelude) : true;
    parser.parseValue =
      "parseValue" in options ? Boolean(options.parseValue) : true;
    parser.parseCustomProperty =
      "parseCustomProperty" in options
        ? Boolean(options.parseCustomProperty)
        : false;

    const { context = "default", onComment } = options;

    if (context in parser.context === false) {
      throw new Error("Unknown context `" + context + "`");
    }

    if (typeof onComment === "function") {
      parser.forEachToken((type, start, end) => {
        if (type === types$Q.Comment) {
          const loc = parser.getLocation(start, end);
          const value = utils$h.cmpStr(source, end - 2, end, "*/")
            ? source.slice(start + 2, end - 2)
            : source.slice(start + 2, end);

          onComment(value, loc);
        }
      });
    }

    const ast = parser.context[context].call(parser, options);

    if (!parser.eof) {
      parser.error();
    }

    return ast;
  };

  return Object.assign(parse, {
    SyntaxError: SyntaxError$4.SyntaxError,
    config: parser.config,
  });
}

create$7.createParser = createParser;

var create$6 = {};

var sourceMap$1 = {};

const sourceMapGenerator_js = sourceMapGenerator;

const trackNodes = new Set(["Atrule", "Selector", "Declaration"]);

function generateSourceMap(handlers) {
  const map = new sourceMapGenerator_js.SourceMapGenerator();
  const generated = {
    line: 1,
    column: 0,
  };
  const original = {
    line: 0, // should be zero to add first mapping
    column: 0,
  };
  const activatedGenerated = {
    line: 1,
    column: 0,
  };
  const activatedMapping = {
    generated: activatedGenerated,
  };
  let line = 1;
  let column = 0;
  let sourceMappingActive = false;

  const origHandlersNode = handlers.node;
  handlers.node = function (node) {
    if (node.loc && node.loc.start && trackNodes.has(node.type)) {
      const nodeLine = node.loc.start.line;
      const nodeColumn = node.loc.start.column - 1;

      if (original.line !== nodeLine || original.column !== nodeColumn) {
        original.line = nodeLine;
        original.column = nodeColumn;

        generated.line = line;
        generated.column = column;

        if (sourceMappingActive) {
          sourceMappingActive = false;
          if (
            generated.line !== activatedGenerated.line ||
            generated.column !== activatedGenerated.column
          ) {
            map.addMapping(activatedMapping);
          }
        }

        sourceMappingActive = true;
        map.addMapping({
          source: node.loc.source,
          original,
          generated,
        });
      }
    }

    origHandlersNode.call(this, node);

    if (sourceMappingActive && trackNodes.has(node.type)) {
      activatedGenerated.line = line;
      activatedGenerated.column = column;
    }
  };

  const origHandlersEmit = handlers.emit;
  handlers.emit = function (value, type, auto) {
    for (let i = 0; i < value.length; i++) {
      if (value.charCodeAt(i) === 10) {
        // \n
        line++;
        column = 0;
      } else {
        column++;
      }
    }

    origHandlersEmit(value, type, auto);
  };

  const origHandlersResult = handlers.result;
  handlers.result = function () {
    if (sourceMappingActive) {
      map.addMapping(activatedMapping);
    }

    return {
      css: origHandlersResult(),
      map,
    };
  };

  return handlers;
}

sourceMap$1.generateSourceMap = generateSourceMap;

var tokenBefore$1 = {};

const types$P = types$U;

const PLUSSIGN$9 = 0x002b; // U+002B PLUS SIGN (+)
const HYPHENMINUS$6 = 0x002d; // U+002D HYPHEN-MINUS (-)

const code = (type, value) => {
  if (type === types$P.Delim) {
    type = value;
  }

  if (typeof type === "string") {
    const charCode = type.charCodeAt(0);
    return charCode > 0x7f ? 0x8000 : charCode << 8;
  }

  return type;
};

// https://www.w3.org/TR/css-syntax-3/#serialization
// The only requirement for serialization is that it must "round-trip" with parsing,
// that is, parsing the stylesheet must produce the same data structures as parsing,
// serializing, and parsing again, except for consecutive <whitespace-token>s,
// which may be collapsed into a single token.

const specPairs = [
  [types$P.Ident, types$P.Ident],
  [types$P.Ident, types$P.Function],
  [types$P.Ident, types$P.Url],
  [types$P.Ident, types$P.BadUrl],
  [types$P.Ident, "-"],
  [types$P.Ident, types$P.Number],
  [types$P.Ident, types$P.Percentage],
  [types$P.Ident, types$P.Dimension],
  [types$P.Ident, types$P.CDC],
  [types$P.Ident, types$P.LeftParenthesis],

  [types$P.AtKeyword, types$P.Ident],
  [types$P.AtKeyword, types$P.Function],
  [types$P.AtKeyword, types$P.Url],
  [types$P.AtKeyword, types$P.BadUrl],
  [types$P.AtKeyword, "-"],
  [types$P.AtKeyword, types$P.Number],
  [types$P.AtKeyword, types$P.Percentage],
  [types$P.AtKeyword, types$P.Dimension],
  [types$P.AtKeyword, types$P.CDC],

  [types$P.Hash, types$P.Ident],
  [types$P.Hash, types$P.Function],
  [types$P.Hash, types$P.Url],
  [types$P.Hash, types$P.BadUrl],
  [types$P.Hash, "-"],
  [types$P.Hash, types$P.Number],
  [types$P.Hash, types$P.Percentage],
  [types$P.Hash, types$P.Dimension],
  [types$P.Hash, types$P.CDC],

  [types$P.Dimension, types$P.Ident],
  [types$P.Dimension, types$P.Function],
  [types$P.Dimension, types$P.Url],
  [types$P.Dimension, types$P.BadUrl],
  [types$P.Dimension, "-"],
  [types$P.Dimension, types$P.Number],
  [types$P.Dimension, types$P.Percentage],
  [types$P.Dimension, types$P.Dimension],
  [types$P.Dimension, types$P.CDC],

  ["#", types$P.Ident],
  ["#", types$P.Function],
  ["#", types$P.Url],
  ["#", types$P.BadUrl],
  ["#", "-"],
  ["#", types$P.Number],
  ["#", types$P.Percentage],
  ["#", types$P.Dimension],
  ["#", types$P.CDC], // https://github.com/w3c/csswg-drafts/pull/6874

  ["-", types$P.Ident],
  ["-", types$P.Function],
  ["-", types$P.Url],
  ["-", types$P.BadUrl],
  ["-", "-"],
  ["-", types$P.Number],
  ["-", types$P.Percentage],
  ["-", types$P.Dimension],
  ["-", types$P.CDC], // https://github.com/w3c/csswg-drafts/pull/6874

  [types$P.Number, types$P.Ident],
  [types$P.Number, types$P.Function],
  [types$P.Number, types$P.Url],
  [types$P.Number, types$P.BadUrl],
  [types$P.Number, types$P.Number],
  [types$P.Number, types$P.Percentage],
  [types$P.Number, types$P.Dimension],
  [types$P.Number, "%"],
  [types$P.Number, types$P.CDC], // https://github.com/w3c/csswg-drafts/pull/6874

  ["@", types$P.Ident],
  ["@", types$P.Function],
  ["@", types$P.Url],
  ["@", types$P.BadUrl],
  ["@", "-"],
  ["@", types$P.CDC], // https://github.com/w3c/csswg-drafts/pull/6874

  [".", types$P.Number],
  [".", types$P.Percentage],
  [".", types$P.Dimension],

  ["+", types$P.Number],
  ["+", types$P.Percentage],
  ["+", types$P.Dimension],

  ["/", "*"],
];
// validate with scripts/generate-safe
const safePairs = specPairs.concat([
  [types$P.Ident, types$P.Hash],

  [types$P.Dimension, types$P.Hash],

  [types$P.Hash, types$P.Hash],

  [types$P.AtKeyword, types$P.LeftParenthesis],
  [types$P.AtKeyword, types$P.String],
  [types$P.AtKeyword, types$P.Colon],

  [types$P.Percentage, types$P.Percentage],
  [types$P.Percentage, types$P.Dimension],
  [types$P.Percentage, types$P.Function],
  [types$P.Percentage, "-"],

  [types$P.RightParenthesis, types$P.Ident],
  [types$P.RightParenthesis, types$P.Function],
  [types$P.RightParenthesis, types$P.Percentage],
  [types$P.RightParenthesis, types$P.Dimension],
  [types$P.RightParenthesis, types$P.Hash],
  [types$P.RightParenthesis, "-"],
]);

function createMap(pairs) {
  const isWhiteSpaceRequired = new Set(
    pairs.map(([prev, next]) => (code(prev) << 16) | code(next)),
  );

  return function (prevCode, type, value) {
    const nextCode = code(type, value);
    const nextCharCode = value.charCodeAt(0);
    const emitWs =
      (nextCharCode === HYPHENMINUS$6 &&
        type !== types$P.Ident &&
        type !== types$P.Function &&
        type !== types$P.CDC) ||
      nextCharCode === PLUSSIGN$9
        ? isWhiteSpaceRequired.has((prevCode << 16) | (nextCharCode << 8))
        : isWhiteSpaceRequired.has((prevCode << 16) | nextCode);

    if (emitWs) {
      this.emit(" ", types$P.WhiteSpace, true);
    }

    return nextCode;
  };
}

const spec = createMap(specPairs);
const safe = createMap(safePairs);

tokenBefore$1.safe = safe;
tokenBefore$1.spec = spec;

const index$a = tokenizer$2;
const sourceMap = sourceMap$1;
const tokenBefore = tokenBefore$1;
const types$O = types$U;

const REVERSESOLIDUS = 0x005c; // U+005C REVERSE SOLIDUS (\)

function processChildren(node, delimeter) {
  if (typeof delimeter === "function") {
    let prev = null;

    node.children.forEach((node) => {
      if (prev !== null) {
        delimeter.call(this, prev);
      }

      this.node(node);
      prev = node;
    });

    return;
  }

  node.children.forEach(this.node, this);
}

function processChunk(chunk) {
  index$a.tokenize(chunk, (type, start, end) => {
    this.token(type, chunk.slice(start, end));
  });
}

function createGenerator(config) {
  const types$1 = new Map();

  for (let name in config.node) {
    const item = config.node[name];
    const fn = item.generate || item;

    if (typeof fn === "function") {
      types$1.set(name, item.generate || item);
    }
  }

  return function (node, options) {
    let buffer = "";
    let prevCode = 0;
    let handlers = {
      node(node) {
        if (types$1.has(node.type)) {
          types$1.get(node.type).call(publicApi, node);
        } else {
          throw new Error("Unknown node type: " + node.type);
        }
      },
      tokenBefore: tokenBefore.safe,
      token(type, value) {
        prevCode = this.tokenBefore(prevCode, type, value);

        this.emit(value, type, false);

        if (type === types$O.Delim && value.charCodeAt(0) === REVERSESOLIDUS) {
          this.emit("\n", types$O.WhiteSpace, true);
        }
      },
      emit(value) {
        buffer += value;
      },
      result() {
        return buffer;
      },
    };

    if (options) {
      if (typeof options.decorator === "function") {
        handlers = options.decorator(handlers);
      }

      if (options.sourceMap) {
        handlers = sourceMap.generateSourceMap(handlers);
      }

      if (options.mode in tokenBefore) {
        handlers.tokenBefore = tokenBefore[options.mode];
      }
    }

    const publicApi = {
      node: (node) => handlers.node(node),
      children: processChildren,
      token: (type, value) => handlers.token(type, value),
      tokenize: processChunk,
    };

    handlers.node(node);

    return handlers.result();
  };
}

create$6.createGenerator = createGenerator;

var create$5 = {};

const List$4 = List$7;

function createConvertor(walk) {
  return {
    fromPlainObject(ast) {
      walk(ast, {
        enter(node) {
          if (node.children && node.children instanceof List$4.List === false) {
            node.children = new List$4.List().fromArray(node.children);
          }
        },
      });

      return ast;
    },
    toPlainObject(ast) {
      walk(ast, {
        leave(node) {
          if (node.children && node.children instanceof List$4.List) {
            node.children = node.children.toArray();
          }
        },
      });

      return ast;
    },
  };
}

create$5.createConvertor = createConvertor;

var create$4 = {};

const { hasOwnProperty: hasOwnProperty$9 } = Object.prototype;
const noop$5 = function () {};

function ensureFunction$1(value) {
  return typeof value === "function" ? value : noop$5;
}

function invokeForType(fn, type) {
  return function (node, item, list) {
    if (node.type === type) {
      fn.call(this, node, item, list);
    }
  };
}

function getWalkersFromStructure(name, nodeType) {
  const structure = nodeType.structure;
  const walkers = [];

  for (const key in structure) {
    if (hasOwnProperty$9.call(structure, key) === false) {
      continue;
    }

    let fieldTypes = structure[key];
    const walker = {
      name: key,
      type: false,
      nullable: false,
    };

    if (!Array.isArray(fieldTypes)) {
      fieldTypes = [fieldTypes];
    }

    for (const fieldType of fieldTypes) {
      if (fieldType === null) {
        walker.nullable = true;
      } else if (typeof fieldType === "string") {
        walker.type = "node";
      } else if (Array.isArray(fieldType)) {
        walker.type = "list";
      }
    }

    if (walker.type) {
      walkers.push(walker);
    }
  }

  if (walkers.length) {
    return {
      context: nodeType.walkContext,
      fields: walkers,
    };
  }

  return null;
}

function getTypesFromConfig(config) {
  const types = {};

  for (const name in config.node) {
    if (hasOwnProperty$9.call(config.node, name)) {
      const nodeType = config.node[name];

      if (!nodeType.structure) {
        throw new Error(
          "Missed `structure` field in `" + name + "` node type definition",
        );
      }

      types[name] = getWalkersFromStructure(name, nodeType);
    }
  }

  return types;
}

function createTypeIterator(config, reverse) {
  const fields = config.fields.slice();
  const contextName = config.context;
  const useContext = typeof contextName === "string";

  if (reverse) {
    fields.reverse();
  }

  return function (node, context, walk, walkReducer) {
    let prevContextValue;

    if (useContext) {
      prevContextValue = context[contextName];
      context[contextName] = node;
    }

    for (const field of fields) {
      const ref = node[field.name];

      if (!field.nullable || ref) {
        if (field.type === "list") {
          const breakWalk = reverse
            ? ref.reduceRight(walkReducer, false)
            : ref.reduce(walkReducer, false);

          if (breakWalk) {
            return true;
          }
        } else if (walk(ref)) {
          return true;
        }
      }
    }

    if (useContext) {
      context[contextName] = prevContextValue;
    }
  };
}

function createFastTraveralMap({
  StyleSheet,
  Atrule,
  Rule,
  Block,
  DeclarationList,
}) {
  return {
    Atrule: {
      StyleSheet,
      Atrule,
      Rule,
      Block,
    },
    Rule: {
      StyleSheet,
      Atrule,
      Rule,
      Block,
    },
    Declaration: {
      StyleSheet,
      Atrule,
      Rule,
      Block,
      DeclarationList,
    },
  };
}

function createWalker(config) {
  const types = getTypesFromConfig(config);
  const iteratorsNatural = {};
  const iteratorsReverse = {};
  const breakWalk = Symbol("break-walk");
  const skipNode = Symbol("skip-node");

  for (const name in types) {
    if (hasOwnProperty$9.call(types, name) && types[name] !== null) {
      iteratorsNatural[name] = createTypeIterator(types[name], false);
      iteratorsReverse[name] = createTypeIterator(types[name], true);
    }
  }

  const fastTraversalIteratorsNatural = createFastTraveralMap(iteratorsNatural);
  const fastTraversalIteratorsReverse = createFastTraveralMap(iteratorsReverse);

  const walk = function (root, options) {
    function walkNode(node, item, list) {
      const enterRet = enter.call(context, node, item, list);

      if (enterRet === breakWalk) {
        return true;
      }

      if (enterRet === skipNode) {
        return false;
      }

      if (iterators.hasOwnProperty(node.type)) {
        if (iterators[node.type](node, context, walkNode, walkReducer)) {
          return true;
        }
      }

      if (leave.call(context, node, item, list) === breakWalk) {
        return true;
      }

      return false;
    }

    let enter = noop$5;
    let leave = noop$5;
    let iterators = iteratorsNatural;
    let walkReducer = (ret, data, item, list) =>
      ret || walkNode(data, item, list);
    const context = {
      break: breakWalk,
      skip: skipNode,

      root,
      stylesheet: null,
      atrule: null,
      atrulePrelude: null,
      rule: null,
      selector: null,
      block: null,
      declaration: null,
      function: null,
    };

    if (typeof options === "function") {
      enter = options;
    } else if (options) {
      enter = ensureFunction$1(options.enter);
      leave = ensureFunction$1(options.leave);

      if (options.reverse) {
        iterators = iteratorsReverse;
      }

      if (options.visit) {
        if (fastTraversalIteratorsNatural.hasOwnProperty(options.visit)) {
          iterators = options.reverse
            ? fastTraversalIteratorsReverse[options.visit]
            : fastTraversalIteratorsNatural[options.visit];
        } else if (!types.hasOwnProperty(options.visit)) {
          throw new Error(
            "Bad value `" +
              options.visit +
              "` for `visit` option (should be: " +
              Object.keys(types).sort().join(", ") +
              ")",
          );
        }

        enter = invokeForType(enter, options.visit);
        leave = invokeForType(leave, options.visit);
      }
    }

    if (enter === noop$5 && leave === noop$5) {
      throw new Error(
        "Neither `enter` nor `leave` walker handler is set or both aren't a function",
      );
    }

    walkNode(root);
  };

  walk.break = breakWalk;
  walk.skip = skipNode;

  walk.find = function (ast, fn) {
    let found = null;

    walk(ast, function (node, item, list) {
      if (fn.call(this, node, item, list)) {
        found = node;
        return breakWalk;
      }
    });

    return found;
  };

  walk.findLast = function (ast, fn) {
    let found = null;

    walk(ast, {
      reverse: true,
      enter(node, item, list) {
        if (fn.call(this, node, item, list)) {
          found = node;
          return breakWalk;
        }
      },
    });

    return found;
  };

  walk.findAll = function (ast, fn) {
    const found = [];

    walk(ast, function (node, item, list) {
      if (fn.call(this, node, item, list)) {
        found.push(node);
      }
    });

    return found;
  };

  return walk;
}

create$4.createWalker = createWalker;

var Lexer$3 = {};

var error$2 = {};

var generate$L = {};

function noop$4(value) {
  return value;
}

function generateMultiplier(multiplier) {
  const { min, max, comma } = multiplier;

  if (min === 0 && max === 0) {
    return comma ? "#?" : "*";
  }

  if (min === 0 && max === 1) {
    return "?";
  }

  if (min === 1 && max === 0) {
    return comma ? "#" : "+";
  }

  if (min === 1 && max === 1) {
    return "";
  }

  return (
    (comma ? "#" : "") +
    (min === max
      ? "{" + min + "}"
      : "{" + min + "," + (max !== 0 ? max : "") + "}")
  );
}

function generateTypeOpts(node) {
  switch (node.type) {
    case "Range":
      return (
        " [" +
        (node.min === null ? "-" : node.min) +
        "," +
        (node.max === null ? "" : node.max) +
        "]"
      );

    default:
      throw new Error("Unknown node type `" + node.type + "`");
  }
}

function generateSequence(node, decorate, forceBraces, compact) {
  const combinator =
    node.combinator === " " || compact
      ? node.combinator
      : " " + node.combinator + " ";
  const result = node.terms
    .map((term) => internalGenerate(term, decorate, forceBraces, compact))
    .join(combinator);

  if (node.explicit || forceBraces) {
    return (
      (compact || result[0] === "," ? "[" : "[ ") +
      result +
      (compact ? "]" : " ]")
    );
  }

  return result;
}

function internalGenerate(node, decorate, forceBraces, compact) {
  let result;

  switch (node.type) {
    case "Group":
      result =
        generateSequence(node, decorate, forceBraces, compact) +
        (node.disallowEmpty ? "!" : "");
      break;

    case "Multiplier":
      // return since node is a composition
      return (
        internalGenerate(node.term, decorate, forceBraces, compact) +
        decorate(generateMultiplier(node), node)
      );

    case "Type":
      result =
        "<" +
        node.name +
        (node.opts ? decorate(generateTypeOpts(node.opts), node.opts) : "") +
        ">";
      break;

    case "Property":
      result = "<'" + node.name + "'>";
      break;

    case "Keyword":
      result = node.name;
      break;

    case "AtKeyword":
      result = "@" + node.name;
      break;

    case "Function":
      result = node.name + "(";
      break;

    case "String":
    case "Token":
      result = node.value;
      break;

    case "Comma":
      result = ",";
      break;

    default:
      throw new Error("Unknown node type `" + node.type + "`");
  }

  return decorate(result, node);
}

function generate$K(node, options) {
  let decorate = noop$4;
  let forceBraces = false;
  let compact = false;

  if (typeof options === "function") {
    decorate = options;
  } else if (options) {
    forceBraces = Boolean(options.forceBraces);
    compact = Boolean(options.compact);
    if (typeof options.decorate === "function") {
      decorate = options.decorate;
    }
  }

  return internalGenerate(node, decorate, forceBraces, compact);
}

generate$L.generate = generate$K;

const createCustomError$1 = createCustomError$4;
const generate$J = generate$L;

const defaultLoc = { offset: 0, line: 1, column: 1 };

function locateMismatch(matchResult, node) {
  const tokens = matchResult.tokens;
  const longestMatch = matchResult.longestMatch;
  const mismatchNode =
    longestMatch < tokens.length ? tokens[longestMatch].node || null : null;
  const badNode = mismatchNode !== node ? mismatchNode : null;
  let mismatchOffset = 0;
  let mismatchLength = 0;
  let entries = 0;
  let css = "";
  let start;
  let end;

  for (let i = 0; i < tokens.length; i++) {
    const token = tokens[i].value;

    if (i === longestMatch) {
      mismatchLength = token.length;
      mismatchOffset = css.length;
    }

    if (badNode !== null && tokens[i].node === badNode) {
      if (i <= longestMatch) {
        entries++;
      } else {
        entries = 0;
      }
    }

    css += token;
  }

  if (longestMatch === tokens.length || entries > 1) {
    // last
    start = fromLoc(badNode || node, "end") || buildLoc(defaultLoc, css);
    end = buildLoc(start);
  } else {
    start =
      fromLoc(badNode, "start") ||
      buildLoc(
        fromLoc(node, "start") || defaultLoc,
        css.slice(0, mismatchOffset),
      );
    end =
      fromLoc(badNode, "end") ||
      buildLoc(start, css.substr(mismatchOffset, mismatchLength));
  }

  return {
    css,
    mismatchOffset,
    mismatchLength,
    start,
    end,
  };
}

function fromLoc(node, point) {
  const value = node && node.loc && node.loc[point];

  if (value) {
    return "line" in value ? buildLoc(value) : value;
  }

  return null;
}

function buildLoc({ offset, line, column }, extra) {
  const loc = {
    offset,
    line,
    column,
  };

  if (extra) {
    const lines = extra.split(/\n|\r\n?|\f/);

    loc.offset += extra.length;
    loc.line += lines.length - 1;
    loc.column =
      lines.length === 1 ? loc.column + extra.length : lines.pop().length + 1;
  }

  return loc;
}

const SyntaxReferenceError = function (type, referenceName) {
  const error = createCustomError$1.createCustomError(
    "SyntaxReferenceError",
    type + (referenceName ? " `" + referenceName + "`" : ""),
  );

  error.reference = referenceName;

  return error;
};

const SyntaxMatchError = function (message, syntax, node, matchResult) {
  const error = createCustomError$1.createCustomError(
    "SyntaxMatchError",
    message,
  );
  const { css, mismatchOffset, mismatchLength, start, end } = locateMismatch(
    matchResult,
    node,
  );

  error.rawMessage = message;
  error.syntax = syntax ? generate$J.generate(syntax) : "<generic>";
  error.css = css;
  error.mismatchOffset = mismatchOffset;
  error.mismatchLength = mismatchLength;
  error.message =
    message +
    "\n" +
    "  syntax: " +
    error.syntax +
    "\n" +
    "   value: " +
    (css || "<empty string>") +
    "\n" +
    "  --------" +
    new Array(error.mismatchOffset + 1).join("-") +
    "^";

  Object.assign(error, start);
  error.loc = {
    source: (node && node.loc && node.loc.source) || "<unknown>",
    start,
    end,
  };

  return error;
};

error$2.SyntaxMatchError = SyntaxMatchError;
error$2.SyntaxReferenceError = SyntaxReferenceError;

var names$4 = {};

const keywords$1 = new Map();
const properties$1 = new Map();
const HYPHENMINUS$5 = 45; // '-'.charCodeAt()

const keyword = getKeywordDescriptor;
const property = getPropertyDescriptor;
const vendorPrefix = getVendorPrefix;
function isCustomProperty(str, offset) {
  offset = offset || 0;

  return (
    str.length - offset >= 2 &&
    str.charCodeAt(offset) === HYPHENMINUS$5 &&
    str.charCodeAt(offset + 1) === HYPHENMINUS$5
  );
}

function getVendorPrefix(str, offset) {
  offset = offset || 0;

  // verdor prefix should be at least 3 chars length
  if (str.length - offset >= 3) {
    // vendor prefix starts with hyper minus following non-hyper minus
    if (
      str.charCodeAt(offset) === HYPHENMINUS$5 &&
      str.charCodeAt(offset + 1) !== HYPHENMINUS$5
    ) {
      // vendor prefix should contain a hyper minus at the ending
      const secondDashIndex = str.indexOf("-", offset + 2);

      if (secondDashIndex !== -1) {
        return str.substring(offset, secondDashIndex + 1);
      }
    }
  }

  return "";
}

function getKeywordDescriptor(keyword) {
  if (keywords$1.has(keyword)) {
    return keywords$1.get(keyword);
  }

  const name = keyword.toLowerCase();
  let descriptor = keywords$1.get(name);

  if (descriptor === undefined) {
    const custom = isCustomProperty(name, 0);
    const vendor = !custom ? getVendorPrefix(name, 0) : "";
    descriptor = Object.freeze({
      basename: name.substr(vendor.length),
      name,
      prefix: vendor,
      vendor,
      custom,
    });
  }

  keywords$1.set(keyword, descriptor);

  return descriptor;
}

function getPropertyDescriptor(property) {
  if (properties$1.has(property)) {
    return properties$1.get(property);
  }

  let name = property;
  let hack = property[0];

  if (hack === "/") {
    hack = property[1] === "/" ? "//" : "/";
  } else if (
    hack !== "_" &&
    hack !== "*" &&
    hack !== "$" &&
    hack !== "#" &&
    hack !== "+" &&
    hack !== "&"
  ) {
    hack = "";
  }

  const custom = isCustomProperty(name, hack.length);

  // re-use result when possible (the same as for lower case)
  if (!custom) {
    name = name.toLowerCase();
    if (properties$1.has(name)) {
      const descriptor = properties$1.get(name);
      properties$1.set(property, descriptor);
      return descriptor;
    }
  }

  const vendor = !custom ? getVendorPrefix(name, hack.length) : "";
  const prefix = name.substr(0, hack.length + vendor.length);
  const descriptor = Object.freeze({
    basename: name.substr(prefix.length),
    name: name.substr(hack.length),
    hack,
    vendor,
    prefix,
    custom,
  });

  properties$1.set(property, descriptor);

  return descriptor;
}

names$4.isCustomProperty = isCustomProperty;
names$4.keyword = keyword;
names$4.property = property;
names$4.vendorPrefix = vendorPrefix;

var genericConst$2 = {};

// https://drafts.csswg.org/css-cascade-5/
const cssWideKeywords = [
  "initial",
  "inherit",
  "unset",
  "revert",
  "revert-layer",
];

genericConst$2.cssWideKeywords = cssWideKeywords;

const charCodeDefinitions$8 = charCodeDefinitions$c;
const types$N = types$U;
const utils$g = utils$k;

const PLUSSIGN$8 = 0x002b; // U+002B PLUS SIGN (+)
const HYPHENMINUS$4 = 0x002d; // U+002D HYPHEN-MINUS (-)
const N$3 = 0x006e; // U+006E LATIN SMALL LETTER N (n)
const DISALLOW_SIGN$1 = true;
const ALLOW_SIGN$1 = false;

function isDelim$1(token, code) {
  return (
    token !== null &&
    token.type === types$N.Delim &&
    token.value.charCodeAt(0) === code
  );
}

function skipSC(token, offset, getNextToken) {
  while (
    token !== null &&
    (token.type === types$N.WhiteSpace || token.type === types$N.Comment)
  ) {
    token = getNextToken(++offset);
  }

  return offset;
}

function checkInteger$1(token, valueOffset, disallowSign, offset) {
  if (!token) {
    return 0;
  }

  const code = token.value.charCodeAt(valueOffset);

  if (code === PLUSSIGN$8 || code === HYPHENMINUS$4) {
    if (disallowSign) {
      // Number sign is not allowed
      return 0;
    }
    valueOffset++;
  }

  for (; valueOffset < token.value.length; valueOffset++) {
    if (!charCodeDefinitions$8.isDigit(token.value.charCodeAt(valueOffset))) {
      // Integer is expected
      return 0;
    }
  }

  return offset + 1;
}

// ... <signed-integer>
// ... ['+' | '-'] <signless-integer>
function consumeB$1(token, offset_, getNextToken) {
  let sign = false;
  let offset = skipSC(token, offset_, getNextToken);

  token = getNextToken(offset);

  if (token === null) {
    return offset_;
  }

  if (token.type !== types$N.Number) {
    if (isDelim$1(token, PLUSSIGN$8) || isDelim$1(token, HYPHENMINUS$4)) {
      sign = true;
      offset = skipSC(getNextToken(++offset), offset, getNextToken);
      token = getNextToken(offset);

      if (token === null || token.type !== types$N.Number) {
        return 0;
      }
    } else {
      return offset_;
    }
  }

  if (!sign) {
    const code = token.value.charCodeAt(0);
    if (code !== PLUSSIGN$8 && code !== HYPHENMINUS$4) {
      // Number sign is expected
      return 0;
    }
  }

  return checkInteger$1(token, sign ? 0 : 1, sign, offset);
}

// An+B microsyntax https://www.w3.org/TR/css-syntax-3/#anb
function anPlusB(token, getNextToken) {
  /* eslint-disable brace-style*/
  let offset = 0;

  if (!token) {
    return 0;
  }

  // <integer>
  if (token.type === types$N.Number) {
    return checkInteger$1(token, 0, ALLOW_SIGN$1, offset); // b
  }

  // -n
  // -n <signed-integer>
  // -n ['+' | '-'] <signless-integer>
  // -n- <signless-integer>
  // <dashndashdigit-ident>
  else if (
    token.type === types$N.Ident &&
    token.value.charCodeAt(0) === HYPHENMINUS$4
  ) {
    // expect 1st char is N
    if (!utils$g.cmpChar(token.value, 1, N$3)) {
      return 0;
    }

    switch (token.value.length) {
      // -n
      // -n <signed-integer>
      // -n ['+' | '-'] <signless-integer>
      case 2:
        return consumeB$1(getNextToken(++offset), offset, getNextToken);

      // -n- <signless-integer>
      case 3:
        if (token.value.charCodeAt(2) !== HYPHENMINUS$4) {
          return 0;
        }

        offset = skipSC(getNextToken(++offset), offset, getNextToken);
        token = getNextToken(offset);

        return checkInteger$1(token, 0, DISALLOW_SIGN$1, offset);

      // <dashndashdigit-ident>
      default:
        if (token.value.charCodeAt(2) !== HYPHENMINUS$4) {
          return 0;
        }

        return checkInteger$1(token, 3, DISALLOW_SIGN$1, offset);
    }
  }

  // '+'? n
  // '+'? n <signed-integer>
  // '+'? n ['+' | '-'] <signless-integer>
  // '+'? n- <signless-integer>
  // '+'? <ndashdigit-ident>
  else if (
    token.type === types$N.Ident ||
    (isDelim$1(token, PLUSSIGN$8) &&
      getNextToken(offset + 1).type === types$N.Ident)
  ) {
    // just ignore a plus
    if (token.type !== types$N.Ident) {
      token = getNextToken(++offset);
    }

    if (token === null || !utils$g.cmpChar(token.value, 0, N$3)) {
      return 0;
    }

    switch (token.value.length) {
      // '+'? n
      // '+'? n <signed-integer>
      // '+'? n ['+' | '-'] <signless-integer>
      case 1:
        return consumeB$1(getNextToken(++offset), offset, getNextToken);

      // '+'? n- <signless-integer>
      case 2:
        if (token.value.charCodeAt(1) !== HYPHENMINUS$4) {
          return 0;
        }

        offset = skipSC(getNextToken(++offset), offset, getNextToken);
        token = getNextToken(offset);

        return checkInteger$1(token, 0, DISALLOW_SIGN$1, offset);

      // '+'? <ndashdigit-ident>
      default:
        if (token.value.charCodeAt(1) !== HYPHENMINUS$4) {
          return 0;
        }

        return checkInteger$1(token, 2, DISALLOW_SIGN$1, offset);
    }
  }

  // <ndashdigit-dimension>
  // <ndash-dimension> <signless-integer>
  // <n-dimension>
  // <n-dimension> <signed-integer>
  // <n-dimension> ['+' | '-'] <signless-integer>
  else if (token.type === types$N.Dimension) {
    let code = token.value.charCodeAt(0);
    let sign = code === PLUSSIGN$8 || code === HYPHENMINUS$4 ? 1 : 0;
    let i = sign;

    for (; i < token.value.length; i++) {
      if (!charCodeDefinitions$8.isDigit(token.value.charCodeAt(i))) {
        break;
      }
    }

    if (i === sign) {
      // Integer is expected
      return 0;
    }

    if (!utils$g.cmpChar(token.value, i, N$3)) {
      return 0;
    }

    // <n-dimension>
    // <n-dimension> <signed-integer>
    // <n-dimension> ['+' | '-'] <signless-integer>
    if (i + 1 === token.value.length) {
      return consumeB$1(getNextToken(++offset), offset, getNextToken);
    } else {
      if (token.value.charCodeAt(i + 1) !== HYPHENMINUS$4) {
        return 0;
      }

      // <ndash-dimension> <signless-integer>
      if (i + 2 === token.value.length) {
        offset = skipSC(getNextToken(++offset), offset, getNextToken);
        token = getNextToken(offset);

        return checkInteger$1(token, 0, DISALLOW_SIGN$1, offset);
      }
      // <ndashdigit-dimension>
      else {
        return checkInteger$1(token, i + 2, DISALLOW_SIGN$1, offset);
      }
    }
  }

  return 0;
}

var genericAnPlusB$1 = anPlusB;

const charCodeDefinitions$7 = charCodeDefinitions$c;
const types$M = types$U;
const utils$f = utils$k;

const PLUSSIGN$7 = 0x002b; // U+002B PLUS SIGN (+)
const HYPHENMINUS$3 = 0x002d; // U+002D HYPHEN-MINUS (-)
const QUESTIONMARK$2 = 0x003f; // U+003F QUESTION MARK (?)
const U$1 = 0x0075; // U+0075 LATIN SMALL LETTER U (u)

function isDelim(token, code) {
  return (
    token !== null &&
    token.type === types$M.Delim &&
    token.value.charCodeAt(0) === code
  );
}

function startsWith$1(token, code) {
  return token.value.charCodeAt(0) === code;
}

function hexSequence(token, offset, allowDash) {
  let hexlen = 0;

  for (let pos = offset; pos < token.value.length; pos++) {
    const code = token.value.charCodeAt(pos);

    if (code === HYPHENMINUS$3 && allowDash && hexlen !== 0) {
      hexSequence(token, offset + hexlen + 1, false);
      return 6; // dissallow following question marks
    }

    if (!charCodeDefinitions$7.isHexDigit(code)) {
      return 0; // not a hex digit
    }

    if (++hexlen > 6) {
      return 0; // too many hex digits
    }
  }

  return hexlen;
}

function withQuestionMarkSequence(consumed, length, getNextToken) {
  if (!consumed) {
    return 0; // nothing consumed
  }

  while (isDelim(getNextToken(length), QUESTIONMARK$2)) {
    if (++consumed > 6) {
      return 0; // too many question marks
    }

    length++;
  }

  return length;
}

// https://drafts.csswg.org/css-syntax/#urange
// Informally, the <urange> production has three forms:
// U+0001
//      Defines a range consisting of a single code point, in this case the code point "1".
// U+0001-00ff
//      Defines a range of codepoints between the first and the second value, in this case
//      the range between "1" and "ff" (255 in decimal) inclusive.
// U+00??
//      Defines a range of codepoints where the "?" characters range over all hex digits,
//      in this case defining the same as the value U+0000-00ff.
// In each form, a maximum of 6 digits is allowed for each hexadecimal number (if you treat "?" as a hexadecimal digit).
//
// <urange> =
//   u '+' <ident-token> '?'* |
//   u <dimension-token> '?'* |
//   u <number-token> '?'* |
//   u <number-token> <dimension-token> |
//   u <number-token> <number-token> |
//   u '+' '?'+
function urange(token, getNextToken) {
  let length = 0;

  // should start with `u` or `U`
  if (
    token === null ||
    token.type !== types$M.Ident ||
    !utils$f.cmpChar(token.value, 0, U$1)
  ) {
    return 0;
  }

  token = getNextToken(++length);
  if (token === null) {
    return 0;
  }

  // u '+' <ident-token> '?'*
  // u '+' '?'+
  if (isDelim(token, PLUSSIGN$7)) {
    token = getNextToken(++length);
    if (token === null) {
      return 0;
    }

    if (token.type === types$M.Ident) {
      // u '+' <ident-token> '?'*
      return withQuestionMarkSequence(
        hexSequence(token, 0, true),
        ++length,
        getNextToken,
      );
    }

    if (isDelim(token, QUESTIONMARK$2)) {
      // u '+' '?'+
      return withQuestionMarkSequence(1, ++length, getNextToken);
    }

    // Hex digit or question mark is expected
    return 0;
  }

  // u <number-token> '?'*
  // u <number-token> <dimension-token>
  // u <number-token> <number-token>
  if (token.type === types$M.Number) {
    const consumedHexLength = hexSequence(token, 1, true);
    if (consumedHexLength === 0) {
      return 0;
    }

    token = getNextToken(++length);
    if (token === null) {
      // u <number-token> <eof>
      return length;
    }

    if (token.type === types$M.Dimension || token.type === types$M.Number) {
      // u <number-token> <dimension-token>
      // u <number-token> <number-token>
      if (
        !startsWith$1(token, HYPHENMINUS$3) ||
        !hexSequence(token, 1, false)
      ) {
        return 0;
      }

      return length + 1;
    }

    // u <number-token> '?'*
    return withQuestionMarkSequence(consumedHexLength, length, getNextToken);
  }

  // u <dimension-token> '?'*
  if (token.type === types$M.Dimension) {
    return withQuestionMarkSequence(
      hexSequence(token, 1, true),
      ++length,
      getNextToken,
    );
  }

  return 0;
}

var genericUrange$1 = urange;

const genericConst$1 = genericConst$2;
const genericAnPlusB = genericAnPlusB$1;
const genericUrange = genericUrange$1;
const types$L = types$U;
const charCodeDefinitions$6 = charCodeDefinitions$c;
const utils$e = utils$k;

const calcFunctionNames = ["calc(", "-moz-calc(", "-webkit-calc("];
const balancePair = new Map([
  [types$L.Function, types$L.RightParenthesis],
  [types$L.LeftParenthesis, types$L.RightParenthesis],
  [types$L.LeftSquareBracket, types$L.RightSquareBracket],
  [types$L.LeftCurlyBracket, types$L.RightCurlyBracket],
]);

// units
const LENGTH = [
  // absolute length units https://www.w3.org/TR/css-values-3/#lengths
  "cm",
  "mm",
  "q",
  "in",
  "pt",
  "pc",
  "px",
  // font-relative length units https://drafts.csswg.org/css-values-4/#font-relative-lengths
  "em",
  "rem",
  "ex",
  "rex",
  "cap",
  "rcap",
  "ch",
  "rch",
  "ic",
  "ric",
  "lh",
  "rlh",
  // viewport-percentage lengths https://drafts.csswg.org/css-values-4/#viewport-relative-lengths
  "vw",
  "svw",
  "lvw",
  "dvw",
  "vh",
  "svh",
  "lvh",
  "dvh",
  "vi",
  "svi",
  "lvi",
  "dvi",
  "vb",
  "svb",
  "lvb",
  "dvb",
  "vmin",
  "svmin",
  "lvmin",
  "dvmin",
  "vmax",
  "svmax",
  "lvmax",
  "dvmax",
  // container relative lengths https://drafts.csswg.org/css-contain-3/#container-lengths
  "cqw",
  "cqh",
  "cqi",
  "cqb",
  "cqmin",
  "cqmax",
];
const ANGLE = ["deg", "grad", "rad", "turn"]; // https://www.w3.org/TR/css-values-3/#angles
const TIME = ["s", "ms"]; // https://www.w3.org/TR/css-values-3/#time
const FREQUENCY = ["hz", "khz"]; // https://www.w3.org/TR/css-values-3/#frequency
const RESOLUTION = ["dpi", "dpcm", "dppx", "x"]; // https://www.w3.org/TR/css-values-3/#resolution
const FLEX = ["fr"]; // https://drafts.csswg.org/css-grid/#fr-unit
const DECIBEL = ["db"]; // https://www.w3.org/TR/css3-speech/#mixing-props-voice-volume
const SEMITONES = ["st"]; // https://www.w3.org/TR/css3-speech/#voice-props-voice-pitch

// safe char code getter
function charCodeAt(str, index) {
  return index < str.length ? str.charCodeAt(index) : 0;
}

function eqStr(actual, expected) {
  return utils$e.cmpStr(actual, 0, actual.length, expected);
}

function eqStrAny(actual, expected) {
  for (let i = 0; i < expected.length; i++) {
    if (eqStr(actual, expected[i])) {
      return true;
    }
  }

  return false;
}

// IE postfix hack, i.e. 123\0 or 123px\9
function isPostfixIeHack(str, offset) {
  if (offset !== str.length - 2) {
    return false;
  }

  return (
    charCodeAt(str, offset) === 0x005c && // U+005C REVERSE SOLIDUS (\)
    charCodeDefinitions$6.isDigit(charCodeAt(str, offset + 1))
  );
}

function outOfRange(opts, value, numEnd) {
  if (opts && opts.type === "Range") {
    const num = Number(
      numEnd !== undefined && numEnd !== value.length
        ? value.substr(0, numEnd)
        : value,
    );

    if (isNaN(num)) {
      return true;
    }

    // FIXME: when opts.min is a string it's a dimension, skip a range validation
    // for now since it requires a type covertation which is not implmented yet
    if (opts.min !== null && num < opts.min && typeof opts.min !== "string") {
      return true;
    }

    // FIXME: when opts.max is a string it's a dimension, skip a range validation
    // for now since it requires a type covertation which is not implmented yet
    if (opts.max !== null && num > opts.max && typeof opts.max !== "string") {
      return true;
    }
  }

  return false;
}

function consumeFunction(token, getNextToken) {
  let balanceCloseType = 0;
  let balanceStash = [];
  let length = 0;

  // balanced token consuming
  scan: do {
    switch (token.type) {
      case types$L.RightCurlyBracket:
      case types$L.RightParenthesis:
      case types$L.RightSquareBracket:
        if (token.type !== balanceCloseType) {
          break scan;
        }

        balanceCloseType = balanceStash.pop();

        if (balanceStash.length === 0) {
          length++;
          break scan;
        }

        break;

      case types$L.Function:
      case types$L.LeftParenthesis:
      case types$L.LeftSquareBracket:
      case types$L.LeftCurlyBracket:
        balanceStash.push(balanceCloseType);
        balanceCloseType = balancePair.get(token.type);
        break;
    }

    length++;
  } while ((token = getNextToken(length)));

  return length;
}

// TODO: implement
// can be used wherever <length>, <frequency>, <angle>, <time>, <percentage>, <number>, or <integer> values are allowed
// https://drafts.csswg.org/css-values/#calc-notation
function calc(next) {
  return function (token, getNextToken, opts) {
    if (token === null) {
      return 0;
    }

    if (
      token.type === types$L.Function &&
      eqStrAny(token.value, calcFunctionNames)
    ) {
      return consumeFunction(token, getNextToken);
    }

    return next(token, getNextToken, opts);
  };
}

function tokenType(expectedTokenType) {
  return function (token) {
    if (token === null || token.type !== expectedTokenType) {
      return 0;
    }

    return 1;
  };
}

// =========================
// Complex types
//

// https://drafts.csswg.org/css-values-4/#custom-idents
// 4.2. Author-defined Identifiers: the <custom-ident> type
// Some properties accept arbitrary author-defined identifiers as a component value.
// This generic data type is denoted by <custom-ident>, and represents any valid CSS identifier
// that would not be misinterpreted as a pre-defined keyword in that propertys value definition.
//
// See also: https://developer.mozilla.org/en-US/docs/Web/CSS/custom-ident
function customIdent(token) {
  if (token === null || token.type !== types$L.Ident) {
    return 0;
  }

  const name = token.value.toLowerCase();

  // The CSS-wide keywords are not valid <custom-ident>s
  if (eqStrAny(name, genericConst$1.cssWideKeywords)) {
    return 0;
  }

  // The default keyword is reserved and is also not a valid <custom-ident>
  if (eqStr(name, "default")) {
    return 0;
  }

  // TODO: ignore property specific keywords (as described https://developer.mozilla.org/en-US/docs/Web/CSS/custom-ident)
  // Specifications using <custom-ident> must specify clearly what other keywords
  // are excluded from <custom-ident>, if anyfor example by saying that any pre-defined keywords
  // in that propertys value definition are excluded. Excluded keywords are excluded
  // in all ASCII case permutations.

  return 1;
}

// https://drafts.csswg.org/css-variables/#typedef-custom-property-name
// A custom property is any property whose name starts with two dashes (U+002D HYPHEN-MINUS), like --foo.
// The <custom-property-name> production corresponds to this: its defined as any valid identifier
// that starts with two dashes, except -- itself, which is reserved for future use by CSS.
// NOTE: Current implementation treat `--` as a valid name since most (all?) major browsers treat it as valid.
function customPropertyName(token) {
  // ... defined as any valid identifier
  if (token === null || token.type !== types$L.Ident) {
    return 0;
  }

  // ... that starts with two dashes (U+002D HYPHEN-MINUS)
  if (
    charCodeAt(token.value, 0) !== 0x002d ||
    charCodeAt(token.value, 1) !== 0x002d
  ) {
    return 0;
  }

  return 1;
}

// https://drafts.csswg.org/css-color-4/#hex-notation
// The syntax of a <hex-color> is a <hash-token> token whose value consists of 3, 4, 6, or 8 hexadecimal digits.
// In other words, a hex color is written as a hash character, "#", followed by some number of digits 0-9 or
// letters a-f (the case of the letters doesnt matter - #00ff00 is identical to #00FF00).
function hexColor(token) {
  if (token === null || token.type !== types$L.Hash) {
    return 0;
  }

  const length = token.value.length;

  // valid values (length): #rgb (4), #rgba (5), #rrggbb (7), #rrggbbaa (9)
  if (length !== 4 && length !== 5 && length !== 7 && length !== 9) {
    return 0;
  }

  for (let i = 1; i < length; i++) {
    if (!charCodeDefinitions$6.isHexDigit(charCodeAt(token.value, i))) {
      return 0;
    }
  }

  return 1;
}

function idSelector(token) {
  if (token === null || token.type !== types$L.Hash) {
    return 0;
  }

  if (
    !charCodeDefinitions$6.isIdentifierStart(
      charCodeAt(token.value, 1),
      charCodeAt(token.value, 2),
      charCodeAt(token.value, 3),
    )
  ) {
    return 0;
  }

  return 1;
}

// https://drafts.csswg.org/css-syntax/#any-value
// It represents the entirety of what a valid declaration can have as its value.
function declarationValue(token, getNextToken) {
  if (!token) {
    return 0;
  }

  let balanceCloseType = 0;
  let balanceStash = [];
  let length = 0;

  // The <declaration-value> production matches any sequence of one or more tokens,
  // so long as the sequence does not contain ...
  scan: do {
    switch (token.type) {
      // ... <bad-string-token>, <bad-url-token>,
      case types$L.BadString:
      case types$L.BadUrl:
        break scan;

      // ... unmatched <)-token>, <]-token>, or <}-token>,
      case types$L.RightCurlyBracket:
      case types$L.RightParenthesis:
      case types$L.RightSquareBracket:
        if (token.type !== balanceCloseType) {
          break scan;
        }

        balanceCloseType = balanceStash.pop();
        break;

      // ... or top-level <semicolon-token> tokens
      case types$L.Semicolon:
        if (balanceCloseType === 0) {
          break scan;
        }

        break;

      // ... or <delim-token> tokens with a value of "!"
      case types$L.Delim:
        if (balanceCloseType === 0 && token.value === "!") {
          break scan;
        }

        break;

      case types$L.Function:
      case types$L.LeftParenthesis:
      case types$L.LeftSquareBracket:
      case types$L.LeftCurlyBracket:
        balanceStash.push(balanceCloseType);
        balanceCloseType = balancePair.get(token.type);
        break;
    }

    length++;
  } while ((token = getNextToken(length)));

  return length;
}

// https://drafts.csswg.org/css-syntax/#any-value
// The <any-value> production is identical to <declaration-value>, but also
// allows top-level <semicolon-token> tokens and <delim-token> tokens
// with a value of "!". It represents the entirety of what valid CSS can be in any context.
function anyValue(token, getNextToken) {
  if (!token) {
    return 0;
  }

  let balanceCloseType = 0;
  let balanceStash = [];
  let length = 0;

  // The <any-value> production matches any sequence of one or more tokens,
  // so long as the sequence ...
  scan: do {
    switch (token.type) {
      // ... does not contain <bad-string-token>, <bad-url-token>,
      case types$L.BadString:
      case types$L.BadUrl:
        break scan;

      // ... unmatched <)-token>, <]-token>, or <}-token>,
      case types$L.RightCurlyBracket:
      case types$L.RightParenthesis:
      case types$L.RightSquareBracket:
        if (token.type !== balanceCloseType) {
          break scan;
        }

        balanceCloseType = balanceStash.pop();
        break;

      case types$L.Function:
      case types$L.LeftParenthesis:
      case types$L.LeftSquareBracket:
      case types$L.LeftCurlyBracket:
        balanceStash.push(balanceCloseType);
        balanceCloseType = balancePair.get(token.type);
        break;
    }

    length++;
  } while ((token = getNextToken(length)));

  return length;
}

// =========================
// Dimensions
//

function dimension(type) {
  if (type) {
    type = new Set(type);
  }

  return function (token, getNextToken, opts) {
    if (token === null || token.type !== types$L.Dimension) {
      return 0;
    }

    const numberEnd = utils$e.consumeNumber(token.value, 0);

    // check unit
    if (type !== null) {
      // check for IE postfix hack, i.e. 123px\0 or 123px\9
      const reverseSolidusOffset = token.value.indexOf("\\", numberEnd);
      const unit =
        reverseSolidusOffset === -1 ||
        !isPostfixIeHack(token.value, reverseSolidusOffset)
          ? token.value.substr(numberEnd)
          : token.value.substring(numberEnd, reverseSolidusOffset);

      if (type.has(unit.toLowerCase()) === false) {
        return 0;
      }
    }

    // check range if specified
    if (outOfRange(opts, token.value, numberEnd)) {
      return 0;
    }

    return 1;
  };
}

// =========================
// Percentage
//

// 5.5. Percentages: the <percentage> type
// https://drafts.csswg.org/css-values-4/#percentages
function percentage(token, getNextToken, opts) {
  // ... corresponds to the <percentage-token> production
  if (token === null || token.type !== types$L.Percentage) {
    return 0;
  }

  // check range if specified
  if (outOfRange(opts, token.value, token.value.length - 1)) {
    return 0;
  }

  return 1;
}

// =========================
// Numeric
//

// https://drafts.csswg.org/css-values-4/#numbers
// The value <zero> represents a literal number with the value 0. Expressions that merely
// evaluate to a <number> with the value 0 (for example, calc(0)) do not match <zero>;
// only literal <number-token>s do.
function zero(next) {
  if (typeof next !== "function") {
    next = function () {
      return 0;
    };
  }

  return function (token, getNextToken, opts) {
    if (token !== null && token.type === types$L.Number) {
      if (Number(token.value) === 0) {
        return 1;
      }
    }

    return next(token, getNextToken, opts);
  };
}

//  5.3. Real Numbers: the <number> type
// https://drafts.csswg.org/css-values-4/#numbers
// Number values are denoted by <number>, and represent real numbers, possibly with a fractional component.
// ... It corresponds to the <number-token> production
function number(token, getNextToken, opts) {
  if (token === null) {
    return 0;
  }

  const numberEnd = utils$e.consumeNumber(token.value, 0);
  const isNumber = numberEnd === token.value.length;
  if (!isNumber && !isPostfixIeHack(token.value, numberEnd)) {
    return 0;
  }

  // check range if specified
  if (outOfRange(opts, token.value, numberEnd)) {
    return 0;
  }

  return 1;
}

// 5.2. Integers: the <integer> type
// https://drafts.csswg.org/css-values-4/#integers
function integer(token, getNextToken, opts) {
  // ... corresponds to a subset of the <number-token> production
  if (token === null || token.type !== types$L.Number) {
    return 0;
  }

  // The first digit of an integer may be immediately preceded by `-` or `+` to indicate the integers sign.
  let i =
    charCodeAt(token.value, 0) === 0x002b || // U+002B PLUS SIGN (+)
    charCodeAt(token.value, 0) === 0x002d
      ? 1
      : 0; // U+002D HYPHEN-MINUS (-)

  // When written literally, an integer is one or more decimal digits 0 through 9 ...
  for (; i < token.value.length; i++) {
    if (!charCodeDefinitions$6.isDigit(charCodeAt(token.value, i))) {
      return 0;
    }
  }

  // check range if specified
  if (outOfRange(opts, token.value, i)) {
    return 0;
  }

  return 1;
}

const genericSyntaxes = {
  // token types
  "ident-token": tokenType(types$L.Ident),
  "function-token": tokenType(types$L.Function),
  "at-keyword-token": tokenType(types$L.AtKeyword),
  "hash-token": tokenType(types$L.Hash),
  "string-token": tokenType(types$L.String),
  "bad-string-token": tokenType(types$L.BadString),
  "url-token": tokenType(types$L.Url),
  "bad-url-token": tokenType(types$L.BadUrl),
  "delim-token": tokenType(types$L.Delim),
  "number-token": tokenType(types$L.Number),
  "percentage-token": tokenType(types$L.Percentage),
  "dimension-token": tokenType(types$L.Dimension),
  "whitespace-token": tokenType(types$L.WhiteSpace),
  "CDO-token": tokenType(types$L.CDO),
  "CDC-token": tokenType(types$L.CDC),
  "colon-token": tokenType(types$L.Colon),
  "semicolon-token": tokenType(types$L.Semicolon),
  "comma-token": tokenType(types$L.Comma),
  "[-token": tokenType(types$L.LeftSquareBracket),
  "]-token": tokenType(types$L.RightSquareBracket),
  "(-token": tokenType(types$L.LeftParenthesis),
  ")-token": tokenType(types$L.RightParenthesis),
  "{-token": tokenType(types$L.LeftCurlyBracket),
  "}-token": tokenType(types$L.RightCurlyBracket),

  // token type aliases
  string: tokenType(types$L.String),
  ident: tokenType(types$L.Ident),

  // complex types
  "custom-ident": customIdent,
  "custom-property-name": customPropertyName,
  "hex-color": hexColor,
  "id-selector": idSelector, // element( <id-selector> )
  "an-plus-b": genericAnPlusB,
  urange: genericUrange,
  "declaration-value": declarationValue,
  "any-value": anyValue,

  // dimensions
  dimension: calc(dimension(null)),
  angle: calc(dimension(ANGLE)),
  decibel: calc(dimension(DECIBEL)),
  frequency: calc(dimension(FREQUENCY)),
  flex: calc(dimension(FLEX)),
  length: calc(zero(dimension(LENGTH))),
  resolution: calc(dimension(RESOLUTION)),
  semitones: calc(dimension(SEMITONES)),
  time: calc(dimension(TIME)),

  // percentage
  percentage: calc(percentage),

  // numeric
  zero: zero(),
  number: calc(number),
  integer: calc(integer),
};

var generic$1 = genericSyntaxes;

const index$9 = tokenizer$2;

const astToTokens = {
  decorator(handlers) {
    const tokens = [];
    let curNode = null;

    return {
      ...handlers,
      node(node) {
        const tmp = curNode;
        curNode = node;
        handlers.node.call(this, node);
        curNode = tmp;
      },
      emit(value, type, auto) {
        tokens.push({
          type,
          value,
          node: auto ? null : curNode,
        });
      },
      result() {
        return tokens;
      },
    };
  },
};

function stringToTokens(str) {
  const tokens = [];

  index$9.tokenize(str, (type, start, end) =>
    tokens.push({
      type,
      value: str.slice(start, end),
      node: null,
    }),
  );

  return tokens;
}

function prepareTokens$1(value, syntax) {
  if (typeof value === "string") {
    return stringToTokens(value);
  }

  return syntax.generate(value, astToTokens);
}

var prepareTokens_1 = prepareTokens$1;

var matchGraph$2 = {};

var parse$P = {};

var tokenizer$1 = {};

var _SyntaxError = {};

const createCustomError = createCustomError$4;

function SyntaxError$3(message, input, offset) {
  return Object.assign(
    createCustomError.createCustomError("SyntaxError", message),
    {
      input,
      offset,
      rawMessage: message,
      message:
        message +
        "\n" +
        "  " +
        input +
        "\n" +
        "--" +
        new Array((offset || input.length) + 1).join("-") +
        "^",
    },
  );
}

_SyntaxError.SyntaxError = SyntaxError$3;

const SyntaxError$2 = _SyntaxError;

const TAB$1 = 9;
const N$2 = 10;
const F$1 = 12;
const R$1 = 13;
const SPACE$3 = 32;

class Tokenizer {
  constructor(str) {
    this.str = str;
    this.pos = 0;
  }
  charCodeAt(pos) {
    return pos < this.str.length ? this.str.charCodeAt(pos) : 0;
  }
  charCode() {
    return this.charCodeAt(this.pos);
  }
  nextCharCode() {
    return this.charCodeAt(this.pos + 1);
  }
  nextNonWsCode(pos) {
    return this.charCodeAt(this.findWsEnd(pos));
  }
  findWsEnd(pos) {
    for (; pos < this.str.length; pos++) {
      const code = this.str.charCodeAt(pos);
      if (
        code !== R$1 &&
        code !== N$2 &&
        code !== F$1 &&
        code !== SPACE$3 &&
        code !== TAB$1
      ) {
        break;
      }
    }

    return pos;
  }
  substringToPos(end) {
    return this.str.substring(this.pos, (this.pos = end));
  }
  eat(code) {
    if (this.charCode() !== code) {
      this.error("Expect `" + String.fromCharCode(code) + "`");
    }

    this.pos++;
  }
  peek() {
    return this.pos < this.str.length ? this.str.charAt(this.pos++) : "";
  }
  error(message) {
    throw new SyntaxError$2.SyntaxError(message, this.str, this.pos);
  }
}

tokenizer$1.Tokenizer = Tokenizer;

const tokenizer = tokenizer$1;

const TAB = 9;
const N$1 = 10;
const F = 12;
const R = 13;
const SPACE$2 = 32;
const EXCLAMATIONMARK$2 = 33; // !
const NUMBERSIGN$3 = 35; // #
const AMPERSAND$1 = 38; // &
const APOSTROPHE$2 = 39; // '
const LEFTPARENTHESIS$2 = 40; // (
const RIGHTPARENTHESIS$2 = 41; // )
const ASTERISK$6 = 42; // *
const PLUSSIGN$6 = 43; // +
const COMMA = 44; // ,
const HYPERMINUS = 45; // -
const LESSTHANSIGN = 60; // <
const GREATERTHANSIGN$2 = 62; // >
const QUESTIONMARK$1 = 63; // ?
const COMMERCIALAT = 64; // @
const LEFTSQUAREBRACKET = 91; // [
const RIGHTSQUAREBRACKET = 93; // ]
const LEFTCURLYBRACKET = 123; // {
const VERTICALLINE$3 = 124; // |
const RIGHTCURLYBRACKET = 125; // }
const INFINITY = 8734; // 
const NAME_CHAR = new Uint8Array(128).map((_, idx) =>
  /[a-zA-Z0-9\-]/.test(String.fromCharCode(idx)) ? 1 : 0,
);
const COMBINATOR_PRECEDENCE = {
  " ": 1,
  "&&": 2,
  "||": 3,
  "|": 4,
};

function scanSpaces(tokenizer) {
  return tokenizer.substringToPos(tokenizer.findWsEnd(tokenizer.pos));
}

function scanWord(tokenizer) {
  let end = tokenizer.pos;

  for (; end < tokenizer.str.length; end++) {
    const code = tokenizer.str.charCodeAt(end);
    if (code >= 128 || NAME_CHAR[code] === 0) {
      break;
    }
  }

  if (tokenizer.pos === end) {
    tokenizer.error("Expect a keyword");
  }

  return tokenizer.substringToPos(end);
}

function scanNumber(tokenizer) {
  let end = tokenizer.pos;

  for (; end < tokenizer.str.length; end++) {
    const code = tokenizer.str.charCodeAt(end);
    if (code < 48 || code > 57) {
      break;
    }
  }

  if (tokenizer.pos === end) {
    tokenizer.error("Expect a number");
  }

  return tokenizer.substringToPos(end);
}

function scanString(tokenizer) {
  const end = tokenizer.str.indexOf("'", tokenizer.pos + 1);

  if (end === -1) {
    tokenizer.pos = tokenizer.str.length;
    tokenizer.error("Expect an apostrophe");
  }

  return tokenizer.substringToPos(end + 1);
}

function readMultiplierRange(tokenizer) {
  let min = null;
  let max = null;

  tokenizer.eat(LEFTCURLYBRACKET);

  min = scanNumber(tokenizer);

  if (tokenizer.charCode() === COMMA) {
    tokenizer.pos++;
    if (tokenizer.charCode() !== RIGHTCURLYBRACKET) {
      max = scanNumber(tokenizer);
    }
  } else {
    max = min;
  }

  tokenizer.eat(RIGHTCURLYBRACKET);

  return {
    min: Number(min),
    max: max ? Number(max) : 0,
  };
}

function readMultiplier(tokenizer) {
  let range = null;
  let comma = false;

  switch (tokenizer.charCode()) {
    case ASTERISK$6:
      tokenizer.pos++;

      range = {
        min: 0,
        max: 0,
      };

      break;

    case PLUSSIGN$6:
      tokenizer.pos++;

      range = {
        min: 1,
        max: 0,
      };

      break;

    case QUESTIONMARK$1:
      tokenizer.pos++;

      range = {
        min: 0,
        max: 1,
      };

      break;

    case NUMBERSIGN$3:
      tokenizer.pos++;

      comma = true;

      if (tokenizer.charCode() === LEFTCURLYBRACKET) {
        range = readMultiplierRange(tokenizer);
      } else if (tokenizer.charCode() === QUESTIONMARK$1) {
        // https://www.w3.org/TR/css-values-4/#component-multipliers
        // > the # and ? multipliers may be stacked as #?
        // In this case just treat "#?" as a single multiplier
        // { min: 0, max: 0, comma: true }
        tokenizer.pos++;
        range = {
          min: 0,
          max: 0,
        };
      } else {
        range = {
          min: 1,
          max: 0,
        };
      }

      break;

    case LEFTCURLYBRACKET:
      range = readMultiplierRange(tokenizer);
      break;

    default:
      return null;
  }

  return {
    type: "Multiplier",
    comma,
    min: range.min,
    max: range.max,
    term: null,
  };
}

function maybeMultiplied(tokenizer, node) {
  const multiplier = readMultiplier(tokenizer);

  if (multiplier !== null) {
    multiplier.term = node;

    // https://www.w3.org/TR/css-values-4/#component-multipliers
    // > The + and # multipliers may be stacked as +#;
    // Represent "+#" as nested multipliers:
    // { ...<multiplier #>,
    //   term: {
    //     ...<multipler +>,
    //     term: node
    //   }
    // }
    if (
      tokenizer.charCode() === NUMBERSIGN$3 &&
      tokenizer.charCodeAt(tokenizer.pos - 1) === PLUSSIGN$6
    ) {
      return maybeMultiplied(tokenizer, multiplier);
    }

    return multiplier;
  }

  return node;
}

function maybeToken(tokenizer) {
  const ch = tokenizer.peek();

  if (ch === "") {
    return null;
  }

  return {
    type: "Token",
    value: ch,
  };
}

function readProperty$1(tokenizer) {
  let name;

  tokenizer.eat(LESSTHANSIGN);
  tokenizer.eat(APOSTROPHE$2);

  name = scanWord(tokenizer);

  tokenizer.eat(APOSTROPHE$2);
  tokenizer.eat(GREATERTHANSIGN$2);

  return maybeMultiplied(tokenizer, {
    type: "Property",
    name,
  });
}

// https://drafts.csswg.org/css-values-3/#numeric-ranges
// 4.1. Range Restrictions and Range Definition Notation
//
// Range restrictions can be annotated in the numeric type notation using CSS bracketed
// range notation[min,max]within the angle brackets, after the identifying keyword,
// indicating a closed range between (and including) min and max.
// For example, <integer [0, 10]> indicates an integer between 0 and 10, inclusive.
function readTypeRange(tokenizer) {
  // use null for Infinity to make AST format JSON serializable/deserializable
  let min = null; // -Infinity
  let max = null; // Infinity
  let sign = 1;

  tokenizer.eat(LEFTSQUAREBRACKET);

  if (tokenizer.charCode() === HYPERMINUS) {
    tokenizer.peek();
    sign = -1;
  }

  if (sign == -1 && tokenizer.charCode() === INFINITY) {
    tokenizer.peek();
  } else {
    min = sign * Number(scanNumber(tokenizer));

    if (NAME_CHAR[tokenizer.charCode()] !== 0) {
      min += scanWord(tokenizer);
    }
  }

  scanSpaces(tokenizer);
  tokenizer.eat(COMMA);
  scanSpaces(tokenizer);

  if (tokenizer.charCode() === INFINITY) {
    tokenizer.peek();
  } else {
    sign = 1;

    if (tokenizer.charCode() === HYPERMINUS) {
      tokenizer.peek();
      sign = -1;
    }

    max = sign * Number(scanNumber(tokenizer));

    if (NAME_CHAR[tokenizer.charCode()] !== 0) {
      max += scanWord(tokenizer);
    }
  }

  tokenizer.eat(RIGHTSQUAREBRACKET);

  return {
    type: "Range",
    min,
    max,
  };
}

function readType(tokenizer) {
  let name;
  let opts = null;

  tokenizer.eat(LESSTHANSIGN);
  name = scanWord(tokenizer);

  if (
    tokenizer.charCode() === LEFTPARENTHESIS$2 &&
    tokenizer.nextCharCode() === RIGHTPARENTHESIS$2
  ) {
    tokenizer.pos += 2;
    name += "()";
  }

  if (
    tokenizer.charCodeAt(tokenizer.findWsEnd(tokenizer.pos)) ===
    LEFTSQUAREBRACKET
  ) {
    scanSpaces(tokenizer);
    opts = readTypeRange(tokenizer);
  }

  tokenizer.eat(GREATERTHANSIGN$2);

  return maybeMultiplied(tokenizer, {
    type: "Type",
    name,
    opts,
  });
}

function readKeywordOrFunction(tokenizer) {
  const name = scanWord(tokenizer);

  if (tokenizer.charCode() === LEFTPARENTHESIS$2) {
    tokenizer.pos++;

    return {
      type: "Function",
      name,
    };
  }

  return maybeMultiplied(tokenizer, {
    type: "Keyword",
    name,
  });
}

function regroupTerms(terms, combinators) {
  function createGroup(terms, combinator) {
    return {
      type: "Group",
      terms,
      combinator,
      disallowEmpty: false,
      explicit: false,
    };
  }

  let combinator;

  combinators = Object.keys(combinators).sort(
    (a, b) => COMBINATOR_PRECEDENCE[a] - COMBINATOR_PRECEDENCE[b],
  );

  while (combinators.length > 0) {
    combinator = combinators.shift();

    let i = 0;
    let subgroupStart = 0;

    for (; i < terms.length; i++) {
      const term = terms[i];

      if (term.type === "Combinator") {
        if (term.value === combinator) {
          if (subgroupStart === -1) {
            subgroupStart = i - 1;
          }
          terms.splice(i, 1);
          i--;
        } else {
          if (subgroupStart !== -1 && i - subgroupStart > 1) {
            terms.splice(
              subgroupStart,
              i - subgroupStart,
              createGroup(terms.slice(subgroupStart, i), combinator),
            );
            i = subgroupStart + 1;
          }
          subgroupStart = -1;
        }
      }
    }

    if (subgroupStart !== -1 && combinators.length) {
      terms.splice(
        subgroupStart,
        i - subgroupStart,
        createGroup(terms.slice(subgroupStart, i), combinator),
      );
    }
  }

  return combinator;
}

function readImplicitGroup(tokenizer) {
  const terms = [];
  const combinators = {};
  let token;
  let prevToken = null;
  let prevTokenPos = tokenizer.pos;

  while ((token = peek(tokenizer))) {
    if (token.type !== "Spaces") {
      if (token.type === "Combinator") {
        // check for combinator in group beginning and double combinator sequence
        if (prevToken === null || prevToken.type === "Combinator") {
          tokenizer.pos = prevTokenPos;
          tokenizer.error("Unexpected combinator");
        }

        combinators[token.value] = true;
      } else if (prevToken !== null && prevToken.type !== "Combinator") {
        combinators[" "] = true; // a b
        terms.push({
          type: "Combinator",
          value: " ",
        });
      }

      terms.push(token);
      prevToken = token;
      prevTokenPos = tokenizer.pos;
    }
  }

  // check for combinator in group ending
  if (prevToken !== null && prevToken.type === "Combinator") {
    tokenizer.pos -= prevTokenPos;
    tokenizer.error("Unexpected combinator");
  }

  return {
    type: "Group",
    terms,
    combinator: regroupTerms(terms, combinators) || " ",
    disallowEmpty: false,
    explicit: false,
  };
}

function readGroup(tokenizer) {
  let result;

  tokenizer.eat(LEFTSQUAREBRACKET);
  result = readImplicitGroup(tokenizer);
  tokenizer.eat(RIGHTSQUAREBRACKET);

  result.explicit = true;

  if (tokenizer.charCode() === EXCLAMATIONMARK$2) {
    tokenizer.pos++;
    result.disallowEmpty = true;
  }

  return result;
}

function peek(tokenizer) {
  let code = tokenizer.charCode();

  if (code < 128 && NAME_CHAR[code] === 1) {
    return readKeywordOrFunction(tokenizer);
  }

  switch (code) {
    case RIGHTSQUAREBRACKET:
      // don't eat, stop scan a group
      break;

    case LEFTSQUAREBRACKET:
      return maybeMultiplied(tokenizer, readGroup(tokenizer));

    case LESSTHANSIGN:
      return tokenizer.nextCharCode() === APOSTROPHE$2
        ? readProperty$1(tokenizer)
        : readType(tokenizer);

    case VERTICALLINE$3:
      return {
        type: "Combinator",
        value: tokenizer.substringToPos(
          tokenizer.pos + (tokenizer.nextCharCode() === VERTICALLINE$3 ? 2 : 1),
        ),
      };

    case AMPERSAND$1:
      tokenizer.pos++;
      tokenizer.eat(AMPERSAND$1);

      return {
        type: "Combinator",
        value: "&&",
      };

    case COMMA:
      tokenizer.pos++;
      return {
        type: "Comma",
      };

    case APOSTROPHE$2:
      return maybeMultiplied(tokenizer, {
        type: "String",
        value: scanString(tokenizer),
      });

    case SPACE$2:
    case TAB:
    case N$1:
    case R:
    case F:
      return {
        type: "Spaces",
        value: scanSpaces(tokenizer),
      };

    case COMMERCIALAT:
      code = tokenizer.nextCharCode();

      if (code < 128 && NAME_CHAR[code] === 1) {
        tokenizer.pos++;
        return {
          type: "AtKeyword",
          name: scanWord(tokenizer),
        };
      }

      return maybeToken(tokenizer);

    case ASTERISK$6:
    case PLUSSIGN$6:
    case QUESTIONMARK$1:
    case NUMBERSIGN$3:
    case EXCLAMATIONMARK$2:
      // prohibited tokens (used as a multiplier start)
      break;

    case LEFTCURLYBRACKET:
      // LEFTCURLYBRACKET is allowed since mdn/data uses it w/o quoting
      // check next char isn't a number, because it's likely a disjoined multiplier
      code = tokenizer.nextCharCode();

      if (code < 48 || code > 57) {
        return maybeToken(tokenizer);
      }

      break;

    default:
      return maybeToken(tokenizer);
  }
}

function parse$O(source) {
  const tokenizer$1 = new tokenizer.Tokenizer(source);
  const result = readImplicitGroup(tokenizer$1);

  if (tokenizer$1.pos !== source.length) {
    tokenizer$1.error("Unexpected input");
  }

  // reduce redundant groups with single group term
  if (result.terms.length === 1 && result.terms[0].type === "Group") {
    return result.terms[0];
  }

  return result;
}

parse$P.parse = parse$O;

const parse$N = parse$P;

const MATCH = { type: "Match" };
const MISMATCH = { type: "Mismatch" };
const DISALLOW_EMPTY = { type: "DisallowEmpty" };

const LEFTPARENTHESIS$1 = 40; // (
const RIGHTPARENTHESIS$1 = 41; // )

function createCondition(match, thenBranch, elseBranch) {
  // reduce node count
  if (thenBranch === MATCH && elseBranch === MISMATCH) {
    return match;
  }

  if (match === MATCH && thenBranch === MATCH && elseBranch === MATCH) {
    return match;
  }

  if (match.type === "If" && match.else === MISMATCH && thenBranch === MATCH) {
    thenBranch = match.then;
    match = match.match;
  }

  return {
    type: "If",
    match,
    then: thenBranch,
    else: elseBranch,
  };
}

function isFunctionType(name) {
  return (
    name.length > 2 &&
    name.charCodeAt(name.length - 2) === LEFTPARENTHESIS$1 &&
    name.charCodeAt(name.length - 1) === RIGHTPARENTHESIS$1
  );
}

function isEnumCapatible(term) {
  return (
    term.type === "Keyword" ||
    term.type === "AtKeyword" ||
    term.type === "Function" ||
    (term.type === "Type" && isFunctionType(term.name))
  );
}

function buildGroupMatchGraph(combinator, terms, atLeastOneTermMatched) {
  switch (combinator) {
    case " ": {
      // Juxtaposing components means that all of them must occur, in the given order.
      //
      // a b c
      // =
      // match a
      //   then match b
      //     then match c
      //       then MATCH
      //       else MISMATCH
      //     else MISMATCH
      //   else MISMATCH
      let result = MATCH;

      for (let i = terms.length - 1; i >= 0; i--) {
        const term = terms[i];

        result = createCondition(term, result, MISMATCH);
      }
      return result;
    }

    case "|": {
      // A bar (|) separates two or more alternatives: exactly one of them must occur.
      //
      // a | b | c
      // =
      // match a
      //   then MATCH
      //   else match b
      //     then MATCH
      //     else match c
      //       then MATCH
      //       else MISMATCH

      let result = MISMATCH;
      let map = null;

      for (let i = terms.length - 1; i >= 0; i--) {
        let term = terms[i];

        // reduce sequence of keywords into a Enum
        if (isEnumCapatible(term)) {
          if (map === null && i > 0 && isEnumCapatible(terms[i - 1])) {
            map = Object.create(null);
            result = createCondition(
              {
                type: "Enum",
                map,
              },
              MATCH,
              result,
            );
          }

          if (map !== null) {
            const key = (
              isFunctionType(term.name) ? term.name.slice(0, -1) : term.name
            ).toLowerCase();
            if (key in map === false) {
              map[key] = term;
              continue;
            }
          }
        }

        map = null;

        // create a new conditonal node
        result = createCondition(term, MATCH, result);
      }
      return result;
    }

    case "&&": {
      // A double ampersand (&&) separates two or more components,
      // all of which must occur, in any order.

      // Use MatchOnce for groups with a large number of terms,
      // since &&-groups produces at least N!-node trees
      if (terms.length > 5) {
        return {
          type: "MatchOnce",
          terms,
          all: true,
        };
      }

      // Use a combination tree for groups with small number of terms
      //
      // a && b && c
      // =
      // match a
      //   then [b && c]
      //   else match b
      //     then [a && c]
      //     else match c
      //       then [a && b]
      //       else MISMATCH
      //
      // a && b
      // =
      // match a
      //   then match b
      //     then MATCH
      //     else MISMATCH
      //   else match b
      //     then match a
      //       then MATCH
      //       else MISMATCH
      //     else MISMATCH
      let result = MISMATCH;

      for (let i = terms.length - 1; i >= 0; i--) {
        const term = terms[i];
        let thenClause;

        if (terms.length > 1) {
          thenClause = buildGroupMatchGraph(
            combinator,
            terms.filter(function (newGroupTerm) {
              return newGroupTerm !== term;
            }),
            false,
          );
        } else {
          thenClause = MATCH;
        }

        result = createCondition(term, thenClause, result);
      }
      return result;
    }

    case "||": {
      // A double bar (||) separates two or more options:
      // one or more of them must occur, in any order.

      // Use MatchOnce for groups with a large number of terms,
      // since ||-groups produces at least N!-node trees
      if (terms.length > 5) {
        return {
          type: "MatchOnce",
          terms,
          all: false,
        };
      }

      // Use a combination tree for groups with small number of terms
      //
      // a || b || c
      // =
      // match a
      //   then [b || c]
      //   else match b
      //     then [a || c]
      //     else match c
      //       then [a || b]
      //       else MISMATCH
      //
      // a || b
      // =
      // match a
      //   then match b
      //     then MATCH
      //     else MATCH
      //   else match b
      //     then match a
      //       then MATCH
      //       else MATCH
      //     else MISMATCH
      let result = atLeastOneTermMatched ? MATCH : MISMATCH;

      for (let i = terms.length - 1; i >= 0; i--) {
        const term = terms[i];
        let thenClause;

        if (terms.length > 1) {
          thenClause = buildGroupMatchGraph(
            combinator,
            terms.filter(function (newGroupTerm) {
              return newGroupTerm !== term;
            }),
            true,
          );
        } else {
          thenClause = MATCH;
        }

        result = createCondition(term, thenClause, result);
      }
      return result;
    }
  }
}

function buildMultiplierMatchGraph(node) {
  let result = MATCH;
  let matchTerm = buildMatchGraphInternal(node.term);

  if (node.max === 0) {
    // disable repeating of empty match to prevent infinite loop
    matchTerm = createCondition(matchTerm, DISALLOW_EMPTY, MISMATCH);

    // an occurrence count is not limited, make a cycle;
    // to collect more terms on each following matching mismatch
    result = createCondition(
      matchTerm,
      null, // will be a loop
      MISMATCH,
    );

    result.then = createCondition(
      MATCH,
      MATCH,
      result, // make a loop
    );

    if (node.comma) {
      result.then.else = createCondition(
        { type: "Comma", syntax: node },
        result,
        MISMATCH,
      );
    }
  } else {
    // create a match node chain for [min .. max] interval with optional matches
    for (let i = node.min || 1; i <= node.max; i++) {
      if (node.comma && result !== MATCH) {
        result = createCondition(
          { type: "Comma", syntax: node },
          result,
          MISMATCH,
        );
      }

      result = createCondition(
        matchTerm,
        createCondition(MATCH, MATCH, result),
        MISMATCH,
      );
    }
  }

  if (node.min === 0) {
    // allow zero match
    result = createCondition(MATCH, MATCH, result);
  } else {
    // create a match node chain to collect [0 ... min - 1] required matches
    for (let i = 0; i < node.min - 1; i++) {
      if (node.comma && result !== MATCH) {
        result = createCondition(
          { type: "Comma", syntax: node },
          result,
          MISMATCH,
        );
      }

      result = createCondition(matchTerm, result, MISMATCH);
    }
  }

  return result;
}

function buildMatchGraphInternal(node) {
  if (typeof node === "function") {
    return {
      type: "Generic",
      fn: node,
    };
  }

  switch (node.type) {
    case "Group": {
      let result = buildGroupMatchGraph(
        node.combinator,
        node.terms.map(buildMatchGraphInternal),
        false,
      );

      if (node.disallowEmpty) {
        result = createCondition(result, DISALLOW_EMPTY, MISMATCH);
      }

      return result;
    }

    case "Multiplier":
      return buildMultiplierMatchGraph(node);

    case "Type":
    case "Property":
      return {
        type: node.type,
        name: node.name,
        syntax: node,
      };

    case "Keyword":
      return {
        type: node.type,
        name: node.name.toLowerCase(),
        syntax: node,
      };

    case "AtKeyword":
      return {
        type: node.type,
        name: "@" + node.name.toLowerCase(),
        syntax: node,
      };

    case "Function":
      return {
        type: node.type,
        name: node.name.toLowerCase() + "(",
        syntax: node,
      };

    case "String":
      // convert a one char length String to a Token
      if (node.value.length === 3) {
        return {
          type: "Token",
          value: node.value.charAt(1),
          syntax: node,
        };
      }

      // otherwise use it as is
      return {
        type: node.type,
        value: node.value.substr(1, node.value.length - 2).replace(/\\'/g, "'"),
        syntax: node,
      };

    case "Token":
      return {
        type: node.type,
        value: node.value,
        syntax: node,
      };

    case "Comma":
      return {
        type: node.type,
        syntax: node,
      };

    default:
      throw new Error("Unknown node type:", node.type);
  }
}

function buildMatchGraph(syntaxTree, ref) {
  if (typeof syntaxTree === "string") {
    syntaxTree = parse$N.parse(syntaxTree);
  }

  return {
    type: "MatchGraph",
    match: buildMatchGraphInternal(syntaxTree),
    syntax: ref || null,
    source: syntaxTree,
  };
}

matchGraph$2.DISALLOW_EMPTY = DISALLOW_EMPTY;
matchGraph$2.MATCH = MATCH;
matchGraph$2.MISMATCH = MISMATCH;
matchGraph$2.buildMatchGraph = buildMatchGraph;

var match$1 = {};

const matchGraph$1 = matchGraph$2;
const types$K = types$U;

const { hasOwnProperty: hasOwnProperty$8 } = Object.prototype;
const STUB = 0;
const TOKEN = 1;
const OPEN_SYNTAX = 2;
const CLOSE_SYNTAX = 3;

const EXIT_REASON_MATCH = "Match";
const EXIT_REASON_MISMATCH = "Mismatch";
const EXIT_REASON_ITERATION_LIMIT =
  "Maximum iteration number exceeded (please fill an issue on https://github.com/csstree/csstree/issues)";

const ITERATION_LIMIT = 15000;

function reverseList(list) {
  let prev = null;
  let next = null;
  let item = list;

  while (item !== null) {
    next = item.prev;
    item.prev = prev;
    prev = item;
    item = next;
  }

  return prev;
}

function areStringsEqualCaseInsensitive(testStr, referenceStr) {
  if (testStr.length !== referenceStr.length) {
    return false;
  }

  for (let i = 0; i < testStr.length; i++) {
    const referenceCode = referenceStr.charCodeAt(i);
    let testCode = testStr.charCodeAt(i);

    // testCode.toLowerCase() for U+0041 LATIN CAPITAL LETTER A (A) .. U+005A LATIN CAPITAL LETTER Z (Z).
    if (testCode >= 0x0041 && testCode <= 0x005a) {
      testCode = testCode | 32;
    }

    if (testCode !== referenceCode) {
      return false;
    }
  }

  return true;
}

function isContextEdgeDelim(token) {
  if (token.type !== types$K.Delim) {
    return false;
  }

  // Fix matching for unicode-range: U+30??, U+FF00-FF9F
  // Probably we need to check out previous match instead
  return token.value !== "?";
}

function isCommaContextStart(token) {
  if (token === null) {
    return true;
  }

  return (
    token.type === types$K.Comma ||
    token.type === types$K.Function ||
    token.type === types$K.LeftParenthesis ||
    token.type === types$K.LeftSquareBracket ||
    token.type === types$K.LeftCurlyBracket ||
    isContextEdgeDelim(token)
  );
}

function isCommaContextEnd(token) {
  if (token === null) {
    return true;
  }

  return (
    token.type === types$K.RightParenthesis ||
    token.type === types$K.RightSquareBracket ||
    token.type === types$K.RightCurlyBracket ||
    (token.type === types$K.Delim && token.value === "/")
  );
}

function internalMatch(tokens, state, syntaxes) {
  function moveToNextToken() {
    do {
      tokenIndex++;
      token = tokenIndex < tokens.length ? tokens[tokenIndex] : null;
    } while (
      token !== null &&
      (token.type === types$K.WhiteSpace || token.type === types$K.Comment)
    );
  }

  function getNextToken(offset) {
    const nextIndex = tokenIndex + offset;

    return nextIndex < tokens.length ? tokens[nextIndex] : null;
  }

  function stateSnapshotFromSyntax(nextState, prev) {
    return {
      nextState,
      matchStack,
      syntaxStack,
      thenStack,
      tokenIndex,
      prev,
    };
  }

  function pushThenStack(nextState) {
    thenStack = {
      nextState,
      matchStack,
      syntaxStack,
      prev: thenStack,
    };
  }

  function pushElseStack(nextState) {
    elseStack = stateSnapshotFromSyntax(nextState, elseStack);
  }

  function addTokenToMatch() {
    matchStack = {
      type: TOKEN,
      syntax: state.syntax,
      token,
      prev: matchStack,
    };

    moveToNextToken();
    syntaxStash = null;

    if (tokenIndex > longestMatch) {
      longestMatch = tokenIndex;
    }
  }

  function openSyntax() {
    syntaxStack = {
      syntax: state.syntax,
      opts:
        state.syntax.opts || (syntaxStack !== null && syntaxStack.opts) || null,
      prev: syntaxStack,
    };

    matchStack = {
      type: OPEN_SYNTAX,
      syntax: state.syntax,
      token: matchStack.token,
      prev: matchStack,
    };
  }

  function closeSyntax() {
    if (matchStack.type === OPEN_SYNTAX) {
      matchStack = matchStack.prev;
    } else {
      matchStack = {
        type: CLOSE_SYNTAX,
        syntax: syntaxStack.syntax,
        token: matchStack.token,
        prev: matchStack,
      };
    }

    syntaxStack = syntaxStack.prev;
  }

  let syntaxStack = null;
  let thenStack = null;
  let elseStack = null;

  // null  stashing allowed, nothing stashed
  // false  stashing disabled, nothing stashed
  // anithing else  fail stashable syntaxes, some syntax stashed
  let syntaxStash = null;

  let iterationCount = 0; // count iterations and prevent infinite loop
  let exitReason = null;

  let token = null;
  let tokenIndex = -1;
  let longestMatch = 0;
  let matchStack = {
    type: STUB,
    syntax: null,
    token: null,
    prev: null,
  };

  moveToNextToken();

  while (exitReason === null && ++iterationCount < ITERATION_LIMIT) {
    // function mapList(list, fn) {
    //     const result = [];
    //     while (list) {
    //         result.unshift(fn(list));
    //         list = list.prev;
    //     }
    //     return result;
    // }
    // console.log('--\n',
    //     '#' + iterationCount,
    //     require('util').inspect({
    //         match: mapList(matchStack, x => x.type === TOKEN ? x.token && x.token.value : x.syntax ? ({ [OPEN_SYNTAX]: '<', [CLOSE_SYNTAX]: '</' }[x.type] || x.type) + '!' + x.syntax.name : null),
    //         token: token && token.value,
    //         tokenIndex,
    //         syntax: syntax.type + (syntax.id ? ' #' + syntax.id : '')
    //     }, { depth: null })
    // );
    switch (state.type) {
      case "Match":
        if (thenStack === null) {
          // turn to MISMATCH when some tokens left unmatched
          if (token !== null) {
            // doesn't mismatch if just one token left and it's an IE hack
            if (
              tokenIndex !== tokens.length - 1 ||
              (token.value !== "\\0" && token.value !== "\\9")
            ) {
              state = matchGraph$1.MISMATCH;
              break;
            }
          }

          // break the main loop, return a result - MATCH
          exitReason = EXIT_REASON_MATCH;
          break;
        }

        // go to next syntax (`then` branch)
        state = thenStack.nextState;

        // check match is not empty
        if (state === matchGraph$1.DISALLOW_EMPTY) {
          if (thenStack.matchStack === matchStack) {
            state = matchGraph$1.MISMATCH;
            break;
          } else {
            state = matchGraph$1.MATCH;
          }
        }

        // close syntax if needed
        while (thenStack.syntaxStack !== syntaxStack) {
          closeSyntax();
        }

        // pop stack
        thenStack = thenStack.prev;
        break;

      case "Mismatch":
        // when some syntax is stashed
        if (syntaxStash !== null && syntaxStash !== false) {
          // there is no else branches or a branch reduce match stack
          if (elseStack === null || tokenIndex > elseStack.tokenIndex) {
            // restore state from the stash
            elseStack = syntaxStash;
            syntaxStash = false; // disable stashing
          }
        } else if (elseStack === null) {
          // no else branches -> break the main loop
          // return a result - MISMATCH
          exitReason = EXIT_REASON_MISMATCH;
          break;
        }

        // go to next syntax (`else` branch)
        state = elseStack.nextState;

        // restore all the rest stack states
        thenStack = elseStack.thenStack;
        syntaxStack = elseStack.syntaxStack;
        matchStack = elseStack.matchStack;
        tokenIndex = elseStack.tokenIndex;
        token = tokenIndex < tokens.length ? tokens[tokenIndex] : null;

        // pop stack
        elseStack = elseStack.prev;
        break;

      case "MatchGraph":
        state = state.match;
        break;

      case "If":
        // IMPORTANT: else stack push must go first,
        // since it stores the state of thenStack before changes
        if (state.else !== matchGraph$1.MISMATCH) {
          pushElseStack(state.else);
        }

        if (state.then !== matchGraph$1.MATCH) {
          pushThenStack(state.then);
        }

        state = state.match;
        break;

      case "MatchOnce":
        state = {
          type: "MatchOnceBuffer",
          syntax: state,
          index: 0,
          mask: 0,
        };
        break;

      case "MatchOnceBuffer": {
        const terms = state.syntax.terms;

        if (state.index === terms.length) {
          // no matches at all or it's required all terms to be matched
          if (state.mask === 0 || state.syntax.all) {
            state = matchGraph$1.MISMATCH;
            break;
          }

          // a partial match is ok
          state = matchGraph$1.MATCH;
          break;
        }

        // all terms are matched
        if (state.mask === (1 << terms.length) - 1) {
          state = matchGraph$1.MATCH;
          break;
        }

        for (; state.index < terms.length; state.index++) {
          const matchFlag = 1 << state.index;

          if ((state.mask & matchFlag) === 0) {
            // IMPORTANT: else stack push must go first,
            // since it stores the state of thenStack before changes
            pushElseStack(state);
            pushThenStack({
              type: "AddMatchOnce",
              syntax: state.syntax,
              mask: state.mask | matchFlag,
            });

            // match
            state = terms[state.index++];
            break;
          }
        }
        break;
      }

      case "AddMatchOnce":
        state = {
          type: "MatchOnceBuffer",
          syntax: state.syntax,
          index: 0,
          mask: state.mask,
        };
        break;

      case "Enum":
        if (token !== null) {
          let name = token.value.toLowerCase();

          // drop \0 and \9 hack from keyword name
          if (name.indexOf("\\") !== -1) {
            name = name.replace(/\\[09].*$/, "");
          }

          if (hasOwnProperty$8.call(state.map, name)) {
            state = state.map[name];
            break;
          }
        }

        state = matchGraph$1.MISMATCH;
        break;

      case "Generic": {
        const opts = syntaxStack !== null ? syntaxStack.opts : null;
        const lastTokenIndex =
          tokenIndex + Math.floor(state.fn(token, getNextToken, opts));

        if (!isNaN(lastTokenIndex) && lastTokenIndex > tokenIndex) {
          while (tokenIndex < lastTokenIndex) {
            addTokenToMatch();
          }

          state = matchGraph$1.MATCH;
        } else {
          state = matchGraph$1.MISMATCH;
        }

        break;
      }

      case "Type":
      case "Property": {
        const syntaxDict = state.type === "Type" ? "types" : "properties";
        const dictSyntax = hasOwnProperty$8.call(syntaxes, syntaxDict)
          ? syntaxes[syntaxDict][state.name]
          : null;

        if (!dictSyntax || !dictSyntax.match) {
          throw new Error(
            "Bad syntax reference: " +
              (state.type === "Type"
                ? "<" + state.name + ">"
                : "<'" + state.name + "'>"),
          );
        }

        // stash a syntax for types with low priority
        if (syntaxStash !== false && token !== null && state.type === "Type") {
          const lowPriorityMatching =
            // https://drafts.csswg.org/css-values-4/#custom-idents
            // When parsing positionally-ambiguous keywords in a property value, a <custom-ident> production
            // can only claim the keyword if no other unfulfilled production can claim it.
            (state.name === "custom-ident" && token.type === types$K.Ident) ||
            // https://drafts.csswg.org/css-values-4/#lengths
            // ... if a `0` could be parsed as either a <number> or a <length> in a property (such as line-height),
            // it must parse as a <number>
            (state.name === "length" && token.value === "0");

          if (lowPriorityMatching) {
            if (syntaxStash === null) {
              syntaxStash = stateSnapshotFromSyntax(state, elseStack);
            }

            state = matchGraph$1.MISMATCH;
            break;
          }
        }

        openSyntax();
        state = dictSyntax.match;
        break;
      }

      case "Keyword": {
        const name = state.name;

        if (token !== null) {
          let keywordName = token.value;

          // drop \0 and \9 hack from keyword name
          if (keywordName.indexOf("\\") !== -1) {
            keywordName = keywordName.replace(/\\[09].*$/, "");
          }

          if (areStringsEqualCaseInsensitive(keywordName, name)) {
            addTokenToMatch();
            state = matchGraph$1.MATCH;
            break;
          }
        }

        state = matchGraph$1.MISMATCH;
        break;
      }

      case "AtKeyword":
      case "Function":
        if (
          token !== null &&
          areStringsEqualCaseInsensitive(token.value, state.name)
        ) {
          addTokenToMatch();
          state = matchGraph$1.MATCH;
          break;
        }

        state = matchGraph$1.MISMATCH;
        break;

      case "Token":
        if (token !== null && token.value === state.value) {
          addTokenToMatch();
          state = matchGraph$1.MATCH;
          break;
        }

        state = matchGraph$1.MISMATCH;
        break;

      case "Comma":
        if (token !== null && token.type === types$K.Comma) {
          if (isCommaContextStart(matchStack.token)) {
            state = matchGraph$1.MISMATCH;
          } else {
            addTokenToMatch();
            state = isCommaContextEnd(token)
              ? matchGraph$1.MISMATCH
              : matchGraph$1.MATCH;
          }
        } else {
          state =
            isCommaContextStart(matchStack.token) || isCommaContextEnd(token)
              ? matchGraph$1.MATCH
              : matchGraph$1.MISMATCH;
        }

        break;

      case "String":
        let string = "";
        let lastTokenIndex = tokenIndex;

        for (
          ;
          lastTokenIndex < tokens.length && string.length < state.value.length;
          lastTokenIndex++
        ) {
          string += tokens[lastTokenIndex].value;
        }

        if (areStringsEqualCaseInsensitive(string, state.value)) {
          while (tokenIndex < lastTokenIndex) {
            addTokenToMatch();
          }

          state = matchGraph$1.MATCH;
        } else {
          state = matchGraph$1.MISMATCH;
        }

        break;

      default:
        throw new Error("Unknown node type: " + state.type);
    }
  }

  switch (exitReason) {
    case null:
      console.warn(
        "[csstree-match] BREAK after " + ITERATION_LIMIT + " iterations",
      );
      exitReason = EXIT_REASON_ITERATION_LIMIT;
      matchStack = null;
      break;

    case EXIT_REASON_MATCH:
      while (syntaxStack !== null) {
        closeSyntax();
      }
      break;

    default:
      matchStack = null;
  }

  return {
    tokens,
    reason: exitReason,
    iterations: iterationCount,
    match: matchStack,
    longestMatch,
  };
}

function matchAsList(tokens, matchGraph, syntaxes) {
  const matchResult = internalMatch(tokens, matchGraph, syntaxes || {});

  if (matchResult.match !== null) {
    let item = reverseList(matchResult.match).prev;

    matchResult.match = [];

    while (item !== null) {
      switch (item.type) {
        case OPEN_SYNTAX:
        case CLOSE_SYNTAX:
          matchResult.match.push({
            type: item.type,
            syntax: item.syntax,
          });
          break;

        default:
          matchResult.match.push({
            token: item.token.value,
            node: item.token.node,
          });
          break;
      }

      item = item.prev;
    }
  }

  return matchResult;
}

function matchAsTree(tokens, matchGraph, syntaxes) {
  const matchResult = internalMatch(tokens, matchGraph, syntaxes || {});

  if (matchResult.match === null) {
    return matchResult;
  }

  let item = matchResult.match;
  let host = (matchResult.match = {
    syntax: matchGraph.syntax || null,
    match: [],
  });
  const hostStack = [host];

  // revert a list and start with 2nd item since 1st is a stub item
  item = reverseList(item).prev;

  // build a tree
  while (item !== null) {
    switch (item.type) {
      case OPEN_SYNTAX:
        host.match.push(
          (host = {
            syntax: item.syntax,
            match: [],
          }),
        );
        hostStack.push(host);
        break;

      case CLOSE_SYNTAX:
        hostStack.pop();
        host = hostStack[hostStack.length - 1];
        break;

      default:
        host.match.push({
          syntax: item.syntax || null,
          token: item.token.value,
          node: item.token.node,
        });
    }

    item = item.prev;
  }

  return matchResult;
}

match$1.matchAsList = matchAsList;
match$1.matchAsTree = matchAsTree;

var trace$1 = {};

function getTrace(node) {
  function shouldPutToTrace(syntax) {
    if (syntax === null) {
      return false;
    }

    return (
      syntax.type === "Type" ||
      syntax.type === "Property" ||
      syntax.type === "Keyword"
    );
  }

  function hasMatch(matchNode) {
    if (Array.isArray(matchNode.match)) {
      // use for-loop for better perfomance
      for (let i = 0; i < matchNode.match.length; i++) {
        if (hasMatch(matchNode.match[i])) {
          if (shouldPutToTrace(matchNode.syntax)) {
            result.unshift(matchNode.syntax);
          }

          return true;
        }
      }
    } else if (matchNode.node === node) {
      result = shouldPutToTrace(matchNode.syntax) ? [matchNode.syntax] : [];

      return true;
    }

    return false;
  }

  let result = null;

  if (this.matched !== null) {
    hasMatch(this.matched);
  }

  return result;
}

function isType(node, type) {
  return testNode(
    this,
    node,
    (match) => match.type === "Type" && match.name === type,
  );
}

function isProperty(node, property) {
  return testNode(
    this,
    node,
    (match) => match.type === "Property" && match.name === property,
  );
}

function isKeyword(node) {
  return testNode(this, node, (match) => match.type === "Keyword");
}

function testNode(match, node, fn) {
  const trace = getTrace.call(match, node);

  if (trace === null) {
    return false;
  }

  return trace.some(fn);
}

trace$1.getTrace = getTrace;
trace$1.isKeyword = isKeyword;
trace$1.isProperty = isProperty;
trace$1.isType = isType;

var search$1 = {};

const List$3 = List$7;

function getFirstMatchNode(matchNode) {
  if ("node" in matchNode) {
    return matchNode.node;
  }

  return getFirstMatchNode(matchNode.match[0]);
}

function getLastMatchNode(matchNode) {
  if ("node" in matchNode) {
    return matchNode.node;
  }

  return getLastMatchNode(matchNode.match[matchNode.match.length - 1]);
}

function matchFragments(lexer, ast, match, type, name) {
  function findFragments(matchNode) {
    if (
      matchNode.syntax !== null &&
      matchNode.syntax.type === type &&
      matchNode.syntax.name === name
    ) {
      const start = getFirstMatchNode(matchNode);
      const end = getLastMatchNode(matchNode);

      lexer.syntax.walk(ast, function (node, item, list) {
        if (node === start) {
          const nodes = new List$3.List();

          do {
            nodes.appendData(item.data);

            if (item.data === end) {
              break;
            }

            item = item.next;
          } while (item !== null);

          fragments.push({
            parent: list,
            nodes,
          });
        }
      });
    }

    if (Array.isArray(matchNode.match)) {
      matchNode.match.forEach(findFragments);
    }
  }

  const fragments = [];

  if (match.matched !== null) {
    findFragments(match.matched);
  }

  return fragments;
}

search$1.matchFragments = matchFragments;

var structure$F = {};

const List$2 = List$7;

const { hasOwnProperty: hasOwnProperty$7 } = Object.prototype;

function isValidNumber(value) {
  // Number.isInteger(value) && value >= 0
  return (
    typeof value === "number" &&
    isFinite(value) &&
    Math.floor(value) === value &&
    value >= 0
  );
}

function isValidLocation(loc) {
  return (
    Boolean(loc) &&
    isValidNumber(loc.offset) &&
    isValidNumber(loc.line) &&
    isValidNumber(loc.column)
  );
}

function createNodeStructureChecker(type, fields) {
  return function checkNode(node, warn) {
    if (!node || node.constructor !== Object) {
      return warn(node, "Type of node should be an Object");
    }

    for (let key in node) {
      let valid = true;

      if (hasOwnProperty$7.call(node, key) === false) {
        continue;
      }

      if (key === "type") {
        if (node.type !== type) {
          warn(
            node,
            "Wrong node type `" + node.type + "`, expected `" + type + "`",
          );
        }
      } else if (key === "loc") {
        if (node.loc === null) {
          continue;
        } else if (node.loc && node.loc.constructor === Object) {
          if (typeof node.loc.source !== "string") {
            key += ".source";
          } else if (!isValidLocation(node.loc.start)) {
            key += ".start";
          } else if (!isValidLocation(node.loc.end)) {
            key += ".end";
          } else {
            continue;
          }
        }

        valid = false;
      } else if (fields.hasOwnProperty(key)) {
        valid = false;

        for (let i = 0; !valid && i < fields[key].length; i++) {
          const fieldType = fields[key][i];

          switch (fieldType) {
            case String:
              valid = typeof node[key] === "string";
              break;

            case Boolean:
              valid = typeof node[key] === "boolean";
              break;

            case null:
              valid = node[key] === null;
              break;

            default:
              if (typeof fieldType === "string") {
                valid = node[key] && node[key].type === fieldType;
              } else if (Array.isArray(fieldType)) {
                valid = node[key] instanceof List$2.List;
              }
          }
        }
      } else {
        warn(node, "Unknown field `" + key + "` for " + type + " node type");
      }

      if (!valid) {
        warn(node, "Bad value for `" + type + "." + key + "`");
      }
    }

    for (const key in fields) {
      if (
        hasOwnProperty$7.call(fields, key) &&
        hasOwnProperty$7.call(node, key) === false
      ) {
        warn(node, "Field `" + type + "." + key + "` is missed");
      }
    }
  };
}

function processStructure(name, nodeType) {
  const structure = nodeType.structure;
  const fields = {
    type: String,
    loc: true,
  };
  const docs = {
    type: '"' + name + '"',
  };

  for (const key in structure) {
    if (hasOwnProperty$7.call(structure, key) === false) {
      continue;
    }

    const docsTypes = [];
    const fieldTypes = (fields[key] = Array.isArray(structure[key])
      ? structure[key].slice()
      : [structure[key]]);

    for (let i = 0; i < fieldTypes.length; i++) {
      const fieldType = fieldTypes[i];
      if (fieldType === String || fieldType === Boolean) {
        docsTypes.push(fieldType.name);
      } else if (fieldType === null) {
        docsTypes.push("null");
      } else if (typeof fieldType === "string") {
        docsTypes.push("<" + fieldType + ">");
      } else if (Array.isArray(fieldType)) {
        docsTypes.push("List"); // TODO: use type enum
      } else {
        throw new Error(
          "Wrong value `" +
            fieldType +
            "` in `" +
            name +
            "." +
            key +
            "` structure definition",
        );
      }
    }

    docs[key] = docsTypes.join(" | ");
  }

  return {
    docs,
    check: createNodeStructureChecker(name, fields),
  };
}

function getStructureFromConfig(config) {
  const structure = {};

  if (config.node) {
    for (const name in config.node) {
      if (hasOwnProperty$7.call(config.node, name)) {
        const nodeType = config.node[name];

        if (nodeType.structure) {
          structure[name] = processStructure(name, nodeType);
        } else {
          throw new Error(
            "Missed `structure` field in `" + name + "` node type definition",
          );
        }
      }
    }
  }

  return structure;
}

structure$F.getStructureFromConfig = getStructureFromConfig;

var walk$5 = {};

const noop$3 = function () {};

function ensureFunction(value) {
  return typeof value === "function" ? value : noop$3;
}

function walk$4(node, options, context) {
  function walk(node) {
    enter.call(context, node);

    switch (node.type) {
      case "Group":
        node.terms.forEach(walk);
        break;

      case "Multiplier":
        walk(node.term);
        break;

      case "Type":
      case "Property":
      case "Keyword":
      case "AtKeyword":
      case "Function":
      case "String":
      case "Token":
      case "Comma":
        break;

      default:
        throw new Error("Unknown type: " + node.type);
    }

    leave.call(context, node);
  }

  let enter = noop$3;
  let leave = noop$3;

  if (typeof options === "function") {
    enter = options;
  } else if (options) {
    enter = ensureFunction(options.enter);
    leave = ensureFunction(options.leave);
  }

  if (enter === noop$3 && leave === noop$3) {
    throw new Error(
      "Neither `enter` nor `leave` walker handler is set or both aren't a function",
    );
  }

  walk(node);
}

walk$5.walk = walk$4;

const error$1 = error$2;
const names$3 = names$4;
const genericConst = genericConst$2;
const generic = generic$1;
const prepareTokens = prepareTokens_1;
const matchGraph = matchGraph$2;
const match = match$1;
const trace = trace$1;
const search = search$1;
const structure$E = structure$F;
const parse$M = parse$P;
const generate$I = generate$L;
const walk$3 = walk$5;

const cssWideKeywordsSyntax = matchGraph.buildMatchGraph(
  genericConst.cssWideKeywords.join(" | "),
);

function dumpMapSyntax(map, compact, syntaxAsAst) {
  const result = {};

  for (const name in map) {
    if (map[name].syntax) {
      result[name] = syntaxAsAst
        ? map[name].syntax
        : generate$I.generate(map[name].syntax, { compact });
    }
  }

  return result;
}

function dumpAtruleMapSyntax(map, compact, syntaxAsAst) {
  const result = {};

  for (const [name, atrule] of Object.entries(map)) {
    result[name] = {
      prelude:
        atrule.prelude &&
        (syntaxAsAst
          ? atrule.prelude.syntax
          : generate$I.generate(atrule.prelude.syntax, { compact })),
      descriptors:
        atrule.descriptors &&
        dumpMapSyntax(atrule.descriptors, compact, syntaxAsAst),
    };
  }

  return result;
}

function valueHasVar(tokens) {
  for (let i = 0; i < tokens.length; i++) {
    if (tokens[i].value.toLowerCase() === "var(") {
      return true;
    }
  }

  return false;
}

function buildMatchResult(matched, error, iterations) {
  return {
    matched,
    iterations,
    error,
    ...trace,
  };
}

function matchSyntax(lexer, syntax, value, useCssWideKeywords) {
  const tokens = prepareTokens(value, lexer.syntax);
  let result;

  if (valueHasVar(tokens)) {
    return buildMatchResult(
      null,
      new Error("Matching for a tree with var() is not supported"),
    );
  }

  if (useCssWideKeywords) {
    result = match.matchAsTree(tokens, lexer.cssWideKeywordsSyntax, lexer);
  }

  if (!useCssWideKeywords || !result.match) {
    result = match.matchAsTree(tokens, syntax.match, lexer);
    if (!result.match) {
      return buildMatchResult(
        null,
        new error$1.SyntaxMatchError(
          result.reason,
          syntax.syntax,
          value,
          result,
        ),
        result.iterations,
      );
    }
  }

  return buildMatchResult(result.match, null, result.iterations);
}

let Lexer$2 = class Lexer {
  constructor(config, syntax, structure$1) {
    this.cssWideKeywordsSyntax = cssWideKeywordsSyntax;
    this.syntax = syntax;
    this.generic = false;
    this.atrules = Object.create(null);
    this.properties = Object.create(null);
    this.types = Object.create(null);
    this.structure = structure$1 || structure$E.getStructureFromConfig(config);

    if (config) {
      if (config.types) {
        for (const name in config.types) {
          this.addType_(name, config.types[name]);
        }
      }

      if (config.generic) {
        this.generic = true;
        for (const name in generic) {
          this.addType_(name, generic[name]);
        }
      }

      if (config.atrules) {
        for (const name in config.atrules) {
          this.addAtrule_(name, config.atrules[name]);
        }
      }

      if (config.properties) {
        for (const name in config.properties) {
          this.addProperty_(name, config.properties[name]);
        }
      }
    }
  }

  checkStructure(ast) {
    function collectWarning(node, message) {
      warns.push({ node, message });
    }

    const structure = this.structure;
    const warns = [];

    this.syntax.walk(ast, function (node) {
      if (structure.hasOwnProperty(node.type)) {
        structure[node.type].check(node, collectWarning);
      } else {
        collectWarning(node, "Unknown node type `" + node.type + "`");
      }
    });

    return warns.length ? warns : false;
  }

  createDescriptor(syntax, type, name, parent = null) {
    const ref = {
      type,
      name,
    };
    const descriptor = {
      type,
      name,
      parent,
      serializable:
        typeof syntax === "string" ||
        (syntax && typeof syntax.type === "string"),
      syntax: null,
      match: null,
    };

    if (typeof syntax === "function") {
      descriptor.match = matchGraph.buildMatchGraph(syntax, ref);
    } else {
      if (typeof syntax === "string") {
        // lazy parsing on first access
        Object.defineProperty(descriptor, "syntax", {
          get() {
            Object.defineProperty(descriptor, "syntax", {
              value: parse$M.parse(syntax),
            });

            return descriptor.syntax;
          },
        });
      } else {
        descriptor.syntax = syntax;
      }

      // lazy graph build on first access
      Object.defineProperty(descriptor, "match", {
        get() {
          Object.defineProperty(descriptor, "match", {
            value: matchGraph.buildMatchGraph(descriptor.syntax, ref),
          });

          return descriptor.match;
        },
      });
    }

    return descriptor;
  }
  addAtrule_(name, syntax) {
    if (!syntax) {
      return;
    }

    this.atrules[name] = {
      type: "Atrule",
      name: name,
      prelude: syntax.prelude
        ? this.createDescriptor(syntax.prelude, "AtrulePrelude", name)
        : null,
      descriptors: syntax.descriptors
        ? Object.keys(syntax.descriptors).reduce((map, descName) => {
            map[descName] = this.createDescriptor(
              syntax.descriptors[descName],
              "AtruleDescriptor",
              descName,
              name,
            );
            return map;
          }, Object.create(null))
        : null,
    };
  }
  addProperty_(name, syntax) {
    if (!syntax) {
      return;
    }

    this.properties[name] = this.createDescriptor(syntax, "Property", name);
  }
  addType_(name, syntax) {
    if (!syntax) {
      return;
    }

    this.types[name] = this.createDescriptor(syntax, "Type", name);
  }

  checkAtruleName(atruleName) {
    if (!this.getAtrule(atruleName)) {
      return new error$1.SyntaxReferenceError(
        "Unknown at-rule",
        "@" + atruleName,
      );
    }
  }
  checkAtrulePrelude(atruleName, prelude) {
    const error = this.checkAtruleName(atruleName);

    if (error) {
      return error;
    }

    const atrule = this.getAtrule(atruleName);

    if (!atrule.prelude && prelude) {
      return new SyntaxError(
        "At-rule `@" + atruleName + "` should not contain a prelude",
      );
    }

    if (atrule.prelude && !prelude) {
      if (!matchSyntax(this, atrule.prelude, "", false).matched) {
        return new SyntaxError(
          "At-rule `@" + atruleName + "` should contain a prelude",
        );
      }
    }
  }
  checkAtruleDescriptorName(atruleName, descriptorName) {
    const error$1$1 = this.checkAtruleName(atruleName);

    if (error$1$1) {
      return error$1$1;
    }

    const atrule = this.getAtrule(atruleName);
    const descriptor = names$3.keyword(descriptorName);

    if (!atrule.descriptors) {
      return new SyntaxError(
        "At-rule `@" + atruleName + "` has no known descriptors",
      );
    }

    if (
      !atrule.descriptors[descriptor.name] &&
      !atrule.descriptors[descriptor.basename]
    ) {
      return new error$1.SyntaxReferenceError(
        "Unknown at-rule descriptor",
        descriptorName,
      );
    }
  }
  checkPropertyName(propertyName) {
    if (!this.getProperty(propertyName)) {
      return new error$1.SyntaxReferenceError("Unknown property", propertyName);
    }
  }

  matchAtrulePrelude(atruleName, prelude) {
    const error = this.checkAtrulePrelude(atruleName, prelude);

    if (error) {
      return buildMatchResult(null, error);
    }

    const atrule = this.getAtrule(atruleName);

    if (!atrule.prelude) {
      return buildMatchResult(null, null);
    }

    return matchSyntax(this, atrule.prelude, prelude || "", false);
  }
  matchAtruleDescriptor(atruleName, descriptorName, value) {
    const error = this.checkAtruleDescriptorName(atruleName, descriptorName);

    if (error) {
      return buildMatchResult(null, error);
    }

    const atrule = this.getAtrule(atruleName);
    const descriptor = names$3.keyword(descriptorName);

    return matchSyntax(
      this,
      atrule.descriptors[descriptor.name] ||
        atrule.descriptors[descriptor.basename],
      value,
      false,
    );
  }
  matchDeclaration(node) {
    if (node.type !== "Declaration") {
      return buildMatchResult(null, new Error("Not a Declaration node"));
    }

    return this.matchProperty(node.property, node.value);
  }
  matchProperty(propertyName, value) {
    // don't match syntax for a custom property at the moment
    if (names$3.property(propertyName).custom) {
      return buildMatchResult(
        null,
        new Error("Lexer matching doesn't applicable for custom properties"),
      );
    }

    const error = this.checkPropertyName(propertyName);

    if (error) {
      return buildMatchResult(null, error);
    }

    return matchSyntax(this, this.getProperty(propertyName), value, true);
  }
  matchType(typeName, value) {
    const typeSyntax = this.getType(typeName);

    if (!typeSyntax) {
      return buildMatchResult(
        null,
        new error$1.SyntaxReferenceError("Unknown type", typeName),
      );
    }

    return matchSyntax(this, typeSyntax, value, false);
  }
  match(syntax, value) {
    if (typeof syntax !== "string" && (!syntax || !syntax.type)) {
      return buildMatchResult(
        null,
        new error$1.SyntaxReferenceError("Bad syntax"),
      );
    }

    if (typeof syntax === "string" || !syntax.match) {
      syntax = this.createDescriptor(syntax, "Type", "anonymous");
    }

    return matchSyntax(this, syntax, value, false);
  }

  findValueFragments(propertyName, value, type, name) {
    return search.matchFragments(
      this,
      value,
      this.matchProperty(propertyName, value),
      type,
      name,
    );
  }
  findDeclarationValueFragments(declaration, type, name) {
    return search.matchFragments(
      this,
      declaration.value,
      this.matchDeclaration(declaration),
      type,
      name,
    );
  }
  findAllFragments(ast, type, name) {
    const result = [];

    this.syntax.walk(ast, {
      visit: "Declaration",
      enter: (declaration) => {
        result.push.apply(
          result,
          this.findDeclarationValueFragments(declaration, type, name),
        );
      },
    });

    return result;
  }

  getAtrule(atruleName, fallbackBasename = true) {
    const atrule = names$3.keyword(atruleName);
    const atruleEntry =
      atrule.vendor && fallbackBasename
        ? this.atrules[atrule.name] || this.atrules[atrule.basename]
        : this.atrules[atrule.name];

    return atruleEntry || null;
  }
  getAtrulePrelude(atruleName, fallbackBasename = true) {
    const atrule = this.getAtrule(atruleName, fallbackBasename);

    return (atrule && atrule.prelude) || null;
  }
  getAtruleDescriptor(atruleName, name) {
    return this.atrules.hasOwnProperty(atruleName) && this.atrules.declarators
      ? this.atrules[atruleName].declarators[name] || null
      : null;
  }
  getProperty(propertyName, fallbackBasename = true) {
    const property = names$3.property(propertyName);
    const propertyEntry =
      property.vendor && fallbackBasename
        ? this.properties[property.name] || this.properties[property.basename]
        : this.properties[property.name];

    return propertyEntry || null;
  }
  getType(name) {
    return hasOwnProperty.call(this.types, name) ? this.types[name] : null;
  }

  validate() {
    function validate(syntax, name, broken, descriptor) {
      if (broken.has(name)) {
        return broken.get(name);
      }

      broken.set(name, false);
      if (descriptor.syntax !== null) {
        walk$3.walk(
          descriptor.syntax,
          function (node) {
            if (node.type !== "Type" && node.type !== "Property") {
              return;
            }

            const map = node.type === "Type" ? syntax.types : syntax.properties;
            const brokenMap =
              node.type === "Type" ? brokenTypes : brokenProperties;

            if (
              !hasOwnProperty.call(map, node.name) ||
              validate(syntax, node.name, brokenMap, map[node.name])
            ) {
              broken.set(name, true);
            }
          },
          this,
        );
      }
    }

    let brokenTypes = new Map();
    let brokenProperties = new Map();

    for (const key in this.types) {
      validate(this, key, brokenTypes, this.types[key]);
    }

    for (const key in this.properties) {
      validate(this, key, brokenProperties, this.properties[key]);
    }

    brokenTypes = [...brokenTypes.keys()].filter((name) =>
      brokenTypes.get(name),
    );
    brokenProperties = [...brokenProperties.keys()].filter((name) =>
      brokenProperties.get(name),
    );

    if (brokenTypes.length || brokenProperties.length) {
      return {
        types: brokenTypes,
        properties: brokenProperties,
      };
    }

    return null;
  }
  dump(syntaxAsAst, pretty) {
    return {
      generic: this.generic,
      types: dumpMapSyntax(this.types, !pretty, syntaxAsAst),
      properties: dumpMapSyntax(this.properties, !pretty, syntaxAsAst),
      atrules: dumpAtruleMapSyntax(this.atrules, !pretty, syntaxAsAst),
    };
  }
  toString() {
    return JSON.stringify(this.dump());
  }
};

Lexer$3.Lexer = Lexer$2;

const { hasOwnProperty: hasOwnProperty$6 } = Object.prototype;
const shape$1 = {
  generic: true,
  types: appendOrAssign,
  atrules: {
    prelude: appendOrAssignOrNull,
    descriptors: appendOrAssignOrNull,
  },
  properties: appendOrAssign,
  parseContext: assign,
  scope: deepAssign,
  atrule: ["parse"],
  pseudo: ["parse"],
  node: ["name", "structure", "parse", "generate", "walkContext"],
};

function isObject(value) {
  return value && value.constructor === Object;
}

function copy(value) {
  return isObject(value) ? { ...value } : value;
}

function assign(dest, src) {
  return Object.assign(dest, src);
}

function deepAssign(dest, src) {
  for (const key in src) {
    if (hasOwnProperty$6.call(src, key)) {
      if (isObject(dest[key])) {
        deepAssign(dest[key], src[key]);
      } else {
        dest[key] = copy(src[key]);
      }
    }
  }

  return dest;
}

function append(a, b) {
  if (typeof b === "string" && /^\s*\|/.test(b)) {
    return typeof a === "string" ? a + b : b.replace(/^\s*\|\s*/, "");
  }

  return b || null;
}

function appendOrAssign(a, b) {
  if (typeof b === "string") {
    return append(a, b);
  }

  const result = { ...a };
  for (let key in b) {
    if (hasOwnProperty$6.call(b, key)) {
      result[key] = append(
        hasOwnProperty$6.call(a, key) ? a[key] : undefined,
        b[key],
      );
    }
  }

  return result;
}

function appendOrAssignOrNull(a, b) {
  const result = appendOrAssign(a, b);

  return !isObject(result) || Object.keys(result).length ? result : null;
}

function mix$1(dest, src, shape) {
  for (const key in shape) {
    if (hasOwnProperty$6.call(shape, key) === false) {
      continue;
    }

    if (shape[key] === true) {
      if (hasOwnProperty$6.call(src, key)) {
        dest[key] = copy(src[key]);
      }
    } else if (shape[key]) {
      if (typeof shape[key] === "function") {
        const fn = shape[key];
        dest[key] = fn({}, dest[key]);
        dest[key] = fn(dest[key] || {}, src[key]);
      } else if (isObject(shape[key])) {
        const result = {};

        for (let name in dest[key]) {
          result[name] = mix$1({}, dest[key][name], shape[key]);
        }

        for (let name in src[key]) {
          result[name] = mix$1(result[name] || {}, src[key][name], shape[key]);
        }

        dest[key] = result;
      } else if (Array.isArray(shape[key])) {
        const res = {};
        const innerShape = shape[key].reduce(function (s, k) {
          s[k] = true;
          return s;
        }, {});

        for (const [name, value] of Object.entries(dest[key] || {})) {
          res[name] = {};
          if (value) {
            mix$1(res[name], value, innerShape);
          }
        }

        for (const name in src[key]) {
          if (hasOwnProperty$6.call(src[key], name)) {
            if (!res[name]) {
              res[name] = {};
            }

            if (src[key] && src[key][name]) {
              mix$1(res[name], src[key][name], innerShape);
            }
          }
        }

        dest[key] = res;
      }
    }
  }
  return dest;
}

const mix$1$1 = (dest, src) => mix$1(dest, src, shape$1);

var mix_1 = mix$1$1;

const index$8 = tokenizer$2;
const create$2 = create$7;
const create$2$1 = create$6;
const create$3 = create$5;
const create$1$1 = create$4;
const Lexer$1 = Lexer$3;
const mix = mix_1;

function createSyntax(config) {
  const parse = create$2.createParser(config);
  const walk = create$1$1.createWalker(config);
  const generate = create$2$1.createGenerator(config);
  const { fromPlainObject, toPlainObject } = create$3.createConvertor(walk);

  const syntax = {
    lexer: null,
    createLexer: (config) =>
      new Lexer$1.Lexer(config, syntax, syntax.lexer.structure),

    tokenize: index$8.tokenize,
    parse,
    generate,

    walk,
    find: walk.find,
    findLast: walk.findLast,
    findAll: walk.findAll,

    fromPlainObject,
    toPlainObject,

    fork(extension) {
      const base = mix({}, config); // copy of config

      return createSyntax(
        typeof extension === "function"
          ? extension(base, Object.assign)
          : mix(base, extension),
      );
    },
  };

  syntax.lexer = new Lexer$1.Lexer(
    {
      generic: true,
      types: config.types,
      atrules: config.atrules,
      properties: config.properties,
      node: config.node,
    },
    syntax,
  );

  return syntax;
}
const createSyntax$1 = (config) => createSyntax(mix({}, config));

var create_1 = createSyntax$1;

const atrules = {
  charset: {
    prelude: "<string>",
  },
  "font-face": {
    descriptors: {
      "unicode-range": {
        comment: "replaces <unicode-range>, an old production name",
        syntax: "<urange>#",
      },
    },
  },
};
const properties = {
  "-moz-background-clip": {
    comment:
      "deprecated syntax in old Firefox, https://developer.mozilla.org/en/docs/Web/CSS/background-clip",
    syntax: "padding | border",
  },
  "-moz-border-radius-bottomleft": {
    comment:
      "https://developer.mozilla.org/en-US/docs/Web/CSS/border-bottom-left-radius",
    syntax: "<'border-bottom-left-radius'>",
  },
  "-moz-border-radius-bottomright": {
    comment:
      "https://developer.mozilla.org/en-US/docs/Web/CSS/border-bottom-right-radius",
    syntax: "<'border-bottom-right-radius'>",
  },
  "-moz-border-radius-topleft": {
    comment:
      "https://developer.mozilla.org/en-US/docs/Web/CSS/border-top-left-radius",
    syntax: "<'border-top-left-radius'>",
  },
  "-moz-border-radius-topright": {
    comment:
      "https://developer.mozilla.org/en-US/docs/Web/CSS/border-bottom-right-radius",
    syntax: "<'border-bottom-right-radius'>",
  },
  "-moz-control-character-visibility": {
    comment:
      "firefox specific keywords, https://bugzilla.mozilla.org/show_bug.cgi?id=947588",
    syntax: "visible | hidden",
  },
  "-moz-osx-font-smoothing": {
    comment:
      "misssed old syntax https://developer.mozilla.org/en-US/docs/Web/CSS/font-smooth",
    syntax: "auto | grayscale",
  },
  "-moz-user-select": {
    comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/user-select",
    syntax: "none | text | all | -moz-none",
  },
  "-ms-flex-align": {
    comment:
      "misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-align",
    syntax: "start | end | center | baseline | stretch",
  },
  "-ms-flex-item-align": {
    comment:
      "misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-align",
    syntax: "auto | start | end | center | baseline | stretch",
  },
  "-ms-flex-line-pack": {
    comment:
      "misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-line-pack",
    syntax: "start | end | center | justify | distribute | stretch",
  },
  "-ms-flex-negative": {
    comment:
      "misssed old syntax implemented in IE; TODO: find references for comfirmation",
    syntax: "<'flex-shrink'>",
  },
  "-ms-flex-pack": {
    comment:
      "misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-pack",
    syntax: "start | end | center | justify | distribute",
  },
  "-ms-flex-order": {
    comment:
      "misssed old syntax implemented in IE; https://msdn.microsoft.com/en-us/library/jj127303(v=vs.85).aspx",
    syntax: "<integer>",
  },
  "-ms-flex-positive": {
    comment:
      "misssed old syntax implemented in IE; TODO: find references for comfirmation",
    syntax: "<'flex-grow'>",
  },
  "-ms-flex-preferred-size": {
    comment:
      "misssed old syntax implemented in IE; TODO: find references for comfirmation",
    syntax: "<'flex-basis'>",
  },
  "-ms-interpolation-mode": {
    comment: "https://msdn.microsoft.com/en-us/library/ff521095(v=vs.85).aspx",
    syntax: "nearest-neighbor | bicubic",
  },
  "-ms-grid-column-align": {
    comment:
      "add this property first since it uses as fallback for flexbox, https://msdn.microsoft.com/en-us/library/windows/apps/hh466338.aspx",
    syntax: "start | end | center | stretch",
  },
  "-ms-grid-row-align": {
    comment:
      "add this property first since it uses as fallback for flexbox, https://msdn.microsoft.com/en-us/library/windows/apps/hh466348.aspx",
    syntax: "start | end | center | stretch",
  },
  "-ms-hyphenate-limit-last": {
    comment:
      "misssed old syntax implemented in IE; https://www.w3.org/TR/css-text-4/#hyphenate-line-limits",
    syntax: "none | always | column | page | spread",
  },
  "-webkit-appearance": {
    comment: "webkit specific keywords",
    references: ["http://css-infos.net/property/-webkit-appearance"],
    syntax:
      "none | button | button-bevel | caps-lock-indicator | caret | checkbox | default-button | inner-spin-button | listbox | listitem | media-controls-background | media-controls-fullscreen-background | media-current-time-display | media-enter-fullscreen-button | media-exit-fullscreen-button | media-fullscreen-button | media-mute-button | media-overlay-play-button | media-play-button | media-seek-back-button | media-seek-forward-button | media-slider | media-sliderthumb | media-time-remaining-display | media-toggle-closed-captions-button | media-volume-slider | media-volume-slider-container | media-volume-sliderthumb | menulist | menulist-button | menulist-text | menulist-textfield | meter | progress-bar | progress-bar-value | push-button | radio | scrollbarbutton-down | scrollbarbutton-left | scrollbarbutton-right | scrollbarbutton-up | scrollbargripper-horizontal | scrollbargripper-vertical | scrollbarthumb-horizontal | scrollbarthumb-vertical | scrollbartrack-horizontal | scrollbartrack-vertical | searchfield | searchfield-cancel-button | searchfield-decoration | searchfield-results-button | searchfield-results-decoration | slider-horizontal | slider-vertical | sliderthumb-horizontal | sliderthumb-vertical | square-button | textarea | textfield | -apple-pay-button",
  },
  "-webkit-background-clip": {
    comment: "https://developer.mozilla.org/en/docs/Web/CSS/background-clip",
    syntax: "[ <box> | border | padding | content | text ]#",
  },
  "-webkit-column-break-after": {
    comment: "added, http://help.dottoro.com/lcrthhhv.php",
    syntax: "always | auto | avoid",
  },
  "-webkit-column-break-before": {
    comment: "added, http://help.dottoro.com/lcxquvkf.php",
    syntax: "always | auto | avoid",
  },
  "-webkit-column-break-inside": {
    comment: "added, http://help.dottoro.com/lclhnthl.php",
    syntax: "always | auto | avoid",
  },
  "-webkit-font-smoothing": {
    comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/font-smooth",
    syntax: "auto | none | antialiased | subpixel-antialiased",
  },
  "-webkit-mask-box-image": {
    comment:
      "missed; https://developer.mozilla.org/en-US/docs/Web/CSS/-webkit-mask-box-image",
    syntax:
      "[ <url> | <gradient> | none ] [ <length-percentage>{4} <-webkit-mask-box-repeat>{2} ]?",
  },
  "-webkit-print-color-adjust": {
    comment: "missed",
    references: [
      "https://developer.mozilla.org/en/docs/Web/CSS/-webkit-print-color-adjust",
    ],
    syntax: "economy | exact",
  },
  "-webkit-text-security": {
    comment: "missed; http://help.dottoro.com/lcbkewgt.php",
    syntax: "none | circle | disc | square",
  },
  "-webkit-user-drag": {
    comment: "missed; http://help.dottoro.com/lcbixvwm.php",
    syntax: "none | element | auto",
  },
  "-webkit-user-select": {
    comment:
      "auto is supported by old webkit, https://developer.mozilla.org/en-US/docs/Web/CSS/user-select",
    syntax: "auto | none | text | all",
  },
  "alignment-baseline": {
    comment: "added SVG property",
    references: [
      "https://www.w3.org/TR/SVG/text.html#AlignmentBaselineProperty",
    ],
    syntax:
      "auto | baseline | before-edge | text-before-edge | middle | central | after-edge | text-after-edge | ideographic | alphabetic | hanging | mathematical",
  },
  "background-clip": {
    comment:
      "used <bg-clip> from CSS Backgrounds and Borders 4 since it adds new values",
    references: ["https://github.com/csstree/csstree/issues/190"],
    syntax: "<bg-clip>#",
  },
  "baseline-shift": {
    comment: "added SVG property",
    references: ["https://www.w3.org/TR/SVG/text.html#BaselineShiftProperty"],
    syntax: "baseline | sub | super | <svg-length>",
  },
  behavior: {
    comment:
      "added old IE property https://msdn.microsoft.com/en-us/library/ms530723(v=vs.85).aspx",
    syntax: "<url>+",
  },
  "clip-rule": {
    comment: "added SVG property",
    references: ["https://www.w3.org/TR/SVG/masking.html#ClipRuleProperty"],
    syntax: "nonzero | evenodd",
  },
  cue: {
    comment: "https://www.w3.org/TR/css3-speech/#property-index",
    syntax: "<'cue-before'> <'cue-after'>?",
  },
  "cue-after": {
    comment: "https://www.w3.org/TR/css3-speech/#property-index",
    syntax: "<url> <decibel>? | none",
  },
  "cue-before": {
    comment: "https://www.w3.org/TR/css3-speech/#property-index",
    syntax: "<url> <decibel>? | none",
  },
  cursor: {
    comment:
      "added legacy keywords: hand, -webkit-grab. -webkit-grabbing, -webkit-zoom-in, -webkit-zoom-out, -moz-grab, -moz-grabbing, -moz-zoom-in, -moz-zoom-out",
    references: ["https://www.sitepoint.com/css3-cursor-styles/"],
    syntax:
      "[ [ <url> [ <x> <y> ]? , ]* [ auto | default | none | context-menu | help | pointer | progress | wait | cell | crosshair | text | vertical-text | alias | copy | move | no-drop | not-allowed | e-resize | n-resize | ne-resize | nw-resize | s-resize | se-resize | sw-resize | w-resize | ew-resize | ns-resize | nesw-resize | nwse-resize | col-resize | row-resize | all-scroll | zoom-in | zoom-out | grab | grabbing | hand | -webkit-grab | -webkit-grabbing | -webkit-zoom-in | -webkit-zoom-out | -moz-grab | -moz-grabbing | -moz-zoom-in | -moz-zoom-out ] ]",
  },
  display: {
    comment: "extended with -ms-flexbox",
    syntax: "| <-non-standard-display>",
  },
  position: {
    comment: "extended with -webkit-sticky",
    syntax: "| -webkit-sticky",
  },
  "dominant-baseline": {
    comment: "added SVG property",
    references: [
      "https://www.w3.org/TR/SVG/text.html#DominantBaselineProperty",
    ],
    syntax:
      "auto | use-script | no-change | reset-size | ideographic | alphabetic | hanging | mathematical | central | middle | text-after-edge | text-before-edge",
  },
  "image-rendering": {
    comment:
      "extended with <-non-standard-image-rendering>, added SVG keywords optimizeSpeed and optimizeQuality",
    references: [
      "https://developer.mozilla.org/en/docs/Web/CSS/image-rendering",
      "https://www.w3.org/TR/SVG/painting.html#ImageRenderingProperty",
    ],
    syntax:
      "| optimizeSpeed | optimizeQuality | <-non-standard-image-rendering>",
  },
  fill: {
    comment: "added SVG property",
    references: ["https://www.w3.org/TR/SVG/painting.html#FillProperty"],
    syntax: "<paint>",
  },
  "fill-opacity": {
    comment: "added SVG property",
    references: ["https://www.w3.org/TR/SVG/painting.html#FillProperty"],
    syntax: "<number-zero-one>",
  },
  "fill-rule": {
    comment: "added SVG property",
    references: ["https://www.w3.org/TR/SVG/painting.html#FillProperty"],
    syntax: "nonzero | evenodd",
  },
  filter: {
    comment: "extend with IE legacy syntaxes",
    syntax: "| <-ms-filter-function-list>",
  },
  "glyph-orientation-horizontal": {
    comment: "added SVG property",
    references: [
      "https://www.w3.org/TR/SVG/text.html#GlyphOrientationHorizontalProperty",
    ],
    syntax: "<angle>",
  },
  "glyph-orientation-vertical": {
    comment: "added SVG property",
    references: [
      "https://www.w3.org/TR/SVG/text.html#GlyphOrientationVerticalProperty",
    ],
    syntax: "<angle>",
  },
  kerning: {
    comment: "added SVG property",
    references: ["https://www.w3.org/TR/SVG/text.html#KerningProperty"],
    syntax: "auto | <svg-length>",
  },
  "letter-spacing": {
    comment: "fix syntax <length> -> <length-percentage>",
    references: [
      "https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/letter-spacing",
    ],
    syntax: "normal | <length-percentage>",
  },
  marker: {
    comment: "added SVG property",
    references: ["https://www.w3.org/TR/SVG/painting.html#MarkerProperties"],
    syntax: "none | <url>",
  },
  "marker-end": {
    comment: "added SVG property",
    references: ["https://www.w3.org/TR/SVG/painting.html#MarkerProperties"],
    syntax: "none | <url>",
  },
  "marker-mid": {
    comment: "added SVG property",
    references: ["https://www.w3.org/TR/SVG/painting.html#MarkerProperties"],
    syntax: "none | <url>",
  },
  "marker-start": {
    comment: "added SVG property",
    references: ["https://www.w3.org/TR/SVG/painting.html#MarkerProperties"],
    syntax: "none | <url>",
  },
  "max-width": {
    comment:
      "extend by non-standard width keywords https://developer.mozilla.org/en-US/docs/Web/CSS/max-width",
    syntax: "| <-non-standard-width>",
  },
  width: {
    references: [
      "https://developer.mozilla.org/en-US/docs/Web/CSS/width",
      "https://github.com/csstree/stylelint-validator/issues/29",
    ],
    syntax:
      "| fill | stretch | intrinsic | -moz-max-content | -webkit-max-content | -moz-fit-content | -webkit-fit-content",
  },
  "min-width": {
    comment:
      "extend by non-standard width keywords https://developer.mozilla.org/en-US/docs/Web/CSS/width",
    syntax: "| <-non-standard-width>",
  },
  overflow: {
    comment:
      "extend by vendor keywords https://developer.mozilla.org/en-US/docs/Web/CSS/overflow",
    syntax: "| <-non-standard-overflow>",
  },
  pause: {
    comment: "https://www.w3.org/TR/css3-speech/#property-index",
    syntax: "<'pause-before'> <'pause-after'>?",
  },
  "pause-after": {
    comment: "https://www.w3.org/TR/css3-speech/#property-index",
    syntax: "<time> | none | x-weak | weak | medium | strong | x-strong",
  },
  "pause-before": {
    comment: "https://www.w3.org/TR/css3-speech/#property-index",
    syntax: "<time> | none | x-weak | weak | medium | strong | x-strong",
  },
  rest: {
    comment: "https://www.w3.org/TR/css3-speech/#property-index",
    syntax: "<'rest-before'> <'rest-after'>?",
  },
  "rest-after": {
    comment: "https://www.w3.org/TR/css3-speech/#property-index",
    syntax: "<time> | none | x-weak | weak | medium | strong | x-strong",
  },
  "rest-before": {
    comment: "https://www.w3.org/TR/css3-speech/#property-index",
    syntax: "<time> | none | x-weak | weak | medium | strong | x-strong",
  },
  "shape-rendering": {
    comment: "added SVG property",
    references: [
      "https://www.w3.org/TR/SVG/painting.html#ShapeRenderingPropert",
    ],
    syntax: "auto | optimizeSpeed | crispEdges | geometricPrecision",
  },
  src: {
    comment:
      "added @font-face's src property https://developer.mozilla.org/en-US/docs/Web/CSS/@font-face/src",
    syntax: "[ <url> [ format( <string># ) ]? | local( <family-name> ) ]#",
  },
  speak: {
    comment: "https://www.w3.org/TR/css3-speech/#property-index",
    syntax: "auto | none | normal",
  },
  "speak-as": {
    comment: "https://www.w3.org/TR/css3-speech/#property-index",
    syntax:
      "normal | spell-out || digits || [ literal-punctuation | no-punctuation ]",
  },
  stroke: {
    comment: "added SVG property",
    references: ["https://www.w3.org/TR/SVG/painting.html#StrokeProperties"],
    syntax: "<paint>",
  },
  "stroke-dasharray": {
    comment:
      "added SVG property; a list of comma and/or white space separated <length>s and <percentage>s",
    references: ["https://www.w3.org/TR/SVG/painting.html#StrokeProperties"],
    syntax: "none | [ <svg-length>+ ]#",
  },
  "stroke-dashoffset": {
    comment: "added SVG property",
    references: ["https://www.w3.org/TR/SVG/painting.html#StrokeProperties"],
    syntax: "<svg-length>",
  },
  "stroke-linecap": {
    comment: "added SVG property",
    references: ["https://www.w3.org/TR/SVG/painting.html#StrokeProperties"],
    syntax: "butt | round | square",
  },
  "stroke-linejoin": {
    comment: "added SVG property",
    references: ["https://www.w3.org/TR/SVG/painting.html#StrokeProperties"],
    syntax: "miter | round | bevel",
  },
  "stroke-miterlimit": {
    comment: "added SVG property (<miterlimit> = <number-one-or-greater>) ",
    references: ["https://www.w3.org/TR/SVG/painting.html#StrokeProperties"],
    syntax: "<number-one-or-greater>",
  },
  "stroke-opacity": {
    comment: "added SVG property",
    references: ["https://www.w3.org/TR/SVG/painting.html#StrokeProperties"],
    syntax: "<number-zero-one>",
  },
  "stroke-width": {
    comment: "added SVG property",
    references: ["https://www.w3.org/TR/SVG/painting.html#StrokeProperties"],
    syntax: "<svg-length>",
  },
  "text-anchor": {
    comment: "added SVG property",
    references: ["https://www.w3.org/TR/SVG/text.html#TextAlignmentProperties"],
    syntax: "start | middle | end",
  },
  "unicode-bidi": {
    comment:
      "added prefixed keywords https://developer.mozilla.org/en-US/docs/Web/CSS/unicode-bidi",
    syntax:
      "| -moz-isolate | -moz-isolate-override | -moz-plaintext | -webkit-isolate | -webkit-isolate-override | -webkit-plaintext",
  },
  "unicode-range": {
    comment:
      "added missed property https://developer.mozilla.org/en-US/docs/Web/CSS/%40font-face/unicode-range",
    syntax: "<urange>#",
  },
  "voice-balance": {
    comment: "https://www.w3.org/TR/css3-speech/#property-index",
    syntax: "<number> | left | center | right | leftwards | rightwards",
  },
  "voice-duration": {
    comment: "https://www.w3.org/TR/css3-speech/#property-index",
    syntax: "auto | <time>",
  },
  "voice-family": {
    comment:
      "<name> -> <family-name>, https://www.w3.org/TR/css3-speech/#property-index",
    syntax:
      "[ [ <family-name> | <generic-voice> ] , ]* [ <family-name> | <generic-voice> ] | preserve",
  },
  "voice-pitch": {
    comment: "https://www.w3.org/TR/css3-speech/#property-index",
    syntax:
      "<frequency> && absolute | [ [ x-low | low | medium | high | x-high ] || [ <frequency> | <semitones> | <percentage> ] ]",
  },
  "voice-range": {
    comment: "https://www.w3.org/TR/css3-speech/#property-index",
    syntax:
      "<frequency> && absolute | [ [ x-low | low | medium | high | x-high ] || [ <frequency> | <semitones> | <percentage> ] ]",
  },
  "voice-rate": {
    comment: "https://www.w3.org/TR/css3-speech/#property-index",
    syntax:
      "[ normal | x-slow | slow | medium | fast | x-fast ] || <percentage>",
  },
  "voice-stress": {
    comment: "https://www.w3.org/TR/css3-speech/#property-index",
    syntax: "normal | strong | moderate | none | reduced",
  },
  "voice-volume": {
    comment: "https://www.w3.org/TR/css3-speech/#property-index",
    syntax:
      "silent | [ [ x-soft | soft | medium | loud | x-loud ] || <decibel> ]",
  },
  "writing-mode": {
    comment: "extend with SVG keywords",
    syntax: "| <svg-writing-mode>",
  },
};
const types$J = {
  "-legacy-gradient": {
    comment: "added collection of legacy gradient syntaxes",
    syntax:
      "<-webkit-gradient()> | <-legacy-linear-gradient> | <-legacy-repeating-linear-gradient> | <-legacy-radial-gradient> | <-legacy-repeating-radial-gradient>",
  },
  "-legacy-linear-gradient": {
    comment:
      "like standard syntax but w/o `to` keyword https://developer.mozilla.org/en-US/docs/Web/CSS/linear-gradient",
    syntax:
      "-moz-linear-gradient( <-legacy-linear-gradient-arguments> ) | -webkit-linear-gradient( <-legacy-linear-gradient-arguments> ) | -o-linear-gradient( <-legacy-linear-gradient-arguments> )",
  },
  "-legacy-repeating-linear-gradient": {
    comment:
      "like standard syntax but w/o `to` keyword https://developer.mozilla.org/en-US/docs/Web/CSS/linear-gradient",
    syntax:
      "-moz-repeating-linear-gradient( <-legacy-linear-gradient-arguments> ) | -webkit-repeating-linear-gradient( <-legacy-linear-gradient-arguments> ) | -o-repeating-linear-gradient( <-legacy-linear-gradient-arguments> )",
  },
  "-legacy-linear-gradient-arguments": {
    comment:
      "like standard syntax but w/o `to` keyword https://developer.mozilla.org/en-US/docs/Web/CSS/linear-gradient",
    syntax: "[ <angle> | <side-or-corner> ]? , <color-stop-list>",
  },
  "-legacy-radial-gradient": {
    comment:
      "deprecated syntax that implemented by some browsers https://www.w3.org/TR/2011/WD-css3-images-20110908/#radial-gradients",
    syntax:
      "-moz-radial-gradient( <-legacy-radial-gradient-arguments> ) | -webkit-radial-gradient( <-legacy-radial-gradient-arguments> ) | -o-radial-gradient( <-legacy-radial-gradient-arguments> )",
  },
  "-legacy-repeating-radial-gradient": {
    comment:
      "deprecated syntax that implemented by some browsers https://www.w3.org/TR/2011/WD-css3-images-20110908/#radial-gradients",
    syntax:
      "-moz-repeating-radial-gradient( <-legacy-radial-gradient-arguments> ) | -webkit-repeating-radial-gradient( <-legacy-radial-gradient-arguments> ) | -o-repeating-radial-gradient( <-legacy-radial-gradient-arguments> )",
  },
  "-legacy-radial-gradient-arguments": {
    comment:
      "deprecated syntax that implemented by some browsers https://www.w3.org/TR/2011/WD-css3-images-20110908/#radial-gradients",
    syntax:
      "[ <position> , ]? [ [ [ <-legacy-radial-gradient-shape> || <-legacy-radial-gradient-size> ] | [ <length> | <percentage> ]{2} ] , ]? <color-stop-list>",
  },
  "-legacy-radial-gradient-size": {
    comment:
      "before a standard it contains 2 extra keywords (`contain` and `cover`) https://www.w3.org/TR/2011/WD-css3-images-20110908/#ltsize",
    syntax:
      "closest-side | closest-corner | farthest-side | farthest-corner | contain | cover",
  },
  "-legacy-radial-gradient-shape": {
    comment:
      "define to double sure it doesn't extends in future https://www.w3.org/TR/2011/WD-css3-images-20110908/#ltshape",
    syntax: "circle | ellipse",
  },
  "-non-standard-font": {
    comment: "non standard fonts",
    references: [
      "https://webkit.org/blog/3709/using-the-system-font-in-web-content/",
    ],
    syntax:
      "-apple-system-body | -apple-system-headline | -apple-system-subheadline | -apple-system-caption1 | -apple-system-caption2 | -apple-system-footnote | -apple-system-short-body | -apple-system-short-headline | -apple-system-short-subheadline | -apple-system-short-caption1 | -apple-system-short-footnote | -apple-system-tall-body",
  },
  "-non-standard-color": {
    comment: "non standard colors",
    references: [
      "http://cssdot.ru/%D0%A1%D0%BF%D1%80%D0%B0%D0%B2%D0%BE%D1%87%D0%BD%D0%B8%D0%BA_CSS/color-i305.html",
      "https://developer.mozilla.org/en-US/docs/Web/CSS/color_value#Mozilla_Color_Preference_Extensions",
    ],
    syntax:
      "-moz-ButtonDefault | -moz-ButtonHoverFace | -moz-ButtonHoverText | -moz-CellHighlight | -moz-CellHighlightText | -moz-Combobox | -moz-ComboboxText | -moz-Dialog | -moz-DialogText | -moz-dragtargetzone | -moz-EvenTreeRow | -moz-Field | -moz-FieldText | -moz-html-CellHighlight | -moz-html-CellHighlightText | -moz-mac-accentdarkestshadow | -moz-mac-accentdarkshadow | -moz-mac-accentface | -moz-mac-accentlightesthighlight | -moz-mac-accentlightshadow | -moz-mac-accentregularhighlight | -moz-mac-accentregularshadow | -moz-mac-chrome-active | -moz-mac-chrome-inactive | -moz-mac-focusring | -moz-mac-menuselect | -moz-mac-menushadow | -moz-mac-menutextselect | -moz-MenuHover | -moz-MenuHoverText | -moz-MenuBarText | -moz-MenuBarHoverText | -moz-nativehyperlinktext | -moz-OddTreeRow | -moz-win-communicationstext | -moz-win-mediatext | -moz-activehyperlinktext | -moz-default-background-color | -moz-default-color | -moz-hyperlinktext | -moz-visitedhyperlinktext | -webkit-activelink | -webkit-focus-ring-color | -webkit-link | -webkit-text",
  },
  "-non-standard-image-rendering": {
    comment:
      "non-standard keywords http://phrogz.net/tmp/canvas_image_zoom.html",
    syntax:
      "optimize-contrast | -moz-crisp-edges | -o-crisp-edges | -webkit-optimize-contrast",
  },
  "-non-standard-overflow": {
    comment:
      "non-standard keywords https://developer.mozilla.org/en-US/docs/Web/CSS/overflow",
    syntax:
      "-moz-scrollbars-none | -moz-scrollbars-horizontal | -moz-scrollbars-vertical | -moz-hidden-unscrollable",
  },
  "-non-standard-width": {
    comment:
      "non-standard keywords https://developer.mozilla.org/en-US/docs/Web/CSS/width",
    syntax:
      "fill-available | min-intrinsic | intrinsic | -moz-available | -moz-fit-content | -moz-min-content | -moz-max-content | -webkit-min-content | -webkit-max-content",
  },
  "-webkit-gradient()": {
    comment:
      "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/ - TODO: simplify when after match algorithm improvement ( [, point, radius | , point] -> [, radius]? , point )",
    syntax:
      "-webkit-gradient( <-webkit-gradient-type>, <-webkit-gradient-point> [, <-webkit-gradient-point> | , <-webkit-gradient-radius>, <-webkit-gradient-point> ] [, <-webkit-gradient-radius>]? [, <-webkit-gradient-color-stop>]* )",
  },
  "-webkit-gradient-color-stop": {
    comment:
      "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/",
    syntax:
      "from( <color> ) | color-stop( [ <number-zero-one> | <percentage> ] , <color> ) | to( <color> )",
  },
  "-webkit-gradient-point": {
    comment:
      "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/",
    syntax:
      "[ left | center | right | <length-percentage> ] [ top | center | bottom | <length-percentage> ]",
  },
  "-webkit-gradient-radius": {
    comment:
      "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/",
    syntax: "<length> | <percentage>",
  },
  "-webkit-gradient-type": {
    comment:
      "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/",
    syntax: "linear | radial",
  },
  "-webkit-mask-box-repeat": {
    comment:
      "missed; https://developer.mozilla.org/en-US/docs/Web/CSS/-webkit-mask-box-image",
    syntax: "repeat | stretch | round",
  },
  "-webkit-mask-clip-style": {
    comment:
      "missed; there is no enough information about `-webkit-mask-clip` property, but looks like all those keywords are working",
    syntax:
      "border | border-box | padding | padding-box | content | content-box | text",
  },
  "-ms-filter-function-list": {
    comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-filter",
    syntax: "<-ms-filter-function>+",
  },
  "-ms-filter-function": {
    comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-filter",
    syntax: "<-ms-filter-function-progid> | <-ms-filter-function-legacy>",
  },
  "-ms-filter-function-progid": {
    comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-filter",
    syntax:
      "'progid:' [ <ident-token> '.' ]* [ <ident-token> | <function-token> <any-value>? ) ]",
  },
  "-ms-filter-function-legacy": {
    comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-filter",
    syntax: "<ident-token> | <function-token> <any-value>? )",
  },
  "-ms-filter": {
    syntax: "<string>",
  },
  age: {
    comment: "https://www.w3.org/TR/css3-speech/#voice-family",
    syntax: "child | young | old",
  },
  "attr-name": {
    syntax: "<wq-name>",
  },
  "attr-fallback": {
    syntax: "<any-value>",
  },
  "bg-clip": {
    comment:
      "missed, https://drafts.csswg.org/css-backgrounds-4/#typedef-bg-clip",
    syntax: "<box> | border | text",
  },
  "border-radius": {
    comment:
      "missed, https://drafts.csswg.org/css-backgrounds-3/#the-border-radius",
    syntax: "<length-percentage>{1,2}",
  },
  bottom: {
    comment:
      "missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect",
    syntax: "<length> | auto",
  },
  "content-list": {
    comment: "added attr(), see https://github.com/csstree/csstree/issues/201",
    syntax:
      "[ <string> | contents | <image> | <counter> | <quote> | <target> | <leader()> | <attr()> ]+",
  },
  "element()": {
    comment:
      "https://drafts.csswg.org/css-gcpm/#element-syntax & https://drafts.csswg.org/css-images-4/#element-notation",
    syntax:
      "element( <custom-ident> , [ first | start | last | first-except ]? ) | element( <id-selector> )",
  },
  "generic-voice": {
    comment: "https://www.w3.org/TR/css3-speech/#voice-family",
    syntax: "[ <age>? <gender> <integer>? ]",
  },
  gender: {
    comment: "https://www.w3.org/TR/css3-speech/#voice-family",
    syntax: "male | female | neutral",
  },
  "generic-family": {
    comment: "added -apple-system",
    references: [
      "https://webkit.org/blog/3709/using-the-system-font-in-web-content/",
    ],
    syntax: "| -apple-system",
  },
  gradient: {
    comment: "added legacy syntaxes support",
    syntax: "| <-legacy-gradient>",
  },
  "lab()": {
    comment: "missed; https://www.w3.org/TR/css-color-4/#specifying-lab-lch",
    syntax:
      "lab( [<percentage> | <number> | none] [ <percentage> | <number> | none] [ <percentage> | <number> | none] [ / [<alpha-value> | none] ]? )",
  },
  "lch()": {
    comment: "missed; https://www.w3.org/TR/css-color-4/#specifying-lab-lch",
    syntax:
      "lch( [<percentage> | <number> | none] [ <percentage> | <number> | none] [ <hue> | none] [ / [<alpha-value> | none] ]? )",
  },
  left: {
    comment:
      "missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect",
    syntax: "<length> | auto",
  },
  "mask-image": {
    comment: "missed; https://drafts.fxtf.org/css-masking-1/#the-mask-image",
    syntax: "<mask-reference>#",
  },
  "named-color": {
    comment: "added non standard color names",
    syntax: "| <-non-standard-color>",
  },
  paint: {
    comment:
      "used by SVG https://www.w3.org/TR/SVG/painting.html#SpecifyingPaint",
    syntax:
      "none | <color> | <url> [ none | <color> ]? | context-fill | context-stroke",
  },
  ratio: {
    comment: "missed, https://drafts.csswg.org/css-values-4/#ratio-value",
    syntax: "<number [0,]> [ / <number [0,]> ]?",
  },
  "reversed-counter-name": {
    comment:
      "missed; https://drafts.csswg.org/css-lists/#typedef-reversed-counter-name",
    syntax: "reversed( <counter-name> )",
  },
  right: {
    comment:
      "missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect",
    syntax: "<length> | auto",
  },
  shape: {
    comment:
      "missed spaces in function body and add backwards compatible syntax",
    syntax:
      "rect( <top>, <right>, <bottom>, <left> ) | rect( <top> <right> <bottom> <left> )",
  },
  "svg-length": {
    comment:
      "All coordinates and lengths in SVG can be specified with or without a unit identifier",
    references: ["https://www.w3.org/TR/SVG11/coords.html#Units"],
    syntax: "<percentage> | <length> | <number>",
  },
  "svg-writing-mode": {
    comment: "SVG specific keywords (deprecated for CSS)",
    references: [
      "https://developer.mozilla.org/en/docs/Web/CSS/writing-mode",
      "https://www.w3.org/TR/SVG/text.html#WritingModeProperty",
    ],
    syntax: "lr-tb | rl-tb | tb-rl | lr | rl | tb",
  },
  top: {
    comment:
      "missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect",
    syntax: "<length> | auto",
  },
  "track-group": {
    comment: "used by old grid-columns and grid-rows syntax v0",
    syntax:
      "'(' [ <string>* <track-minmax> <string>* ]+ ')' [ '[' <positive-integer> ']' ]? | <track-minmax>",
  },
  "track-list-v0": {
    comment: "used by old grid-columns and grid-rows syntax v0",
    syntax: "[ <string>* <track-group> <string>* ]+ | none",
  },
  "track-minmax": {
    comment: "used by old grid-columns and grid-rows syntax v0",
    syntax:
      "minmax( <track-breadth> , <track-breadth> ) | auto | <track-breadth> | fit-content",
  },
  x: {
    comment:
      "missed; not sure we should add it, but no others except `cursor` is using it so it's ok for now; https://drafts.csswg.org/css-ui-3/#cursor",
    syntax: "<number>",
  },
  y: {
    comment:
      "missed; not sure we should add it, but no others except `cursor` is using so it's ok for now; https://drafts.csswg.org/css-ui-3/#cursor",
    syntax: "<number>",
  },
  declaration: {
    comment: "missed, restored by https://drafts.csswg.org/css-syntax",
    syntax: "<ident-token> : <declaration-value>? [ '!' important ]?",
  },
  "declaration-list": {
    comment: "missed, restored by https://drafts.csswg.org/css-syntax",
    syntax: "[ <declaration>? ';' ]* <declaration>?",
  },
  url: {
    comment: "https://drafts.csswg.org/css-values-4/#urls",
    syntax: "url( <string> <url-modifier>* ) | <url-token>",
  },
  "url-modifier": {
    comment: "https://drafts.csswg.org/css-values-4/#typedef-url-modifier",
    syntax: "<ident> | <function-token> <any-value> )",
  },
  "number-zero-one": {
    syntax: "<number [0,1]>",
  },
  "number-one-or-greater": {
    syntax: "<number [1,]>",
  },
  "positive-integer": {
    syntax: "<integer [0,]>",
  },
  "-non-standard-display": {
    syntax:
      "-ms-inline-flexbox | -ms-grid | -ms-inline-grid | -webkit-flex | -webkit-inline-flex | -webkit-box | -webkit-inline-box | -moz-inline-stack | -moz-box | -moz-inline-box",
  },
};
const require$$0$1 = {
  atrules: atrules,
  properties: properties,
  types: types$J,
};

const patch = require$$0$1;

const patch$1 = patch;

var dataPatch$1 = patch$1;

const require$$1 = {
  "@charset": {
    syntax: '@charset "<charset>";',
    groups: ["CSS Charsets"],
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@charset",
  },
  "@counter-style": {
    syntax:
      "@counter-style <counter-style-name> {\n  [ system: <counter-system>; ] ||\n  [ symbols: <counter-symbols>; ] ||\n  [ additive-symbols: <additive-symbols>; ] ||\n  [ negative: <negative-symbol>; ] ||\n  [ prefix: <prefix>; ] ||\n  [ suffix: <suffix>; ] ||\n  [ range: <range>; ] ||\n  [ pad: <padding>; ] ||\n  [ speak-as: <speak-as>; ] ||\n  [ fallback: <counter-style-name>; ]\n}",
    interfaces: ["CSSCounterStyleRule"],
    groups: ["CSS Counter Styles"],
    descriptors: {
      "additive-symbols": {
        syntax: "[ <integer> && <symbol> ]#",
        media: "all",
        initial: "n/a (required)",
        percentages: "no",
        computed: "asSpecified",
        order: "orderOfAppearance",
        status: "standard",
      },
      fallback: {
        syntax: "<counter-style-name>",
        media: "all",
        initial: "decimal",
        percentages: "no",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
      },
      negative: {
        syntax: "<symbol> <symbol>?",
        media: "all",
        initial: '"-" hyphen-minus',
        percentages: "no",
        computed: "asSpecified",
        order: "orderOfAppearance",
        status: "standard",
      },
      pad: {
        syntax: "<integer> && <symbol>",
        media: "all",
        initial: '0 ""',
        percentages: "no",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
      },
      prefix: {
        syntax: "<symbol>",
        media: "all",
        initial: '""',
        percentages: "no",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
      },
      range: {
        syntax: "[ [ <integer> | infinite ]{2} ]# | auto",
        media: "all",
        initial: "auto",
        percentages: "no",
        computed: "asSpecified",
        order: "orderOfAppearance",
        status: "standard",
      },
      "speak-as": {
        syntax:
          "auto | bullets | numbers | words | spell-out | <counter-style-name>",
        media: "all",
        initial: "auto",
        percentages: "no",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
      },
      suffix: {
        syntax: "<symbol>",
        media: "all",
        initial: '". "',
        percentages: "no",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
      },
      symbols: {
        syntax: "<symbol>+",
        media: "all",
        initial: "n/a (required)",
        percentages: "no",
        computed: "asSpecified",
        order: "orderOfAppearance",
        status: "standard",
      },
      system: {
        syntax:
          "cyclic | numeric | alphabetic | symbolic | additive | [ fixed <integer>? ] | [ extends <counter-style-name> ]",
        media: "all",
        initial: "symbolic",
        percentages: "no",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
      },
    },
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@counter-style",
  },
  "@document": {
    syntax:
      "@document [ <url> | url-prefix(<string>) | domain(<string>) | media-document(<string>) | regexp(<string>) ]# {\n  <group-rule-body>\n}",
    interfaces: ["CSSGroupingRule", "CSSConditionRule"],
    groups: ["CSS Conditional Rules"],
    status: "nonstandard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@document",
  },
  "@font-face": {
    syntax:
      "@font-face {\n  [ font-family: <family-name>; ] ||\n  [ src: <src>; ] ||\n  [ unicode-range: <unicode-range>; ] ||\n  [ font-variant: <font-variant>; ] ||\n  [ font-feature-settings: <font-feature-settings>; ] ||\n  [ font-variation-settings: <font-variation-settings>; ] ||\n  [ font-stretch: <font-stretch>; ] ||\n  [ font-weight: <font-weight>; ] ||\n  [ font-style: <font-style>; ] ||\n  [ size-adjust: <size-adjust>; ] ||\n  [ ascent-override: <ascent-override>; ] ||\n  [ descent-override: <descent-override>; ] ||\n  [ line-gap-override: <line-gap-override>; ]\n}",
    interfaces: ["CSSFontFaceRule"],
    groups: ["CSS Fonts"],
    descriptors: {
      "ascent-override": {
        syntax: "normal | <percentage>",
        media: "all",
        initial: "normal",
        percentages: "asSpecified",
        computed: "asSpecified",
        order: "orderOfAppearance",
        status: "experimental",
      },
      "descent-override": {
        syntax: "normal | <percentage>",
        media: "all",
        initial: "normal",
        percentages: "asSpecified",
        computed: "asSpecified",
        order: "orderOfAppearance",
        status: "experimental",
      },
      "font-display": {
        syntax: "[ auto | block | swap | fallback | optional ]",
        media: "visual",
        percentages: "no",
        initial: "auto",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "experimental",
      },
      "font-family": {
        syntax: "<family-name>",
        media: "all",
        initial: "n/a (required)",
        percentages: "no",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
      },
      "font-feature-settings": {
        syntax: "normal | <feature-tag-value>#",
        media: "all",
        initial: "normal",
        percentages: "no",
        computed: "asSpecified",
        order: "orderOfAppearance",
        status: "standard",
      },
      "font-variation-settings": {
        syntax: "normal | [ <string> <number> ]#",
        media: "all",
        initial: "normal",
        percentages: "no",
        computed: "asSpecified",
        order: "orderOfAppearance",
        status: "standard",
      },
      "font-stretch": {
        syntax: "<font-stretch-absolute>{1,2}",
        media: "all",
        initial: "normal",
        percentages: "no",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
      },
      "font-style": {
        syntax: "normal | italic | oblique <angle>{0,2}",
        media: "all",
        initial: "normal",
        percentages: "no",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
      },
      "font-weight": {
        syntax: "<font-weight-absolute>{1,2}",
        media: "all",
        initial: "normal",
        percentages: "no",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
      },
      "font-variant": {
        syntax:
          "normal | none | [ <common-lig-values> || <discretionary-lig-values> || <historical-lig-values> || <contextual-alt-values> || stylistic(<feature-value-name>) || historical-forms || styleset(<feature-value-name>#) || character-variant(<feature-value-name>#) || swash(<feature-value-name>) || ornaments(<feature-value-name>) || annotation(<feature-value-name>) || [ small-caps | all-small-caps | petite-caps | all-petite-caps | unicase | titling-caps ] || <numeric-figure-values> || <numeric-spacing-values> || <numeric-fraction-values> || ordinal || slashed-zero || <east-asian-variant-values> || <east-asian-width-values> || ruby ]",
        media: "all",
        initial: "normal",
        percentages: "no",
        computed: "asSpecified",
        order: "orderOfAppearance",
        status: "standard",
      },
      "line-gap-override": {
        syntax: "normal | <percentage>",
        media: "all",
        initial: "normal",
        percentages: "asSpecified",
        computed: "asSpecified",
        order: "orderOfAppearance",
        status: "experimental",
      },
      "size-adjust": {
        syntax: "<percentage>",
        media: "all",
        initial: "100%",
        percentages: "asSpecified",
        computed: "asSpecified",
        order: "orderOfAppearance",
        status: "experimental",
      },
      src: {
        syntax: "[ <url> [ format( <string># ) ]? | local( <family-name> ) ]#",
        media: "all",
        initial: "n/a (required)",
        percentages: "no",
        computed: "asSpecified",
        order: "orderOfAppearance",
        status: "standard",
      },
      "unicode-range": {
        syntax: "<unicode-range>#",
        media: "all",
        initial: "U+0-10FFFF",
        percentages: "no",
        computed: "asSpecified",
        order: "orderOfAppearance",
        status: "standard",
      },
    },
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@font-face",
  },
  "@font-feature-values": {
    syntax:
      "@font-feature-values <family-name># {\n  <feature-value-block-list>\n}",
    interfaces: ["CSSFontFeatureValuesRule"],
    groups: ["CSS Fonts"],
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@font-feature-values",
  },
  "@import": {
    syntax:
      "@import [ <string> | <url> ]\n        [ layer | layer(<layer-name>) ]?\n        [ supports( [ <supports-condition> | <declaration> ] ) ]?\n        <media-query-list>? ;",
    groups: ["CSS Conditional Rules", "Media Queries"],
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@import",
  },
  "@keyframes": {
    syntax: "@keyframes <keyframes-name> {\n  <keyframe-block-list>\n}",
    interfaces: ["CSSKeyframeRule", "CSSKeyframesRule"],
    groups: ["CSS Animations"],
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@keyframes",
  },
  "@layer": {
    syntax: "@layer [ <layer-name># | <layer-name>?  {\n  <stylesheet>\n} ]",
    interfaces: ["CSSLayerBlockRule", "CSSLayerStatementRule"],
    groups: ["CSS Cascading and Inheritance"],
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@layer",
  },
  "@media": {
    syntax: "@media <media-query-list> {\n  <group-rule-body>\n}",
    interfaces: [
      "CSSGroupingRule",
      "CSSConditionRule",
      "CSSMediaRule",
      "CSSCustomMediaRule",
    ],
    groups: ["CSS Conditional Rules", "Media Queries"],
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@media",
  },
  "@namespace": {
    syntax: "@namespace <namespace-prefix>? [ <string> | <url> ];",
    groups: ["CSS Namespaces"],
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@namespace",
  },
  "@page": {
    syntax: "@page <page-selector-list> {\n  <page-body>\n}",
    interfaces: ["CSSPageRule"],
    groups: ["CSS Pages"],
    descriptors: {
      bleed: {
        syntax: "auto | <length>",
        media: ["visual", "paged"],
        initial: "auto",
        percentages: "no",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
      },
      marks: {
        syntax: "none | [ crop || cross ]",
        media: ["visual", "paged"],
        initial: "none",
        percentages: "no",
        computed: "asSpecified",
        order: "orderOfAppearance",
        status: "standard",
      },
      size: {
        syntax:
          "<length>{1,2} | auto | [ <page-size> || [ portrait | landscape ] ]",
        media: ["visual", "paged"],
        initial: "auto",
        percentages: "no",
        computed: "asSpecifiedRelativeToAbsoluteLengths",
        order: "orderOfAppearance",
        status: "standard",
      },
    },
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@page",
  },
  "@property": {
    syntax: "@property <custom-property-name> {\n  <declaration-list>\n}",
    interfaces: ["CSS", "CSSPropertyRule"],
    groups: ["CSS Houdini"],
    descriptors: {
      syntax: {
        syntax: "<string>",
        media: "all",
        percentages: "no",
        initial: "n/a (required)",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "experimental",
      },
      inherits: {
        syntax: "true | false",
        media: "all",
        percentages: "no",
        initial: "auto",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "experimental",
      },
      "initial-value": {
        syntax: "<string>",
        media: "all",
        initial: "n/a (required)",
        percentages: "no",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "experimental",
      },
    },
    status: "experimental",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@property",
  },
  "@scroll-timeline": {
    syntax: "@scroll-timeline <timeline-name> { <declaration-list> }",
    interfaces: ["ScrollTimeline"],
    groups: ["CSS Animations"],
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@scroll-timeline",
  },
  "@supports": {
    syntax: "@supports <supports-condition> {\n  <group-rule-body>\n}",
    interfaces: ["CSSGroupingRule", "CSSConditionRule", "CSSSupportsRule"],
    groups: ["CSS Conditional Rules"],
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@supports",
  },
  "@viewport": {
    syntax: "@viewport {\n  <group-rule-body>\n}",
    interfaces: ["CSSViewportRule"],
    groups: ["CSS Device Adaptation"],
    descriptors: {
      height: {
        syntax: "<viewport-length>{1,2}",
        media: ["visual", "continuous"],
        initial: ["min-height", "max-height"],
        percentages: ["min-height", "max-height"],
        computed: ["min-height", "max-height"],
        order: "orderOfAppearance",
        status: "standard",
      },
      "max-height": {
        syntax: "<viewport-length>",
        media: ["visual", "continuous"],
        initial: "auto",
        percentages: "referToHeightOfInitialViewport",
        computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
        order: "uniqueOrder",
        status: "standard",
      },
      "max-width": {
        syntax: "<viewport-length>",
        media: ["visual", "continuous"],
        initial: "auto",
        percentages: "referToWidthOfInitialViewport",
        computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
        order: "uniqueOrder",
        status: "standard",
      },
      "max-zoom": {
        syntax: "auto | <number> | <percentage>",
        media: ["visual", "continuous"],
        initial: "auto",
        percentages: "the zoom factor itself",
        computed: "autoNonNegativeOrPercentage",
        order: "uniqueOrder",
        status: "standard",
      },
      "min-height": {
        syntax: "<viewport-length>",
        media: ["visual", "continuous"],
        initial: "auto",
        percentages: "referToHeightOfInitialViewport",
        computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
        order: "uniqueOrder",
        status: "standard",
      },
      "min-width": {
        syntax: "<viewport-length>",
        media: ["visual", "continuous"],
        initial: "auto",
        percentages: "referToWidthOfInitialViewport",
        computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
        order: "uniqueOrder",
        status: "standard",
      },
      "min-zoom": {
        syntax: "auto | <number> | <percentage>",
        media: ["visual", "continuous"],
        initial: "auto",
        percentages: "the zoom factor itself",
        computed: "autoNonNegativeOrPercentage",
        order: "uniqueOrder",
        status: "standard",
      },
      orientation: {
        syntax: "auto | portrait | landscape",
        media: ["visual", "continuous"],
        initial: "auto",
        percentages: "referToSizeOfBoundingBox",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
      },
      "user-zoom": {
        syntax: "zoom | fixed",
        media: ["visual", "continuous"],
        initial: "zoom",
        percentages: "referToSizeOfBoundingBox",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
      },
      "viewport-fit": {
        syntax: "auto | contain | cover",
        media: ["visual", "continuous"],
        initial: "auto",
        percentages: "no",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
      },
      width: {
        syntax: "<viewport-length>{1,2}",
        media: ["visual", "continuous"],
        initial: ["min-width", "max-width"],
        percentages: ["min-width", "max-width"],
        computed: ["min-width", "max-width"],
        order: "orderOfAppearance",
        status: "standard",
      },
      zoom: {
        syntax: "auto | <number> | <percentage>",
        media: ["visual", "continuous"],
        initial: "auto",
        percentages: "the zoom factor itself",
        computed: "autoNonNegativeOrPercentage",
        order: "uniqueOrder",
        status: "standard",
      },
    },
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@viewport",
  },
};

const all = {
  syntax: "initial | inherit | unset | revert | revert-layer",
  media: "noPracticalMedia",
  inherited: false,
  animationType: "eachOfShorthandPropertiesExceptUnicodeBiDiAndDirection",
  percentages: "no",
  groups: ["CSS Miscellaneous"],
  initial: "noPracticalInitialValue",
  appliesto: "allElements",
  computed: "asSpecifiedAppliesToEachProperty",
  order: "uniqueOrder",
  status: "standard",
  mdn_url: "https://developer.mozilla.org/docs/Web/CSS/all",
};
const animation = {
  syntax: "<single-animation>#",
  media: "visual",
  inherited: false,
  animationType: "notAnimatable",
  percentages: "no",
  groups: ["CSS Animations"],
  initial: [
    "animation-name",
    "animation-duration",
    "animation-timing-function",
    "animation-delay",
    "animation-iteration-count",
    "animation-direction",
    "animation-fill-mode",
    "animation-play-state",
    "animation-timeline",
  ],
  appliesto: "allElementsAndPseudos",
  computed: [
    "animation-name",
    "animation-duration",
    "animation-timing-function",
    "animation-delay",
    "animation-direction",
    "animation-iteration-count",
    "animation-fill-mode",
    "animation-play-state",
    "animation-timeline",
  ],
  order: "orderOfAppearance",
  status: "standard",
  mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation",
};
const appearance = {
  syntax: "none | auto | textfield | menulist-button | <compat-auto>",
  media: "all",
  inherited: false,
  animationType: "discrete",
  percentages: "no",
  groups: ["CSS Basic User Interface"],
  initial: "none",
  appliesto: "allElements",
  computed: "asSpecified",
  order: "perGrammar",
  status: "experimental",
  mdn_url: "https://developer.mozilla.org/docs/Web/CSS/appearance",
};
const azimuth = {
  syntax:
    "<angle> | [ [ left-side | far-left | left | center-left | center | center-right | right | far-right | right-side ] || behind ] | leftwards | rightwards",
  media: "aural",
  inherited: true,
  animationType: "discrete",
  percentages: "no",
  groups: ["CSS Speech"],
  initial: "center",
  appliesto: "allElements",
  computed: "normalizedAngle",
  order: "orderOfAppearance",
  status: "obsolete",
  mdn_url: "https://developer.mozilla.org/docs/Web/CSS/azimuth",
};
const background$2 = {
  syntax: "[ <bg-layer> , ]* <final-bg-layer>",
  media: "visual",
  inherited: false,
  animationType: [
    "background-color",
    "background-image",
    "background-clip",
    "background-position",
    "background-size",
    "background-repeat",
    "background-attachment",
  ],
  percentages: ["background-position", "background-size"],
  groups: ["CSS Backgrounds and Borders"],
  initial: [
    "background-image",
    "background-position",
    "background-size",
    "background-repeat",
    "background-origin",
    "background-clip",
    "background-attachment",
    "background-color",
  ],
  appliesto: "allElements",
  computed: [
    "background-image",
    "background-position",
    "background-size",
    "background-repeat",
    "background-origin",
    "background-clip",
    "background-attachment",
    "background-color",
  ],
  order: "orderOfAppearance",
  alsoAppliesTo: ["::first-letter", "::first-line", "::placeholder"],
  status: "standard",
  mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background",
};
const border$2 = {
  syntax: "<line-width> || <line-style> || <color>",
  media: "visual",
  inherited: false,
  animationType: ["border-color", "border-style", "border-width"],
  percentages: "no",
  groups: ["CSS Backgrounds and Borders"],
  initial: ["border-width", "border-style", "border-color"],
  appliesto: "allElements",
  computed: ["border-width", "border-style", "border-color"],
  order: "orderOfAppearance",
  alsoAppliesTo: ["::first-letter"],
  status: "standard",
  mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border",
};
const bottom = {
  syntax: "<length> | <percentage> | auto",
  media: "visual",
  inherited: false,
  animationType: "lpc",
  percentages: "referToContainingBlockHeight",
  groups: ["CSS Positioning"],
  initial: "auto",
  appliesto: "positionedElements",
  computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
  order: "uniqueOrder",
  status: "standard",
  mdn_url: "https://developer.mozilla.org/docs/Web/CSS/bottom",
};
const clear = {
  syntax: "none | left | right | both | inline-start | inline-end",
  media: "visual",
  inherited: false,
  animationType: "discrete",
  percentages: "no",
  groups: ["CSS Positioning"],
  initial: "none",
  appliesto: "blockLevelElements",
  computed: "asSpecified",
  order: "uniqueOrder",
  status: "standard",
  mdn_url: "https://developer.mozilla.org/docs/Web/CSS/clear",
};
const clip = {
  syntax: "<shape> | auto",
  media: "visual",
  inherited: false,
  animationType: "rectangle",
  percentages: "no",
  groups: ["CSS Masking"],
  initial: "auto",
  appliesto: "absolutelyPositionedElements",
  computed: "autoOrRectangle",
  order: "uniqueOrder",
  status: "standard",
  mdn_url: "https://developer.mozilla.org/docs/Web/CSS/clip",
};
const color$3 = {
  syntax: "<color>",
  media: "visual",
  inherited: true,
  animationType: "byComputedValueType",
  percentages: "no",
  groups: ["CSS Color"],
  initial: "canvastext",
  appliesto: "allElementsAndText",
  computed: "computedColor",
  order: "perGrammar",
  alsoAppliesTo: ["::first-letter", "::first-line", "::placeholder"],
  status: "standard",
  mdn_url: "https://developer.mozilla.org/docs/Web/CSS/color",
};
const columns = {
  syntax: "<'column-width'> || <'column-count'>",
  media: "visual",
  inherited: false,
  animationType: ["column-width", "column-count"],
  percentages: "no",
  groups: ["CSS Columns"],
  initial: ["column-width", "column-count"],
  appliesto: "blockContainersExceptTableWrappers",
  computed: ["column-width", "column-count"],
  order: "perGrammar",
  status: "standard",
  mdn_url: "https://developer.mozilla.org/docs/Web/CSS/columns",
};
const contain = {
  syntax: "none | strict | content | [ size || layout || style || paint ]",
  media: "all",
  inherited: false,
  animationType: "discrete",
  percentages: "no",
  groups: ["CSS Containment"],
  initial: "none",
  appliesto: "allElements",
  computed: "asSpecified",
  order: "perGrammar",
  status: "standard",
  mdn_url: "https://developer.mozilla.org/docs/Web/CSS/contain",
};
const content = {
  syntax:
    "normal | none | [ <content-replacement> | <content-list> ] [/ [ <string> | <counter> ]+ ]?",
  media: "all",
  inherited: false,
  animationType: "discrete",
  percentages: "no",
  groups: ["CSS Generated Content"],
  initial: "normal",
  appliesto: "allElementsTreeAbidingPseudoElementsPageMarginBoxes",
  computed: "normalOnElementsForPseudosNoneAbsoluteURIStringOrAsSpecified",
  order: "uniqueOrder",
  status: "standard",
  mdn_url: "https://developer.mozilla.org/docs/Web/CSS/content",
};
const cursor = {
  syntax:
    "[ [ <url> [ <x> <y> ]? , ]* [ auto | default | none | context-menu | help | pointer | progress | wait | cell | crosshair | text | vertical-text | alias | copy | move | no-drop | not-allowed | e-resize | n-resize | ne-resize | nw-resize | s-resize | se-resize | sw-resize | w-resize | ew-resize | ns-resize | nesw-resize | nwse-resize | col-resize | row-resize | all-scroll | zoom-in | zoom-out | grab | grabbing ] ]",
  media: ["visual", "interactive"],
  inherited: true,
  animationType: "discrete",
  percentages: "no",
  groups: ["CSS Basic User Interface"],
  initial: "auto",
  appliesto: "allElements",
  computed: "asSpecifiedURLsAbsolute",
  order: "uniqueOrder",
  status: "standard",
  mdn_url: "https://developer.mozilla.org/docs/Web/CSS/cursor",
};
const direction = {
  syntax: "ltr | rtl",
  media: "visual",
  inherited: true,
  animationType: "discrete",
  percentages: "no",
  groups: ["CSS Writing Modes"],
  initial: "ltr",
  appliesto: "allElements",
  computed: "asSpecified",
  order: "uniqueOrder",
  status: "standard",
  mdn_url: "https://developer.mozilla.org/docs/Web/CSS/direction",
};
const display = {
  syntax:
    "[ <display-outside> || <display-inside> ] | <display-listitem> | <display-internal> | <display-box> | <display-legacy>",
  media: "all",
  inherited: false,
  animationType: "notAnimatable",
  percentages: "no",
  groups: ["CSS Display"],
  initial: "inline",
  appliesto: "allElements",
  computed:
    "asSpecifiedExceptPositionedFloatingAndRootElementsKeywordMaybeDifferent",
  order: "uniqueOrder",
  status: "standard",
  mdn_url: "https://developer.mozilla.org/docs/Web/CSS/display",
};
const filter = {
  syntax: "none | <filter-function-list>",
  media: "visual",
  inherited: false,
  animationType: "filterList",
  percentages: "no",
  groups: ["Filter Effects"],
  initial: "none",
  appliesto: "allElementsSVGContainerElements",
  computed: "asSpecified",
  order: "uniqueOrder",
  status: "standard",
  mdn_url: "https://developer.mozilla.org/docs/Web/CSS/filter",
};
const flex = {
  syntax: "none | [ <'flex-grow'> <'flex-shrink'>? || <'flex-basis'> ]",
  media: "visual",
  inherited: false,
  animationType: ["flex-grow", "flex-shrink", "flex-basis"],
  percentages: "no",
  groups: ["CSS Flexible Box Layout"],
  initial: ["flex-grow", "flex-shrink", "flex-basis"],
  appliesto: "flexItemsAndInFlowPseudos",
  computed: ["flex-grow", "flex-shrink", "flex-basis"],
  order: "orderOfAppearance",
  status: "standard",
  mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex",
};
const float = {
  syntax: "left | right | none | inline-start | inline-end",
  media: "visual",
  inherited: false,
  animationType: "discrete",
  percentages: "no",
  groups: ["CSS Positioning"],
  initial: "none",
  appliesto: "allElementsNoEffectIfDisplayNone",
  computed: "asSpecified",
  order: "uniqueOrder",
  status: "standard",
  mdn_url: "https://developer.mozilla.org/docs/Web/CSS/float",
};
const font$2 = {
  syntax:
    "[ [ <'font-style'> || <font-variant-css21> || <'font-weight'> || <'font-stretch'> ]? <'font-size'> [ / <'line-height'> ]? <'font-family'> ] | caption | icon | menu | message-box | small-caption | status-bar",
  media: "visual",
  inherited: true,
  animationType: [
    "font-style",
    "font-variant",
    "font-weight",
    "font-stretch",
    "font-size",
    "line-height",
    "font-family",
  ],
  percentages: ["font-size", "line-height"],
  groups: ["CSS Fonts"],
  initial: [
    "font-style",
    "font-variant",
    "font-weight",
    "font-stretch",
    "font-size",
    "line-height",
    "font-family",
  ],
  appliesto: "allElements",
  computed: [
    "font-style",
    "font-variant",
    "font-weight",
    "font-stretch",
    "font-size",
    "line-height",
    "font-family",
  ],
  order: "orderOfAppearance",
  alsoAppliesTo: ["::first-letter", "::first-line", "::placeholder"],
  status: "standard",
  mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font",
};
const gap = {
  syntax: "<'row-gap'> <'column-gap'>?",
  media: "visual",
  inherited: false,
  animationType: ["row-gap", "column-gap"],
  percentages: "no",
  groups: ["CSS Box Alignment"],
  initial: ["row-gap", "column-gap"],
  appliesto: "multiColumnElementsFlexContainersGridContainers",
  computed: ["row-gap", "column-gap"],
  order: "uniqueOrder",
  status: "standard",
  mdn_url: "https://developer.mozilla.org/docs/Web/CSS/gap",
};
const grid = {
  syntax:
    "<'grid-template'> | <'grid-template-rows'> / [ auto-flow && dense? ] <'grid-auto-columns'>? | [ auto-flow && dense? ] <'grid-auto-rows'>? / <'grid-template-columns'>",
  media: "visual",
  inherited: false,
  animationType: "discrete",
  percentages: [
    "grid-template-rows",
    "grid-template-columns",
    "grid-auto-rows",
    "grid-auto-columns",
  ],
  groups: ["CSS Grid Layout"],
  initial: [
    "grid-template-rows",
    "grid-template-columns",
    "grid-template-areas",
    "grid-auto-rows",
    "grid-auto-columns",
    "grid-auto-flow",
    "grid-column-gap",
    "grid-row-gap",
    "column-gap",
    "row-gap",
  ],
  appliesto: "gridContainers",
  computed: [
    "grid-template-rows",
    "grid-template-columns",
    "grid-template-areas",
    "grid-auto-rows",
    "grid-auto-columns",
    "grid-auto-flow",
    "grid-column-gap",
    "grid-row-gap",
    "column-gap",
    "row-gap",
  ],
  order: "uniqueOrder",
  status: "standard",
  mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid",
};
const height = {
  syntax:
    "auto | <length> | <percentage> | min-content | max-content | fit-content | fit-content(<length-percentage>)",
  media: "visual",
  inherited: false,
  animationType: "lpc",
  percentages:
    "regardingHeightOfGeneratedBoxContainingBlockPercentagesRelativeToContainingBlock",
  groups: ["CSS Box Model"],
  initial: "auto",
  appliesto: "allElementsButNonReplacedAndTableColumns",
  computed: "percentageAutoOrAbsoluteLength",
  order: "uniqueOrder",
  status: "standard",
  mdn_url: "https://developer.mozilla.org/docs/Web/CSS/height",
};
const hyphens = {
  syntax: "none | manual | auto",
  media: "visual",
  inherited: true,
  animationType: "discrete",
  percentages: "no",
  groups: ["CSS Text"],
  initial: "manual",
  appliesto: "allElements",
  computed: "asSpecified",
  order: "uniqueOrder",
  status: "standard",
  mdn_url: "https://developer.mozilla.org/docs/Web/CSS/hyphens",
};
const inset = {
  syntax: "<'top'>{1,4}",
  media: "visual",
  inherited: false,
  animationType: "lpc",
  percentages: "logicalHeightOrWidthOfContainingBlock",
  groups: ["CSS Logical Properties"],
  initial: "auto",
  appliesto: "positionedElements",
  computed: "sameAsBoxOffsets",
  order: "uniqueOrder",
  status: "standard",
  mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset",
};
const isolation = {
  syntax: "auto | isolate",
  media: "visual",
  inherited: false,
  animationType: "discrete",
  percentages: "no",
  groups: ["Compositing and Blending"],
  initial: "auto",
  appliesto: "allElementsSVGContainerGraphicsAndGraphicsReferencingElements",
  computed: "asSpecified",
  order: "uniqueOrder",
  status: "standard",
  mdn_url: "https://developer.mozilla.org/docs/Web/CSS/isolation",
};
const left = {
  syntax: "<length> | <percentage> | auto",
  media: "visual",
  inherited: false,
  animationType: "lpc",
  percentages: "referToWidthOfContainingBlock",
  groups: ["CSS Positioning"],
  initial: "auto",
  appliesto: "positionedElements",
  computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
  order: "uniqueOrder",
  status: "standard",
  mdn_url: "https://developer.mozilla.org/docs/Web/CSS/left",
};
const margin = {
  syntax: "[ <length> | <percentage> | auto ]{1,4}",
  media: "visual",
  inherited: false,
  animationType: "length",
  percentages: "referToWidthOfContainingBlock",
  groups: ["CSS Box Model"],
  initial: ["margin-bottom", "margin-left", "margin-right", "margin-top"],
  appliesto: "allElementsExceptTableDisplayTypes",
  computed: ["margin-bottom", "margin-left", "margin-right", "margin-top"],
  order: "uniqueOrder",
  alsoAppliesTo: ["::first-letter", "::first-line"],
  status: "standard",
  mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin",
};
const mask = {
  syntax: "<mask-layer>#",
  media: "visual",
  inherited: false,
  animationType: [
    "mask-image",
    "mask-mode",
    "mask-repeat",
    "mask-position",
    "mask-clip",
    "mask-origin",
    "mask-size",
    "mask-composite",
  ],
  percentages: ["mask-position"],
  groups: ["CSS Masking"],
  initial: [
    "mask-image",
    "mask-mode",
    "mask-repeat",
    "mask-position",
    "mask-clip",
    "mask-origin",
    "mask-size",
    "mask-composite",
  ],
  appliesto: "allElementsSVGContainerElements",
  computed: [
    "mask-image",
    "mask-mode",
    "mask-repeat",
    "mask-position",
    "mask-clip",
    "mask-origin",
    "mask-size",
    "mask-composite",
  ],
  order: "perGrammar",
  stacking: true,
  status: "standard",
  mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask",
};
const offset = {
  syntax:
    "[ <'offset-position'>? [ <'offset-path'> [ <'offset-distance'> || <'offset-rotate'> ]? ]? ]! [ / <'offset-anchor'> ]?",
  media: "visual",
  inherited: false,
  animationType: [
    "offset-position",
    "offset-path",
    "offset-distance",
    "offset-anchor",
    "offset-rotate",
  ],
  percentages: ["offset-position", "offset-distance", "offset-anchor"],
  groups: ["CSS Motion Path"],
  initial: [
    "offset-position",
    "offset-path",
    "offset-distance",
    "offset-anchor",
    "offset-rotate",
  ],
  appliesto: "transformableElements",
  computed: [
    "offset-position",
    "offset-path",
    "offset-distance",
    "offset-anchor",
    "offset-rotate",
  ],
  order: "perGrammar",
  stacking: true,
  status: "standard",
  mdn_url: "https://developer.mozilla.org/docs/Web/CSS/offset",
};
const opacity = {
  syntax: "<alpha-value>",
  media: "visual",
  inherited: false,
  animationType: "byComputedValueType",
  percentages: "mapToRange0To1",
  groups: ["CSS Color"],
  initial: "1",
  appliesto: "allElements",
  computed: "specifiedValueNumberClipped0To1",
  order: "perGrammar",
  alsoAppliesTo: ["::placeholder"],
  status: "standard",
  mdn_url: "https://developer.mozilla.org/docs/Web/CSS/opacity",
};
const order = {
  syntax: "<integer>",
  media: "visual",
  inherited: false,
  animationType: "integer",
  percentages: "no",
  groups: ["CSS Flexible Box Layout"],
  initial: "0",
  appliesto: "flexItemsGridItemsAbsolutelyPositionedContainerChildren",
  computed: "asSpecified",
  order: "uniqueOrder",
  status: "standard",
  mdn_url: "https://developer.mozilla.org/docs/Web/CSS/order",
};
const orphans = {
  syntax: "<integer>",
  media: "visual",
  inherited: true,
  animationType: "discrete",
  percentages: "no",
  groups: ["CSS Fragmentation"],
  initial: "2",
  appliesto: "blockContainerElements",
  computed: "asSpecified",
  order: "perGrammar",
  status: "standard",
  mdn_url: "https://developer.mozilla.org/docs/Web/CSS/orphans",
};
const outline = {
  syntax: "[ <'outline-color'> || <'outline-style'> || <'outline-width'> ]",
  media: ["visual", "interactive"],
  inherited: false,
  animationType: ["outline-color", "outline-width", "outline-style"],
  percentages: "no",
  groups: ["CSS Basic User Interface"],
  initial: ["outline-color", "outline-style", "outline-width"],
  appliesto: "allElements",
  computed: ["outline-color", "outline-width", "outline-style"],
  order: "orderOfAppearance",
  status: "standard",
  mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline",
};
const overflow = {
  syntax: "[ visible | hidden | clip | scroll | auto ]{1,2}",
  media: "visual",
  inherited: false,
  animationType: "discrete",
  percentages: "no",
  groups: ["CSS Overflow"],
  initial: "visible",
  appliesto: "blockContainersFlexContainersGridContainers",
  computed: ["overflow-x", "overflow-y"],
  order: "uniqueOrder",
  status: "standard",
  mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow",
};
const padding = {
  syntax: "[ <length> | <percentage> ]{1,4}",
  media: "visual",
  inherited: false,
  animationType: "length",
  percentages: "referToWidthOfContainingBlock",
  groups: ["CSS Box Model"],
  initial: ["padding-bottom", "padding-left", "padding-right", "padding-top"],
  appliesto: "allElementsExceptInternalTableDisplayTypes",
  computed: ["padding-bottom", "padding-left", "padding-right", "padding-top"],
  order: "uniqueOrder",
  alsoAppliesTo: ["::first-letter", "::first-line"],
  status: "standard",
  mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding",
};
const perspective = {
  syntax: "none | <length>",
  media: "visual",
  inherited: false,
  animationType: "length",
  percentages: "no",
  groups: ["CSS Transforms"],
  initial: "none",
  appliesto: "transformableElements",
  computed: "absoluteLengthOrNone",
  order: "uniqueOrder",
  stacking: true,
  status: "standard",
  mdn_url: "https://developer.mozilla.org/docs/Web/CSS/perspective",
};
const position$1 = {
  syntax: "static | relative | absolute | sticky | fixed",
  media: "visual",
  inherited: false,
  animationType: "discrete",
  percentages: "no",
  groups: ["CSS Positioning"],
  initial: "static",
  appliesto: "allElements",
  computed: "asSpecified",
  order: "uniqueOrder",
  stacking: true,
  status: "standard",
  mdn_url: "https://developer.mozilla.org/docs/Web/CSS/position",
};
const quotes = {
  syntax: "none | auto | [ <string> <string> ]+",
  media: "visual",
  inherited: true,
  animationType: "discrete",
  percentages: "no",
  groups: ["CSS Generated Content"],
  initial: "dependsOnUserAgent",
  appliesto: "allElements",
  computed: "asSpecified",
  order: "uniqueOrder",
  status: "standard",
  mdn_url: "https://developer.mozilla.org/docs/Web/CSS/quotes",
};
const resize = {
  syntax: "none | both | horizontal | vertical | block | inline",
  media: "visual",
  inherited: false,
  animationType: "discrete",
  percentages: "no",
  groups: ["CSS Basic User Interface"],
  initial: "none",
  appliesto: "elementsWithOverflowNotVisibleAndReplacedElements",
  computed: "asSpecified",
  order: "uniqueOrder",
  status: "standard",
  mdn_url: "https://developer.mozilla.org/docs/Web/CSS/resize",
};
const right = {
  syntax: "<length> | <percentage> | auto",
  media: "visual",
  inherited: false,
  animationType: "lpc",
  percentages: "referToWidthOfContainingBlock",
  groups: ["CSS Positioning"],
  initial: "auto",
  appliesto: "positionedElements",
  computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
  order: "uniqueOrder",
  status: "standard",
  mdn_url: "https://developer.mozilla.org/docs/Web/CSS/right",
};
const rotate = {
  syntax: "none | <angle> | [ x | y | z | <number>{3} ] && <angle>",
  media: "visual",
  inherited: false,
  animationType: "transform",
  percentages: "no",
  groups: ["CSS Transforms"],
  initial: "none",
  appliesto: "transformableElements",
  computed: "asSpecified",
  order: "perGrammar",
  stacking: true,
  status: "standard",
  mdn_url: "https://developer.mozilla.org/docs/Web/CSS/rotate",
};
const scale = {
  syntax: "none | <number>{1,3}",
  media: "visual",
  inherited: false,
  animationType: "transform",
  percentages: "no",
  groups: ["CSS Transforms"],
  initial: "none",
  appliesto: "transformableElements",
  computed: "asSpecified",
  order: "perGrammar",
  stacking: true,
  status: "standard",
  mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scale",
};
const top = {
  syntax: "<length> | <percentage> | auto",
  media: "visual",
  inherited: false,
  animationType: "lpc",
  percentages: "referToContainingBlockHeight",
  groups: ["CSS Positioning"],
  initial: "auto",
  appliesto: "positionedElements",
  computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
  order: "uniqueOrder",
  status: "standard",
  mdn_url: "https://developer.mozilla.org/docs/Web/CSS/top",
};
const transform = {
  syntax: "none | <transform-list>",
  media: "visual",
  inherited: false,
  animationType: "transform",
  percentages: "referToSizeOfBoundingBox",
  groups: ["CSS Transforms"],
  initial: "none",
  appliesto: "transformableElements",
  computed: "asSpecifiedRelativeToAbsoluteLengths",
  order: "uniqueOrder",
  stacking: true,
  status: "standard",
  mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transform",
};
const transition = {
  syntax: "<single-transition>#",
  media: "interactive",
  inherited: false,
  animationType: "discrete",
  percentages: "no",
  groups: ["CSS Transitions"],
  initial: [
    "transition-delay",
    "transition-duration",
    "transition-property",
    "transition-timing-function",
  ],
  appliesto: "allElementsAndPseudos",
  computed: [
    "transition-delay",
    "transition-duration",
    "transition-property",
    "transition-timing-function",
  ],
  order: "orderOfAppearance",
  status: "standard",
  mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition",
};
const translate = {
  syntax: "none | <length-percentage> [ <length-percentage> <length>? ]?",
  media: "visual",
  inherited: false,
  animationType: "transform",
  percentages: "referToSizeOfBoundingBox",
  groups: ["CSS Transforms"],
  initial: "none",
  appliesto: "transformableElements",
  computed: "asSpecifiedRelativeToAbsoluteLengths",
  order: "perGrammar",
  stacking: true,
  status: "standard",
  mdn_url: "https://developer.mozilla.org/docs/Web/CSS/translate",
};
const visibility = {
  syntax: "visible | hidden | collapse",
  media: "visual",
  inherited: true,
  animationType: "visibility",
  percentages: "no",
  groups: ["CSS Box Model"],
  initial: "visible",
  appliesto: "allElements",
  computed: "asSpecified",
  order: "uniqueOrder",
  status: "standard",
  mdn_url: "https://developer.mozilla.org/docs/Web/CSS/visibility",
};
const widows = {
  syntax: "<integer>",
  media: "visual",
  inherited: true,
  animationType: "discrete",
  percentages: "no",
  groups: ["CSS Fragmentation"],
  initial: "2",
  appliesto: "blockContainerElements",
  computed: "asSpecified",
  order: "perGrammar",
  status: "standard",
  mdn_url: "https://developer.mozilla.org/docs/Web/CSS/widows",
};
const width = {
  syntax:
    "auto | <length> | <percentage> | min-content | max-content | fit-content | fit-content(<length-percentage>)",
  media: "visual",
  inherited: false,
  animationType: "lpc",
  percentages: "referToWidthOfContainingBlock",
  groups: ["CSS Box Model"],
  initial: "auto",
  appliesto: "allElementsButNonReplacedAndTableRows",
  computed: "percentageAutoOrAbsoluteLength",
  order: "lengthOrPercentageBeforeKeywordIfBothPresent",
  status: "standard",
  mdn_url: "https://developer.mozilla.org/docs/Web/CSS/width",
};
const zoom = {
  syntax: "normal | reset | <number> | <percentage>",
  media: "visual",
  inherited: false,
  animationType: "integer",
  percentages: "no",
  groups: ["Microsoft Extensions"],
  initial: "normal",
  appliesto: "allElements",
  computed: "asSpecified",
  order: "uniqueOrder",
  status: "nonstandard",
  mdn_url: "https://developer.mozilla.org/docs/Web/CSS/zoom",
};
const require$$2 = {
  "--*": {
    syntax: "<declaration-value>",
    media: "all",
    inherited: true,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Variables"],
    initial: "seeProse",
    appliesto: "allElements",
    computed: "asSpecifiedWithVarsSubstituted",
    order: "perGrammar",
    status: "experimental",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/--*",
  },
  "-ms-accelerator": {
    syntax: "false | true",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["Microsoft Extensions"],
    initial: "false",
    appliesto: "allElements",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "nonstandard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-accelerator",
  },
  "-ms-block-progression": {
    syntax: "tb | rl | bt | lr",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["Microsoft Extensions"],
    initial: "tb",
    appliesto: "allElements",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "nonstandard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-block-progression",
  },
  "-ms-content-zoom-chaining": {
    syntax: "none | chained",
    media: "interactive",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["Microsoft Extensions"],
    initial: "none",
    appliesto: "nonReplacedBlockAndInlineBlockElements",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "nonstandard",
    mdn_url:
      "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-chaining",
  },
  "-ms-content-zooming": {
    syntax: "none | zoom",
    media: "interactive",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["Microsoft Extensions"],
    initial: "zoomForTheTopLevelNoneForTheRest",
    appliesto: "nonReplacedBlockAndInlineBlockElements",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "nonstandard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zooming",
  },
  "-ms-content-zoom-limit": {
    syntax: "<'-ms-content-zoom-limit-min'> <'-ms-content-zoom-limit-max'>",
    media: "interactive",
    inherited: false,
    animationType: "discrete",
    percentages: ["-ms-content-zoom-limit-max", "-ms-content-zoom-limit-min"],
    groups: ["Microsoft Extensions"],
    initial: ["-ms-content-zoom-limit-max", "-ms-content-zoom-limit-min"],
    appliesto: "nonReplacedBlockAndInlineBlockElements",
    computed: ["-ms-content-zoom-limit-max", "-ms-content-zoom-limit-min"],
    order: "uniqueOrder",
    status: "nonstandard",
    mdn_url:
      "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-limit",
  },
  "-ms-content-zoom-limit-max": {
    syntax: "<percentage>",
    media: "interactive",
    inherited: false,
    animationType: "discrete",
    percentages: "maxZoomFactor",
    groups: ["Microsoft Extensions"],
    initial: "400%",
    appliesto: "nonReplacedBlockAndInlineBlockElements",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "nonstandard",
    mdn_url:
      "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-limit-max",
  },
  "-ms-content-zoom-limit-min": {
    syntax: "<percentage>",
    media: "interactive",
    inherited: false,
    animationType: "discrete",
    percentages: "minZoomFactor",
    groups: ["Microsoft Extensions"],
    initial: "100%",
    appliesto: "nonReplacedBlockAndInlineBlockElements",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "nonstandard",
    mdn_url:
      "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-limit-min",
  },
  "-ms-content-zoom-snap": {
    syntax:
      "<'-ms-content-zoom-snap-type'> || <'-ms-content-zoom-snap-points'>",
    media: "interactive",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["Microsoft Extensions"],
    initial: ["-ms-content-zoom-snap-type", "-ms-content-zoom-snap-points"],
    appliesto: "nonReplacedBlockAndInlineBlockElements",
    computed: ["-ms-content-zoom-snap-type", "-ms-content-zoom-snap-points"],
    order: "uniqueOrder",
    status: "nonstandard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-snap",
  },
  "-ms-content-zoom-snap-points": {
    syntax:
      "snapInterval( <percentage>, <percentage> ) | snapList( <percentage># )",
    media: "interactive",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["Microsoft Extensions"],
    initial: "snapInterval(0%, 100%)",
    appliesto: "nonReplacedBlockAndInlineBlockElements",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "nonstandard",
    mdn_url:
      "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-snap-points",
  },
  "-ms-content-zoom-snap-type": {
    syntax: "none | proximity | mandatory",
    media: "interactive",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["Microsoft Extensions"],
    initial: "none",
    appliesto: "nonReplacedBlockAndInlineBlockElements",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "nonstandard",
    mdn_url:
      "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-snap-type",
  },
  "-ms-filter": {
    syntax: "<string>",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["Microsoft Extensions"],
    initial: '""',
    appliesto: "allElements",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "nonstandard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-filter",
  },
  "-ms-flow-from": {
    syntax: "[ none | <custom-ident> ]#",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["Microsoft Extensions"],
    initial: "none",
    appliesto: "nonReplacedElements",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "nonstandard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-flow-from",
  },
  "-ms-flow-into": {
    syntax: "[ none | <custom-ident> ]#",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["Microsoft Extensions"],
    initial: "none",
    appliesto: "iframeElements",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "nonstandard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-flow-into",
  },
  "-ms-grid-columns": {
    syntax: "none | <track-list> | <auto-track-list>",
    media: "visual",
    inherited: false,
    animationType: "simpleListOfLpcDifferenceLpc",
    percentages: "referToDimensionOfContentArea",
    groups: ["CSS Grid Layout"],
    initial: "none",
    appliesto: "gridContainers",
    computed: "asSpecifiedRelativeToAbsoluteLengths",
    order: "uniqueOrder",
    status: "nonstandard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-grid-columns",
  },
  "-ms-grid-rows": {
    syntax: "none | <track-list> | <auto-track-list>",
    media: "visual",
    inherited: false,
    animationType: "simpleListOfLpcDifferenceLpc",
    percentages: "referToDimensionOfContentArea",
    groups: ["CSS Grid Layout"],
    initial: "none",
    appliesto: "gridContainers",
    computed: "asSpecifiedRelativeToAbsoluteLengths",
    order: "uniqueOrder",
    status: "nonstandard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-grid-rows",
  },
  "-ms-high-contrast-adjust": {
    syntax: "auto | none",
    media: "visual",
    inherited: true,
    animationType: "discrete",
    percentages: "no",
    groups: ["Microsoft Extensions"],
    initial: "auto",
    appliesto: "allElements",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "nonstandard",
    mdn_url:
      "https://developer.mozilla.org/docs/Web/CSS/-ms-high-contrast-adjust",
  },
  "-ms-hyphenate-limit-chars": {
    syntax: "auto | <integer>{1,3}",
    media: "visual",
    inherited: true,
    animationType: "discrete",
    percentages: "no",
    groups: ["Microsoft Extensions"],
    initial: "auto",
    appliesto: "allElements",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "nonstandard",
    mdn_url:
      "https://developer.mozilla.org/docs/Web/CSS/-ms-hyphenate-limit-chars",
  },
  "-ms-hyphenate-limit-lines": {
    syntax: "no-limit | <integer>",
    media: "visual",
    inherited: true,
    animationType: "discrete",
    percentages: "no",
    groups: ["Microsoft Extensions"],
    initial: "no-limit",
    appliesto: "blockContainerElements",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "nonstandard",
    mdn_url:
      "https://developer.mozilla.org/docs/Web/CSS/-ms-hyphenate-limit-lines",
  },
  "-ms-hyphenate-limit-zone": {
    syntax: "<percentage> | <length>",
    media: "visual",
    inherited: true,
    animationType: "discrete",
    percentages: "referToLineBoxWidth",
    groups: ["Microsoft Extensions"],
    initial: "0",
    appliesto: "blockContainerElements",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "nonstandard",
    mdn_url:
      "https://developer.mozilla.org/docs/Web/CSS/-ms-hyphenate-limit-zone",
  },
  "-ms-ime-align": {
    syntax: "auto | after",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["Microsoft Extensions"],
    initial: "auto",
    appliesto: "allElements",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "nonstandard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-ime-align",
  },
  "-ms-overflow-style": {
    syntax: "auto | none | scrollbar | -ms-autohiding-scrollbar",
    media: "interactive",
    inherited: true,
    animationType: "discrete",
    percentages: "no",
    groups: ["Microsoft Extensions"],
    initial: "auto",
    appliesto: "nonReplacedBlockAndInlineBlockElements",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "nonstandard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-overflow-style",
  },
  "-ms-scrollbar-3dlight-color": {
    syntax: "<color>",
    media: "visual",
    inherited: true,
    animationType: "discrete",
    percentages: "no",
    groups: ["Microsoft Extensions"],
    initial: "dependsOnUserAgent",
    appliesto: "allElements",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "nonstandard",
    mdn_url:
      "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-3dlight-color",
  },
  "-ms-scrollbar-arrow-color": {
    syntax: "<color>",
    media: "visual",
    inherited: true,
    animationType: "discrete",
    percentages: "no",
    groups: ["Microsoft Extensions"],
    initial: "ButtonText",
    appliesto: "allElements",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "nonstandard",
    mdn_url:
      "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-arrow-color",
  },
  "-ms-scrollbar-base-color": {
    syntax: "<color>",
    media: "visual",
    inherited: true,
    animationType: "discrete",
    percentages: "no",
    groups: ["Microsoft Extensions"],
    initial: "dependsOnUserAgent",
    appliesto: "allElements",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "nonstandard",
    mdn_url:
      "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-base-color",
  },
  "-ms-scrollbar-darkshadow-color": {
    syntax: "<color>",
    media: "visual",
    inherited: true,
    animationType: "discrete",
    percentages: "no",
    groups: ["Microsoft Extensions"],
    initial: "ThreeDDarkShadow",
    appliesto: "allElements",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "nonstandard",
    mdn_url:
      "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-darkshadow-color",
  },
  "-ms-scrollbar-face-color": {
    syntax: "<color>",
    media: "visual",
    inherited: true,
    animationType: "discrete",
    percentages: "no",
    groups: ["Microsoft Extensions"],
    initial: "ThreeDFace",
    appliesto: "allElements",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "nonstandard",
    mdn_url:
      "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-face-color",
  },
  "-ms-scrollbar-highlight-color": {
    syntax: "<color>",
    media: "visual",
    inherited: true,
    animationType: "discrete",
    percentages: "no",
    groups: ["Microsoft Extensions"],
    initial: "ThreeDHighlight",
    appliesto: "allElements",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "nonstandard",
    mdn_url:
      "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-highlight-color",
  },
  "-ms-scrollbar-shadow-color": {
    syntax: "<color>",
    media: "visual",
    inherited: true,
    animationType: "discrete",
    percentages: "no",
    groups: ["Microsoft Extensions"],
    initial: "ThreeDDarkShadow",
    appliesto: "allElements",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "nonstandard",
    mdn_url:
      "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-shadow-color",
  },
  "-ms-scrollbar-track-color": {
    syntax: "<color>",
    media: "visual",
    inherited: true,
    animationType: "discrete",
    percentages: "no",
    groups: ["Microsoft Extensions"],
    initial: "Scrollbar",
    appliesto: "allElements",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "nonstandard",
    mdn_url:
      "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-track-color",
  },
  "-ms-scroll-chaining": {
    syntax: "chained | none",
    media: "interactive",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["Microsoft Extensions"],
    initial: "chained",
    appliesto: "nonReplacedBlockAndInlineBlockElements",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "nonstandard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-chaining",
  },
  "-ms-scroll-limit": {
    syntax:
      "<'-ms-scroll-limit-x-min'> <'-ms-scroll-limit-y-min'> <'-ms-scroll-limit-x-max'> <'-ms-scroll-limit-y-max'>",
    media: "interactive",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["Microsoft Extensions"],
    initial: [
      "-ms-scroll-limit-x-min",
      "-ms-scroll-limit-y-min",
      "-ms-scroll-limit-x-max",
      "-ms-scroll-limit-y-max",
    ],
    appliesto: "nonReplacedBlockAndInlineBlockElements",
    computed: [
      "-ms-scroll-limit-x-min",
      "-ms-scroll-limit-y-min",
      "-ms-scroll-limit-x-max",
      "-ms-scroll-limit-y-max",
    ],
    order: "uniqueOrder",
    status: "nonstandard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit",
  },
  "-ms-scroll-limit-x-max": {
    syntax: "auto | <length>",
    media: "interactive",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["Microsoft Extensions"],
    initial: "auto",
    appliesto: "nonReplacedBlockAndInlineBlockElements",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "nonstandard",
    mdn_url:
      "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit-x-max",
  },
  "-ms-scroll-limit-x-min": {
    syntax: "<length>",
    media: "interactive",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["Microsoft Extensions"],
    initial: "0",
    appliesto: "nonReplacedBlockAndInlineBlockElements",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "nonstandard",
    mdn_url:
      "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit-x-min",
  },
  "-ms-scroll-limit-y-max": {
    syntax: "auto | <length>",
    media: "interactive",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["Microsoft Extensions"],
    initial: "auto",
    appliesto: "nonReplacedBlockAndInlineBlockElements",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "nonstandard",
    mdn_url:
      "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit-y-max",
  },
  "-ms-scroll-limit-y-min": {
    syntax: "<length>",
    media: "interactive",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["Microsoft Extensions"],
    initial: "0",
    appliesto: "nonReplacedBlockAndInlineBlockElements",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "nonstandard",
    mdn_url:
      "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit-y-min",
  },
  "-ms-scroll-rails": {
    syntax: "none | railed",
    media: "interactive",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["Microsoft Extensions"],
    initial: "railed",
    appliesto: "nonReplacedBlockAndInlineBlockElements",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "nonstandard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-rails",
  },
  "-ms-scroll-snap-points-x": {
    syntax:
      "snapInterval( <length-percentage>, <length-percentage> ) | snapList( <length-percentage># )",
    media: "interactive",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["Microsoft Extensions"],
    initial: "snapInterval(0px, 100%)",
    appliesto: "nonReplacedBlockAndInlineBlockElements",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "nonstandard",
    mdn_url:
      "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-points-x",
  },
  "-ms-scroll-snap-points-y": {
    syntax:
      "snapInterval( <length-percentage>, <length-percentage> ) | snapList( <length-percentage># )",
    media: "interactive",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["Microsoft Extensions"],
    initial: "snapInterval(0px, 100%)",
    appliesto: "nonReplacedBlockAndInlineBlockElements",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "nonstandard",
    mdn_url:
      "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-points-y",
  },
  "-ms-scroll-snap-type": {
    syntax: "none | proximity | mandatory",
    media: "interactive",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["Microsoft Extensions"],
    initial: "none",
    appliesto: "nonReplacedBlockAndInlineBlockElements",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "nonstandard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-type",
  },
  "-ms-scroll-snap-x": {
    syntax: "<'-ms-scroll-snap-type'> <'-ms-scroll-snap-points-x'>",
    media: "interactive",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["Microsoft Extensions"],
    initial: ["-ms-scroll-snap-type", "-ms-scroll-snap-points-x"],
    appliesto: "nonReplacedBlockAndInlineBlockElements",
    computed: ["-ms-scroll-snap-type", "-ms-scroll-snap-points-x"],
    order: "uniqueOrder",
    status: "nonstandard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-x",
  },
  "-ms-scroll-snap-y": {
    syntax: "<'-ms-scroll-snap-type'> <'-ms-scroll-snap-points-y'>",
    media: "interactive",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["Microsoft Extensions"],
    initial: ["-ms-scroll-snap-type", "-ms-scroll-snap-points-y"],
    appliesto: "nonReplacedBlockAndInlineBlockElements",
    computed: ["-ms-scroll-snap-type", "-ms-scroll-snap-points-y"],
    order: "uniqueOrder",
    status: "nonstandard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-y",
  },
  "-ms-scroll-translation": {
    syntax: "none | vertical-to-horizontal",
    media: "interactive",
    inherited: true,
    animationType: "discrete",
    percentages: "no",
    groups: ["Microsoft Extensions"],
    initial: "none",
    appliesto: "allElements",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "nonstandard",
    mdn_url:
      "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-translation",
  },
  "-ms-text-autospace": {
    syntax:
      "none | ideograph-alpha | ideograph-numeric | ideograph-parenthesis | ideograph-space",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["Microsoft Extensions"],
    initial: "none",
    appliesto: "allElements",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "nonstandard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-text-autospace",
  },
  "-ms-touch-select": {
    syntax: "grippers | none",
    media: "interactive",
    inherited: true,
    animationType: "discrete",
    percentages: "no",
    groups: ["Microsoft Extensions"],
    initial: "grippers",
    appliesto: "allElements",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "nonstandard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-touch-select",
  },
  "-ms-user-select": {
    syntax: "none | element | text",
    media: "interactive",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["Microsoft Extensions"],
    initial: "text",
    appliesto: "nonReplacedElements",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "nonstandard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-user-select",
  },
  "-ms-wrap-flow": {
    syntax: "auto | both | start | end | maximum | clear",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["Microsoft Extensions"],
    initial: "auto",
    appliesto: "blockLevelElements",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "nonstandard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-wrap-flow",
  },
  "-ms-wrap-margin": {
    syntax: "<length>",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["Microsoft Extensions"],
    initial: "0",
    appliesto: "exclusionElements",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "nonstandard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-wrap-margin",
  },
  "-ms-wrap-through": {
    syntax: "wrap | none",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["Microsoft Extensions"],
    initial: "wrap",
    appliesto: "blockLevelElements",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "nonstandard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-wrap-through",
  },
  "-moz-appearance": {
    syntax:
      "none | button | button-arrow-down | button-arrow-next | button-arrow-previous | button-arrow-up | button-bevel | button-focus | caret | checkbox | checkbox-container | checkbox-label | checkmenuitem | dualbutton | groupbox | listbox | listitem | menuarrow | menubar | menucheckbox | menuimage | menuitem | menuitemtext | menulist | menulist-button | menulist-text | menulist-textfield | menupopup | menuradio | menuseparator | meterbar | meterchunk | progressbar | progressbar-vertical | progresschunk | progresschunk-vertical | radio | radio-container | radio-label | radiomenuitem | range | range-thumb | resizer | resizerpanel | scale-horizontal | scalethumbend | scalethumb-horizontal | scalethumbstart | scalethumbtick | scalethumb-vertical | scale-vertical | scrollbarbutton-down | scrollbarbutton-left | scrollbarbutton-right | scrollbarbutton-up | scrollbarthumb-horizontal | scrollbarthumb-vertical | scrollbartrack-horizontal | scrollbartrack-vertical | searchfield | separator | sheet | spinner | spinner-downbutton | spinner-textfield | spinner-upbutton | splitter | statusbar | statusbarpanel | tab | tabpanel | tabpanels | tab-scroll-arrow-back | tab-scroll-arrow-forward | textfield | textfield-multiline | toolbar | toolbarbutton | toolbarbutton-dropdown | toolbargripper | toolbox | tooltip | treeheader | treeheadercell | treeheadersortarrow | treeitem | treeline | treetwisty | treetwistyopen | treeview | -moz-mac-unified-toolbar | -moz-win-borderless-glass | -moz-win-browsertabbar-toolbox | -moz-win-communicationstext | -moz-win-communications-toolbox | -moz-win-exclude-glass | -moz-win-glass | -moz-win-mediatext | -moz-win-media-toolbox | -moz-window-button-box | -moz-window-button-box-maximized | -moz-window-button-close | -moz-window-button-maximize | -moz-window-button-minimize | -moz-window-button-restore | -moz-window-frame-bottom | -moz-window-frame-left | -moz-window-frame-right | -moz-window-titlebar | -moz-window-titlebar-maximized",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["Mozilla Extensions", "WebKit Extensions"],
    initial: "noneButOverriddenInUserAgentCSS",
    appliesto: "allElements",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "nonstandard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/appearance",
  },
  "-moz-binding": {
    syntax: "<url> | none",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["Mozilla Extensions"],
    initial: "none",
    appliesto: "allElementsExceptGeneratedContentOrPseudoElements",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "nonstandard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-binding",
  },
  "-moz-border-bottom-colors": {
    syntax: "<color>+ | none",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["Mozilla Extensions"],
    initial: "none",
    appliesto: "allElements",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "nonstandard",
    mdn_url:
      "https://developer.mozilla.org/docs/Web/CSS/-moz-border-bottom-colors",
  },
  "-moz-border-left-colors": {
    syntax: "<color>+ | none",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["Mozilla Extensions"],
    initial: "none",
    appliesto: "allElements",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "nonstandard",
    mdn_url:
      "https://developer.mozilla.org/docs/Web/CSS/-moz-border-left-colors",
  },
  "-moz-border-right-colors": {
    syntax: "<color>+ | none",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["Mozilla Extensions"],
    initial: "none",
    appliesto: "allElements",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "nonstandard",
    mdn_url:
      "https://developer.mozilla.org/docs/Web/CSS/-moz-border-right-colors",
  },
  "-moz-border-top-colors": {
    syntax: "<color>+ | none",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["Mozilla Extensions"],
    initial: "none",
    appliesto: "allElements",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "nonstandard",
    mdn_url:
      "https://developer.mozilla.org/docs/Web/CSS/-moz-border-top-colors",
  },
  "-moz-context-properties": {
    syntax: "none | [ fill | fill-opacity | stroke | stroke-opacity ]#",
    media: "visual",
    inherited: true,
    animationType: "discrete",
    percentages: "no",
    groups: ["Mozilla Extensions"],
    initial: "none",
    appliesto: "allElementsThatCanReferenceImages",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "nonstandard",
    mdn_url:
      "https://developer.mozilla.org/docs/Web/CSS/-moz-context-properties",
  },
  "-moz-float-edge": {
    syntax: "border-box | content-box | margin-box | padding-box",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["Mozilla Extensions"],
    initial: "content-box",
    appliesto: "allElements",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "nonstandard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-float-edge",
  },
  "-moz-force-broken-image-icon": {
    syntax: "0 | 1",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["Mozilla Extensions"],
    initial: "0",
    appliesto: "images",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "nonstandard",
    mdn_url:
      "https://developer.mozilla.org/docs/Web/CSS/-moz-force-broken-image-icon",
  },
  "-moz-image-region": {
    syntax: "<shape> | auto",
    media: "visual",
    inherited: true,
    animationType: "discrete",
    percentages: "no",
    groups: ["Mozilla Extensions"],
    initial: "auto",
    appliesto: "xulImageElements",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "nonstandard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-image-region",
  },
  "-moz-orient": {
    syntax: "inline | block | horizontal | vertical",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["Mozilla Extensions"],
    initial: "inline",
    appliesto: "anyElementEffectOnProgressAndMeter",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "nonstandard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-orient",
  },
  "-moz-outline-radius": {
    syntax: "<outline-radius>{1,4} [ / <outline-radius>{1,4} ]?",
    media: "visual",
    inherited: false,
    animationType: [
      "-moz-outline-radius-topleft",
      "-moz-outline-radius-topright",
      "-moz-outline-radius-bottomright",
      "-moz-outline-radius-bottomleft",
    ],
    percentages: [
      "-moz-outline-radius-topleft",
      "-moz-outline-radius-topright",
      "-moz-outline-radius-bottomright",
      "-moz-outline-radius-bottomleft",
    ],
    groups: ["Mozilla Extensions"],
    initial: [
      "-moz-outline-radius-topleft",
      "-moz-outline-radius-topright",
      "-moz-outline-radius-bottomright",
      "-moz-outline-radius-bottomleft",
    ],
    appliesto: "allElements",
    computed: [
      "-moz-outline-radius-topleft",
      "-moz-outline-radius-topright",
      "-moz-outline-radius-bottomright",
      "-moz-outline-radius-bottomleft",
    ],
    order: "uniqueOrder",
    status: "nonstandard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius",
  },
  "-moz-outline-radius-bottomleft": {
    syntax: "<outline-radius>",
    media: "visual",
    inherited: false,
    animationType: "lpc",
    percentages: "referToDimensionOfBorderBox",
    groups: ["Mozilla Extensions"],
    initial: "0",
    appliesto: "allElements",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "nonstandard",
    mdn_url:
      "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius-bottomleft",
  },
  "-moz-outline-radius-bottomright": {
    syntax: "<outline-radius>",
    media: "visual",
    inherited: false,
    animationType: "lpc",
    percentages: "referToDimensionOfBorderBox",
    groups: ["Mozilla Extensions"],
    initial: "0",
    appliesto: "allElements",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "nonstandard",
    mdn_url:
      "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius-bottomright",
  },
  "-moz-outline-radius-topleft": {
    syntax: "<outline-radius>",
    media: "visual",
    inherited: false,
    animationType: "lpc",
    percentages: "referToDimensionOfBorderBox",
    groups: ["Mozilla Extensions"],
    initial: "0",
    appliesto: "allElements",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "nonstandard",
    mdn_url:
      "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius-topleft",
  },
  "-moz-outline-radius-topright": {
    syntax: "<outline-radius>",
    media: "visual",
    inherited: false,
    animationType: "lpc",
    percentages: "referToDimensionOfBorderBox",
    groups: ["Mozilla Extensions"],
    initial: "0",
    appliesto: "allElements",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "nonstandard",
    mdn_url:
      "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius-topright",
  },
  "-moz-stack-sizing": {
    syntax: "ignore | stretch-to-fit",
    media: "visual",
    inherited: true,
    animationType: "discrete",
    percentages: "no",
    groups: ["Mozilla Extensions"],
    initial: "stretch-to-fit",
    appliesto: "allElements",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "nonstandard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-stack-sizing",
  },
  "-moz-text-blink": {
    syntax: "none | blink",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["Mozilla Extensions"],
    initial: "none",
    appliesto: "allElements",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "nonstandard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-text-blink",
  },
  "-moz-user-focus": {
    syntax:
      "ignore | normal | select-after | select-before | select-menu | select-same | select-all | none",
    media: "interactive",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["Mozilla Extensions"],
    initial: "none",
    appliesto: "allElements",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "nonstandard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-user-focus",
  },
  "-moz-user-input": {
    syntax: "auto | none | enabled | disabled",
    media: "visual",
    inherited: true,
    animationType: "discrete",
    percentages: "no",
    groups: ["Mozilla Extensions"],
    initial: "auto",
    appliesto: "allElements",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "nonstandard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-user-input",
  },
  "-moz-user-modify": {
    syntax: "read-only | read-write | write-only",
    media: "interactive",
    inherited: true,
    animationType: "discrete",
    percentages: "no",
    groups: ["Mozilla Extensions"],
    initial: "read-only",
    appliesto: "allElements",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "nonstandard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-user-modify",
  },
  "-moz-window-dragging": {
    syntax: "drag | no-drag",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["Mozilla Extensions"],
    initial: "drag",
    appliesto: "allElementsCreatingNativeWindows",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "nonstandard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-window-dragging",
  },
  "-moz-window-shadow": {
    syntax: "default | menu | tooltip | sheet | none",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["Mozilla Extensions"],
    initial: "default",
    appliesto: "allElementsCreatingNativeWindows",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "nonstandard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-window-shadow",
  },
  "-webkit-appearance": {
    syntax:
      "none | button | button-bevel | caret | checkbox | default-button | inner-spin-button | listbox | listitem | media-controls-background | media-controls-fullscreen-background | media-current-time-display | media-enter-fullscreen-button | media-exit-fullscreen-button | media-fullscreen-button | media-mute-button | media-overlay-play-button | media-play-button | media-seek-back-button | media-seek-forward-button | media-slider | media-sliderthumb | media-time-remaining-display | media-toggle-closed-captions-button | media-volume-slider | media-volume-slider-container | media-volume-sliderthumb | menulist | menulist-button | menulist-text | menulist-textfield | meter | progress-bar | progress-bar-value | push-button | radio | searchfield | searchfield-cancel-button | searchfield-decoration | searchfield-results-button | searchfield-results-decoration | slider-horizontal | slider-vertical | sliderthumb-horizontal | sliderthumb-vertical | square-button | textarea | textfield | -apple-pay-button",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["WebKit Extensions"],
    initial: "noneButOverriddenInUserAgentCSS",
    appliesto: "allElements",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "nonstandard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/appearance",
  },
  "-webkit-border-before": {
    syntax: "<'border-width'> || <'border-style'> || <color>",
    media: "visual",
    inherited: true,
    animationType: "discrete",
    percentages: ["-webkit-border-before-width"],
    groups: ["WebKit Extensions"],
    initial: ["border-width", "border-style", "color"],
    appliesto: "allElements",
    computed: ["border-width", "border-style", "color"],
    order: "uniqueOrder",
    status: "nonstandard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-border-before",
  },
  "-webkit-border-before-color": {
    syntax: "<color>",
    media: "visual",
    inherited: true,
    animationType: "discrete",
    percentages: "no",
    groups: ["WebKit Extensions"],
    initial: "currentcolor",
    appliesto: "allElements",
    computed: "computedColor",
    order: "uniqueOrder",
    status: "nonstandard",
  },
  "-webkit-border-before-style": {
    syntax: "<'border-style'>",
    media: "visual",
    inherited: true,
    animationType: "discrete",
    percentages: "no",
    groups: ["WebKit Extensions"],
    initial: "none",
    appliesto: "allElements",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "nonstandard",
  },
  "-webkit-border-before-width": {
    syntax: "<'border-width'>",
    media: "visual",
    inherited: true,
    animationType: "discrete",
    percentages: "logicalWidthOfContainingBlock",
    groups: ["WebKit Extensions"],
    initial: "medium",
    appliesto: "allElements",
    computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
    order: "uniqueOrder",
    status: "nonstandard",
  },
  "-webkit-box-reflect": {
    syntax: "[ above | below | right | left ]? <length>? <image>?",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["WebKit Extensions"],
    initial: "none",
    appliesto: "allElements",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "nonstandard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-box-reflect",
  },
  "-webkit-line-clamp": {
    syntax: "none | <integer>",
    media: "visual",
    inherited: false,
    animationType: "byComputedValueType",
    percentages: "no",
    groups: ["WebKit Extensions", "CSS Overflow"],
    initial: "none",
    appliesto: "allElements",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-line-clamp",
  },
  "-webkit-mask": {
    syntax:
      "[ <mask-reference> || <position> [ / <bg-size> ]? || <repeat-style> || [ <box> | border | padding | content | text ] || [ <box> | border | padding | content ] ]#",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["WebKit Extensions"],
    initial: [
      "-webkit-mask-image",
      "-webkit-mask-repeat",
      "-webkit-mask-attachment",
      "-webkit-mask-position",
      "-webkit-mask-origin",
      "-webkit-mask-clip",
    ],
    appliesto: "allElements",
    computed: [
      "-webkit-mask-image",
      "-webkit-mask-repeat",
      "-webkit-mask-attachment",
      "-webkit-mask-position",
      "-webkit-mask-origin",
      "-webkit-mask-clip",
    ],
    order: "uniqueOrder",
    status: "nonstandard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask",
  },
  "-webkit-mask-attachment": {
    syntax: "<attachment>#",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["WebKit Extensions"],
    initial: "scroll",
    appliesto: "allElements",
    computed: "asSpecified",
    order: "orderOfAppearance",
    status: "nonstandard",
    mdn_url:
      "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-attachment",
  },
  "-webkit-mask-clip": {
    syntax: "[ <box> | border | padding | content | text ]#",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["WebKit Extensions"],
    initial: "border",
    appliesto: "allElements",
    computed: "asSpecified",
    order: "orderOfAppearance",
    status: "nonstandard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-clip",
  },
  "-webkit-mask-composite": {
    syntax: "<composite-style>#",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["WebKit Extensions"],
    initial: "source-over",
    appliesto: "allElements",
    computed: "asSpecified",
    order: "orderOfAppearance",
    status: "nonstandard",
    mdn_url:
      "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-composite",
  },
  "-webkit-mask-image": {
    syntax: "<mask-reference>#",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["WebKit Extensions"],
    initial: "none",
    appliesto: "allElements",
    computed: "absoluteURIOrNone",
    order: "orderOfAppearance",
    status: "nonstandard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-image",
  },
  "-webkit-mask-origin": {
    syntax: "[ <box> | border | padding | content ]#",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["WebKit Extensions"],
    initial: "padding",
    appliesto: "allElements",
    computed: "asSpecified",
    order: "orderOfAppearance",
    status: "nonstandard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-origin",
  },
  "-webkit-mask-position": {
    syntax: "<position>#",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "referToSizeOfElement",
    groups: ["WebKit Extensions"],
    initial: "0% 0%",
    appliesto: "allElements",
    computed: "absoluteLengthOrPercentage",
    order: "orderOfAppearance",
    status: "nonstandard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-position",
  },
  "-webkit-mask-position-x": {
    syntax: "[ <length-percentage> | left | center | right ]#",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "referToSizeOfElement",
    groups: ["WebKit Extensions"],
    initial: "0%",
    appliesto: "allElements",
    computed: "absoluteLengthOrPercentage",
    order: "orderOfAppearance",
    status: "nonstandard",
    mdn_url:
      "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-position-x",
  },
  "-webkit-mask-position-y": {
    syntax: "[ <length-percentage> | top | center | bottom ]#",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "referToSizeOfElement",
    groups: ["WebKit Extensions"],
    initial: "0%",
    appliesto: "allElements",
    computed: "absoluteLengthOrPercentage",
    order: "orderOfAppearance",
    status: "nonstandard",
    mdn_url:
      "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-position-y",
  },
  "-webkit-mask-repeat": {
    syntax: "<repeat-style>#",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["WebKit Extensions"],
    initial: "repeat",
    appliesto: "allElements",
    computed: "asSpecified",
    order: "orderOfAppearance",
    status: "nonstandard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-repeat",
  },
  "-webkit-mask-repeat-x": {
    syntax: "repeat | no-repeat | space | round",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["WebKit Extensions"],
    initial: "repeat",
    appliesto: "allElements",
    computed: "asSpecified",
    order: "orderOfAppearance",
    status: "nonstandard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-repeat-x",
  },
  "-webkit-mask-repeat-y": {
    syntax: "repeat | no-repeat | space | round",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["WebKit Extensions"],
    initial: "repeat",
    appliesto: "allElements",
    computed: "absoluteLengthOrPercentage",
    order: "orderOfAppearance",
    status: "nonstandard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-repeat-y",
  },
  "-webkit-mask-size": {
    syntax: "<bg-size>#",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "relativeToBackgroundPositioningArea",
    groups: ["WebKit Extensions"],
    initial: "auto auto",
    appliesto: "allElements",
    computed: "asSpecified",
    order: "orderOfAppearance",
    status: "nonstandard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-size",
  },
  "-webkit-overflow-scrolling": {
    syntax: "auto | touch",
    media: "visual",
    inherited: true,
    animationType: "discrete",
    percentages: "no",
    groups: ["WebKit Extensions"],
    initial: "auto",
    appliesto: "scrollingBoxes",
    computed: "asSpecified",
    order: "orderOfAppearance",
    status: "nonstandard",
    mdn_url:
      "https://developer.mozilla.org/docs/Web/CSS/-webkit-overflow-scrolling",
  },
  "-webkit-tap-highlight-color": {
    syntax: "<color>",
    media: "visual",
    inherited: true,
    animationType: "discrete",
    percentages: "no",
    groups: ["WebKit Extensions"],
    initial: "black",
    appliesto: "allElements",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "nonstandard",
    mdn_url:
      "https://developer.mozilla.org/docs/Web/CSS/-webkit-tap-highlight-color",
  },
  "-webkit-text-fill-color": {
    syntax: "<color>",
    media: "visual",
    inherited: true,
    animationType: "color",
    percentages: "no",
    groups: ["WebKit Extensions"],
    initial: "currentcolor",
    appliesto: "allElements",
    computed: "computedColor",
    order: "uniqueOrder",
    status: "nonstandard",
    mdn_url:
      "https://developer.mozilla.org/docs/Web/CSS/-webkit-text-fill-color",
  },
  "-webkit-text-stroke": {
    syntax: "<length> || <color>",
    media: "visual",
    inherited: true,
    animationType: ["-webkit-text-stroke-width", "-webkit-text-stroke-color"],
    percentages: "no",
    groups: ["WebKit Extensions"],
    initial: ["-webkit-text-stroke-width", "-webkit-text-stroke-color"],
    appliesto: "allElements",
    computed: ["-webkit-text-stroke-width", "-webkit-text-stroke-color"],
    order: "canonicalOrder",
    status: "nonstandard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-text-stroke",
  },
  "-webkit-text-stroke-color": {
    syntax: "<color>",
    media: "visual",
    inherited: true,
    animationType: "color",
    percentages: "no",
    groups: ["WebKit Extensions"],
    initial: "currentcolor",
    appliesto: "allElements",
    computed: "computedColor",
    order: "uniqueOrder",
    status: "nonstandard",
    mdn_url:
      "https://developer.mozilla.org/docs/Web/CSS/-webkit-text-stroke-color",
  },
  "-webkit-text-stroke-width": {
    syntax: "<length>",
    media: "visual",
    inherited: true,
    animationType: "discrete",
    percentages: "no",
    groups: ["WebKit Extensions"],
    initial: "0",
    appliesto: "allElements",
    computed: "absoluteLength",
    order: "uniqueOrder",
    status: "nonstandard",
    mdn_url:
      "https://developer.mozilla.org/docs/Web/CSS/-webkit-text-stroke-width",
  },
  "-webkit-touch-callout": {
    syntax: "default | none",
    media: "visual",
    inherited: true,
    animationType: "discrete",
    percentages: "no",
    groups: ["WebKit Extensions"],
    initial: "default",
    appliesto: "allElements",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "nonstandard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-touch-callout",
  },
  "-webkit-user-modify": {
    syntax: "read-only | read-write | read-write-plaintext-only",
    media: "interactive",
    inherited: true,
    animationType: "discrete",
    percentages: "no",
    groups: ["WebKit Extensions"],
    initial: "read-only",
    appliesto: "allElements",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "nonstandard",
  },
  "accent-color": {
    syntax: "auto | <color>",
    media: "interactive",
    inherited: true,
    animationType: "byComputedValueType",
    percentages: "no",
    groups: ["CSS Basic User Interface"],
    initial: "auto",
    appliesto: "allElements",
    computed: "asAutoOrColor",
    order: "perGrammar",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/accent-color",
  },
  "align-content": {
    syntax:
      "normal | <baseline-position> | <content-distribution> | <overflow-position>? <content-position>",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Box Alignment"],
    initial: "normal",
    appliesto: "multilineFlexContainers",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/align-content",
  },
  "align-items": {
    syntax:
      "normal | stretch | <baseline-position> | [ <overflow-position>? <self-position> ]",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Box Alignment"],
    initial: "normal",
    appliesto: "allElements",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/align-items",
  },
  "align-self": {
    syntax:
      "auto | normal | stretch | <baseline-position> | <overflow-position>? <self-position>",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Box Alignment"],
    initial: "auto",
    appliesto: "flexItemsGridItemsAndAbsolutelyPositionedBoxes",
    computed: "autoOnAbsolutelyPositionedElementsValueOfAlignItemsOnParent",
    order: "uniqueOrder",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/align-self",
  },
  "align-tracks": {
    syntax:
      "[ normal | <baseline-position> | <content-distribution> | <overflow-position>? <content-position> ]#",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Grid Layout"],
    initial: "normal",
    appliesto: "gridContainersWithMasonryLayoutInTheirBlockAxis",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "experimental",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/align-tracks",
  },
  all: all,
  animation: animation,
  "animation-delay": {
    syntax: "<time>#",
    media: "visual",
    inherited: false,
    animationType: "notAnimatable",
    percentages: "no",
    groups: ["CSS Animations"],
    initial: "0s",
    appliesto: "allElementsAndPseudos",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-delay",
  },
  "animation-direction": {
    syntax: "<single-animation-direction>#",
    media: "visual",
    inherited: false,
    animationType: "notAnimatable",
    percentages: "no",
    groups: ["CSS Animations"],
    initial: "normal",
    appliesto: "allElementsAndPseudos",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-direction",
  },
  "animation-duration": {
    syntax: "<time>#",
    media: "visual",
    inherited: false,
    animationType: "notAnimatable",
    percentages: "no",
    groups: ["CSS Animations"],
    initial: "0s",
    appliesto: "allElementsAndPseudos",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-duration",
  },
  "animation-fill-mode": {
    syntax: "<single-animation-fill-mode>#",
    media: "visual",
    inherited: false,
    animationType: "notAnimatable",
    percentages: "no",
    groups: ["CSS Animations"],
    initial: "none",
    appliesto: "allElementsAndPseudos",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-fill-mode",
  },
  "animation-iteration-count": {
    syntax: "<single-animation-iteration-count>#",
    media: "visual",
    inherited: false,
    animationType: "notAnimatable",
    percentages: "no",
    groups: ["CSS Animations"],
    initial: "1",
    appliesto: "allElementsAndPseudos",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "standard",
    mdn_url:
      "https://developer.mozilla.org/docs/Web/CSS/animation-iteration-count",
  },
  "animation-name": {
    syntax: "[ none | <keyframes-name> ]#",
    media: "visual",
    inherited: false,
    animationType: "notAnimatable",
    percentages: "no",
    groups: ["CSS Animations"],
    initial: "none",
    appliesto: "allElementsAndPseudos",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-name",
  },
  "animation-play-state": {
    syntax: "<single-animation-play-state>#",
    media: "visual",
    inherited: false,
    animationType: "notAnimatable",
    percentages: "no",
    groups: ["CSS Animations"],
    initial: "running",
    appliesto: "allElementsAndPseudos",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-play-state",
  },
  "animation-timing-function": {
    syntax: "<easing-function>#",
    media: "visual",
    inherited: false,
    animationType: "notAnimatable",
    percentages: "no",
    groups: ["CSS Animations"],
    initial: "ease",
    appliesto: "allElementsAndPseudos",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "standard",
    mdn_url:
      "https://developer.mozilla.org/docs/Web/CSS/animation-timing-function",
  },
  "animation-timeline": {
    syntax: "<single-animation-timeline>#",
    media: "visual",
    inherited: false,
    animationType: "notAnimatable",
    percentages: "no",
    groups: ["CSS Animations"],
    initial: "auto",
    appliesto: "allElements",
    computed: "listEachItemIdentifyerOrNoneAuto",
    order: "uniqueOrder",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-timeline",
  },
  appearance: appearance,
  "aspect-ratio": {
    syntax: "auto | <ratio>",
    media: "all",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Basic User Interface"],
    initial: "auto",
    appliesto: "allElementsExceptInlineBoxesAndInternalRubyOrTableBoxes",
    computed: "asSpecified",
    order: "perGrammar",
    status: "experimental",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/aspect-ratio",
  },
  azimuth: azimuth,
  "backdrop-filter": {
    syntax: "none | <filter-function-list>",
    media: "visual",
    inherited: false,
    animationType: "filterList",
    percentages: "no",
    groups: ["Filter Effects"],
    initial: "none",
    appliesto: "allElementsSVGContainerElements",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/backdrop-filter",
  },
  "backface-visibility": {
    syntax: "visible | hidden",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Transforms"],
    initial: "visible",
    appliesto: "transformableElements",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/backface-visibility",
  },
  background: background$2,
  "background-attachment": {
    syntax: "<attachment>#",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Backgrounds and Borders"],
    initial: "scroll",
    appliesto: "allElements",
    computed: "asSpecified",
    order: "uniqueOrder",
    alsoAppliesTo: ["::first-letter", "::first-line", "::placeholder"],
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-attachment",
  },
  "background-blend-mode": {
    syntax: "<blend-mode>#",
    media: "none",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["Compositing and Blending"],
    initial: "normal",
    appliesto: "allElementsSVGContainerGraphicsAndGraphicsReferencingElements",
    computed: "asSpecified",
    order: "uniqueOrder",
    alsoAppliesTo: ["::first-letter", "::first-line", "::placeholder"],
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-blend-mode",
  },
  "background-clip": {
    syntax: "<box>#",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Backgrounds and Borders"],
    initial: "border-box",
    appliesto: "allElements",
    computed: "asSpecified",
    order: "uniqueOrder",
    alsoAppliesTo: ["::first-letter", "::first-line", "::placeholder"],
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-clip",
  },
  "background-color": {
    syntax: "<color>",
    media: "visual",
    inherited: false,
    animationType: "color",
    percentages: "no",
    groups: ["CSS Backgrounds and Borders"],
    initial: "transparent",
    appliesto: "allElements",
    computed: "computedColor",
    order: "uniqueOrder",
    alsoAppliesTo: ["::first-letter", "::first-line", "::placeholder"],
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-color",
  },
  "background-image": {
    syntax: "<bg-image>#",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Backgrounds and Borders"],
    initial: "none",
    appliesto: "allElements",
    computed: "asSpecifiedURLsAbsolute",
    order: "uniqueOrder",
    alsoAppliesTo: ["::first-letter", "::first-line", "::placeholder"],
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-image",
  },
  "background-origin": {
    syntax: "<box>#",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Backgrounds and Borders"],
    initial: "padding-box",
    appliesto: "allElements",
    computed: "asSpecified",
    order: "uniqueOrder",
    alsoAppliesTo: ["::first-letter", "::first-line", "::placeholder"],
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-origin",
  },
  "background-position": {
    syntax: "<bg-position>#",
    media: "visual",
    inherited: false,
    animationType: "repeatableListOfSimpleListOfLpc",
    percentages:
      "referToSizeOfBackgroundPositioningAreaMinusBackgroundImageSize",
    groups: ["CSS Backgrounds and Borders"],
    initial: "0% 0%",
    appliesto: "allElements",
    computed: ["background-position-x", "background-position-y"],
    order: "uniqueOrder",
    alsoAppliesTo: ["::first-letter", "::first-line", "::placeholder"],
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-position",
  },
  "background-position-x": {
    syntax:
      "[ center | [ [ left | right | x-start | x-end ]? <length-percentage>? ]! ]#",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages:
      "referToWidthOfBackgroundPositioningAreaMinusBackgroundImageHeight",
    groups: ["CSS Backgrounds and Borders"],
    initial: "0%",
    appliesto: "allElements",
    computed: "listEachItemConsistingOfAbsoluteLengthPercentageAndOrigin",
    order: "uniqueOrder",
    status: "experimental",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-position-x",
  },
  "background-position-y": {
    syntax:
      "[ center | [ [ top | bottom | y-start | y-end ]? <length-percentage>? ]! ]#",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages:
      "referToHeightOfBackgroundPositioningAreaMinusBackgroundImageHeight",
    groups: ["CSS Backgrounds and Borders"],
    initial: "0%",
    appliesto: "allElements",
    computed: "listEachItemConsistingOfAbsoluteLengthPercentageAndOrigin",
    order: "uniqueOrder",
    status: "experimental",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-position-y",
  },
  "background-repeat": {
    syntax: "<repeat-style>#",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Backgrounds and Borders"],
    initial: "repeat",
    appliesto: "allElements",
    computed: "listEachItemHasTwoKeywordsOnePerDimension",
    order: "uniqueOrder",
    alsoAppliesTo: ["::first-letter", "::first-line", "::placeholder"],
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-repeat",
  },
  "background-size": {
    syntax: "<bg-size>#",
    media: "visual",
    inherited: false,
    animationType: "repeatableListOfSimpleListOfLpc",
    percentages: "relativeToBackgroundPositioningArea",
    groups: ["CSS Backgrounds and Borders"],
    initial: "auto auto",
    appliesto: "allElements",
    computed: "asSpecifiedRelativeToAbsoluteLengths",
    order: "uniqueOrder",
    alsoAppliesTo: ["::first-letter", "::first-line", "::placeholder"],
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-size",
  },
  "block-overflow": {
    syntax: "clip | ellipsis | <string>",
    media: "visual",
    inherited: true,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Overflow"],
    initial: "clip",
    appliesto: "blockContainers",
    computed: "asSpecified",
    order: "perGrammar",
    status: "experimental",
  },
  "block-size": {
    syntax: "<'width'>",
    media: "visual",
    inherited: false,
    animationType: "lpc",
    percentages: "blockSizeOfContainingBlock",
    groups: ["CSS Logical Properties"],
    initial: "auto",
    appliesto: "sameAsWidthAndHeight",
    computed: "sameAsWidthAndHeight",
    order: "uniqueOrder",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/block-size",
  },
  border: border$2,
  "border-block": {
    syntax: "<'border-top-width'> || <'border-top-style'> || <color>",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Logical Properties"],
    initial: ["border-top-width", "border-top-style", "border-top-color"],
    appliesto: "allElements",
    computed: ["border-top-width", "border-top-style", "border-top-color"],
    order: "uniqueOrder",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block",
  },
  "border-block-color": {
    syntax: "<'border-top-color'>{1,2}",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Logical Properties"],
    initial: "currentcolor",
    appliesto: "allElements",
    computed: "computedColor",
    order: "uniqueOrder",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-color",
  },
  "border-block-style": {
    syntax: "<'border-top-style'>",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Logical Properties"],
    initial: "none",
    appliesto: "allElements",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-style",
  },
  "border-block-width": {
    syntax: "<'border-top-width'>",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "logicalWidthOfContainingBlock",
    groups: ["CSS Logical Properties"],
    initial: "medium",
    appliesto: "allElements",
    computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
    order: "uniqueOrder",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-width",
  },
  "border-block-end": {
    syntax: "<'border-top-width'> || <'border-top-style'> || <color>",
    media: "visual",
    inherited: false,
    animationType: [
      "border-block-end-color",
      "border-block-end-style",
      "border-block-end-width",
    ],
    percentages: "no",
    groups: ["CSS Logical Properties"],
    initial: ["border-top-width", "border-top-style", "border-top-color"],
    appliesto: "allElements",
    computed: ["border-top-width", "border-top-style", "border-top-color"],
    order: "uniqueOrder",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-end",
  },
  "border-block-end-color": {
    syntax: "<'border-top-color'>",
    media: "visual",
    inherited: false,
    animationType: "color",
    percentages: "no",
    groups: ["CSS Logical Properties"],
    initial: "currentcolor",
    appliesto: "allElements",
    computed: "computedColor",
    order: "uniqueOrder",
    status: "standard",
    mdn_url:
      "https://developer.mozilla.org/docs/Web/CSS/border-block-end-color",
  },
  "border-block-end-style": {
    syntax: "<'border-top-style'>",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Logical Properties"],
    initial: "none",
    appliesto: "allElements",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "standard",
    mdn_url:
      "https://developer.mozilla.org/docs/Web/CSS/border-block-end-style",
  },
  "border-block-end-width": {
    syntax: "<'border-top-width'>",
    media: "visual",
    inherited: false,
    animationType: "length",
    percentages: "logicalWidthOfContainingBlock",
    groups: ["CSS Logical Properties"],
    initial: "medium",
    appliesto: "allElements",
    computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
    order: "uniqueOrder",
    status: "standard",
    mdn_url:
      "https://developer.mozilla.org/docs/Web/CSS/border-block-end-width",
  },
  "border-block-start": {
    syntax: "<'border-top-width'> || <'border-top-style'> || <color>",
    media: "visual",
    inherited: false,
    animationType: [
      "border-block-start-color",
      "border-block-start-style",
      "border-block-start-width",
    ],
    percentages: "no",
    groups: ["CSS Logical Properties"],
    initial: ["border-width", "border-style", "color"],
    appliesto: "allElements",
    computed: ["border-width", "border-style", "border-block-start-color"],
    order: "uniqueOrder",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-start",
  },
  "border-block-start-color": {
    syntax: "<'border-top-color'>",
    media: "visual",
    inherited: false,
    animationType: "color",
    percentages: "no",
    groups: ["CSS Logical Properties"],
    initial: "currentcolor",
    appliesto: "allElements",
    computed: "computedColor",
    order: "uniqueOrder",
    status: "standard",
    mdn_url:
      "https://developer.mozilla.org/docs/Web/CSS/border-block-start-color",
  },
  "border-block-start-style": {
    syntax: "<'border-top-style'>",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Logical Properties"],
    initial: "none",
    appliesto: "allElements",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "standard",
    mdn_url:
      "https://developer.mozilla.org/docs/Web/CSS/border-block-start-style",
  },
  "border-block-start-width": {
    syntax: "<'border-top-width'>",
    media: "visual",
    inherited: false,
    animationType: "length",
    percentages: "logicalWidthOfContainingBlock",
    groups: ["CSS Logical Properties"],
    initial: "medium",
    appliesto: "allElements",
    computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
    order: "uniqueOrder",
    status: "standard",
    mdn_url:
      "https://developer.mozilla.org/docs/Web/CSS/border-block-start-width",
  },
  "border-bottom": {
    syntax: "<line-width> || <line-style> || <color>",
    media: "visual",
    inherited: false,
    animationType: [
      "border-bottom-color",
      "border-bottom-style",
      "border-bottom-width",
    ],
    percentages: "no",
    groups: ["CSS Backgrounds and Borders"],
    initial: [
      "border-bottom-width",
      "border-bottom-style",
      "border-bottom-color",
    ],
    appliesto: "allElements",
    computed: [
      "border-bottom-width",
      "border-bottom-style",
      "border-bottom-color",
    ],
    order: "orderOfAppearance",
    alsoAppliesTo: ["::first-letter"],
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom",
  },
  "border-bottom-color": {
    syntax: "<'border-top-color'>",
    media: "visual",
    inherited: false,
    animationType: "color",
    percentages: "no",
    groups: ["CSS Backgrounds and Borders"],
    initial: "currentcolor",
    appliesto: "allElements",
    computed: "computedColor",
    order: "uniqueOrder",
    alsoAppliesTo: ["::first-letter"],
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-color",
  },
  "border-bottom-left-radius": {
    syntax: "<length-percentage>{1,2}",
    media: "visual",
    inherited: false,
    animationType: "lpc",
    percentages: "referToDimensionOfBorderBox",
    groups: ["CSS Backgrounds and Borders"],
    initial: "0",
    appliesto: "allElementsUAsNotRequiredWhenCollapse",
    computed: "twoAbsoluteLengthOrPercentages",
    order: "uniqueOrder",
    alsoAppliesTo: ["::first-letter"],
    status: "standard",
    mdn_url:
      "https://developer.mozilla.org/docs/Web/CSS/border-bottom-left-radius",
  },
  "border-bottom-right-radius": {
    syntax: "<length-percentage>{1,2}",
    media: "visual",
    inherited: false,
    animationType: "lpc",
    percentages: "referToDimensionOfBorderBox",
    groups: ["CSS Backgrounds and Borders"],
    initial: "0",
    appliesto: "allElementsUAsNotRequiredWhenCollapse",
    computed: "twoAbsoluteLengthOrPercentages",
    order: "uniqueOrder",
    alsoAppliesTo: ["::first-letter"],
    status: "standard",
    mdn_url:
      "https://developer.mozilla.org/docs/Web/CSS/border-bottom-right-radius",
  },
  "border-bottom-style": {
    syntax: "<line-style>",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Backgrounds and Borders"],
    initial: "none",
    appliesto: "allElements",
    computed: "asSpecified",
    order: "uniqueOrder",
    alsoAppliesTo: ["::first-letter"],
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-style",
  },
  "border-bottom-width": {
    syntax: "<line-width>",
    media: "visual",
    inherited: false,
    animationType: "length",
    percentages: "no",
    groups: ["CSS Backgrounds and Borders"],
    initial: "medium",
    appliesto: "allElements",
    computed: "absoluteLengthOr0IfBorderBottomStyleNoneOrHidden",
    order: "uniqueOrder",
    alsoAppliesTo: ["::first-letter"],
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-width",
  },
  "border-collapse": {
    syntax: "collapse | separate",
    media: "visual",
    inherited: true,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Table"],
    initial: "separate",
    appliesto: "tableElements",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-collapse",
  },
  "border-color": {
    syntax: "<color>{1,4}",
    media: "visual",
    inherited: false,
    animationType: [
      "border-bottom-color",
      "border-left-color",
      "border-right-color",
      "border-top-color",
    ],
    percentages: "no",
    groups: ["CSS Backgrounds and Borders"],
    initial: [
      "border-top-color",
      "border-right-color",
      "border-bottom-color",
      "border-left-color",
    ],
    appliesto: "allElements",
    computed: [
      "border-bottom-color",
      "border-left-color",
      "border-right-color",
      "border-top-color",
    ],
    order: "uniqueOrder",
    alsoAppliesTo: ["::first-letter"],
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-color",
  },
  "border-end-end-radius": {
    syntax: "<length-percentage>{1,2}",
    media: "visual",
    inherited: false,
    animationType: "lpc",
    percentages: "referToDimensionOfBorderBox",
    groups: ["CSS Logical Properties"],
    initial: "0",
    appliesto: "allElementsUAsNotRequiredWhenCollapse",
    computed: "twoAbsoluteLengthOrPercentages",
    order: "uniqueOrder",
    alsoAppliesTo: ["::first-letter"],
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-end-end-radius",
  },
  "border-end-start-radius": {
    syntax: "<length-percentage>{1,2}",
    media: "visual",
    inherited: false,
    animationType: "lpc",
    percentages: "referToDimensionOfBorderBox",
    groups: ["CSS Logical Properties"],
    initial: "0",
    appliesto: "allElementsUAsNotRequiredWhenCollapse",
    computed: "twoAbsoluteLengthOrPercentages",
    order: "uniqueOrder",
    alsoAppliesTo: ["::first-letter"],
    status: "standard",
    mdn_url:
      "https://developer.mozilla.org/docs/Web/CSS/border-end-start-radius",
  },
  "border-image": {
    syntax:
      "<'border-image-source'> || <'border-image-slice'> [ / <'border-image-width'> | / <'border-image-width'>? / <'border-image-outset'> ]? || <'border-image-repeat'>",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: ["border-image-slice", "border-image-width"],
    groups: ["CSS Backgrounds and Borders"],
    initial: [
      "border-image-source",
      "border-image-slice",
      "border-image-width",
      "border-image-outset",
      "border-image-repeat",
    ],
    appliesto: "allElementsExceptTableElementsWhenCollapse",
    computed: [
      "border-image-outset",
      "border-image-repeat",
      "border-image-slice",
      "border-image-source",
      "border-image-width",
    ],
    order: "uniqueOrder",
    alsoAppliesTo: ["::first-letter"],
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image",
  },
  "border-image-outset": {
    syntax: "[ <length> | <number> ]{1,4}",
    media: "visual",
    inherited: false,
    animationType: "byComputedValueType",
    percentages: "no",
    groups: ["CSS Backgrounds and Borders"],
    initial: "0",
    appliesto: "allElementsExceptTableElementsWhenCollapse",
    computed: "asSpecifiedRelativeToAbsoluteLengths",
    order: "uniqueOrder",
    alsoAppliesTo: ["::first-letter"],
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-outset",
  },
  "border-image-repeat": {
    syntax: "[ stretch | repeat | round | space ]{1,2}",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Backgrounds and Borders"],
    initial: "stretch",
    appliesto: "allElementsExceptTableElementsWhenCollapse",
    computed: "asSpecified",
    order: "uniqueOrder",
    alsoAppliesTo: ["::first-letter"],
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-repeat",
  },
  "border-image-slice": {
    syntax: "<number-percentage>{1,4} && fill?",
    media: "visual",
    inherited: false,
    animationType: "byComputedValueType",
    percentages: "referToSizeOfBorderImage",
    groups: ["CSS Backgrounds and Borders"],
    initial: "100%",
    appliesto: "allElementsExceptTableElementsWhenCollapse",
    computed: "oneToFourPercentagesOrAbsoluteLengthsPlusFill",
    order: "percentagesOrLengthsFollowedByFill",
    alsoAppliesTo: ["::first-letter"],
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-slice",
  },
  "border-image-source": {
    syntax: "none | <image>",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Backgrounds and Borders"],
    initial: "none",
    appliesto: "allElementsExceptTableElementsWhenCollapse",
    computed: "noneOrImageWithAbsoluteURI",
    order: "uniqueOrder",
    alsoAppliesTo: ["::first-letter"],
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-source",
  },
  "border-image-width": {
    syntax: "[ <length-percentage> | <number> | auto ]{1,4}",
    media: "visual",
    inherited: false,
    animationType: "byComputedValueType",
    percentages: "referToWidthOrHeightOfBorderImageArea",
    groups: ["CSS Backgrounds and Borders"],
    initial: "1",
    appliesto: "allElementsExceptTableElementsWhenCollapse",
    computed: "asSpecifiedRelativeToAbsoluteLengths",
    order: "uniqueOrder",
    alsoAppliesTo: ["::first-letter"],
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-width",
  },
  "border-inline": {
    syntax: "<'border-top-width'> || <'border-top-style'> || <color>",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Logical Properties"],
    initial: ["border-top-width", "border-top-style", "border-top-color"],
    appliesto: "allElements",
    computed: ["border-top-width", "border-top-style", "border-top-color"],
    order: "uniqueOrder",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline",
  },
  "border-inline-end": {
    syntax: "<'border-top-width'> || <'border-top-style'> || <color>",
    media: "visual",
    inherited: false,
    animationType: [
      "border-inline-end-color",
      "border-inline-end-style",
      "border-inline-end-width",
    ],
    percentages: "no",
    groups: ["CSS Logical Properties"],
    initial: ["border-width", "border-style", "color"],
    appliesto: "allElements",
    computed: ["border-width", "border-style", "border-inline-end-color"],
    order: "uniqueOrder",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-end",
  },
  "border-inline-color": {
    syntax: "<'border-top-color'>{1,2}",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Logical Properties"],
    initial: "currentcolor",
    appliesto: "allElements",
    computed: "computedColor",
    order: "uniqueOrder",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-color",
  },
  "border-inline-style": {
    syntax: "<'border-top-style'>",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Logical Properties"],
    initial: "none",
    appliesto: "allElements",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-style",
  },
  "border-inline-width": {
    syntax: "<'border-top-width'>",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "logicalWidthOfContainingBlock",
    groups: ["CSS Logical Properties"],
    initial: "medium",
    appliesto: "allElements",
    computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
    order: "uniqueOrder",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-width",
  },
  "border-inline-end-color": {
    syntax: "<'border-top-color'>",
    media: "visual",
    inherited: false,
    animationType: "color",
    percentages: "no",
    groups: ["CSS Logical Properties"],
    initial: "currentcolor",
    appliesto: "allElements",
    computed: "computedColor",
    order: "uniqueOrder",
    status: "standard",
    mdn_url:
      "https://developer.mozilla.org/docs/Web/CSS/border-inline-end-color",
  },
  "border-inline-end-style": {
    syntax: "<'border-top-style'>",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Logical Properties"],
    initial: "none",
    appliesto: "allElements",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "standard",
    mdn_url:
      "https://developer.mozilla.org/docs/Web/CSS/border-inline-end-style",
  },
  "border-inline-end-width": {
    syntax: "<'border-top-width'>",
    media: "visual",
    inherited: false,
    animationType: "length",
    percentages: "logicalWidthOfContainingBlock",
    groups: ["CSS Logical Properties"],
    initial: "medium",
    appliesto: "allElements",
    computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
    order: "uniqueOrder",
    status: "standard",
    mdn_url:
      "https://developer.mozilla.org/docs/Web/CSS/border-inline-end-width",
  },
  "border-inline-start": {
    syntax: "<'border-top-width'> || <'border-top-style'> || <color>",
    media: "visual",
    inherited: false,
    animationType: [
      "border-inline-start-color",
      "border-inline-start-style",
      "border-inline-start-width",
    ],
    percentages: "no",
    groups: ["CSS Logical Properties"],
    initial: ["border-width", "border-style", "color"],
    appliesto: "allElements",
    computed: ["border-width", "border-style", "border-inline-start-color"],
    order: "uniqueOrder",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-start",
  },
  "border-inline-start-color": {
    syntax: "<'border-top-color'>",
    media: "visual",
    inherited: false,
    animationType: "color",
    percentages: "no",
    groups: ["CSS Logical Properties"],
    initial: "currentcolor",
    appliesto: "allElements",
    computed: "computedColor",
    order: "uniqueOrder",
    status: "standard",
    mdn_url:
      "https://developer.mozilla.org/docs/Web/CSS/border-inline-start-color",
  },
  "border-inline-start-style": {
    syntax: "<'border-top-style'>",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Logical Properties"],
    initial: "none",
    appliesto: "allElements",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "standard",
    mdn_url:
      "https://developer.mozilla.org/docs/Web/CSS/border-inline-start-style",
  },
  "border-inline-start-width": {
    syntax: "<'border-top-width'>",
    media: "visual",
    inherited: false,
    animationType: "length",
    percentages: "logicalWidthOfContainingBlock",
    groups: ["CSS Logical Properties"],
    initial: "medium",
    appliesto: "allElements",
    computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
    order: "uniqueOrder",
    status: "standard",
    mdn_url:
      "https://developer.mozilla.org/docs/Web/CSS/border-inline-start-width",
  },
  "border-left": {
    syntax: "<line-width> || <line-style> || <color>",
    media: "visual",
    inherited: false,
    animationType: [
      "border-left-color",
      "border-left-style",
      "border-left-width",
    ],
    percentages: "no",
    groups: ["CSS Backgrounds and Borders"],
    initial: ["border-left-width", "border-left-style", "border-left-color"],
    appliesto: "allElements",
    computed: ["border-left-width", "border-left-style", "border-left-color"],
    order: "orderOfAppearance",
    alsoAppliesTo: ["::first-letter"],
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-left",
  },
  "border-left-color": {
    syntax: "<color>",
    media: "visual",
    inherited: false,
    animationType: "color",
    percentages: "no",
    groups: ["CSS Backgrounds and Borders"],
    initial: "currentcolor",
    appliesto: "allElements",
    computed: "computedColor",
    order: "uniqueOrder",
    alsoAppliesTo: ["::first-letter"],
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-left-color",
  },
  "border-left-style": {
    syntax: "<line-style>",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Backgrounds and Borders"],
    initial: "none",
    appliesto: "allElements",
    computed: "asSpecified",
    order: "uniqueOrder",
    alsoAppliesTo: ["::first-letter"],
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-left-style",
  },
  "border-left-width": {
    syntax: "<line-width>",
    media: "visual",
    inherited: false,
    animationType: "length",
    percentages: "no",
    groups: ["CSS Backgrounds and Borders"],
    initial: "medium",
    appliesto: "allElements",
    computed: "absoluteLengthOr0IfBorderLeftStyleNoneOrHidden",
    order: "uniqueOrder",
    alsoAppliesTo: ["::first-letter"],
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-left-width",
  },
  "border-radius": {
    syntax: "<length-percentage>{1,4} [ / <length-percentage>{1,4} ]?",
    media: "visual",
    inherited: false,
    animationType: [
      "border-top-left-radius",
      "border-top-right-radius",
      "border-bottom-right-radius",
      "border-bottom-left-radius",
    ],
    percentages: "referToDimensionOfBorderBox",
    groups: ["CSS Backgrounds and Borders"],
    initial: [
      "border-top-left-radius",
      "border-top-right-radius",
      "border-bottom-right-radius",
      "border-bottom-left-radius",
    ],
    appliesto: "allElementsUAsNotRequiredWhenCollapse",
    computed: [
      "border-bottom-left-radius",
      "border-bottom-right-radius",
      "border-top-left-radius",
      "border-top-right-radius",
    ],
    order: "uniqueOrder",
    alsoAppliesTo: ["::first-letter"],
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-radius",
  },
  "border-right": {
    syntax: "<line-width> || <line-style> || <color>",
    media: "visual",
    inherited: false,
    animationType: [
      "border-right-color",
      "border-right-style",
      "border-right-width",
    ],
    percentages: "no",
    groups: ["CSS Backgrounds and Borders"],
    initial: ["border-right-width", "border-right-style", "border-right-color"],
    appliesto: "allElements",
    computed: [
      "border-right-width",
      "border-right-style",
      "border-right-color",
    ],
    order: "orderOfAppearance",
    alsoAppliesTo: ["::first-letter"],
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-right",
  },
  "border-right-color": {
    syntax: "<color>",
    media: "visual",
    inherited: false,
    animationType: "color",
    percentages: "no",
    groups: ["CSS Backgrounds and Borders"],
    initial: "currentcolor",
    appliesto: "allElements",
    computed: "computedColor",
    order: "uniqueOrder",
    alsoAppliesTo: ["::first-letter"],
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-right-color",
  },
  "border-right-style": {
    syntax: "<line-style>",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Backgrounds and Borders"],
    initial: "none",
    appliesto: "allElements",
    computed: "asSpecified",
    order: "uniqueOrder",
    alsoAppliesTo: ["::first-letter"],
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-right-style",
  },
  "border-right-width": {
    syntax: "<line-width>",
    media: "visual",
    inherited: false,
    animationType: "length",
    percentages: "no",
    groups: ["CSS Backgrounds and Borders"],
    initial: "medium",
    appliesto: "allElements",
    computed: "absoluteLengthOr0IfBorderRightStyleNoneOrHidden",
    order: "uniqueOrder",
    alsoAppliesTo: ["::first-letter"],
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-right-width",
  },
  "border-spacing": {
    syntax: "<length> <length>?",
    media: "visual",
    inherited: true,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Table"],
    initial: "0",
    appliesto: "tableElements",
    computed: "twoAbsoluteLengths",
    order: "uniqueOrder",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-spacing",
  },
  "border-start-end-radius": {
    syntax: "<length-percentage>{1,2}",
    media: "visual",
    inherited: false,
    animationType: "lpc",
    percentages: "referToDimensionOfBorderBox",
    groups: ["CSS Logical Properties"],
    initial: "0",
    appliesto: "allElementsUAsNotRequiredWhenCollapse",
    computed: "twoAbsoluteLengthOrPercentages",
    order: "uniqueOrder",
    alsoAppliesTo: ["::first-letter"],
    status: "standard",
    mdn_url:
      "https://developer.mozilla.org/docs/Web/CSS/border-start-end-radius",
  },
  "border-start-start-radius": {
    syntax: "<length-percentage>{1,2}",
    media: "visual",
    inherited: false,
    animationType: "lpc",
    percentages: "referToDimensionOfBorderBox",
    groups: ["CSS Logical Properties"],
    initial: "0",
    appliesto: "allElementsUAsNotRequiredWhenCollapse",
    computed: "twoAbsoluteLengthOrPercentages",
    order: "uniqueOrder",
    alsoAppliesTo: ["::first-letter"],
    status: "standard",
    mdn_url:
      "https://developer.mozilla.org/docs/Web/CSS/border-start-start-radius",
  },
  "border-style": {
    syntax: "<line-style>{1,4}",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Backgrounds and Borders"],
    initial: [
      "border-top-style",
      "border-right-style",
      "border-bottom-style",
      "border-left-style",
    ],
    appliesto: "allElements",
    computed: [
      "border-bottom-style",
      "border-left-style",
      "border-right-style",
      "border-top-style",
    ],
    order: "uniqueOrder",
    alsoAppliesTo: ["::first-letter"],
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-style",
  },
  "border-top": {
    syntax: "<line-width> || <line-style> || <color>",
    media: "visual",
    inherited: false,
    animationType: ["border-top-color", "border-top-style", "border-top-width"],
    percentages: "no",
    groups: ["CSS Backgrounds and Borders"],
    initial: ["border-top-width", "border-top-style", "border-top-color"],
    appliesto: "allElements",
    computed: ["border-top-width", "border-top-style", "border-top-color"],
    order: "orderOfAppearance",
    alsoAppliesTo: ["::first-letter"],
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top",
  },
  "border-top-color": {
    syntax: "<color>",
    media: "visual",
    inherited: false,
    animationType: "color",
    percentages: "no",
    groups: ["CSS Backgrounds and Borders"],
    initial: "currentcolor",
    appliesto: "allElements",
    computed: "computedColor",
    order: "uniqueOrder",
    alsoAppliesTo: ["::first-letter"],
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-color",
  },
  "border-top-left-radius": {
    syntax: "<length-percentage>{1,2}",
    media: "visual",
    inherited: false,
    animationType: "lpc",
    percentages: "referToDimensionOfBorderBox",
    groups: ["CSS Backgrounds and Borders"],
    initial: "0",
    appliesto: "allElementsUAsNotRequiredWhenCollapse",
    computed: "twoAbsoluteLengthOrPercentages",
    order: "uniqueOrder",
    alsoAppliesTo: ["::first-letter"],
    status: "standard",
    mdn_url:
      "https://developer.mozilla.org/docs/Web/CSS/border-top-left-radius",
  },
  "border-top-right-radius": {
    syntax: "<length-percentage>{1,2}",
    media: "visual",
    inherited: false,
    animationType: "lpc",
    percentages: "referToDimensionOfBorderBox",
    groups: ["CSS Backgrounds and Borders"],
    initial: "0",
    appliesto: "allElementsUAsNotRequiredWhenCollapse",
    computed: "twoAbsoluteLengthOrPercentages",
    order: "uniqueOrder",
    alsoAppliesTo: ["::first-letter"],
    status: "standard",
    mdn_url:
      "https://developer.mozilla.org/docs/Web/CSS/border-top-right-radius",
  },
  "border-top-style": {
    syntax: "<line-style>",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Backgrounds and Borders"],
    initial: "none",
    appliesto: "allElements",
    computed: "asSpecified",
    order: "uniqueOrder",
    alsoAppliesTo: ["::first-letter"],
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-style",
  },
  "border-top-width": {
    syntax: "<line-width>",
    media: "visual",
    inherited: false,
    animationType: "length",
    percentages: "no",
    groups: ["CSS Backgrounds and Borders"],
    initial: "medium",
    appliesto: "allElements",
    computed: "absoluteLengthOr0IfBorderTopStyleNoneOrHidden",
    order: "uniqueOrder",
    alsoAppliesTo: ["::first-letter"],
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-width",
  },
  "border-width": {
    syntax: "<line-width>{1,4}",
    media: "visual",
    inherited: false,
    animationType: [
      "border-bottom-width",
      "border-left-width",
      "border-right-width",
      "border-top-width",
    ],
    percentages: "no",
    groups: ["CSS Backgrounds and Borders"],
    initial: [
      "border-top-width",
      "border-right-width",
      "border-bottom-width",
      "border-left-width",
    ],
    appliesto: "allElements",
    computed: [
      "border-bottom-width",
      "border-left-width",
      "border-right-width",
      "border-top-width",
    ],
    order: "uniqueOrder",
    alsoAppliesTo: ["::first-letter"],
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-width",
  },
  bottom: bottom,
  "box-align": {
    syntax: "start | center | end | baseline | stretch",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["Mozilla Extensions", "WebKit Extensions"],
    initial: "stretch",
    appliesto: "elementsWithDisplayBoxOrInlineBox",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "nonstandard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-align",
  },
  "box-decoration-break": {
    syntax: "slice | clone",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Fragmentation"],
    initial: "slice",
    appliesto: "allElements",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-decoration-break",
  },
  "box-direction": {
    syntax: "normal | reverse | inherit",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["Mozilla Extensions", "WebKit Extensions"],
    initial: "normal",
    appliesto: "elementsWithDisplayBoxOrInlineBox",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "nonstandard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-direction",
  },
  "box-flex": {
    syntax: "<number>",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["Mozilla Extensions", "WebKit Extensions"],
    initial: "0",
    appliesto: "directChildrenOfElementsWithDisplayMozBoxMozInlineBox",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "nonstandard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-flex",
  },
  "box-flex-group": {
    syntax: "<integer>",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["Mozilla Extensions", "WebKit Extensions"],
    initial: "1",
    appliesto: "inFlowChildrenOfBoxElements",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "nonstandard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-flex-group",
  },
  "box-lines": {
    syntax: "single | multiple",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["Mozilla Extensions", "WebKit Extensions"],
    initial: "single",
    appliesto: "boxElements",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "nonstandard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-lines",
  },
  "box-ordinal-group": {
    syntax: "<integer>",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["Mozilla Extensions", "WebKit Extensions"],
    initial: "1",
    appliesto: "childrenOfBoxElements",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "nonstandard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-ordinal-group",
  },
  "box-orient": {
    syntax: "horizontal | vertical | inline-axis | block-axis | inherit",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["Mozilla Extensions", "WebKit Extensions"],
    initial: "inlineAxisHorizontalInXUL",
    appliesto: "elementsWithDisplayBoxOrInlineBox",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "nonstandard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-orient",
  },
  "box-pack": {
    syntax: "start | center | end | justify",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["Mozilla Extensions", "WebKit Extensions"],
    initial: "start",
    appliesto: "elementsWithDisplayMozBoxMozInlineBox",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "nonstandard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-pack",
  },
  "box-shadow": {
    syntax: "none | <shadow>#",
    media: "visual",
    inherited: false,
    animationType: "shadowList",
    percentages: "no",
    groups: ["CSS Backgrounds and Borders"],
    initial: "none",
    appliesto: "allElements",
    computed: "absoluteLengthsSpecifiedColorAsSpecified",
    order: "uniqueOrder",
    alsoAppliesTo: ["::first-letter"],
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-shadow",
  },
  "box-sizing": {
    syntax: "content-box | border-box",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Box Model"],
    initial: "content-box",
    appliesto: "allElementsAcceptingWidthOrHeight",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-sizing",
  },
  "break-after": {
    syntax:
      "auto | avoid | always | all | avoid-page | page | left | right | recto | verso | avoid-column | column | avoid-region | region",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Fragmentation"],
    initial: "auto",
    appliesto: "blockLevelElements",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/break-after",
  },
  "break-before": {
    syntax:
      "auto | avoid | always | all | avoid-page | page | left | right | recto | verso | avoid-column | column | avoid-region | region",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Fragmentation"],
    initial: "auto",
    appliesto: "blockLevelElements",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/break-before",
  },
  "break-inside": {
    syntax: "auto | avoid | avoid-page | avoid-column | avoid-region",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Fragmentation"],
    initial: "auto",
    appliesto: "blockLevelElements",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/break-inside",
  },
  "caption-side": {
    syntax:
      "top | bottom | block-start | block-end | inline-start | inline-end",
    media: "visual",
    inherited: true,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Table"],
    initial: "top",
    appliesto: "tableCaptionElements",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/caption-side",
  },
  "caret-color": {
    syntax: "auto | <color>",
    media: "interactive",
    inherited: true,
    animationType: "color",
    percentages: "no",
    groups: ["CSS Basic User Interface"],
    initial: "auto",
    appliesto: "allElements",
    computed: "asAutoOrColor",
    order: "perGrammar",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/caret-color",
  },
  clear: clear,
  clip: clip,
  "clip-path": {
    syntax: "<clip-source> | [ <basic-shape> || <geometry-box> ] | none",
    media: "visual",
    inherited: false,
    animationType: "basicShapeOtherwiseNo",
    percentages: "referToReferenceBoxWhenSpecifiedOtherwiseBorderBox",
    groups: ["CSS Masking"],
    initial: "none",
    appliesto: "allElementsSVGContainerElements",
    computed: "asSpecifiedURLsAbsolute",
    order: "uniqueOrder",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/clip-path",
  },
  color: color$3,
  "print-color-adjust": {
    syntax: "economy | exact",
    media: "visual",
    inherited: true,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Color"],
    initial: "economy",
    appliesto: "allElements",
    computed: "asSpecified",
    order: "perGrammar",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/print-color-adjust",
  },
  "color-scheme": {
    syntax: "normal | [ light | dark | <custom-ident> ]+ && only?",
    media: "visual",
    inherited: true,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Color"],
    initial: "normal",
    appliesto: "allElementsAndText",
    computed: "asSpecified",
    order: "perGrammar",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/color-scheme",
  },
  "column-count": {
    syntax: "<integer> | auto",
    media: "visual",
    inherited: false,
    animationType: "integer",
    percentages: "no",
    groups: ["CSS Columns"],
    initial: "auto",
    appliesto: "blockContainersExceptTableWrappers",
    computed: "asSpecified",
    order: "perGrammar",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-count",
  },
  "column-fill": {
    syntax: "auto | balance | balance-all",
    media: "visualInContinuousMediaNoEffectInOverflowColumns",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Columns"],
    initial: "balance",
    appliesto: "multicolElements",
    computed: "asSpecified",
    order: "perGrammar",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-fill",
  },
  "column-gap": {
    syntax: "normal | <length-percentage>",
    media: "visual",
    inherited: false,
    animationType: "lpc",
    percentages: "referToDimensionOfContentArea",
    groups: ["CSS Box Alignment"],
    initial: "normal",
    appliesto: "multiColumnElementsFlexContainersGridContainers",
    computed:
      "asSpecifiedWithLengthsAbsoluteAndNormalComputingToZeroExceptMultiColumn",
    order: "perGrammar",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-gap",
  },
  "column-rule": {
    syntax:
      "<'column-rule-width'> || <'column-rule-style'> || <'column-rule-color'>",
    media: "visual",
    inherited: false,
    animationType: [
      "column-rule-color",
      "column-rule-style",
      "column-rule-width",
    ],
    percentages: "no",
    groups: ["CSS Columns"],
    initial: ["column-rule-width", "column-rule-style", "column-rule-color"],
    appliesto: "multicolElements",
    computed: ["column-rule-color", "column-rule-style", "column-rule-width"],
    order: "perGrammar",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-rule",
  },
  "column-rule-color": {
    syntax: "<color>",
    media: "visual",
    inherited: false,
    animationType: "color",
    percentages: "no",
    groups: ["CSS Columns"],
    initial: "currentcolor",
    appliesto: "multicolElements",
    computed: "computedColor",
    order: "perGrammar",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-rule-color",
  },
  "column-rule-style": {
    syntax: "<'border-style'>",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Columns"],
    initial: "none",
    appliesto: "multicolElements",
    computed: "asSpecified",
    order: "perGrammar",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-rule-style",
  },
  "column-rule-width": {
    syntax: "<'border-width'>",
    media: "visual",
    inherited: false,
    animationType: "length",
    percentages: "no",
    groups: ["CSS Columns"],
    initial: "medium",
    appliesto: "multicolElements",
    computed: "absoluteLength0IfColumnRuleStyleNoneOrHidden",
    order: "perGrammar",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-rule-width",
  },
  "column-span": {
    syntax: "none | all",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Columns"],
    initial: "none",
    appliesto: "inFlowBlockLevelElements",
    computed: "asSpecified",
    order: "perGrammar",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-span",
  },
  "column-width": {
    syntax: "<length> | auto",
    media: "visual",
    inherited: false,
    animationType: "length",
    percentages: "no",
    groups: ["CSS Columns"],
    initial: "auto",
    appliesto: "blockContainersExceptTableWrappers",
    computed: "absoluteLengthZeroOrLarger",
    order: "perGrammar",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-width",
  },
  columns: columns,
  contain: contain,
  content: content,
  "content-visibility": {
    syntax: "visible | auto | hidden",
    media: "all",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Containment"],
    initial: "visible",
    appliesto: "elementsForWhichLayoutContainmentCanApply",
    computed: "asSpecified",
    order: "perGrammar",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/content-visibility",
  },
  "counter-increment": {
    syntax: "[ <counter-name> <integer>? ]+ | none",
    media: "all",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Counter Styles"],
    initial: "none",
    appliesto: "allElements",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/counter-increment",
  },
  "counter-reset": {
    syntax:
      "[ <counter-name> <integer>? | <reversed-counter-name> <integer>? ]+ | none",
    media: "all",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Counter Styles"],
    initial: "none",
    appliesto: "allElements",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/counter-reset",
  },
  "counter-set": {
    syntax: "[ <counter-name> <integer>? ]+ | none",
    media: "all",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Counter Styles"],
    initial: "none",
    appliesto: "allElements",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/counter-set",
  },
  cursor: cursor,
  direction: direction,
  display: display,
  "empty-cells": {
    syntax: "show | hide",
    media: "visual",
    inherited: true,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Table"],
    initial: "show",
    appliesto: "tableCellElements",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/empty-cells",
  },
  filter: filter,
  flex: flex,
  "flex-basis": {
    syntax: "content | <'width'>",
    media: "visual",
    inherited: false,
    animationType: "lpc",
    percentages: "referToFlexContainersInnerMainSize",
    groups: ["CSS Flexible Box Layout"],
    initial: "auto",
    appliesto: "flexItemsAndInFlowPseudos",
    computed: "asSpecifiedRelativeToAbsoluteLengths",
    order: "lengthOrPercentageBeforeKeywordIfBothPresent",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-basis",
  },
  "flex-direction": {
    syntax: "row | row-reverse | column | column-reverse",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Flexible Box Layout"],
    initial: "row",
    appliesto: "flexContainers",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-direction",
  },
  "flex-flow": {
    syntax: "<'flex-direction'> || <'flex-wrap'>",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Flexible Box Layout"],
    initial: ["flex-direction", "flex-wrap"],
    appliesto: "flexContainers",
    computed: ["flex-direction", "flex-wrap"],
    order: "orderOfAppearance",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-flow",
  },
  "flex-grow": {
    syntax: "<number>",
    media: "visual",
    inherited: false,
    animationType: "number",
    percentages: "no",
    groups: ["CSS Flexible Box Layout"],
    initial: "0",
    appliesto: "flexItemsAndInFlowPseudos",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-grow",
  },
  "flex-shrink": {
    syntax: "<number>",
    media: "visual",
    inherited: false,
    animationType: "number",
    percentages: "no",
    groups: ["CSS Flexible Box Layout"],
    initial: "1",
    appliesto: "flexItemsAndInFlowPseudos",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-shrink",
  },
  "flex-wrap": {
    syntax: "nowrap | wrap | wrap-reverse",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Flexible Box Layout"],
    initial: "nowrap",
    appliesto: "flexContainers",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-wrap",
  },
  float: float,
  font: font$2,
  "font-family": {
    syntax: "[ <family-name> | <generic-family> ]#",
    media: "visual",
    inherited: true,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Fonts"],
    initial: "dependsOnUserAgent",
    appliesto: "allElements",
    computed: "asSpecified",
    order: "uniqueOrder",
    alsoAppliesTo: ["::first-letter", "::first-line", "::placeholder"],
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-family",
  },
  "font-feature-settings": {
    syntax: "normal | <feature-tag-value>#",
    media: "visual",
    inherited: true,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Fonts"],
    initial: "normal",
    appliesto: "allElements",
    computed: "asSpecified",
    order: "uniqueOrder",
    alsoAppliesTo: ["::first-letter", "::first-line", "::placeholder"],
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-feature-settings",
  },
  "font-kerning": {
    syntax: "auto | normal | none",
    media: "visual",
    inherited: true,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Fonts"],
    initial: "auto",
    appliesto: "allElements",
    computed: "asSpecified",
    order: "uniqueOrder",
    alsoAppliesTo: ["::first-letter", "::first-line", "::placeholder"],
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-kerning",
  },
  "font-language-override": {
    syntax: "normal | <string>",
    media: "visual",
    inherited: true,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Fonts"],
    initial: "normal",
    appliesto: "allElements",
    computed: "asSpecified",
    order: "uniqueOrder",
    alsoAppliesTo: ["::first-letter", "::first-line", "::placeholder"],
    status: "standard",
    mdn_url:
      "https://developer.mozilla.org/docs/Web/CSS/font-language-override",
  },
  "font-optical-sizing": {
    syntax: "auto | none",
    media: "visual",
    inherited: true,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Fonts"],
    initial: "auto",
    appliesto: "allElements",
    computed: "asSpecified",
    order: "perGrammar",
    alsoAppliesTo: ["::first-letter", "::first-line", "::placeholder"],
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-optical-sizing",
  },
  "font-variation-settings": {
    syntax: "normal | [ <string> <number> ]#",
    media: "visual",
    inherited: true,
    animationType: "transform",
    percentages: "no",
    groups: ["CSS Fonts"],
    initial: "normal",
    appliesto: "allElements",
    computed: "asSpecified",
    order: "perGrammar",
    alsoAppliesTo: ["::first-letter", "::first-line", "::placeholder"],
    status: "standard",
    mdn_url:
      "https://developer.mozilla.org/docs/Web/CSS/font-variation-settings",
  },
  "font-size": {
    syntax: "<absolute-size> | <relative-size> | <length-percentage>",
    media: "visual",
    inherited: true,
    animationType: "length",
    percentages: "referToParentElementsFontSize",
    groups: ["CSS Fonts"],
    initial: "medium",
    appliesto: "allElements",
    computed: "asSpecifiedRelativeToAbsoluteLengths",
    order: "uniqueOrder",
    alsoAppliesTo: ["::first-letter", "::first-line", "::placeholder"],
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-size",
  },
  "font-size-adjust": {
    syntax:
      "none | [ ex-height | cap-height | ch-width | ic-width | ic-height ]? [ from-font | <number> ]",
    media: "visual",
    inherited: true,
    animationType: "number",
    percentages: "no",
    groups: ["CSS Fonts"],
    initial: "none",
    appliesto: "allElements",
    computed: "asSpecified",
    order: "uniqueOrder",
    alsoAppliesTo: ["::first-letter", "::first-line", "::placeholder"],
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-size-adjust",
  },
  "font-smooth": {
    syntax: "auto | never | always | <absolute-size> | <length>",
    media: "visual",
    inherited: true,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Fonts"],
    initial: "auto",
    appliesto: "allElements",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "nonstandard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-smooth",
  },
  "font-stretch": {
    syntax: "<font-stretch-absolute>",
    media: "visual",
    inherited: true,
    animationType: "fontStretch",
    percentages: "no",
    groups: ["CSS Fonts"],
    initial: "normal",
    appliesto: "allElements",
    computed: "asSpecified",
    order: "uniqueOrder",
    alsoAppliesTo: ["::first-letter", "::first-line", "::placeholder"],
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-stretch",
  },
  "font-style": {
    syntax: "normal | italic | oblique <angle>?",
    media: "visual",
    inherited: true,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Fonts"],
    initial: "normal",
    appliesto: "allElements",
    computed: "asSpecified",
    order: "uniqueOrder",
    alsoAppliesTo: ["::first-letter", "::first-line", "::placeholder"],
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-style",
  },
  "font-synthesis": {
    syntax: "none | [ weight || style || small-caps ]",
    media: "visual",
    inherited: true,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Fonts"],
    initial: "weight style",
    appliesto: "allElements",
    computed: "asSpecified",
    order: "orderOfAppearance",
    alsoAppliesTo: ["::first-letter", "::first-line", "::placeholder"],
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-synthesis",
  },
  "font-variant": {
    syntax:
      "normal | none | [ <common-lig-values> || <discretionary-lig-values> || <historical-lig-values> || <contextual-alt-values> || stylistic( <feature-value-name> ) || historical-forms || styleset( <feature-value-name># ) || character-variant( <feature-value-name># ) || swash( <feature-value-name> ) || ornaments( <feature-value-name> ) || annotation( <feature-value-name> ) || [ small-caps | all-small-caps | petite-caps | all-petite-caps | unicase | titling-caps ] || <numeric-figure-values> || <numeric-spacing-values> || <numeric-fraction-values> || ordinal || slashed-zero || <east-asian-variant-values> || <east-asian-width-values> || ruby ]",
    media: "visual",
    inherited: true,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Fonts"],
    initial: "normal",
    appliesto: "allElements",
    computed: "asSpecified",
    order: "uniqueOrder",
    alsoAppliesTo: ["::first-letter", "::first-line", "::placeholder"],
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant",
  },
  "font-variant-alternates": {
    syntax:
      "normal | [ stylistic( <feature-value-name> ) || historical-forms || styleset( <feature-value-name># ) || character-variant( <feature-value-name># ) || swash( <feature-value-name> ) || ornaments( <feature-value-name> ) || annotation( <feature-value-name> ) ]",
    media: "visual",
    inherited: true,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Fonts"],
    initial: "normal",
    appliesto: "allElements",
    computed: "asSpecified",
    order: "orderOfAppearance",
    alsoAppliesTo: ["::first-letter", "::first-line", "::placeholder"],
    status: "standard",
    mdn_url:
      "https://developer.mozilla.org/docs/Web/CSS/font-variant-alternates",
  },
  "font-variant-caps": {
    syntax:
      "normal | small-caps | all-small-caps | petite-caps | all-petite-caps | unicase | titling-caps",
    media: "visual",
    inherited: true,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Fonts"],
    initial: "normal",
    appliesto: "allElements",
    computed: "asSpecified",
    order: "uniqueOrder",
    alsoAppliesTo: ["::first-letter", "::first-line", "::placeholder"],
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-caps",
  },
  "font-variant-east-asian": {
    syntax:
      "normal | [ <east-asian-variant-values> || <east-asian-width-values> || ruby ]",
    media: "visual",
    inherited: true,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Fonts"],
    initial: "normal",
    appliesto: "allElements",
    computed: "asSpecified",
    order: "orderOfAppearance",
    alsoAppliesTo: ["::first-letter", "::first-line", "::placeholder"],
    status: "standard",
    mdn_url:
      "https://developer.mozilla.org/docs/Web/CSS/font-variant-east-asian",
  },
  "font-variant-ligatures": {
    syntax:
      "normal | none | [ <common-lig-values> || <discretionary-lig-values> || <historical-lig-values> || <contextual-alt-values> ]",
    media: "visual",
    inherited: true,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Fonts"],
    initial: "normal",
    appliesto: "allElements",
    computed: "asSpecified",
    order: "orderOfAppearance",
    alsoAppliesTo: ["::first-letter", "::first-line", "::placeholder"],
    status: "standard",
    mdn_url:
      "https://developer.mozilla.org/docs/Web/CSS/font-variant-ligatures",
  },
  "font-variant-numeric": {
    syntax:
      "normal | [ <numeric-figure-values> || <numeric-spacing-values> || <numeric-fraction-values> || ordinal || slashed-zero ]",
    media: "visual",
    inherited: true,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Fonts"],
    initial: "normal",
    appliesto: "allElements",
    computed: "asSpecified",
    order: "orderOfAppearance",
    alsoAppliesTo: ["::first-letter", "::first-line", "::placeholder"],
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-numeric",
  },
  "font-variant-position": {
    syntax: "normal | sub | super",
    media: "visual",
    inherited: true,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Fonts"],
    initial: "normal",
    appliesto: "allElements",
    computed: "asSpecified",
    order: "uniqueOrder",
    alsoAppliesTo: ["::first-letter", "::first-line", "::placeholder"],
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-position",
  },
  "font-weight": {
    syntax: "<font-weight-absolute> | bolder | lighter",
    media: "visual",
    inherited: true,
    animationType: "fontWeight",
    percentages: "no",
    groups: ["CSS Fonts"],
    initial: "normal",
    appliesto: "allElements",
    computed: "keywordOrNumericalValueBolderLighterTransformedToRealValue",
    order: "uniqueOrder",
    alsoAppliesTo: ["::first-letter", "::first-line", "::placeholder"],
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-weight",
  },
  "forced-color-adjust": {
    syntax: "auto | none",
    media: "visual",
    inherited: true,
    animationType: "notAnimatable",
    percentages: "no",
    groups: ["CSS Color"],
    initial: "auto",
    appliesto: "allElementsAndText",
    computed: "asSpecified",
    order: "perGrammar",
    status: "experimental",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/forced-color-adjust",
  },
  gap: gap,
  grid: grid,
  "grid-area": {
    syntax: "<grid-line> [ / <grid-line> ]{0,3}",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Grid Layout"],
    initial: [
      "grid-row-start",
      "grid-column-start",
      "grid-row-end",
      "grid-column-end",
    ],
    appliesto: "gridItemsAndBoxesWithinGridContainer",
    computed: [
      "grid-row-start",
      "grid-column-start",
      "grid-row-end",
      "grid-column-end",
    ],
    order: "uniqueOrder",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-area",
  },
  "grid-auto-columns": {
    syntax: "<track-size>+",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "referToDimensionOfContentArea",
    groups: ["CSS Grid Layout"],
    initial: "auto",
    appliesto: "gridContainers",
    computed: "percentageAsSpecifiedOrAbsoluteLength",
    order: "uniqueOrder",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-auto-columns",
  },
  "grid-auto-flow": {
    syntax: "[ row | column ] || dense",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Grid Layout"],
    initial: "row",
    appliesto: "gridContainers",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-auto-flow",
  },
  "grid-auto-rows": {
    syntax: "<track-size>+",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "referToDimensionOfContentArea",
    groups: ["CSS Grid Layout"],
    initial: "auto",
    appliesto: "gridContainers",
    computed: "percentageAsSpecifiedOrAbsoluteLength",
    order: "uniqueOrder",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-auto-rows",
  },
  "grid-column": {
    syntax: "<grid-line> [ / <grid-line> ]?",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Grid Layout"],
    initial: ["grid-column-start", "grid-column-end"],
    appliesto: "gridItemsAndBoxesWithinGridContainer",
    computed: ["grid-column-start", "grid-column-end"],
    order: "uniqueOrder",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-column",
  },
  "grid-column-end": {
    syntax: "<grid-line>",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Grid Layout"],
    initial: "auto",
    appliesto: "gridItemsAndBoxesWithinGridContainer",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-column-end",
  },
  "grid-column-gap": {
    syntax: "<length-percentage>",
    media: "visual",
    inherited: false,
    animationType: "length",
    percentages: "referToDimensionOfContentArea",
    groups: ["CSS Grid Layout"],
    initial: "0",
    appliesto: "gridContainers",
    computed: "percentageAsSpecifiedOrAbsoluteLength",
    order: "uniqueOrder",
    status: "obsolete",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-gap",
  },
  "grid-column-start": {
    syntax: "<grid-line>",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Grid Layout"],
    initial: "auto",
    appliesto: "gridItemsAndBoxesWithinGridContainer",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-column-start",
  },
  "grid-gap": {
    syntax: "<'grid-row-gap'> <'grid-column-gap'>?",
    media: "visual",
    inherited: false,
    animationType: ["grid-row-gap", "grid-column-gap"],
    percentages: "no",
    groups: ["CSS Grid Layout"],
    initial: ["grid-row-gap", "grid-column-gap"],
    appliesto: "gridContainers",
    computed: ["grid-row-gap", "grid-column-gap"],
    order: "uniqueOrder",
    status: "obsolete",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/gap",
  },
  "grid-row": {
    syntax: "<grid-line> [ / <grid-line> ]?",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Grid Layout"],
    initial: ["grid-row-start", "grid-row-end"],
    appliesto: "gridItemsAndBoxesWithinGridContainer",
    computed: ["grid-row-start", "grid-row-end"],
    order: "uniqueOrder",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-row",
  },
  "grid-row-end": {
    syntax: "<grid-line>",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Grid Layout"],
    initial: "auto",
    appliesto: "gridItemsAndBoxesWithinGridContainer",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-row-end",
  },
  "grid-row-gap": {
    syntax: "<length-percentage>",
    media: "visual",
    inherited: false,
    animationType: "length",
    percentages: "referToDimensionOfContentArea",
    groups: ["CSS Grid Layout"],
    initial: "0",
    appliesto: "gridContainers",
    computed: "percentageAsSpecifiedOrAbsoluteLength",
    order: "uniqueOrder",
    status: "obsolete",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/row-gap",
  },
  "grid-row-start": {
    syntax: "<grid-line>",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Grid Layout"],
    initial: "auto",
    appliesto: "gridItemsAndBoxesWithinGridContainer",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-row-start",
  },
  "grid-template": {
    syntax:
      "none | [ <'grid-template-rows'> / <'grid-template-columns'> ] | [ <line-names>? <string> <track-size>? <line-names>? ]+ [ / <explicit-track-list> ]?",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: ["grid-template-columns", "grid-template-rows"],
    groups: ["CSS Grid Layout"],
    initial: [
      "grid-template-columns",
      "grid-template-rows",
      "grid-template-areas",
    ],
    appliesto: "gridContainers",
    computed: [
      "grid-template-columns",
      "grid-template-rows",
      "grid-template-areas",
    ],
    order: "uniqueOrder",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-template",
  },
  "grid-template-areas": {
    syntax: "none | <string>+",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Grid Layout"],
    initial: "none",
    appliesto: "gridContainers",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-template-areas",
  },
  "grid-template-columns": {
    syntax:
      "none | <track-list> | <auto-track-list> | subgrid <line-name-list>?",
    media: "visual",
    inherited: false,
    animationType: "simpleListOfLpcDifferenceLpc",
    percentages: "referToDimensionOfContentArea",
    groups: ["CSS Grid Layout"],
    initial: "none",
    appliesto: "gridContainers",
    computed: "asSpecifiedRelativeToAbsoluteLengths",
    order: "uniqueOrder",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-template-columns",
  },
  "grid-template-rows": {
    syntax:
      "none | <track-list> | <auto-track-list> | subgrid <line-name-list>?",
    media: "visual",
    inherited: false,
    animationType: "simpleListOfLpcDifferenceLpc",
    percentages: "referToDimensionOfContentArea",
    groups: ["CSS Grid Layout"],
    initial: "none",
    appliesto: "gridContainers",
    computed: "asSpecifiedRelativeToAbsoluteLengths",
    order: "uniqueOrder",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-template-rows",
  },
  "hanging-punctuation": {
    syntax: "none | [ first || [ force-end | allow-end ] || last ]",
    media: "visual",
    inherited: true,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Text"],
    initial: "none",
    appliesto: "allElements",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/hanging-punctuation",
  },
  height: height,
  "hyphenate-character": {
    syntax: "auto | <string>",
    media: "visual",
    inherited: true,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Text"],
    initial: "auto",
    appliesto: "allElements",
    computed: "asSpecified",
    order: "perGrammar",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/hyphenate-character",
  },
  hyphens: hyphens,
  "image-orientation": {
    syntax: "from-image | <angle> | [ <angle>? flip ]",
    media: "visual",
    inherited: true,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Images"],
    initial: "from-image",
    appliesto: "allElements",
    computed: "angleRoundedToNextQuarter",
    order: "uniqueOrder",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/image-orientation",
  },
  "image-rendering": {
    syntax: "auto | crisp-edges | pixelated",
    media: "visual",
    inherited: true,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Images"],
    initial: "auto",
    appliesto: "allElements",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/image-rendering",
  },
  "image-resolution": {
    syntax: "[ from-image || <resolution> ] && snap?",
    media: "visual",
    inherited: true,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Images"],
    initial: "1dppx",
    appliesto: "allElements",
    computed: "asSpecifiedWithExceptionOfResolution",
    order: "uniqueOrder",
    status: "experimental",
  },
  "ime-mode": {
    syntax: "auto | normal | active | inactive | disabled",
    media: "interactive",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Basic User Interface"],
    initial: "auto",
    appliesto: "textFields",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "obsolete",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/ime-mode",
  },
  "initial-letter": {
    syntax: "normal | [ <number> <integer>? ]",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Inline"],
    initial: "normal",
    appliesto: "firstLetterPseudoElementsAndInlineLevelFirstChildren",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "experimental",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/initial-letter",
  },
  "initial-letter-align": {
    syntax: "[ auto | alphabetic | hanging | ideographic ]",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Inline"],
    initial: "auto",
    appliesto: "firstLetterPseudoElementsAndInlineLevelFirstChildren",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "experimental",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/initial-letter-align",
  },
  "inline-size": {
    syntax: "<'width'>",
    media: "visual",
    inherited: false,
    animationType: "lpc",
    percentages: "inlineSizeOfContainingBlock",
    groups: ["CSS Logical Properties"],
    initial: "auto",
    appliesto: "sameAsWidthAndHeight",
    computed: "sameAsWidthAndHeight",
    order: "uniqueOrder",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inline-size",
  },
  "input-security": {
    syntax: "auto | none",
    media: "interactive",
    inherited: false,
    animationType: "byComputedValueType",
    percentages: "no",
    groups: ["CSS Basic User Interface"],
    initial: "auto",
    appliesto: "sensitiveTextInputs",
    computed: "asSpecified",
    order: "perGrammar",
    status: "standard",
  },
  inset: inset,
  "inset-block": {
    syntax: "<'top'>{1,2}",
    media: "visual",
    inherited: false,
    animationType: "lpc",
    percentages: "logicalHeightOfContainingBlock",
    groups: ["CSS Logical Properties"],
    initial: "auto",
    appliesto: "positionedElements",
    computed: "sameAsBoxOffsets",
    order: "uniqueOrder",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-block",
  },
  "inset-block-end": {
    syntax: "<'top'>",
    media: "visual",
    inherited: false,
    animationType: "lpc",
    percentages: "logicalHeightOfContainingBlock",
    groups: ["CSS Logical Properties"],
    initial: "auto",
    appliesto: "positionedElements",
    computed: "sameAsBoxOffsets",
    order: "uniqueOrder",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-block-end",
  },
  "inset-block-start": {
    syntax: "<'top'>",
    media: "visual",
    inherited: false,
    animationType: "lpc",
    percentages: "logicalHeightOfContainingBlock",
    groups: ["CSS Logical Properties"],
    initial: "auto",
    appliesto: "positionedElements",
    computed: "sameAsBoxOffsets",
    order: "uniqueOrder",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-block-start",
  },
  "inset-inline": {
    syntax: "<'top'>{1,2}",
    media: "visual",
    inherited: false,
    animationType: "lpc",
    percentages: "logicalWidthOfContainingBlock",
    groups: ["CSS Logical Properties"],
    initial: "auto",
    appliesto: "positionedElements",
    computed: "sameAsBoxOffsets",
    order: "uniqueOrder",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-inline",
  },
  "inset-inline-end": {
    syntax: "<'top'>",
    media: "visual",
    inherited: false,
    animationType: "lpc",
    percentages: "logicalWidthOfContainingBlock",
    groups: ["CSS Logical Properties"],
    initial: "auto",
    appliesto: "positionedElements",
    computed: "sameAsBoxOffsets",
    order: "uniqueOrder",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-inline-end",
  },
  "inset-inline-start": {
    syntax: "<'top'>",
    media: "visual",
    inherited: false,
    animationType: "lpc",
    percentages: "logicalWidthOfContainingBlock",
    groups: ["CSS Logical Properties"],
    initial: "auto",
    appliesto: "positionedElements",
    computed: "sameAsBoxOffsets",
    order: "uniqueOrder",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-inline-start",
  },
  isolation: isolation,
  "justify-content": {
    syntax:
      "normal | <content-distribution> | <overflow-position>? [ <content-position> | left | right ]",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Box Alignment"],
    initial: "normal",
    appliesto: "flexContainers",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/justify-content",
  },
  "justify-items": {
    syntax:
      "normal | stretch | <baseline-position> | <overflow-position>? [ <self-position> | left | right ] | legacy | legacy && [ left | right | center ]",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Box Alignment"],
    initial: "legacy",
    appliesto: "allElements",
    computed: "asSpecified",
    order: "perGrammar",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/justify-items",
  },
  "justify-self": {
    syntax:
      "auto | normal | stretch | <baseline-position> | <overflow-position>? [ <self-position> | left | right ]",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Box Alignment"],
    initial: "auto",
    appliesto: "blockLevelBoxesAndAbsolutelyPositionedBoxesAndGridItems",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/justify-self",
  },
  "justify-tracks": {
    syntax:
      "[ normal | <content-distribution> | <overflow-position>? [ <content-position> | left | right ] ]#",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Grid Layout"],
    initial: "normal",
    appliesto: "gridContainersWithMasonryLayoutInTheirInlineAxis",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "experimental",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/justify-tracks",
  },
  left: left,
  "letter-spacing": {
    syntax: "normal | <length>",
    media: "visual",
    inherited: true,
    animationType: "length",
    percentages: "no",
    groups: ["CSS Text"],
    initial: "normal",
    appliesto: "allElements",
    computed: "optimumValueOfAbsoluteLengthOrNormal",
    order: "uniqueOrder",
    alsoAppliesTo: ["::first-letter", "::first-line"],
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/letter-spacing",
  },
  "line-break": {
    syntax: "auto | loose | normal | strict | anywhere",
    media: "visual",
    inherited: true,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Text"],
    initial: "auto",
    appliesto: "allElements",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/line-break",
  },
  "line-clamp": {
    syntax: "none | <integer>",
    media: "visual",
    inherited: false,
    animationType: "integer",
    percentages: "no",
    groups: ["CSS Overflow"],
    initial: "none",
    appliesto: "blockContainersExceptMultiColumnContainers",
    computed: "asSpecified",
    order: "perGrammar",
    status: "experimental",
  },
  "line-height": {
    syntax: "normal | <number> | <length> | <percentage>",
    media: "visual",
    inherited: true,
    animationType: "numberOrLength",
    percentages: "referToElementFontSize",
    groups: ["CSS Fonts"],
    initial: "normal",
    appliesto: "allElements",
    computed: "absoluteLengthOrAsSpecified",
    order: "uniqueOrder",
    alsoAppliesTo: ["::first-letter", "::first-line", "::placeholder"],
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/line-height",
  },
  "line-height-step": {
    syntax: "<length>",
    media: "visual",
    inherited: true,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Fonts"],
    initial: "0",
    appliesto: "blockContainers",
    computed: "absoluteLength",
    order: "perGrammar",
    status: "experimental",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/line-height-step",
  },
  "list-style": {
    syntax:
      "<'list-style-type'> || <'list-style-position'> || <'list-style-image'>",
    media: "visual",
    inherited: true,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Lists and Counters"],
    initial: ["list-style-type", "list-style-position", "list-style-image"],
    appliesto: "listItems",
    computed: ["list-style-image", "list-style-position", "list-style-type"],
    order: "orderOfAppearance",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/list-style",
  },
  "list-style-image": {
    syntax: "<image> | none",
    media: "visual",
    inherited: true,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Lists and Counters"],
    initial: "none",
    appliesto: "listItems",
    computed: "theKeywordListStyleImageNoneOrComputedValue",
    order: "uniqueOrder",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/list-style-image",
  },
  "list-style-position": {
    syntax: "inside | outside",
    media: "visual",
    inherited: true,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Lists and Counters"],
    initial: "outside",
    appliesto: "listItems",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/list-style-position",
  },
  "list-style-type": {
    syntax: "<counter-style> | <string> | none",
    media: "visual",
    inherited: true,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Lists and Counters"],
    initial: "disc",
    appliesto: "listItems",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/list-style-type",
  },
  margin: margin,
  "margin-block": {
    syntax: "<'margin-left'>{1,2}",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "dependsOnLayoutModel",
    groups: ["CSS Logical Properties"],
    initial: "0",
    appliesto: "sameAsMargin",
    computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
    order: "uniqueOrder",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-block",
  },
  "margin-block-end": {
    syntax: "<'margin-left'>",
    media: "visual",
    inherited: false,
    animationType: "length",
    percentages: "dependsOnLayoutModel",
    groups: ["CSS Logical Properties"],
    initial: "0",
    appliesto: "sameAsMargin",
    computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
    order: "uniqueOrder",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-block-end",
  },
  "margin-block-start": {
    syntax: "<'margin-left'>",
    media: "visual",
    inherited: false,
    animationType: "length",
    percentages: "dependsOnLayoutModel",
    groups: ["CSS Logical Properties"],
    initial: "0",
    appliesto: "sameAsMargin",
    computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
    order: "uniqueOrder",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-block-start",
  },
  "margin-bottom": {
    syntax: "<length> | <percentage> | auto",
    media: "visual",
    inherited: false,
    animationType: "length",
    percentages: "referToWidthOfContainingBlock",
    groups: ["CSS Box Model"],
    initial: "0",
    appliesto: "allElementsExceptTableDisplayTypes",
    computed: "percentageAsSpecifiedOrAbsoluteLength",
    order: "uniqueOrder",
    alsoAppliesTo: ["::first-letter", "::first-line"],
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-bottom",
  },
  "margin-inline": {
    syntax: "<'margin-left'>{1,2}",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "dependsOnLayoutModel",
    groups: ["CSS Logical Properties"],
    initial: "0",
    appliesto: "sameAsMargin",
    computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
    order: "uniqueOrder",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-inline",
  },
  "margin-inline-end": {
    syntax: "<'margin-left'>",
    media: "visual",
    inherited: false,
    animationType: "length",
    percentages: "dependsOnLayoutModel",
    groups: ["CSS Logical Properties"],
    initial: "0",
    appliesto: "sameAsMargin",
    computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
    order: "uniqueOrder",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-inline-end",
  },
  "margin-inline-start": {
    syntax: "<'margin-left'>",
    media: "visual",
    inherited: false,
    animationType: "length",
    percentages: "dependsOnLayoutModel",
    groups: ["CSS Logical Properties"],
    initial: "0",
    appliesto: "sameAsMargin",
    computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
    order: "uniqueOrder",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-inline-start",
  },
  "margin-left": {
    syntax: "<length> | <percentage> | auto",
    media: "visual",
    inherited: false,
    animationType: "length",
    percentages: "referToWidthOfContainingBlock",
    groups: ["CSS Box Model"],
    initial: "0",
    appliesto: "allElementsExceptTableDisplayTypes",
    computed: "percentageAsSpecifiedOrAbsoluteLength",
    order: "uniqueOrder",
    alsoAppliesTo: ["::first-letter", "::first-line"],
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-left",
  },
  "margin-right": {
    syntax: "<length> | <percentage> | auto",
    media: "visual",
    inherited: false,
    animationType: "length",
    percentages: "referToWidthOfContainingBlock",
    groups: ["CSS Box Model"],
    initial: "0",
    appliesto: "allElementsExceptTableDisplayTypes",
    computed: "percentageAsSpecifiedOrAbsoluteLength",
    order: "uniqueOrder",
    alsoAppliesTo: ["::first-letter", "::first-line"],
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-right",
  },
  "margin-top": {
    syntax: "<length> | <percentage> | auto",
    media: "visual",
    inherited: false,
    animationType: "length",
    percentages: "referToWidthOfContainingBlock",
    groups: ["CSS Box Model"],
    initial: "0",
    appliesto: "allElementsExceptTableDisplayTypes",
    computed: "percentageAsSpecifiedOrAbsoluteLength",
    order: "uniqueOrder",
    alsoAppliesTo: ["::first-letter", "::first-line"],
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-top",
  },
  "margin-trim": {
    syntax: "none | in-flow | all",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Box Model"],
    initial: "none",
    appliesto: "blockContainersAndMultiColumnContainers",
    computed: "asSpecified",
    order: "perGrammar",
    alsoAppliesTo: ["::first-letter", "::first-line"],
    status: "experimental",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-trim",
  },
  mask: mask,
  "mask-border": {
    syntax:
      "<'mask-border-source'> || <'mask-border-slice'> [ / <'mask-border-width'>? [ / <'mask-border-outset'> ]? ]? || <'mask-border-repeat'> || <'mask-border-mode'>",
    media: "visual",
    inherited: false,
    animationType: [
      "mask-border-mode",
      "mask-border-outset",
      "mask-border-repeat",
      "mask-border-slice",
      "mask-border-source",
      "mask-border-width",
    ],
    percentages: ["mask-border-slice", "mask-border-width"],
    groups: ["CSS Masking"],
    initial: [
      "mask-border-mode",
      "mask-border-outset",
      "mask-border-repeat",
      "mask-border-slice",
      "mask-border-source",
      "mask-border-width",
    ],
    appliesto: "allElementsSVGContainerElements",
    computed: [
      "mask-border-mode",
      "mask-border-outset",
      "mask-border-repeat",
      "mask-border-slice",
      "mask-border-source",
      "mask-border-width",
    ],
    order: "perGrammar",
    stacking: true,
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border",
  },
  "mask-border-mode": {
    syntax: "luminance | alpha",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Masking"],
    initial: "alpha",
    appliesto: "allElementsSVGContainerElements",
    computed: "asSpecified",
    order: "perGrammar",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-mode",
  },
  "mask-border-outset": {
    syntax: "[ <length> | <number> ]{1,4}",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Masking"],
    initial: "0",
    appliesto: "allElementsSVGContainerElements",
    computed: "asSpecifiedRelativeToAbsoluteLengths",
    order: "perGrammar",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-outset",
  },
  "mask-border-repeat": {
    syntax: "[ stretch | repeat | round | space ]{1,2}",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Masking"],
    initial: "stretch",
    appliesto: "allElementsSVGContainerElements",
    computed: "asSpecified",
    order: "perGrammar",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-repeat",
  },
  "mask-border-slice": {
    syntax: "<number-percentage>{1,4} fill?",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "referToSizeOfMaskBorderImage",
    groups: ["CSS Masking"],
    initial: "0",
    appliesto: "allElementsSVGContainerElements",
    computed: "asSpecified",
    order: "perGrammar",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-slice",
  },
  "mask-border-source": {
    syntax: "none | <image>",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Masking"],
    initial: "none",
    appliesto: "allElementsSVGContainerElements",
    computed: "asSpecifiedURLsAbsolute",
    order: "perGrammar",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-source",
  },
  "mask-border-width": {
    syntax: "[ <length-percentage> | <number> | auto ]{1,4}",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "relativeToMaskBorderImageArea",
    groups: ["CSS Masking"],
    initial: "auto",
    appliesto: "allElementsSVGContainerElements",
    computed: "asSpecifiedRelativeToAbsoluteLengths",
    order: "perGrammar",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-width",
  },
  "mask-clip": {
    syntax: "[ <geometry-box> | no-clip ]#",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Masking"],
    initial: "border-box",
    appliesto: "allElementsSVGContainerElements",
    computed: "asSpecified",
    order: "perGrammar",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-clip",
  },
  "mask-composite": {
    syntax: "<compositing-operator>#",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Masking"],
    initial: "add",
    appliesto: "allElementsSVGContainerElements",
    computed: "asSpecified",
    order: "perGrammar",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-composite",
  },
  "mask-image": {
    syntax: "<mask-reference>#",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Masking"],
    initial: "none",
    appliesto: "allElementsSVGContainerElements",
    computed: "asSpecifiedURLsAbsolute",
    order: "perGrammar",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-image",
  },
  "mask-mode": {
    syntax: "<masking-mode>#",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Masking"],
    initial: "match-source",
    appliesto: "allElementsSVGContainerElements",
    computed: "asSpecified",
    order: "perGrammar",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-mode",
  },
  "mask-origin": {
    syntax: "<geometry-box>#",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Masking"],
    initial: "border-box",
    appliesto: "allElementsSVGContainerElements",
    computed: "asSpecified",
    order: "perGrammar",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-origin",
  },
  "mask-position": {
    syntax: "<position>#",
    media: "visual",
    inherited: false,
    animationType: "repeatableListOfSimpleListOfLpc",
    percentages: "referToSizeOfMaskPaintingArea",
    groups: ["CSS Masking"],
    initial: "center",
    appliesto: "allElementsSVGContainerElements",
    computed: "consistsOfTwoKeywordsForOriginAndOffsets",
    order: "perGrammar",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-position",
  },
  "mask-repeat": {
    syntax: "<repeat-style>#",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Masking"],
    initial: "no-repeat",
    appliesto: "allElementsSVGContainerElements",
    computed: "consistsOfTwoDimensionKeywords",
    order: "perGrammar",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-repeat",
  },
  "mask-size": {
    syntax: "<bg-size>#",
    media: "visual",
    inherited: false,
    animationType: "repeatableListOfSimpleListOfLpc",
    percentages: "no",
    groups: ["CSS Masking"],
    initial: "auto",
    appliesto: "allElementsSVGContainerElements",
    computed: "asSpecifiedRelativeToAbsoluteLengths",
    order: "perGrammar",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-size",
  },
  "mask-type": {
    syntax: "luminance | alpha",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Masking"],
    initial: "luminance",
    appliesto: "maskElements",
    computed: "asSpecified",
    order: "perGrammar",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-type",
  },
  "masonry-auto-flow": {
    syntax: "[ pack | next ] || [ definite-first | ordered ]",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Grid Layout"],
    initial: "pack",
    appliesto: "gridContainersWithMasonryLayout",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "experimental",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/masonry-auto-flow",
  },
  "math-style": {
    syntax: "normal | compact",
    media: "visual",
    inherited: true,
    animationType: "notAnimatable",
    percentages: "no",
    groups: ["MathML"],
    initial: "normal",
    appliesto: "allElements",
    computed: "asSpecified",
    order: "perGrammar",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/math-style",
  },
  "max-block-size": {
    syntax: "<'max-width'>",
    media: "visual",
    inherited: false,
    animationType: "lpc",
    percentages: "blockSizeOfContainingBlock",
    groups: ["CSS Logical Properties"],
    initial: "none",
    appliesto: "sameAsWidthAndHeight",
    computed: "sameAsMaxWidthAndMaxHeight",
    order: "uniqueOrder",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/max-block-size",
  },
  "max-height": {
    syntax:
      "none | <length-percentage> | min-content | max-content | fit-content | fit-content(<length-percentage>)",
    media: "visual",
    inherited: false,
    animationType: "lpc",
    percentages: "regardingHeightOfGeneratedBoxContainingBlockPercentagesNone",
    groups: ["CSS Box Model"],
    initial: "none",
    appliesto: "allElementsButNonReplacedAndTableColumns",
    computed: "percentageAsSpecifiedAbsoluteLengthOrNone",
    order: "uniqueOrder",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/max-height",
  },
  "max-inline-size": {
    syntax: "<'max-width'>",
    media: "visual",
    inherited: false,
    animationType: "lpc",
    percentages: "inlineSizeOfContainingBlock",
    groups: ["CSS Logical Properties"],
    initial: "none",
    appliesto: "sameAsWidthAndHeight",
    computed: "sameAsMaxWidthAndMaxHeight",
    order: "uniqueOrder",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/max-inline-size",
  },
  "max-lines": {
    syntax: "none | <integer>",
    media: "visual",
    inherited: false,
    animationType: "integer",
    percentages: "no",
    groups: ["CSS Overflow"],
    initial: "none",
    appliesto: "blockContainersExceptMultiColumnContainers",
    computed: "asSpecified",
    order: "perGrammar",
    status: "experimental",
  },
  "max-width": {
    syntax:
      "none | <length-percentage> | min-content | max-content | fit-content | fit-content(<length-percentage>)",
    media: "visual",
    inherited: false,
    animationType: "lpc",
    percentages: "referToWidthOfContainingBlock",
    groups: ["CSS Box Model"],
    initial: "none",
    appliesto: "allElementsButNonReplacedAndTableRows",
    computed: "percentageAsSpecifiedAbsoluteLengthOrNone",
    order: "uniqueOrder",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/max-width",
  },
  "min-block-size": {
    syntax: "<'min-width'>",
    media: "visual",
    inherited: false,
    animationType: "lpc",
    percentages: "blockSizeOfContainingBlock",
    groups: ["CSS Logical Properties"],
    initial: "0",
    appliesto: "sameAsWidthAndHeight",
    computed: "sameAsMinWidthAndMinHeight",
    order: "uniqueOrder",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/min-block-size",
  },
  "min-height": {
    syntax:
      "auto | <length> | <percentage> | min-content | max-content | fit-content | fit-content(<length-percentage>)",
    media: "visual",
    inherited: false,
    animationType: "lpc",
    percentages: "regardingHeightOfGeneratedBoxContainingBlockPercentages0",
    groups: ["CSS Box Model"],
    initial: "auto",
    appliesto: "allElementsButNonReplacedAndTableColumns",
    computed: "percentageAsSpecifiedOrAbsoluteLength",
    order: "uniqueOrder",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/min-height",
  },
  "min-inline-size": {
    syntax: "<'min-width'>",
    media: "visual",
    inherited: false,
    animationType: "lpc",
    percentages: "inlineSizeOfContainingBlock",
    groups: ["CSS Logical Properties"],
    initial: "0",
    appliesto: "sameAsWidthAndHeight",
    computed: "sameAsMinWidthAndMinHeight",
    order: "uniqueOrder",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/min-inline-size",
  },
  "min-width": {
    syntax:
      "auto | <length> | <percentage> | min-content | max-content | fit-content | fit-content(<length-percentage>)",
    media: "visual",
    inherited: false,
    animationType: "lpc",
    percentages: "referToWidthOfContainingBlock",
    groups: ["CSS Box Model"],
    initial: "auto",
    appliesto: "allElementsButNonReplacedAndTableRows",
    computed: "percentageAsSpecifiedOrAbsoluteLength",
    order: "uniqueOrder",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/min-width",
  },
  "mix-blend-mode": {
    syntax: "<blend-mode> | plus-lighter",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["Compositing and Blending"],
    initial: "normal",
    appliesto: "allElements",
    computed: "asSpecified",
    order: "uniqueOrder",
    stacking: true,
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mix-blend-mode",
  },
  "object-fit": {
    syntax: "fill | contain | cover | none | scale-down",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Images"],
    initial: "fill",
    appliesto: "replacedElements",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/object-fit",
  },
  "object-position": {
    syntax: "<position>",
    media: "visual",
    inherited: true,
    animationType: "repeatableListOfSimpleListOfLpc",
    percentages: "referToWidthAndHeightOfElement",
    groups: ["CSS Images"],
    initial: "50% 50%",
    appliesto: "replacedElements",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/object-position",
  },
  offset: offset,
  "offset-anchor": {
    syntax: "auto | <position>",
    media: "visual",
    inherited: false,
    animationType: "position",
    percentages: "relativeToWidthAndHeight",
    groups: ["CSS Motion Path"],
    initial: "auto",
    appliesto: "transformableElements",
    computed: "forLengthAbsoluteValueOtherwisePercentage",
    order: "perGrammar",
    status: "standard",
  },
  "offset-distance": {
    syntax: "<length-percentage>",
    media: "visual",
    inherited: false,
    animationType: "lpc",
    percentages: "referToTotalPathLength",
    groups: ["CSS Motion Path"],
    initial: "0",
    appliesto: "transformableElements",
    computed: "forLengthAbsoluteValueOtherwisePercentage",
    order: "perGrammar",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/offset-distance",
  },
  "offset-path": {
    syntax:
      "none | ray( [ <angle> && <size> && contain? ] ) | <path()> | <url> | [ <basic-shape> || <geometry-box> ]",
    media: "visual",
    inherited: false,
    animationType: "angleOrBasicShapeOrPath",
    percentages: "no",
    groups: ["CSS Motion Path"],
    initial: "none",
    appliesto: "transformableElements",
    computed: "asSpecified",
    order: "perGrammar",
    stacking: true,
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/offset-path",
  },
  "offset-position": {
    syntax: "auto | <position>",
    media: "visual",
    inherited: false,
    animationType: "position",
    percentages: "referToSizeOfContainingBlock",
    groups: ["CSS Motion Path"],
    initial: "auto",
    appliesto: "transformableElements",
    computed: "forLengthAbsoluteValueOtherwisePercentage",
    order: "perGrammar",
    status: "experimental",
  },
  "offset-rotate": {
    syntax: "[ auto | reverse ] || <angle>",
    media: "visual",
    inherited: false,
    animationType: "angleOrBasicShapeOrPath",
    percentages: "no",
    groups: ["CSS Motion Path"],
    initial: "auto",
    appliesto: "transformableElements",
    computed: "asSpecified",
    order: "perGrammar",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/offset-rotate",
  },
  opacity: opacity,
  order: order,
  orphans: orphans,
  outline: outline,
  "outline-color": {
    syntax: "<color> | invert",
    media: ["visual", "interactive"],
    inherited: false,
    animationType: "color",
    percentages: "no",
    groups: ["CSS Basic User Interface"],
    initial: "invertOrCurrentColor",
    appliesto: "allElements",
    computed: "invertForTranslucentColorRGBAOtherwiseRGB",
    order: "uniqueOrder",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline-color",
  },
  "outline-offset": {
    syntax: "<length>",
    media: ["visual", "interactive"],
    inherited: false,
    animationType: "length",
    percentages: "no",
    groups: ["CSS Basic User Interface"],
    initial: "0",
    appliesto: "allElements",
    computed: "asSpecifiedRelativeToAbsoluteLengths",
    order: "uniqueOrder",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline-offset",
  },
  "outline-style": {
    syntax: "auto | <'border-style'>",
    media: ["visual", "interactive"],
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Basic User Interface"],
    initial: "none",
    appliesto: "allElements",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline-style",
  },
  "outline-width": {
    syntax: "<line-width>",
    media: ["visual", "interactive"],
    inherited: false,
    animationType: "length",
    percentages: "no",
    groups: ["CSS Basic User Interface"],
    initial: "medium",
    appliesto: "allElements",
    computed: "absoluteLength0ForNone",
    order: "uniqueOrder",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline-width",
  },
  overflow: overflow,
  "overflow-anchor": {
    syntax: "auto | none",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Scroll Anchoring"],
    initial: "auto",
    appliesto: "allElements",
    computed: "asSpecified",
    order: "perGrammar",
    status: "standard",
  },
  "overflow-block": {
    syntax: "visible | hidden | clip | scroll | auto",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Overflow"],
    initial: "auto",
    appliesto: "blockContainersFlexContainersGridContainers",
    computed:
      "asSpecifiedButVisibleOrClipReplacedToAutoOrHiddenIfOtherValueDifferent",
    order: "perGrammar",
    status: "standard",
  },
  "overflow-clip-box": {
    syntax: "padding-box | content-box",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["Mozilla Extensions"],
    initial: "padding-box",
    appliesto: "allElements",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "nonstandard",
    mdn_url: "https://developer.mozilla.org/docs/Mozilla/CSS/overflow-clip-box",
  },
  "overflow-clip-margin": {
    syntax: "<visual-box> || <length [0,]>",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Overflow"],
    initial: "0px",
    appliesto: "allElements",
    computed: "theComputedLength",
    order: "perGrammar",
    status: "standard",
  },
  "overflow-inline": {
    syntax: "visible | hidden | clip | scroll | auto",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Overflow"],
    initial: "auto",
    appliesto: "blockContainersFlexContainersGridContainers",
    computed:
      "asSpecifiedButVisibleOrClipReplacedToAutoOrHiddenIfOtherValueDifferent",
    order: "perGrammar",
    status: "standard",
  },
  "overflow-wrap": {
    syntax: "normal | break-word | anywhere",
    media: "visual",
    inherited: true,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Text"],
    initial: "normal",
    appliesto: "nonReplacedInlineElements",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow-wrap",
  },
  "overflow-x": {
    syntax: "visible | hidden | clip | scroll | auto",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Overflow"],
    initial: "visible",
    appliesto: "blockContainersFlexContainersGridContainers",
    computed:
      "asSpecifiedButVisibleOrClipReplacedToAutoOrHiddenIfOtherValueDifferent",
    order: "uniqueOrder",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow-x",
  },
  "overflow-y": {
    syntax: "visible | hidden | clip | scroll | auto",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Overflow"],
    initial: "visible",
    appliesto: "blockContainersFlexContainersGridContainers",
    computed:
      "asSpecifiedButVisibleOrClipReplacedToAutoOrHiddenIfOtherValueDifferent",
    order: "uniqueOrder",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow-y",
  },
  "overscroll-behavior": {
    syntax: "[ contain | none | auto ]{1,2}",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Box Model"],
    initial: "auto",
    appliesto: "nonReplacedBlockAndInlineBlockElements",
    computed: ["overscroll-behavior-x", "overscroll-behavior-y"],
    order: "uniqueOrder",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overscroll-behavior",
  },
  "overscroll-behavior-block": {
    syntax: "contain | none | auto",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Box Model"],
    initial: "auto",
    appliesto: "nonReplacedBlockAndInlineBlockElements",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "standard",
    mdn_url:
      "https://developer.mozilla.org/docs/Web/CSS/overscroll-behavior-block",
  },
  "overscroll-behavior-inline": {
    syntax: "contain | none | auto",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Box Model"],
    initial: "auto",
    appliesto: "nonReplacedBlockAndInlineBlockElements",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "standard",
    mdn_url:
      "https://developer.mozilla.org/docs/Web/CSS/overscroll-behavior-inline",
  },
  "overscroll-behavior-x": {
    syntax: "contain | none | auto",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Box Model"],
    initial: "auto",
    appliesto: "nonReplacedBlockAndInlineBlockElements",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overscroll-behavior-x",
  },
  "overscroll-behavior-y": {
    syntax: "contain | none | auto",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Box Model"],
    initial: "auto",
    appliesto: "nonReplacedBlockAndInlineBlockElements",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overscroll-behavior-y",
  },
  padding: padding,
  "padding-block": {
    syntax: "<'padding-left'>{1,2}",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "logicalWidthOfContainingBlock",
    groups: ["CSS Logical Properties"],
    initial: "0",
    appliesto: "allElements",
    computed: "asLength",
    order: "uniqueOrder",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-block",
  },
  "padding-block-end": {
    syntax: "<'padding-left'>",
    media: "visual",
    inherited: false,
    animationType: "length",
    percentages: "logicalWidthOfContainingBlock",
    groups: ["CSS Logical Properties"],
    initial: "0",
    appliesto: "allElements",
    computed: "asLength",
    order: "uniqueOrder",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-block-end",
  },
  "padding-block-start": {
    syntax: "<'padding-left'>",
    media: "visual",
    inherited: false,
    animationType: "length",
    percentages: "logicalWidthOfContainingBlock",
    groups: ["CSS Logical Properties"],
    initial: "0",
    appliesto: "allElements",
    computed: "asLength",
    order: "uniqueOrder",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-block-start",
  },
  "padding-bottom": {
    syntax: "<length> | <percentage>",
    media: "visual",
    inherited: false,
    animationType: "length",
    percentages: "referToWidthOfContainingBlock",
    groups: ["CSS Box Model"],
    initial: "0",
    appliesto: "allElementsExceptInternalTableDisplayTypes",
    computed: "percentageAsSpecifiedOrAbsoluteLength",
    order: "uniqueOrder",
    alsoAppliesTo: ["::first-letter", "::first-line"],
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-bottom",
  },
  "padding-inline": {
    syntax: "<'padding-left'>{1,2}",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "logicalWidthOfContainingBlock",
    groups: ["CSS Logical Properties"],
    initial: "0",
    appliesto: "allElements",
    computed: "asLength",
    order: "uniqueOrder",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-inline",
  },
  "padding-inline-end": {
    syntax: "<'padding-left'>",
    media: "visual",
    inherited: false,
    animationType: "length",
    percentages: "logicalWidthOfContainingBlock",
    groups: ["CSS Logical Properties"],
    initial: "0",
    appliesto: "allElements",
    computed: "asLength",
    order: "uniqueOrder",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-inline-end",
  },
  "padding-inline-start": {
    syntax: "<'padding-left'>",
    media: "visual",
    inherited: false,
    animationType: "length",
    percentages: "logicalWidthOfContainingBlock",
    groups: ["CSS Logical Properties"],
    initial: "0",
    appliesto: "allElements",
    computed: "asLength",
    order: "uniqueOrder",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-inline-start",
  },
  "padding-left": {
    syntax: "<length> | <percentage>",
    media: "visual",
    inherited: false,
    animationType: "length",
    percentages: "referToWidthOfContainingBlock",
    groups: ["CSS Box Model"],
    initial: "0",
    appliesto: "allElementsExceptInternalTableDisplayTypes",
    computed: "percentageAsSpecifiedOrAbsoluteLength",
    order: "uniqueOrder",
    alsoAppliesTo: ["::first-letter", "::first-line"],
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-left",
  },
  "padding-right": {
    syntax: "<length> | <percentage>",
    media: "visual",
    inherited: false,
    animationType: "length",
    percentages: "referToWidthOfContainingBlock",
    groups: ["CSS Box Model"],
    initial: "0",
    appliesto: "allElementsExceptInternalTableDisplayTypes",
    computed: "percentageAsSpecifiedOrAbsoluteLength",
    order: "uniqueOrder",
    alsoAppliesTo: ["::first-letter", "::first-line"],
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-right",
  },
  "padding-top": {
    syntax: "<length> | <percentage>",
    media: "visual",
    inherited: false,
    animationType: "length",
    percentages: "referToWidthOfContainingBlock",
    groups: ["CSS Box Model"],
    initial: "0",
    appliesto: "allElementsExceptInternalTableDisplayTypes",
    computed: "percentageAsSpecifiedOrAbsoluteLength",
    order: "uniqueOrder",
    alsoAppliesTo: ["::first-letter", "::first-line"],
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-top",
  },
  "page-break-after": {
    syntax: "auto | always | avoid | left | right | recto | verso",
    media: ["visual", "paged"],
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Pages"],
    initial: "auto",
    appliesto: "blockElementsInNormalFlow",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/page-break-after",
  },
  "page-break-before": {
    syntax: "auto | always | avoid | left | right | recto | verso",
    media: ["visual", "paged"],
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Pages"],
    initial: "auto",
    appliesto: "blockElementsInNormalFlow",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/page-break-before",
  },
  "page-break-inside": {
    syntax: "auto | avoid",
    media: ["visual", "paged"],
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Pages"],
    initial: "auto",
    appliesto: "blockElementsInNormalFlow",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/page-break-inside",
  },
  "paint-order": {
    syntax: "normal | [ fill || stroke || markers ]",
    media: "visual",
    inherited: true,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Text"],
    initial: "normal",
    appliesto: "textElements",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/paint-order",
  },
  perspective: perspective,
  "perspective-origin": {
    syntax: "<position>",
    media: "visual",
    inherited: false,
    animationType: "simpleListOfLpc",
    percentages: "referToSizeOfBoundingBox",
    groups: ["CSS Transforms"],
    initial: "50% 50%",
    appliesto: "transformableElements",
    computed: "forLengthAbsoluteValueOtherwisePercentage",
    order: "oneOrTwoValuesLengthAbsoluteKeywordsPercentages",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/perspective-origin",
  },
  "place-content": {
    syntax: "<'align-content'> <'justify-content'>?",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Box Alignment"],
    initial: "normal",
    appliesto: "multilineFlexContainers",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/place-content",
  },
  "place-items": {
    syntax: "<'align-items'> <'justify-items'>?",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Box Alignment"],
    initial: ["align-items", "justify-items"],
    appliesto: "allElements",
    computed: ["align-items", "justify-items"],
    order: "uniqueOrder",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/place-items",
  },
  "place-self": {
    syntax: "<'align-self'> <'justify-self'>?",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Box Alignment"],
    initial: ["align-self", "justify-self"],
    appliesto: "blockLevelBoxesAndAbsolutelyPositionedBoxesAndGridItems",
    computed: ["align-self", "justify-self"],
    order: "uniqueOrder",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/place-self",
  },
  "pointer-events": {
    syntax:
      "auto | none | visiblePainted | visibleFill | visibleStroke | visible | painted | fill | stroke | all | inherit",
    media: "visual",
    inherited: true,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Basic User Interface"],
    initial: "auto",
    appliesto: "allElements",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/pointer-events",
  },
  position: position$1,
  quotes: quotes,
  resize: resize,
  right: right,
  rotate: rotate,
  "row-gap": {
    syntax: "normal | <length-percentage>",
    media: "visual",
    inherited: false,
    animationType: "lpc",
    percentages: "referToDimensionOfContentArea",
    groups: ["CSS Box Alignment"],
    initial: "normal",
    appliesto: "multiColumnElementsFlexContainersGridContainers",
    computed:
      "asSpecifiedWithLengthsAbsoluteAndNormalComputingToZeroExceptMultiColumn",
    order: "perGrammar",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/row-gap",
  },
  "ruby-align": {
    syntax: "start | center | space-between | space-around",
    media: "visual",
    inherited: true,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Ruby"],
    initial: "space-around",
    appliesto: "rubyBasesAnnotationsBaseAnnotationContainers",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "experimental",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/ruby-align",
  },
  "ruby-merge": {
    syntax: "separate | collapse | auto",
    media: "visual",
    inherited: true,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Ruby"],
    initial: "separate",
    appliesto: "rubyAnnotationsContainers",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "experimental",
  },
  "ruby-position": {
    syntax: "[ alternate || [ over | under ] ] | inter-character",
    media: "visual",
    inherited: true,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Ruby"],
    initial: "alternate",
    appliesto: "rubyAnnotationsContainers",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "experimental",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/ruby-position",
  },
  scale: scale,
  "scrollbar-color": {
    syntax: "auto | <color>{2}",
    media: "visual",
    inherited: true,
    animationType: "color",
    percentages: "no",
    groups: ["CSS Scrollbars"],
    initial: "auto",
    appliesto: "scrollingBoxes",
    computed: "asSpecified",
    order: "perGrammar",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scrollbar-color",
  },
  "scrollbar-gutter": {
    syntax: "auto | stable && both-edges?",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Overflow"],
    initial: "auto",
    appliesto: "scrollingBoxes",
    computed: "asSpecified",
    order: "perGrammar",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scrollbar-gutter",
  },
  "scrollbar-width": {
    syntax: "auto | thin | none",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Scrollbars"],
    initial: "auto",
    appliesto: "scrollingBoxes",
    computed: "asSpecified",
    order: "perGrammar",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scrollbar-width",
  },
  "scroll-behavior": {
    syntax: "auto | smooth",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSSOM View"],
    initial: "auto",
    appliesto: "scrollingBoxes",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-behavior",
  },
  "scroll-margin": {
    syntax: "<length>{1,4}",
    media: "visual",
    inherited: false,
    animationType: "byComputedValueType",
    percentages: "no",
    groups: ["CSS Scroll Snap"],
    initial: "0",
    appliesto: "allElements",
    computed: "asSpecified",
    order: "perGrammar",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin",
  },
  "scroll-margin-block": {
    syntax: "<length>{1,2}",
    media: "visual",
    inherited: false,
    animationType: "byComputedValueType",
    percentages: "no",
    groups: ["CSS Scroll Snap"],
    initial: "0",
    appliesto: "allElements",
    computed: "asSpecified",
    order: "perGrammar",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-block",
  },
  "scroll-margin-block-start": {
    syntax: "<length>",
    media: "visual",
    inherited: false,
    animationType: "byComputedValueType",
    percentages: "no",
    groups: ["CSS Scroll Snap"],
    initial: "0",
    appliesto: "allElements",
    computed: "asSpecified",
    order: "perGrammar",
    status: "standard",
    mdn_url:
      "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-block-start",
  },
  "scroll-margin-block-end": {
    syntax: "<length>",
    media: "visual",
    inherited: false,
    animationType: "byComputedValueType",
    percentages: "no",
    groups: ["CSS Scroll Snap"],
    initial: "0",
    appliesto: "allElements",
    computed: "asSpecified",
    order: "perGrammar",
    status: "standard",
    mdn_url:
      "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-block-end",
  },
  "scroll-margin-bottom": {
    syntax: "<length>",
    media: "visual",
    inherited: false,
    animationType: "byComputedValueType",
    percentages: "no",
    groups: ["CSS Scroll Snap"],
    initial: "0",
    appliesto: "allElements",
    computed: "asSpecified",
    order: "perGrammar",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-bottom",
  },
  "scroll-margin-inline": {
    syntax: "<length>{1,2}",
    media: "visual",
    inherited: false,
    animationType: "byComputedValueType",
    percentages: "no",
    groups: ["CSS Scroll Snap"],
    initial: "0",
    appliesto: "allElements",
    computed: "asSpecified",
    order: "perGrammar",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-inline",
  },
  "scroll-margin-inline-start": {
    syntax: "<length>",
    media: "visual",
    inherited: false,
    animationType: "byComputedValueType",
    percentages: "no",
    groups: ["CSS Scroll Snap"],
    initial: "0",
    appliesto: "allElements",
    computed: "asSpecified",
    order: "perGrammar",
    status: "standard",
    mdn_url:
      "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-inline-start",
  },
  "scroll-margin-inline-end": {
    syntax: "<length>",
    media: "visual",
    inherited: false,
    animationType: "byComputedValueType",
    percentages: "no",
    groups: ["CSS Scroll Snap"],
    initial: "0",
    appliesto: "allElements",
    computed: "asSpecified",
    order: "perGrammar",
    status: "standard",
    mdn_url:
      "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-inline-end",
  },
  "scroll-margin-left": {
    syntax: "<length>",
    media: "visual",
    inherited: false,
    animationType: "byComputedValueType",
    percentages: "no",
    groups: ["CSS Scroll Snap"],
    initial: "0",
    appliesto: "allElements",
    computed: "asSpecified",
    order: "perGrammar",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-left",
  },
  "scroll-margin-right": {
    syntax: "<length>",
    media: "visual",
    inherited: false,
    animationType: "byComputedValueType",
    percentages: "no",
    groups: ["CSS Scroll Snap"],
    initial: "0",
    appliesto: "allElements",
    computed: "asSpecified",
    order: "perGrammar",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-right",
  },
  "scroll-margin-top": {
    syntax: "<length>",
    media: "visual",
    inherited: false,
    animationType: "byComputedValueType",
    percentages: "no",
    groups: ["CSS Scroll Snap"],
    initial: "0",
    appliesto: "allElements",
    computed: "asSpecified",
    order: "perGrammar",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-top",
  },
  "scroll-padding": {
    syntax: "[ auto | <length-percentage> ]{1,4}",
    media: "visual",
    inherited: false,
    animationType: "byComputedValueType",
    percentages: "relativeToTheScrollContainersScrollport",
    groups: ["CSS Scroll Snap"],
    initial: "auto",
    appliesto: "scrollContainers",
    computed: "asSpecified",
    order: "perGrammar",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding",
  },
  "scroll-padding-block": {
    syntax: "[ auto | <length-percentage> ]{1,2}",
    media: "visual",
    inherited: false,
    animationType: "byComputedValueType",
    percentages: "relativeToTheScrollContainersScrollport",
    groups: ["CSS Scroll Snap"],
    initial: "auto",
    appliesto: "scrollContainers",
    computed: "asSpecified",
    order: "perGrammar",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-block",
  },
  "scroll-padding-block-start": {
    syntax: "auto | <length-percentage>",
    media: "visual",
    inherited: false,
    animationType: "byComputedValueType",
    percentages: "relativeToTheScrollContainersScrollport",
    groups: ["CSS Scroll Snap"],
    initial: "auto",
    appliesto: "scrollContainers",
    computed: "asSpecified",
    order: "perGrammar",
    status: "standard",
    mdn_url:
      "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-block-start",
  },
  "scroll-padding-block-end": {
    syntax: "auto | <length-percentage>",
    media: "visual",
    inherited: false,
    animationType: "byComputedValueType",
    percentages: "relativeToTheScrollContainersScrollport",
    groups: ["CSS Scroll Snap"],
    initial: "auto",
    appliesto: "scrollContainers",
    computed: "asSpecified",
    order: "perGrammar",
    status: "standard",
    mdn_url:
      "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-block-end",
  },
  "scroll-padding-bottom": {
    syntax: "auto | <length-percentage>",
    media: "visual",
    inherited: false,
    animationType: "byComputedValueType",
    percentages: "relativeToTheScrollContainersScrollport",
    groups: ["CSS Scroll Snap"],
    initial: "auto",
    appliesto: "scrollContainers",
    computed: "asSpecified",
    order: "perGrammar",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-bottom",
  },
  "scroll-padding-inline": {
    syntax: "[ auto | <length-percentage> ]{1,2}",
    media: "visual",
    inherited: false,
    animationType: "byComputedValueType",
    percentages: "relativeToTheScrollContainersScrollport",
    groups: ["CSS Scroll Snap"],
    initial: "auto",
    appliesto: "scrollContainers",
    computed: "asSpecified",
    order: "perGrammar",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-inline",
  },
  "scroll-padding-inline-start": {
    syntax: "auto | <length-percentage>",
    media: "visual",
    inherited: false,
    animationType: "byComputedValueType",
    percentages: "relativeToTheScrollContainersScrollport",
    groups: ["CSS Scroll Snap"],
    initial: "auto",
    appliesto: "scrollContainers",
    computed: "asSpecified",
    order: "perGrammar",
    status: "standard",
    mdn_url:
      "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-inline-start",
  },
  "scroll-padding-inline-end": {
    syntax: "auto | <length-percentage>",
    media: "visual",
    inherited: false,
    animationType: "byComputedValueType",
    percentages: "relativeToTheScrollContainersScrollport",
    groups: ["CSS Scroll Snap"],
    initial: "auto",
    appliesto: "scrollContainers",
    computed: "asSpecified",
    order: "perGrammar",
    status: "standard",
    mdn_url:
      "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-inline-end",
  },
  "scroll-padding-left": {
    syntax: "auto | <length-percentage>",
    media: "visual",
    inherited: false,
    animationType: "byComputedValueType",
    percentages: "relativeToTheScrollContainersScrollport",
    groups: ["CSS Scroll Snap"],
    initial: "auto",
    appliesto: "scrollContainers",
    computed: "asSpecified",
    order: "perGrammar",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-left",
  },
  "scroll-padding-right": {
    syntax: "auto | <length-percentage>",
    media: "visual",
    inherited: false,
    animationType: "byComputedValueType",
    percentages: "relativeToTheScrollContainersScrollport",
    groups: ["CSS Scroll Snap"],
    initial: "auto",
    appliesto: "scrollContainers",
    computed: "asSpecified",
    order: "perGrammar",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-right",
  },
  "scroll-padding-top": {
    syntax: "auto | <length-percentage>",
    media: "visual",
    inherited: false,
    animationType: "byComputedValueType",
    percentages: "relativeToTheScrollContainersScrollport",
    groups: ["CSS Scroll Snap"],
    initial: "auto",
    appliesto: "scrollContainers",
    computed: "asSpecified",
    order: "perGrammar",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-top",
  },
  "scroll-snap-align": {
    syntax: "[ none | start | end | center ]{1,2}",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Scroll Snap"],
    initial: "none",
    appliesto: "allElements",
    computed: "asSpecified",
    order: "perGrammar",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-align",
  },
  "scroll-snap-coordinate": {
    syntax: "none | <position>#",
    media: "interactive",
    inherited: false,
    animationType: "position",
    percentages: "referToBorderBox",
    groups: ["CSS Scroll Snap"],
    initial: "none",
    appliesto: "allElements",
    computed: "asSpecifiedRelativeToAbsoluteLengths",
    order: "uniqueOrder",
    status: "obsolete",
    mdn_url:
      "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-coordinate",
  },
  "scroll-snap-destination": {
    syntax: "<position>",
    media: "interactive",
    inherited: false,
    animationType: "position",
    percentages: "relativeToScrollContainerPaddingBoxAxis",
    groups: ["CSS Scroll Snap"],
    initial: "0px 0px",
    appliesto: "scrollContainers",
    computed: "asSpecifiedRelativeToAbsoluteLengths",
    order: "uniqueOrder",
    status: "obsolete",
    mdn_url:
      "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-destination",
  },
  "scroll-snap-points-x": {
    syntax: "none | repeat( <length-percentage> )",
    media: "interactive",
    inherited: false,
    animationType: "discrete",
    percentages: "relativeToScrollContainerPaddingBoxAxis",
    groups: ["CSS Scroll Snap"],
    initial: "none",
    appliesto: "scrollContainers",
    computed: "asSpecifiedRelativeToAbsoluteLengths",
    order: "uniqueOrder",
    status: "obsolete",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-points-x",
  },
  "scroll-snap-points-y": {
    syntax: "none | repeat( <length-percentage> )",
    media: "interactive",
    inherited: false,
    animationType: "discrete",
    percentages: "relativeToScrollContainerPaddingBoxAxis",
    groups: ["CSS Scroll Snap"],
    initial: "none",
    appliesto: "scrollContainers",
    computed: "asSpecifiedRelativeToAbsoluteLengths",
    order: "uniqueOrder",
    status: "obsolete",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-points-y",
  },
  "scroll-snap-stop": {
    syntax: "normal | always",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Scroll Snap"],
    initial: "normal",
    appliesto: "allElements",
    computed: "asSpecified",
    order: "perGrammar",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-stop",
  },
  "scroll-snap-type": {
    syntax:
      "none | [ x | y | block | inline | both ] [ mandatory | proximity ]?",
    media: "interactive",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Scroll Snap"],
    initial: "none",
    appliesto: "allElements",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-type",
  },
  "scroll-snap-type-x": {
    syntax: "none | mandatory | proximity",
    media: "interactive",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Scroll Snap"],
    initial: "none",
    appliesto: "scrollContainers",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "obsolete",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-type-x",
  },
  "scroll-snap-type-y": {
    syntax: "none | mandatory | proximity",
    media: "interactive",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Scroll Snap"],
    initial: "none",
    appliesto: "scrollContainers",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "obsolete",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-type-y",
  },
  "shape-image-threshold": {
    syntax: "<alpha-value>",
    media: "visual",
    inherited: false,
    animationType: "number",
    percentages: "no",
    groups: ["CSS Shapes"],
    initial: "0.0",
    appliesto: "floats",
    computed: "specifiedValueNumberClipped0To1",
    order: "uniqueOrder",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/shape-image-threshold",
  },
  "shape-margin": {
    syntax: "<length-percentage>",
    media: "visual",
    inherited: false,
    animationType: "lpc",
    percentages: "referToWidthOfContainingBlock",
    groups: ["CSS Shapes"],
    initial: "0",
    appliesto: "floats",
    computed: "asSpecifiedRelativeToAbsoluteLengths",
    order: "uniqueOrder",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/shape-margin",
  },
  "shape-outside": {
    syntax: "none | [ <shape-box> || <basic-shape> ] | <image>",
    media: "visual",
    inherited: false,
    animationType: "basicShapeOtherwiseNo",
    percentages: "no",
    groups: ["CSS Shapes"],
    initial: "none",
    appliesto: "floats",
    computed: "asDefinedForBasicShapeWithAbsoluteURIOtherwiseAsSpecified",
    order: "uniqueOrder",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/shape-outside",
  },
  "tab-size": {
    syntax: "<integer> | <length>",
    media: "visual",
    inherited: true,
    animationType: "length",
    percentages: "no",
    groups: ["CSS Text"],
    initial: "8",
    appliesto: "blockContainers",
    computed: "specifiedIntegerOrAbsoluteLength",
    order: "uniqueOrder",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/tab-size",
  },
  "table-layout": {
    syntax: "auto | fixed",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Table"],
    initial: "auto",
    appliesto: "tableElements",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/table-layout",
  },
  "text-align": {
    syntax: "start | end | left | right | center | justify | match-parent",
    media: "visual",
    inherited: true,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Text"],
    initial: "startOrNamelessValueIfLTRRightIfRTL",
    appliesto: "blockContainers",
    computed: "asSpecifiedExceptMatchParent",
    order: "orderOfAppearance",
    alsoAppliesTo: ["::placeholder"],
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-align",
  },
  "text-align-last": {
    syntax: "auto | start | end | left | right | center | justify",
    media: "visual",
    inherited: true,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Text"],
    initial: "auto",
    appliesto: "blockContainers",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-align-last",
  },
  "text-combine-upright": {
    syntax: "none | all | [ digits <integer>? ]",
    media: "visual",
    inherited: true,
    animationType: "notAnimatable",
    percentages: "no",
    groups: ["CSS Writing Modes"],
    initial: "none",
    appliesto: "nonReplacedInlineElements",
    computed: "keywordPlusIntegerIfDigits",
    order: "uniqueOrder",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-combine-upright",
  },
  "text-decoration": {
    syntax:
      "<'text-decoration-line'> || <'text-decoration-style'> || <'text-decoration-color'> || <'text-decoration-thickness'>",
    media: "visual",
    inherited: false,
    animationType: [
      "text-decoration-color",
      "text-decoration-style",
      "text-decoration-line",
      "text-decoration-thickness",
    ],
    percentages: "no",
    groups: ["CSS Text Decoration"],
    initial: [
      "text-decoration-color",
      "text-decoration-style",
      "text-decoration-line",
    ],
    appliesto: "allElements",
    computed: [
      "text-decoration-line",
      "text-decoration-style",
      "text-decoration-color",
      "text-decoration-thickness",
    ],
    order: "orderOfAppearance",
    alsoAppliesTo: ["::first-letter", "::first-line", "::placeholder"],
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration",
  },
  "text-decoration-color": {
    syntax: "<color>",
    media: "visual",
    inherited: false,
    animationType: "color",
    percentages: "no",
    groups: ["CSS Text Decoration"],
    initial: "currentcolor",
    appliesto: "allElements",
    computed: "computedColor",
    order: "uniqueOrder",
    alsoAppliesTo: ["::first-letter", "::first-line", "::placeholder"],
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-color",
  },
  "text-decoration-line": {
    syntax:
      "none | [ underline || overline || line-through || blink ] | spelling-error | grammar-error",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Text Decoration"],
    initial: "none",
    appliesto: "allElements",
    computed: "asSpecified",
    order: "orderOfAppearance",
    alsoAppliesTo: ["::first-letter", "::first-line", "::placeholder"],
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-line",
  },
  "text-decoration-skip": {
    syntax:
      "none | [ objects || [ spaces | [ leading-spaces || trailing-spaces ] ] || edges || box-decoration ]",
    media: "visual",
    inherited: true,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Text Decoration"],
    initial: "objects",
    appliesto: "allElements",
    computed: "asSpecified",
    order: "orderOfAppearance",
    status: "experimental",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-skip",
  },
  "text-decoration-skip-ink": {
    syntax: "auto | all | none",
    media: "visual",
    inherited: true,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Text Decoration"],
    initial: "auto",
    appliesto: "allElements",
    computed: "asSpecified",
    order: "orderOfAppearance",
    status: "standard",
    mdn_url:
      "https://developer.mozilla.org/docs/Web/CSS/text-decoration-skip-ink",
  },
  "text-decoration-style": {
    syntax: "solid | double | dotted | dashed | wavy",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Text Decoration"],
    initial: "solid",
    appliesto: "allElements",
    computed: "asSpecified",
    order: "uniqueOrder",
    alsoAppliesTo: ["::first-letter", "::first-line", "::placeholder"],
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-style",
  },
  "text-decoration-thickness": {
    syntax: "auto | from-font | <length> | <percentage> ",
    media: "visual",
    inherited: false,
    animationType: "byComputedValueType",
    percentages: "referToElementFontSize",
    groups: ["CSS Text Decoration"],
    initial: "auto",
    appliesto: "allElements",
    computed: "asSpecified",
    order: "uniqueOrder",
    alsoAppliesTo: ["::first-letter", "::first-line", "::placeholder"],
    status: "standard",
    mdn_url:
      "https://developer.mozilla.org/docs/Web/CSS/text-decoration-thickness",
  },
  "text-emphasis": {
    syntax: "<'text-emphasis-style'> || <'text-emphasis-color'>",
    media: "visual",
    inherited: false,
    animationType: ["text-emphasis-color", "text-emphasis-style"],
    percentages: "no",
    groups: ["CSS Text Decoration"],
    initial: ["text-emphasis-style", "text-emphasis-color"],
    appliesto: "allElements",
    computed: ["text-emphasis-style", "text-emphasis-color"],
    order: "orderOfAppearance",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-emphasis",
  },
  "text-emphasis-color": {
    syntax: "<color>",
    media: "visual",
    inherited: false,
    animationType: "color",
    percentages: "no",
    groups: ["CSS Text Decoration"],
    initial: "currentcolor",
    appliesto: "allElements",
    computed: "computedColor",
    order: "uniqueOrder",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-emphasis-color",
  },
  "text-emphasis-position": {
    syntax: "[ over | under ] && [ right | left ]",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Text Decoration"],
    initial: "over right",
    appliesto: "allElements",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "standard",
    mdn_url:
      "https://developer.mozilla.org/docs/Web/CSS/text-emphasis-position",
  },
  "text-emphasis-style": {
    syntax:
      "none | [ [ filled | open ] || [ dot | circle | double-circle | triangle | sesame ] ] | <string>",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Text Decoration"],
    initial: "none",
    appliesto: "allElements",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-emphasis-style",
  },
  "text-indent": {
    syntax: "<length-percentage> && hanging? && each-line?",
    media: "visual",
    inherited: true,
    animationType: "lpc",
    percentages: "referToWidthOfContainingBlock",
    groups: ["CSS Text"],
    initial: "0",
    appliesto: "blockContainers",
    computed: "percentageOrAbsoluteLengthPlusKeywords",
    order: "lengthOrPercentageBeforeKeywords",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-indent",
  },
  "text-justify": {
    syntax: "auto | inter-character | inter-word | none",
    media: "visual",
    inherited: true,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Text"],
    initial: "auto",
    appliesto: "inlineLevelAndTableCellElements",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-justify",
  },
  "text-orientation": {
    syntax: "mixed | upright | sideways",
    media: "visual",
    inherited: true,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Writing Modes"],
    initial: "mixed",
    appliesto: "allElementsExceptTableRowGroupsRowsColumnGroupsAndColumns",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-orientation",
  },
  "text-overflow": {
    syntax: "[ clip | ellipsis | <string> ]{1,2}",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Basic User Interface"],
    initial: "clip",
    appliesto: "blockContainerElements",
    computed: "asSpecified",
    order: "uniqueOrder",
    alsoAppliesTo: ["::placeholder"],
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-overflow",
  },
  "text-rendering": {
    syntax: "auto | optimizeSpeed | optimizeLegibility | geometricPrecision",
    media: "visual",
    inherited: true,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Miscellaneous"],
    initial: "auto",
    appliesto: "textElements",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-rendering",
  },
  "text-shadow": {
    syntax: "none | <shadow-t>#",
    media: "visual",
    inherited: true,
    animationType: "shadowList",
    percentages: "no",
    groups: ["CSS Text Decoration"],
    initial: "none",
    appliesto: "allElements",
    computed: "colorPlusThreeAbsoluteLengths",
    order: "uniqueOrder",
    alsoAppliesTo: ["::first-letter", "::first-line", "::placeholder"],
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-shadow",
  },
  "text-size-adjust": {
    syntax: "none | auto | <percentage>",
    media: "visual",
    inherited: true,
    animationType: "discrete",
    percentages: "referToSizeOfFont",
    groups: ["CSS Text"],
    initial: "autoForSmartphoneBrowsersSupportingInflation",
    appliesto: "allElements",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "experimental",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-size-adjust",
  },
  "text-transform": {
    syntax:
      "none | capitalize | uppercase | lowercase | full-width | full-size-kana",
    media: "visual",
    inherited: true,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Text"],
    initial: "none",
    appliesto: "allElements",
    computed: "asSpecified",
    order: "uniqueOrder",
    alsoAppliesTo: ["::first-letter", "::first-line", "::placeholder"],
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-transform",
  },
  "text-underline-offset": {
    syntax: "auto | <length> | <percentage> ",
    media: "visual",
    inherited: true,
    animationType: "byComputedValueType",
    percentages: "referToElementFontSize",
    groups: ["CSS Text Decoration"],
    initial: "auto",
    appliesto: "allElements",
    computed: "asSpecified",
    order: "uniqueOrder",
    alsoAppliesTo: ["::first-letter", "::first-line", "::placeholder"],
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-underline-offset",
  },
  "text-underline-position": {
    syntax: "auto | from-font | [ under || [ left | right ] ]",
    media: "visual",
    inherited: true,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Text Decoration"],
    initial: "auto",
    appliesto: "allElements",
    computed: "asSpecified",
    order: "orderOfAppearance",
    status: "standard",
    mdn_url:
      "https://developer.mozilla.org/docs/Web/CSS/text-underline-position",
  },
  top: top,
  "touch-action": {
    syntax:
      "auto | none | [ [ pan-x | pan-left | pan-right ] || [ pan-y | pan-up | pan-down ] || pinch-zoom ] | manipulation",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["Pointer Events"],
    initial: "auto",
    appliesto:
      "allElementsExceptNonReplacedInlineElementsTableRowsColumnsRowColumnGroups",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/touch-action",
  },
  transform: transform,
  "transform-box": {
    syntax: "content-box | border-box | fill-box | stroke-box | view-box",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Transforms"],
    initial: "view-box",
    appliesto: "transformableElements",
    computed: "asSpecified",
    order: "perGrammar",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transform-box",
  },
  "transform-origin": {
    syntax:
      "[ <length-percentage> | left | center | right | top | bottom ] | [ [ <length-percentage> | left | center | right ] && [ <length-percentage> | top | center | bottom ] ] <length>?",
    media: "visual",
    inherited: false,
    animationType: "simpleListOfLpc",
    percentages: "referToSizeOfBoundingBox",
    groups: ["CSS Transforms"],
    initial: "50% 50% 0",
    appliesto: "transformableElements",
    computed: "forLengthAbsoluteValueOtherwisePercentage",
    order: "oneOrTwoValuesLengthAbsoluteKeywordsPercentages",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transform-origin",
  },
  "transform-style": {
    syntax: "flat | preserve-3d",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Transforms"],
    initial: "flat",
    appliesto: "transformableElements",
    computed: "asSpecified",
    order: "uniqueOrder",
    stacking: true,
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transform-style",
  },
  transition: transition,
  "transition-delay": {
    syntax: "<time>#",
    media: "interactive",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Transitions"],
    initial: "0s",
    appliesto: "allElementsAndPseudos",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition-delay",
  },
  "transition-duration": {
    syntax: "<time>#",
    media: "interactive",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Transitions"],
    initial: "0s",
    appliesto: "allElementsAndPseudos",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition-duration",
  },
  "transition-property": {
    syntax: "none | <single-transition-property>#",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Transitions"],
    initial: "all",
    appliesto: "allElementsAndPseudos",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition-property",
  },
  "transition-timing-function": {
    syntax: "<easing-function>#",
    media: "interactive",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Transitions"],
    initial: "ease",
    appliesto: "allElementsAndPseudos",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "standard",
    mdn_url:
      "https://developer.mozilla.org/docs/Web/CSS/transition-timing-function",
  },
  translate: translate,
  "unicode-bidi": {
    syntax:
      "normal | embed | isolate | bidi-override | isolate-override | plaintext",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Writing Modes"],
    initial: "normal",
    appliesto: "allElementsSomeValuesNoEffectOnNonInlineElements",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/unicode-bidi",
  },
  "user-select": {
    syntax: "auto | text | none | contain | all",
    media: "visual",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Basic User Interface"],
    initial: "auto",
    appliesto: "allElements",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/user-select",
  },
  "vertical-align": {
    syntax:
      "baseline | sub | super | text-top | text-bottom | middle | top | bottom | <percentage> | <length>",
    media: "visual",
    inherited: false,
    animationType: "length",
    percentages: "referToLineHeight",
    groups: ["CSS Table"],
    initial: "baseline",
    appliesto: "inlineLevelAndTableCellElements",
    computed: "absoluteLengthOrKeyword",
    order: "uniqueOrder",
    alsoAppliesTo: ["::first-letter", "::first-line", "::placeholder"],
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/vertical-align",
  },
  visibility: visibility,
  "white-space": {
    syntax: "normal | pre | nowrap | pre-wrap | pre-line | break-spaces",
    media: "visual",
    inherited: true,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Text"],
    initial: "normal",
    appliesto: "allElements",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/white-space",
  },
  widows: widows,
  width: width,
  "will-change": {
    syntax: "auto | <animateable-feature>#",
    media: "all",
    inherited: false,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Will Change"],
    initial: "auto",
    appliesto: "allElements",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/will-change",
  },
  "word-break": {
    syntax: "normal | break-all | keep-all | break-word",
    media: "visual",
    inherited: true,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Text"],
    initial: "normal",
    appliesto: "allElements",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/word-break",
  },
  "word-spacing": {
    syntax: "normal | <length>",
    media: "visual",
    inherited: true,
    animationType: "length",
    percentages: "referToWidthOfAffectedGlyph",
    groups: ["CSS Text"],
    initial: "normal",
    appliesto: "allElements",
    computed: "optimumMinAndMaxValueOfAbsoluteLengthPercentageOrNormal",
    order: "uniqueOrder",
    alsoAppliesTo: ["::first-letter", "::first-line", "::placeholder"],
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/word-spacing",
  },
  "word-wrap": {
    syntax: "normal | break-word",
    media: "visual",
    inherited: true,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Text"],
    initial: "normal",
    appliesto: "nonReplacedInlineElements",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow-wrap",
  },
  "writing-mode": {
    syntax:
      "horizontal-tb | vertical-rl | vertical-lr | sideways-rl | sideways-lr",
    media: "visual",
    inherited: true,
    animationType: "discrete",
    percentages: "no",
    groups: ["CSS Writing Modes"],
    initial: "horizontal-tb",
    appliesto: "allElementsExceptTableRowColumnGroupsTableRowsColumns",
    computed: "asSpecified",
    order: "uniqueOrder",
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/writing-mode",
  },
  "z-index": {
    syntax: "auto | <integer>",
    media: "visual",
    inherited: false,
    animationType: "integer",
    percentages: "no",
    groups: ["CSS Positioning"],
    initial: "auto",
    appliesto: "positionedElements",
    computed: "asSpecified",
    order: "uniqueOrder",
    stacking: true,
    status: "standard",
    mdn_url: "https://developer.mozilla.org/docs/Web/CSS/z-index",
  },
  zoom: zoom,
};

const attachment = {
  syntax: "scroll | fixed | local",
};
const box = {
  syntax: "border-box | padding-box | content-box",
};
const color$2 = {
  syntax:
    "<rgb()> | <rgba()> | <hsl()> | <hsla()> | <hwb()> | <lab()> | <lch()> | <hex-color> | <named-color> | currentcolor | <deprecated-system-color>",
};
const combinator = {
  syntax: "'>' | '+' | '~' | [ '||' ]",
};
const counter = {
  syntax: "<counter()> | <counters()>",
};
const gradient = {
  syntax:
    "<linear-gradient()> | <repeating-linear-gradient()> | <radial-gradient()> | <repeating-radial-gradient()> | <conic-gradient()> | <repeating-conic-gradient()>",
};
const hue = {
  syntax: "<number> | <angle>",
};
const image = {
  syntax:
    "<url> | <image()> | <image-set()> | <element()> | <paint()> | <cross-fade()> | <gradient>",
};
const nth$1 = {
  syntax: "<an-plus-b> | even | odd",
};
const position = {
  syntax:
    "[ [ left | center | right ] || [ top | center | bottom ] | [ left | center | right | <length-percentage> ] [ top | center | bottom | <length-percentage> ]? | [ [ left | right ] <length-percentage> ] && [ [ top | bottom ] <length-percentage> ] ]",
};
const quote = {
  syntax: "open-quote | close-quote | no-open-quote | no-close-quote",
};
const shadow = {
  syntax: "inset? && <length>{2,4} && <color>?",
};
const shape = {
  syntax: "rect(<top>, <right>, <bottom>, <left>)",
};
const size = {
  syntax:
    "closest-side | farthest-side | closest-corner | farthest-corner | <length> | <length-percentage>{2}",
};
const symbol = {
  syntax: "<string> | <image> | <custom-ident>",
};
const target = {
  syntax: "<target-counter()> | <target-counters()> | <target-text()>",
};
const require$$3 = {
  "absolute-size": {
    syntax:
      "xx-small | x-small | small | medium | large | x-large | xx-large | xxx-large",
  },
  "alpha-value": {
    syntax: "<number> | <percentage>",
  },
  "angle-percentage": {
    syntax: "<angle> | <percentage>",
  },
  "angular-color-hint": {
    syntax: "<angle-percentage>",
  },
  "angular-color-stop": {
    syntax: "<color> && <color-stop-angle>?",
  },
  "angular-color-stop-list": {
    syntax:
      "[ <angular-color-stop> [, <angular-color-hint>]? ]# , <angular-color-stop>",
  },
  "animateable-feature": {
    syntax: "scroll-position | contents | <custom-ident>",
  },
  attachment: attachment,
  "attr()": {
    syntax: "attr( <attr-name> <type-or-unit>? [, <attr-fallback> ]? )",
  },
  "attr-matcher": {
    syntax: "[ '~' | '|' | '^' | '$' | '*' ]? '='",
  },
  "attr-modifier": {
    syntax: "i | s",
  },
  "attribute-selector": {
    syntax:
      "'[' <wq-name> ']' | '[' <wq-name> <attr-matcher> [ <string-token> | <ident-token> ] <attr-modifier>? ']'",
  },
  "auto-repeat": {
    syntax:
      "repeat( [ auto-fill | auto-fit ] , [ <line-names>? <fixed-size> ]+ <line-names>? )",
  },
  "auto-track-list": {
    syntax:
      "[ <line-names>? [ <fixed-size> | <fixed-repeat> ] ]* <line-names>? <auto-repeat>\n[ <line-names>? [ <fixed-size> | <fixed-repeat> ] ]* <line-names>?",
  },
  "baseline-position": {
    syntax: "[ first | last ]? baseline",
  },
  "basic-shape": {
    syntax: "<inset()> | <circle()> | <ellipse()> | <polygon()> | <path()>",
  },
  "bg-image": {
    syntax: "none | <image>",
  },
  "bg-layer": {
    syntax:
      "<bg-image> || <bg-position> [ / <bg-size> ]? || <repeat-style> || <attachment> || <box> || <box>",
  },
  "bg-position": {
    syntax:
      "[ [ left | center | right | top | bottom | <length-percentage> ] | [ left | center | right | <length-percentage> ] [ top | center | bottom | <length-percentage> ] | [ center | [ left | right ] <length-percentage>? ] && [ center | [ top | bottom ] <length-percentage>? ] ]",
  },
  "bg-size": {
    syntax: "[ <length-percentage> | auto ]{1,2} | cover | contain",
  },
  "blur()": {
    syntax: "blur( <length> )",
  },
  "blend-mode": {
    syntax:
      "normal | multiply | screen | overlay | darken | lighten | color-dodge | color-burn | hard-light | soft-light | difference | exclusion | hue | saturation | color | luminosity",
  },
  box: box,
  "brightness()": {
    syntax: "brightness( <number-percentage> )",
  },
  "calc()": {
    syntax: "calc( <calc-sum> )",
  },
  "calc-sum": {
    syntax: "<calc-product> [ [ '+' | '-' ] <calc-product> ]*",
  },
  "calc-product": {
    syntax: "<calc-value> [ '*' <calc-value> | '/' <number> ]*",
  },
  "calc-value": {
    syntax: "<number> | <dimension> | <percentage> | ( <calc-sum> )",
  },
  "cf-final-image": {
    syntax: "<image> | <color>",
  },
  "cf-mixing-image": {
    syntax: "<percentage>? && <image>",
  },
  "circle()": {
    syntax: "circle( [ <shape-radius> ]? [ at <position> ]? )",
  },
  "clamp()": {
    syntax: "clamp( <calc-sum>#{3} )",
  },
  "class-selector": {
    syntax: "'.' <ident-token>",
  },
  "clip-source": {
    syntax: "<url>",
  },
  color: color$2,
  "color-stop": {
    syntax: "<color-stop-length> | <color-stop-angle>",
  },
  "color-stop-angle": {
    syntax: "<angle-percentage>{1,2}",
  },
  "color-stop-length": {
    syntax: "<length-percentage>{1,2}",
  },
  "color-stop-list": {
    syntax:
      "[ <linear-color-stop> [, <linear-color-hint>]? ]# , <linear-color-stop>",
  },
  combinator: combinator,
  "common-lig-values": {
    syntax: "[ common-ligatures | no-common-ligatures ]",
  },
  "compat-auto": {
    syntax:
      "searchfield | textarea | push-button | slider-horizontal | checkbox | radio | square-button | menulist | listbox | meter | progress-bar | button",
  },
  "composite-style": {
    syntax:
      "clear | copy | source-over | source-in | source-out | source-atop | destination-over | destination-in | destination-out | destination-atop | xor",
  },
  "compositing-operator": {
    syntax: "add | subtract | intersect | exclude",
  },
  "compound-selector": {
    syntax:
      "[ <type-selector>? <subclass-selector>* [ <pseudo-element-selector> <pseudo-class-selector>* ]* ]!",
  },
  "compound-selector-list": {
    syntax: "<compound-selector>#",
  },
  "complex-selector": {
    syntax: "<compound-selector> [ <combinator>? <compound-selector> ]*",
  },
  "complex-selector-list": {
    syntax: "<complex-selector>#",
  },
  "conic-gradient()": {
    syntax:
      "conic-gradient( [ from <angle> ]? [ at <position> ]?, <angular-color-stop-list> )",
  },
  "contextual-alt-values": {
    syntax: "[ contextual | no-contextual ]",
  },
  "content-distribution": {
    syntax: "space-between | space-around | space-evenly | stretch",
  },
  "content-list": {
    syntax:
      "[ <string> | contents | <image> | <counter> | <quote> | <target> | <leader()> ]+",
  },
  "content-position": {
    syntax: "center | start | end | flex-start | flex-end",
  },
  "content-replacement": {
    syntax: "<image>",
  },
  "contrast()": {
    syntax: "contrast( [ <number-percentage> ] )",
  },
  counter: counter,
  "counter()": {
    syntax: "counter( <counter-name>, <counter-style>? )",
  },
  "counter-name": {
    syntax: "<custom-ident>",
  },
  "counter-style": {
    syntax: "<counter-style-name> | symbols()",
  },
  "counter-style-name": {
    syntax: "<custom-ident>",
  },
  "counters()": {
    syntax: "counters( <counter-name>, <string>, <counter-style>? )",
  },
  "cross-fade()": {
    syntax: "cross-fade( <cf-mixing-image> , <cf-final-image>? )",
  },
  "cubic-bezier-timing-function": {
    syntax:
      "ease | ease-in | ease-out | ease-in-out | cubic-bezier(<number [0,1]>, <number>, <number [0,1]>, <number>)",
  },
  "deprecated-system-color": {
    syntax:
      "ActiveBorder | ActiveCaption | AppWorkspace | Background | ButtonFace | ButtonHighlight | ButtonShadow | ButtonText | CaptionText | GrayText | Highlight | HighlightText | InactiveBorder | InactiveCaption | InactiveCaptionText | InfoBackground | InfoText | Menu | MenuText | Scrollbar | ThreeDDarkShadow | ThreeDFace | ThreeDHighlight | ThreeDLightShadow | ThreeDShadow | Window | WindowFrame | WindowText",
  },
  "discretionary-lig-values": {
    syntax: "[ discretionary-ligatures | no-discretionary-ligatures ]",
  },
  "display-box": {
    syntax: "contents | none",
  },
  "display-inside": {
    syntax: "flow | flow-root | table | flex | grid | ruby",
  },
  "display-internal": {
    syntax:
      "table-row-group | table-header-group | table-footer-group | table-row | table-cell | table-column-group | table-column | table-caption | ruby-base | ruby-text | ruby-base-container | ruby-text-container",
  },
  "display-legacy": {
    syntax:
      "inline-block | inline-list-item | inline-table | inline-flex | inline-grid",
  },
  "display-listitem": {
    syntax: "<display-outside>? && [ flow | flow-root ]? && list-item",
  },
  "display-outside": {
    syntax: "block | inline | run-in",
  },
  "drop-shadow()": {
    syntax: "drop-shadow( <length>{2,3} <color>? )",
  },
  "east-asian-variant-values": {
    syntax: "[ jis78 | jis83 | jis90 | jis04 | simplified | traditional ]",
  },
  "east-asian-width-values": {
    syntax: "[ full-width | proportional-width ]",
  },
  "element()": {
    syntax: "element( <id-selector> )",
  },
  "ellipse()": {
    syntax: "ellipse( [ <shape-radius>{2} ]? [ at <position> ]? )",
  },
  "ending-shape": {
    syntax: "circle | ellipse",
  },
  "env()": {
    syntax: "env( <custom-ident> , <declaration-value>? )",
  },
  "explicit-track-list": {
    syntax: "[ <line-names>? <track-size> ]+ <line-names>?",
  },
  "family-name": {
    syntax: "<string> | <custom-ident>+",
  },
  "feature-tag-value": {
    syntax: "<string> [ <integer> | on | off ]?",
  },
  "feature-type": {
    syntax:
      "@stylistic | @historical-forms | @styleset | @character-variant | @swash | @ornaments | @annotation",
  },
  "feature-value-block": {
    syntax: "<feature-type> '{' <feature-value-declaration-list> '}'",
  },
  "feature-value-block-list": {
    syntax: "<feature-value-block>+",
  },
  "feature-value-declaration": {
    syntax: "<custom-ident>: <integer>+;",
  },
  "feature-value-declaration-list": {
    syntax: "<feature-value-declaration>",
  },
  "feature-value-name": {
    syntax: "<custom-ident>",
  },
  "fill-rule": {
    syntax: "nonzero | evenodd",
  },
  "filter-function": {
    syntax:
      "<blur()> | <brightness()> | <contrast()> | <drop-shadow()> | <grayscale()> | <hue-rotate()> | <invert()> | <opacity()> | <saturate()> | <sepia()>",
  },
  "filter-function-list": {
    syntax: "[ <filter-function> | <url> ]+",
  },
  "final-bg-layer": {
    syntax:
      "<'background-color'> || <bg-image> || <bg-position> [ / <bg-size> ]? || <repeat-style> || <attachment> || <box> || <box>",
  },
  "fit-content()": {
    syntax: "fit-content( [ <length> | <percentage> ] )",
  },
  "fixed-breadth": {
    syntax: "<length-percentage>",
  },
  "fixed-repeat": {
    syntax:
      "repeat( [ <integer [1,]> ] , [ <line-names>? <fixed-size> ]+ <line-names>? )",
  },
  "fixed-size": {
    syntax:
      "<fixed-breadth> | minmax( <fixed-breadth> , <track-breadth> ) | minmax( <inflexible-breadth> , <fixed-breadth> )",
  },
  "font-stretch-absolute": {
    syntax:
      "normal | ultra-condensed | extra-condensed | condensed | semi-condensed | semi-expanded | expanded | extra-expanded | ultra-expanded | <percentage>",
  },
  "font-variant-css21": {
    syntax: "[ normal | small-caps ]",
  },
  "font-weight-absolute": {
    syntax: "normal | bold | <number [1,1000]>",
  },
  "frequency-percentage": {
    syntax: "<frequency> | <percentage>",
  },
  "general-enclosed": {
    syntax: "[ <function-token> <any-value> ) ] | ( <ident> <any-value> )",
  },
  "generic-family": {
    syntax: "serif | sans-serif | cursive | fantasy | monospace",
  },
  "generic-name": {
    syntax: "serif | sans-serif | cursive | fantasy | monospace",
  },
  "geometry-box": {
    syntax: "<shape-box> | fill-box | stroke-box | view-box",
  },
  gradient: gradient,
  "grayscale()": {
    syntax: "grayscale( <number-percentage> )",
  },
  "grid-line": {
    syntax:
      "auto | <custom-ident> | [ <integer> && <custom-ident>? ] | [ span && [ <integer> || <custom-ident> ] ]",
  },
  "historical-lig-values": {
    syntax: "[ historical-ligatures | no-historical-ligatures ]",
  },
  "hsl()": {
    syntax:
      "hsl( <hue> <percentage> <percentage> [ / <alpha-value> ]? ) | hsl( <hue>, <percentage>, <percentage>, <alpha-value>? )",
  },
  "hsla()": {
    syntax:
      "hsla( <hue> <percentage> <percentage> [ / <alpha-value> ]? ) | hsla( <hue>, <percentage>, <percentage>, <alpha-value>? )",
  },
  hue: hue,
  "hue-rotate()": {
    syntax: "hue-rotate( <angle> )",
  },
  "hwb()": {
    syntax:
      "hwb( [<hue> | none] [<percentage> | none] [<percentage> | none] [ / [<alpha-value> | none] ]? )",
  },
  "id-selector": {
    syntax: "<hash-token>",
  },
  image: image,
  "image()": {
    syntax: "image( <image-tags>? [ <image-src>? , <color>? ]! )",
  },
  "image-set()": {
    syntax: "image-set( <image-set-option># )",
  },
  "image-set-option": {
    syntax: "[ <image> | <string> ] [ <resolution> || type(<string>) ]",
  },
  "image-src": {
    syntax: "<url> | <string>",
  },
  "image-tags": {
    syntax: "ltr | rtl",
  },
  "inflexible-breadth": {
    syntax: "<length> | <percentage> | min-content | max-content | auto",
  },
  "inset()": {
    syntax: "inset( <length-percentage>{1,4} [ round <'border-radius'> ]? )",
  },
  "invert()": {
    syntax: "invert( <number-percentage> )",
  },
  "keyframes-name": {
    syntax: "<custom-ident> | <string>",
  },
  "keyframe-block": {
    syntax: "<keyframe-selector># {\n  <declaration-list>\n}",
  },
  "keyframe-block-list": {
    syntax: "<keyframe-block>+",
  },
  "keyframe-selector": {
    syntax: "from | to | <percentage>",
  },
  "layer()": {
    syntax: "layer( <layer-name> )",
  },
  "layer-name": {
    syntax: "<ident> [ '.' <ident> ]*",
  },
  "leader()": {
    syntax: "leader( <leader-type> )",
  },
  "leader-type": {
    syntax: "dotted | solid | space | <string>",
  },
  "length-percentage": {
    syntax: "<length> | <percentage>",
  },
  "line-names": {
    syntax: "'[' <custom-ident>* ']'",
  },
  "line-name-list": {
    syntax: "[ <line-names> | <name-repeat> ]+",
  },
  "line-style": {
    syntax:
      "none | hidden | dotted | dashed | solid | double | groove | ridge | inset | outset",
  },
  "line-width": {
    syntax: "<length> | thin | medium | thick",
  },
  "linear-color-hint": {
    syntax: "<length-percentage>",
  },
  "linear-color-stop": {
    syntax: "<color> <color-stop-length>?",
  },
  "linear-gradient()": {
    syntax:
      "linear-gradient( [ <angle> | to <side-or-corner> ]? , <color-stop-list> )",
  },
  "mask-layer": {
    syntax:
      "<mask-reference> || <position> [ / <bg-size> ]? || <repeat-style> || <geometry-box> || [ <geometry-box> | no-clip ] || <compositing-operator> || <masking-mode>",
  },
  "mask-position": {
    syntax:
      "[ <length-percentage> | left | center | right ] [ <length-percentage> | top | center | bottom ]?",
  },
  "mask-reference": {
    syntax: "none | <image> | <mask-source>",
  },
  "mask-source": {
    syntax: "<url>",
  },
  "masking-mode": {
    syntax: "alpha | luminance | match-source",
  },
  "matrix()": {
    syntax: "matrix( <number>#{6} )",
  },
  "matrix3d()": {
    syntax: "matrix3d( <number>#{16} )",
  },
  "max()": {
    syntax: "max( <calc-sum># )",
  },
  "media-and": {
    syntax: "<media-in-parens> [ and <media-in-parens> ]+",
  },
  "media-condition": {
    syntax: "<media-not> | <media-and> | <media-or> | <media-in-parens>",
  },
  "media-condition-without-or": {
    syntax: "<media-not> | <media-and> | <media-in-parens>",
  },
  "media-feature": {
    syntax: "( [ <mf-plain> | <mf-boolean> | <mf-range> ] )",
  },
  "media-in-parens": {
    syntax: "( <media-condition> ) | <media-feature> | <general-enclosed>",
  },
  "media-not": {
    syntax: "not <media-in-parens>",
  },
  "media-or": {
    syntax: "<media-in-parens> [ or <media-in-parens> ]+",
  },
  "media-query": {
    syntax:
      "<media-condition> | [ not | only ]? <media-type> [ and <media-condition-without-or> ]?",
  },
  "media-query-list": {
    syntax: "<media-query>#",
  },
  "media-type": {
    syntax: "<ident>",
  },
  "mf-boolean": {
    syntax: "<mf-name>",
  },
  "mf-name": {
    syntax: "<ident>",
  },
  "mf-plain": {
    syntax: "<mf-name> : <mf-value>",
  },
  "mf-range": {
    syntax:
      "<mf-name> [ '<' | '>' ]? '='? <mf-value>\n| <mf-value> [ '<' | '>' ]? '='? <mf-name>\n| <mf-value> '<' '='? <mf-name> '<' '='? <mf-value>\n| <mf-value> '>' '='? <mf-name> '>' '='? <mf-value>",
  },
  "mf-value": {
    syntax: "<number> | <dimension> | <ident> | <ratio>",
  },
  "min()": {
    syntax: "min( <calc-sum># )",
  },
  "minmax()": {
    syntax:
      "minmax( [ <length> | <percentage> | min-content | max-content | auto ] , [ <length> | <percentage> | <flex> | min-content | max-content | auto ] )",
  },
  "name-repeat": {
    syntax: "repeat( [ <integer [1,]> | auto-fill ], <line-names>+ )",
  },
  "named-color": {
    syntax:
      "transparent | aliceblue | antiquewhite | aqua | aquamarine | azure | beige | bisque | black | blanchedalmond | blue | blueviolet | brown | burlywood | cadetblue | chartreuse | chocolate | coral | cornflowerblue | cornsilk | crimson | cyan | darkblue | darkcyan | darkgoldenrod | darkgray | darkgreen | darkgrey | darkkhaki | darkmagenta | darkolivegreen | darkorange | darkorchid | darkred | darksalmon | darkseagreen | darkslateblue | darkslategray | darkslategrey | darkturquoise | darkviolet | deeppink | deepskyblue | dimgray | dimgrey | dodgerblue | firebrick | floralwhite | forestgreen | fuchsia | gainsboro | ghostwhite | gold | goldenrod | gray | green | greenyellow | grey | honeydew | hotpink | indianred | indigo | ivory | khaki | lavender | lavenderblush | lawngreen | lemonchiffon | lightblue | lightcoral | lightcyan | lightgoldenrodyellow | lightgray | lightgreen | lightgrey | lightpink | lightsalmon | lightseagreen | lightskyblue | lightslategray | lightslategrey | lightsteelblue | lightyellow | lime | limegreen | linen | magenta | maroon | mediumaquamarine | mediumblue | mediumorchid | mediumpurple | mediumseagreen | mediumslateblue | mediumspringgreen | mediumturquoise | mediumvioletred | midnightblue | mintcream | mistyrose | moccasin | navajowhite | navy | oldlace | olive | olivedrab | orange | orangered | orchid | palegoldenrod | palegreen | paleturquoise | palevioletred | papayawhip | peachpuff | peru | pink | plum | powderblue | purple | rebeccapurple | red | rosybrown | royalblue | saddlebrown | salmon | sandybrown | seagreen | seashell | sienna | silver | skyblue | slateblue | slategray | slategrey | snow | springgreen | steelblue | tan | teal | thistle | tomato | turquoise | violet | wheat | white | whitesmoke | yellow | yellowgreen",
  },
  "namespace-prefix": {
    syntax: "<ident>",
  },
  "ns-prefix": {
    syntax: "[ <ident-token> | '*' ]? '|'",
  },
  "number-percentage": {
    syntax: "<number> | <percentage>",
  },
  "numeric-figure-values": {
    syntax: "[ lining-nums | oldstyle-nums ]",
  },
  "numeric-fraction-values": {
    syntax: "[ diagonal-fractions | stacked-fractions ]",
  },
  "numeric-spacing-values": {
    syntax: "[ proportional-nums | tabular-nums ]",
  },
  nth: nth$1,
  "opacity()": {
    syntax: "opacity( [ <number-percentage> ] )",
  },
  "overflow-position": {
    syntax: "unsafe | safe",
  },
  "outline-radius": {
    syntax: "<length> | <percentage>",
  },
  "page-body": {
    syntax: "<declaration>? [ ; <page-body> ]? | <page-margin-box> <page-body>",
  },
  "page-margin-box": {
    syntax: "<page-margin-box-type> '{' <declaration-list> '}'",
  },
  "page-margin-box-type": {
    syntax:
      "@top-left-corner | @top-left | @top-center | @top-right | @top-right-corner | @bottom-left-corner | @bottom-left | @bottom-center | @bottom-right | @bottom-right-corner | @left-top | @left-middle | @left-bottom | @right-top | @right-middle | @right-bottom",
  },
  "page-selector-list": {
    syntax: "[ <page-selector># ]?",
  },
  "page-selector": {
    syntax: "<pseudo-page>+ | <ident> <pseudo-page>*",
  },
  "page-size": {
    syntax:
      "A5 | A4 | A3 | B5 | B4 | JIS-B5 | JIS-B4 | letter | legal | ledger",
  },
  "path()": {
    syntax: "path( [ <fill-rule>, ]? <string> )",
  },
  "paint()": {
    syntax: "paint( <ident>, <declaration-value>? )",
  },
  "perspective()": {
    syntax: "perspective( <length> )",
  },
  "polygon()": {
    syntax:
      "polygon( <fill-rule>? , [ <length-percentage> <length-percentage> ]# )",
  },
  position: position,
  "pseudo-class-selector": {
    syntax: "':' <ident-token> | ':' <function-token> <any-value> ')'",
  },
  "pseudo-element-selector": {
    syntax: "':' <pseudo-class-selector>",
  },
  "pseudo-page": {
    syntax: ": [ left | right | first | blank ]",
  },
  quote: quote,
  "radial-gradient()": {
    syntax:
      "radial-gradient( [ <ending-shape> || <size> ]? [ at <position> ]? , <color-stop-list> )",
  },
  "relative-selector": {
    syntax: "<combinator>? <complex-selector>",
  },
  "relative-selector-list": {
    syntax: "<relative-selector>#",
  },
  "relative-size": {
    syntax: "larger | smaller",
  },
  "repeat-style": {
    syntax: "repeat-x | repeat-y | [ repeat | space | round | no-repeat ]{1,2}",
  },
  "repeating-conic-gradient()": {
    syntax:
      "repeating-conic-gradient( [ from <angle> ]? [ at <position> ]?, <angular-color-stop-list> )",
  },
  "repeating-linear-gradient()": {
    syntax:
      "repeating-linear-gradient( [ <angle> | to <side-or-corner> ]? , <color-stop-list> )",
  },
  "repeating-radial-gradient()": {
    syntax:
      "repeating-radial-gradient( [ <ending-shape> || <size> ]? [ at <position> ]? , <color-stop-list> )",
  },
  "rgb()": {
    syntax:
      "rgb( <percentage>{3} [ / <alpha-value> ]? ) | rgb( <number>{3} [ / <alpha-value> ]? ) | rgb( <percentage>#{3} , <alpha-value>? ) | rgb( <number>#{3} , <alpha-value>? )",
  },
  "rgba()": {
    syntax:
      "rgba( <percentage>{3} [ / <alpha-value> ]? ) | rgba( <number>{3} [ / <alpha-value> ]? ) | rgba( <percentage>#{3} , <alpha-value>? ) | rgba( <number>#{3} , <alpha-value>? )",
  },
  "rotate()": {
    syntax: "rotate( [ <angle> | <zero> ] )",
  },
  "rotate3d()": {
    syntax: "rotate3d( <number> , <number> , <number> , [ <angle> | <zero> ] )",
  },
  "rotateX()": {
    syntax: "rotateX( [ <angle> | <zero> ] )",
  },
  "rotateY()": {
    syntax: "rotateY( [ <angle> | <zero> ] )",
  },
  "rotateZ()": {
    syntax: "rotateZ( [ <angle> | <zero> ] )",
  },
  "saturate()": {
    syntax: "saturate( <number-percentage> )",
  },
  "scale()": {
    syntax: "scale( <number> , <number>? )",
  },
  "scale3d()": {
    syntax: "scale3d( <number> , <number> , <number> )",
  },
  "scaleX()": {
    syntax: "scaleX( <number> )",
  },
  "scaleY()": {
    syntax: "scaleY( <number> )",
  },
  "scaleZ()": {
    syntax: "scaleZ( <number> )",
  },
  "self-position": {
    syntax:
      "center | start | end | self-start | self-end | flex-start | flex-end",
  },
  "shape-radius": {
    syntax: "<length-percentage> | closest-side | farthest-side",
  },
  "skew()": {
    syntax: "skew( [ <angle> | <zero> ] , [ <angle> | <zero> ]? )",
  },
  "skewX()": {
    syntax: "skewX( [ <angle> | <zero> ] )",
  },
  "skewY()": {
    syntax: "skewY( [ <angle> | <zero> ] )",
  },
  "sepia()": {
    syntax: "sepia( <number-percentage> )",
  },
  shadow: shadow,
  "shadow-t": {
    syntax: "[ <length>{2,3} && <color>? ]",
  },
  shape: shape,
  "shape-box": {
    syntax: "<box> | margin-box",
  },
  "side-or-corner": {
    syntax: "[ left | right ] || [ top | bottom ]",
  },
  "single-animation": {
    syntax:
      "<time> || <easing-function> || <time> || <single-animation-iteration-count> || <single-animation-direction> || <single-animation-fill-mode> || <single-animation-play-state> || [ none | <keyframes-name> ]",
  },
  "single-animation-direction": {
    syntax: "normal | reverse | alternate | alternate-reverse",
  },
  "single-animation-fill-mode": {
    syntax: "none | forwards | backwards | both",
  },
  "single-animation-iteration-count": {
    syntax: "infinite | <number>",
  },
  "single-animation-play-state": {
    syntax: "running | paused",
  },
  "single-animation-timeline": {
    syntax: "auto | none | <timeline-name>",
  },
  "single-transition": {
    syntax:
      "[ none | <single-transition-property> ] || <time> || <easing-function> || <time>",
  },
  "single-transition-property": {
    syntax: "all | <custom-ident>",
  },
  size: size,
  "step-position": {
    syntax: "jump-start | jump-end | jump-none | jump-both | start | end",
  },
  "step-timing-function": {
    syntax: "step-start | step-end | steps(<integer>[, <step-position>]?)",
  },
  "subclass-selector": {
    syntax:
      "<id-selector> | <class-selector> | <attribute-selector> | <pseudo-class-selector>",
  },
  "supports-condition": {
    syntax:
      "not <supports-in-parens> | <supports-in-parens> [ and <supports-in-parens> ]* | <supports-in-parens> [ or <supports-in-parens> ]*",
  },
  "supports-in-parens": {
    syntax:
      "( <supports-condition> ) | <supports-feature> | <general-enclosed>",
  },
  "supports-feature": {
    syntax: "<supports-decl> | <supports-selector-fn>",
  },
  "supports-decl": {
    syntax: "( <declaration> )",
  },
  "supports-selector-fn": {
    syntax: "selector( <complex-selector> )",
  },
  symbol: symbol,
  target: target,
  "target-counter()": {
    syntax:
      "target-counter( [ <string> | <url> ] , <custom-ident> , <counter-style>? )",
  },
  "target-counters()": {
    syntax:
      "target-counters( [ <string> | <url> ] , <custom-ident> , <string> , <counter-style>? )",
  },
  "target-text()": {
    syntax:
      "target-text( [ <string> | <url> ] , [ content | before | after | first-letter ]? )",
  },
  "time-percentage": {
    syntax: "<time> | <percentage>",
  },
  "timeline-name": {
    syntax: "<custom-ident> | <string>",
  },
  "easing-function": {
    syntax: "linear | <cubic-bezier-timing-function> | <step-timing-function>",
  },
  "track-breadth": {
    syntax: "<length-percentage> | <flex> | min-content | max-content | auto",
  },
  "track-list": {
    syntax:
      "[ <line-names>? [ <track-size> | <track-repeat> ] ]+ <line-names>?",
  },
  "track-repeat": {
    syntax:
      "repeat( [ <integer [1,]> ] , [ <line-names>? <track-size> ]+ <line-names>? )",
  },
  "track-size": {
    syntax:
      "<track-breadth> | minmax( <inflexible-breadth> , <track-breadth> ) | fit-content( [ <length> | <percentage> ] )",
  },
  "transform-function": {
    syntax:
      "<matrix()> | <translate()> | <translateX()> | <translateY()> | <scale()> | <scaleX()> | <scaleY()> | <rotate()> | <skew()> | <skewX()> | <skewY()> | <matrix3d()> | <translate3d()> | <translateZ()> | <scale3d()> | <scaleZ()> | <rotate3d()> | <rotateX()> | <rotateY()> | <rotateZ()> | <perspective()>",
  },
  "transform-list": {
    syntax: "<transform-function>+",
  },
  "translate()": {
    syntax: "translate( <length-percentage> , <length-percentage>? )",
  },
  "translate3d()": {
    syntax:
      "translate3d( <length-percentage> , <length-percentage> , <length> )",
  },
  "translateX()": {
    syntax: "translateX( <length-percentage> )",
  },
  "translateY()": {
    syntax: "translateY( <length-percentage> )",
  },
  "translateZ()": {
    syntax: "translateZ( <length> )",
  },
  "type-or-unit": {
    syntax:
      "string | color | url | integer | number | length | angle | time | frequency | cap | ch | em | ex | ic | lh | rlh | rem | vb | vi | vw | vh | vmin | vmax | mm | Q | cm | in | pt | pc | px | deg | grad | rad | turn | ms | s | Hz | kHz | %",
  },
  "type-selector": {
    syntax: "<wq-name> | <ns-prefix>? '*'",
  },
  "var()": {
    syntax: "var( <custom-property-name> , <declaration-value>? )",
  },
  "viewport-length": {
    syntax: "auto | <length-percentage>",
  },
  "visual-box": {
    syntax: "content-box | padding-box | border-box",
  },
  "wq-name": {
    syntax: "<ns-prefix>? <ident-token>",
  },
};

const dataPatch = dataPatch$1;

const mdnAtrules = require$$1;
const mdnProperties = require$$2;
const mdnSyntaxes = require$$3;

const extendSyntax = /^\s*\|\s*/;

function preprocessAtrules(dict) {
  const result = Object.create(null);

  for (const atruleName in dict) {
    const atrule = dict[atruleName];
    let descriptors = null;

    if (atrule.descriptors) {
      descriptors = Object.create(null);

      for (const descriptor in atrule.descriptors) {
        descriptors[descriptor] = atrule.descriptors[descriptor].syntax;
      }
    }

    result[atruleName.substr(1)] = {
      prelude:
        atrule.syntax
          .trim()
          .replace(/\{(.|\s)+\}/, "")
          .match(/^@\S+\s+([^;\{]*)/)[1]
          .trim() || null,
      descriptors,
    };
  }

  return result;
}

function patchDictionary(dict, patchDict) {
  const result = {};

  // copy all syntaxes for an original dict
  for (const key in dict) {
    result[key] = dict[key].syntax || dict[key];
  }

  // apply a patch
  for (const key in patchDict) {
    if (key in dict) {
      if (patchDict[key].syntax) {
        result[key] = extendSyntax.test(patchDict[key].syntax)
          ? result[key] + " " + patchDict[key].syntax.trim()
          : patchDict[key].syntax;
      } else {
        delete result[key];
      }
    } else {
      if (patchDict[key].syntax) {
        result[key] = patchDict[key].syntax.replace(extendSyntax, "");
      }
    }
  }

  return result;
}

function patchAtrules(dict, patchDict) {
  const result = {};

  // copy all syntaxes for an original dict
  for (const key in dict) {
    const patchDescriptors =
      (patchDict[key] && patchDict[key].descriptors) || null;

    result[key] = {
      prelude:
        key in patchDict && "prelude" in patchDict[key]
          ? patchDict[key].prelude
          : dict[key].prelude || null,
      descriptors: patchDictionary(
        dict[key].descriptors || {},
        patchDescriptors || {},
      ),
    };
  }

  // apply a patch
  for (const key in patchDict) {
    if (!hasOwnProperty.call(dict, key)) {
      result[key] = {
        prelude: patchDict[key].prelude || null,
        descriptors:
          patchDict[key].descriptors &&
          patchDictionary({}, patchDict[key].descriptors),
      };
    }
  }

  return result;
}

const definitions = {
  types: patchDictionary(mdnSyntaxes, dataPatch.types),
  atrules: patchAtrules(preprocessAtrules(mdnAtrules), dataPatch.atrules),
  properties: patchDictionary(mdnProperties, dataPatch.properties),
};

var data$1 = definitions;

var node = {};

var AnPlusB$2 = {};

const types$I = types$U;
const charCodeDefinitions$5 = charCodeDefinitions$c;

const PLUSSIGN$5 = 0x002b; // U+002B PLUS SIGN (+)
const HYPHENMINUS$2 = 0x002d; // U+002D HYPHEN-MINUS (-)
const N = 0x006e; // U+006E LATIN SMALL LETTER N (n)
const DISALLOW_SIGN = true;
const ALLOW_SIGN = false;

function checkInteger(offset, disallowSign) {
  let pos = this.tokenStart + offset;
  const code = this.charCodeAt(pos);

  if (code === PLUSSIGN$5 || code === HYPHENMINUS$2) {
    if (disallowSign) {
      this.error("Number sign is not allowed");
    }
    pos++;
  }

  for (; pos < this.tokenEnd; pos++) {
    if (!charCodeDefinitions$5.isDigit(this.charCodeAt(pos))) {
      this.error("Integer is expected", pos);
    }
  }
}

function checkTokenIsInteger(disallowSign) {
  return checkInteger.call(this, 0, disallowSign);
}

function expectCharCode(offset, code) {
  if (!this.cmpChar(this.tokenStart + offset, code)) {
    let msg = "";

    switch (code) {
      case N:
        msg = "N is expected";
        break;
      case HYPHENMINUS$2:
        msg = "HyphenMinus is expected";
        break;
    }

    this.error(msg, this.tokenStart + offset);
  }
}

// ... <signed-integer>
// ... ['+' | '-'] <signless-integer>
function consumeB() {
  let offset = 0;
  let sign = 0;
  let type = this.tokenType;

  while (type === types$I.WhiteSpace || type === types$I.Comment) {
    type = this.lookupType(++offset);
  }

  if (type !== types$I.Number) {
    if (
      this.isDelim(PLUSSIGN$5, offset) ||
      this.isDelim(HYPHENMINUS$2, offset)
    ) {
      sign = this.isDelim(PLUSSIGN$5, offset) ? PLUSSIGN$5 : HYPHENMINUS$2;

      do {
        type = this.lookupType(++offset);
      } while (type === types$I.WhiteSpace || type === types$I.Comment);

      if (type !== types$I.Number) {
        this.skip(offset);
        checkTokenIsInteger.call(this, DISALLOW_SIGN);
      }
    } else {
      return null;
    }
  }

  if (offset > 0) {
    this.skip(offset);
  }

  if (sign === 0) {
    type = this.charCodeAt(this.tokenStart);
    if (type !== PLUSSIGN$5 && type !== HYPHENMINUS$2) {
      this.error("Number sign is expected");
    }
  }

  checkTokenIsInteger.call(this, sign !== 0);
  return sign === HYPHENMINUS$2
    ? "-" + this.consume(types$I.Number)
    : this.consume(types$I.Number);
}

// An+B microsyntax https://www.w3.org/TR/css-syntax-3/#anb
const name$E = "AnPlusB";
const structure$D = {
  a: [String, null],
  b: [String, null],
};

function parse$L() {
  /* eslint-disable brace-style*/
  const start = this.tokenStart;
  let a = null;
  let b = null;

  // <integer>
  if (this.tokenType === types$I.Number) {
    checkTokenIsInteger.call(this, ALLOW_SIGN);
    b = this.consume(types$I.Number);
  }

  // -n
  // -n <signed-integer>
  // -n ['+' | '-'] <signless-integer>
  // -n- <signless-integer>
  // <dashndashdigit-ident>
  else if (
    this.tokenType === types$I.Ident &&
    this.cmpChar(this.tokenStart, HYPHENMINUS$2)
  ) {
    a = "-1";

    expectCharCode.call(this, 1, N);

    switch (this.tokenEnd - this.tokenStart) {
      // -n
      // -n <signed-integer>
      // -n ['+' | '-'] <signless-integer>
      case 2:
        this.next();
        b = consumeB.call(this);
        break;

      // -n- <signless-integer>
      case 3:
        expectCharCode.call(this, 2, HYPHENMINUS$2);

        this.next();
        this.skipSC();

        checkTokenIsInteger.call(this, DISALLOW_SIGN);

        b = "-" + this.consume(types$I.Number);
        break;

      // <dashndashdigit-ident>
      default:
        expectCharCode.call(this, 2, HYPHENMINUS$2);
        checkInteger.call(this, 3, DISALLOW_SIGN);
        this.next();

        b = this.substrToCursor(start + 2);
    }
  }

  // '+'? n
  // '+'? n <signed-integer>
  // '+'? n ['+' | '-'] <signless-integer>
  // '+'? n- <signless-integer>
  // '+'? <ndashdigit-ident>
  else if (
    this.tokenType === types$I.Ident ||
    (this.isDelim(PLUSSIGN$5) && this.lookupType(1) === types$I.Ident)
  ) {
    let sign = 0;
    a = "1";

    // just ignore a plus
    if (this.isDelim(PLUSSIGN$5)) {
      sign = 1;
      this.next();
    }

    expectCharCode.call(this, 0, N);

    switch (this.tokenEnd - this.tokenStart) {
      // '+'? n
      // '+'? n <signed-integer>
      // '+'? n ['+' | '-'] <signless-integer>
      case 1:
        this.next();
        b = consumeB.call(this);
        break;

      // '+'? n- <signless-integer>
      case 2:
        expectCharCode.call(this, 1, HYPHENMINUS$2);

        this.next();
        this.skipSC();

        checkTokenIsInteger.call(this, DISALLOW_SIGN);

        b = "-" + this.consume(types$I.Number);
        break;

      // '+'? <ndashdigit-ident>
      default:
        expectCharCode.call(this, 1, HYPHENMINUS$2);
        checkInteger.call(this, 2, DISALLOW_SIGN);
        this.next();

        b = this.substrToCursor(start + sign + 1);
    }
  }

  // <ndashdigit-dimension>
  // <ndash-dimension> <signless-integer>
  // <n-dimension>
  // <n-dimension> <signed-integer>
  // <n-dimension> ['+' | '-'] <signless-integer>
  else if (this.tokenType === types$I.Dimension) {
    const code = this.charCodeAt(this.tokenStart);
    const sign = code === PLUSSIGN$5 || code === HYPHENMINUS$2;
    let i = this.tokenStart + sign;

    for (; i < this.tokenEnd; i++) {
      if (!charCodeDefinitions$5.isDigit(this.charCodeAt(i))) {
        break;
      }
    }

    if (i === this.tokenStart + sign) {
      this.error("Integer is expected", this.tokenStart + sign);
    }

    expectCharCode.call(this, i - this.tokenStart, N);
    a = this.substring(start, i);

    // <n-dimension>
    // <n-dimension> <signed-integer>
    // <n-dimension> ['+' | '-'] <signless-integer>
    if (i + 1 === this.tokenEnd) {
      this.next();
      b = consumeB.call(this);
    } else {
      expectCharCode.call(this, i - this.tokenStart + 1, HYPHENMINUS$2);

      // <ndash-dimension> <signless-integer>
      if (i + 2 === this.tokenEnd) {
        this.next();
        this.skipSC();
        checkTokenIsInteger.call(this, DISALLOW_SIGN);
        b = "-" + this.consume(types$I.Number);
      }
      // <ndashdigit-dimension>
      else {
        checkInteger.call(this, i - this.tokenStart + 2, DISALLOW_SIGN);
        this.next();
        b = this.substrToCursor(i + 1);
      }
    }
  } else {
    this.error();
  }

  if (a !== null && a.charCodeAt(0) === PLUSSIGN$5) {
    a = a.substr(1);
  }

  if (b !== null && b.charCodeAt(0) === PLUSSIGN$5) {
    b = b.substr(1);
  }

  return {
    type: "AnPlusB",
    loc: this.getLocation(start, this.tokenStart),
    a,
    b,
  };
}

function generate$H(node) {
  if (node.a) {
    const a =
      (node.a === "+1" && "n") ||
      (node.a === "1" && "n") ||
      (node.a === "-1" && "-n") ||
      node.a + "n";

    if (node.b) {
      const b = node.b[0] === "-" || node.b[0] === "+" ? node.b : "+" + node.b;
      this.tokenize(a + b);
    } else {
      this.tokenize(a);
    }
  } else {
    this.tokenize(node.b);
  }
}

AnPlusB$2.generate = generate$H;
AnPlusB$2.name = name$E;
AnPlusB$2.parse = parse$L;
AnPlusB$2.structure = structure$D;

var Atrule$6 = {};

const types$H = types$U;

function consumeRaw$5(startToken) {
  return this.Raw(
    startToken,
    this.consumeUntilLeftCurlyBracketOrSemicolon,
    true,
  );
}

function isDeclarationBlockAtrule() {
  for (let offset = 1, type; (type = this.lookupType(offset)); offset++) {
    if (type === types$H.RightCurlyBracket) {
      return true;
    }

    if (type === types$H.LeftCurlyBracket || type === types$H.AtKeyword) {
      return false;
    }
  }

  return false;
}

const name$D = "Atrule";
const walkContext$9 = "atrule";
const structure$C = {
  name: String,
  prelude: ["AtrulePrelude", "Raw", null],
  block: ["Block", null],
};

function parse$K() {
  const start = this.tokenStart;
  let name;
  let nameLowerCase;
  let prelude = null;
  let block = null;

  this.eat(types$H.AtKeyword);

  name = this.substrToCursor(start + 1);
  nameLowerCase = name.toLowerCase();
  this.skipSC();

  // parse prelude
  if (
    this.eof === false &&
    this.tokenType !== types$H.LeftCurlyBracket &&
    this.tokenType !== types$H.Semicolon
  ) {
    if (this.parseAtrulePrelude) {
      prelude = this.parseWithFallback(
        this.AtrulePrelude.bind(this, name),
        consumeRaw$5,
      );
    } else {
      prelude = consumeRaw$5.call(this, this.tokenIndex);
    }

    this.skipSC();
  }

  switch (this.tokenType) {
    case types$H.Semicolon:
      this.next();
      break;

    case types$H.LeftCurlyBracket:
      if (
        hasOwnProperty.call(this.atrule, nameLowerCase) &&
        typeof this.atrule[nameLowerCase].block === "function"
      ) {
        block = this.atrule[nameLowerCase].block.call(this);
      } else {
        // TODO: should consume block content as Raw?
        block = this.Block(isDeclarationBlockAtrule.call(this));
      }

      break;
  }

  return {
    type: "Atrule",
    loc: this.getLocation(start, this.tokenStart),
    name,
    prelude,
    block,
  };
}

function generate$G(node) {
  this.token(types$H.AtKeyword, "@" + node.name);

  if (node.prelude !== null) {
    this.node(node.prelude);
  }

  if (node.block) {
    this.node(node.block);
  } else {
    this.token(types$H.Semicolon, ";");
  }
}

Atrule$6.generate = generate$G;
Atrule$6.name = name$D;
Atrule$6.parse = parse$K;
Atrule$6.structure = structure$C;
Atrule$6.walkContext = walkContext$9;

var AtrulePrelude$2 = {};

const types$G = types$U;

const name$C = "AtrulePrelude";
const walkContext$8 = "atrulePrelude";
const structure$B = {
  children: [[]],
};

function parse$J(name) {
  let children = null;

  if (name !== null) {
    name = name.toLowerCase();
  }

  this.skipSC();

  if (
    hasOwnProperty.call(this.atrule, name) &&
    typeof this.atrule[name].prelude === "function"
  ) {
    // custom consumer
    children = this.atrule[name].prelude.call(this);
  } else {
    // default consumer
    children = this.readSequence(this.scope.AtrulePrelude);
  }

  this.skipSC();

  if (
    this.eof !== true &&
    this.tokenType !== types$G.LeftCurlyBracket &&
    this.tokenType !== types$G.Semicolon
  ) {
    this.error("Semicolon or block is expected");
  }

  return {
    type: "AtrulePrelude",
    loc: this.getLocationFromList(children),
    children,
  };
}

function generate$F(node) {
  this.children(node);
}

AtrulePrelude$2.generate = generate$F;
AtrulePrelude$2.name = name$C;
AtrulePrelude$2.parse = parse$J;
AtrulePrelude$2.structure = structure$B;
AtrulePrelude$2.walkContext = walkContext$8;

var AttributeSelector$4 = {};

const types$F = types$U;

const DOLLARSIGN$1 = 0x0024; // U+0024 DOLLAR SIGN ($)
const ASTERISK$5 = 0x002a; // U+002A ASTERISK (*)
const EQUALSSIGN = 0x003d; // U+003D EQUALS SIGN (=)
const CIRCUMFLEXACCENT = 0x005e; // U+005E (^)
const VERTICALLINE$2 = 0x007c; // U+007C VERTICAL LINE (|)
const TILDE$2 = 0x007e; // U+007E TILDE (~)

function getAttributeName() {
  if (this.eof) {
    this.error("Unexpected end of input");
  }

  const start = this.tokenStart;
  let expectIdent = false;

  if (this.isDelim(ASTERISK$5)) {
    expectIdent = true;
    this.next();
  } else if (!this.isDelim(VERTICALLINE$2)) {
    this.eat(types$F.Ident);
  }

  if (this.isDelim(VERTICALLINE$2)) {
    if (this.charCodeAt(this.tokenStart + 1) !== EQUALSSIGN) {
      this.next();
      this.eat(types$F.Ident);
    } else if (expectIdent) {
      this.error("Identifier is expected", this.tokenEnd);
    }
  } else if (expectIdent) {
    this.error("Vertical line is expected");
  }

  return {
    type: "Identifier",
    loc: this.getLocation(start, this.tokenStart),
    name: this.substrToCursor(start),
  };
}

function getOperator() {
  const start = this.tokenStart;
  const code = this.charCodeAt(start);

  if (
    code !== EQUALSSIGN && // =
    code !== TILDE$2 && // ~=
    code !== CIRCUMFLEXACCENT && // ^=
    code !== DOLLARSIGN$1 && // $=
    code !== ASTERISK$5 && // *=
    code !== VERTICALLINE$2 // |=
  ) {
    this.error("Attribute selector (=, ~=, ^=, $=, *=, |=) is expected");
  }

  this.next();

  if (code !== EQUALSSIGN) {
    if (!this.isDelim(EQUALSSIGN)) {
      this.error("Equal sign is expected");
    }

    this.next();
  }

  return this.substrToCursor(start);
}

// '[' <wq-name> ']'
// '[' <wq-name> <attr-matcher> [ <string-token> | <ident-token> ] <attr-modifier>? ']'
const name$B = "AttributeSelector";
const structure$A = {
  name: "Identifier",
  matcher: [String, null],
  value: ["String", "Identifier", null],
  flags: [String, null],
};

function parse$I() {
  const start = this.tokenStart;
  let name;
  let matcher = null;
  let value = null;
  let flags = null;

  this.eat(types$F.LeftSquareBracket);
  this.skipSC();

  name = getAttributeName.call(this);
  this.skipSC();

  if (this.tokenType !== types$F.RightSquareBracket) {
    // avoid case `[name i]`
    if (this.tokenType !== types$F.Ident) {
      matcher = getOperator.call(this);

      this.skipSC();

      value =
        this.tokenType === types$F.String ? this.String() : this.Identifier();

      this.skipSC();
    }

    // attribute flags
    if (this.tokenType === types$F.Ident) {
      flags = this.consume(types$F.Ident);

      this.skipSC();
    }
  }

  this.eat(types$F.RightSquareBracket);

  return {
    type: "AttributeSelector",
    loc: this.getLocation(start, this.tokenStart),
    name,
    matcher,
    value,
    flags,
  };
}

function generate$E(node) {
  this.token(types$F.Delim, "[");
  this.node(node.name);

  if (node.matcher !== null) {
    this.tokenize(node.matcher);
    this.node(node.value);
  }

  if (node.flags !== null) {
    this.token(types$F.Ident, node.flags);
  }

  this.token(types$F.Delim, "]");
}

AttributeSelector$4.generate = generate$E;
AttributeSelector$4.name = name$B;
AttributeSelector$4.parse = parse$I;
AttributeSelector$4.structure = structure$A;

var Block$2 = {};

const types$E = types$U;

function consumeRaw$4(startToken) {
  return this.Raw(startToken, null, true);
}
function consumeRule() {
  return this.parseWithFallback(this.Rule, consumeRaw$4);
}
function consumeRawDeclaration(startToken) {
  return this.Raw(startToken, this.consumeUntilSemicolonIncluded, true);
}
function consumeDeclaration() {
  if (this.tokenType === types$E.Semicolon) {
    return consumeRawDeclaration.call(this, this.tokenIndex);
  }

  const node = this.parseWithFallback(this.Declaration, consumeRawDeclaration);

  if (this.tokenType === types$E.Semicolon) {
    this.next();
  }

  return node;
}

const name$A = "Block";
const walkContext$7 = "block";
const structure$z = {
  children: [["Atrule", "Rule", "Declaration"]],
};

function parse$H(isDeclaration) {
  const consumer = isDeclaration ? consumeDeclaration : consumeRule;
  const start = this.tokenStart;
  let children = this.createList();

  this.eat(types$E.LeftCurlyBracket);

  scan: while (!this.eof) {
    switch (this.tokenType) {
      case types$E.RightCurlyBracket:
        break scan;

      case types$E.WhiteSpace:
      case types$E.Comment:
        this.next();
        break;

      case types$E.AtKeyword:
        children.push(this.parseWithFallback(this.Atrule, consumeRaw$4));
        break;

      default:
        children.push(consumer.call(this));
    }
  }

  if (!this.eof) {
    this.eat(types$E.RightCurlyBracket);
  }

  return {
    type: "Block",
    loc: this.getLocation(start, this.tokenStart),
    children,
  };
}

function generate$D(node) {
  this.token(types$E.LeftCurlyBracket, "{");
  this.children(node, (prev) => {
    if (prev.type === "Declaration") {
      this.token(types$E.Semicolon, ";");
    }
  });
  this.token(types$E.RightCurlyBracket, "}");
}

Block$2.generate = generate$D;
Block$2.name = name$A;
Block$2.parse = parse$H;
Block$2.structure = structure$z;
Block$2.walkContext = walkContext$7;

var Brackets$2 = {};

const types$D = types$U;

const name$z = "Brackets";
const structure$y = {
  children: [[]],
};

function parse$G(readSequence, recognizer) {
  const start = this.tokenStart;
  let children = null;

  this.eat(types$D.LeftSquareBracket);

  children = readSequence.call(this, recognizer);

  if (!this.eof) {
    this.eat(types$D.RightSquareBracket);
  }

  return {
    type: "Brackets",
    loc: this.getLocation(start, this.tokenStart),
    children,
  };
}

function generate$C(node) {
  this.token(types$D.Delim, "[");
  this.children(node);
  this.token(types$D.Delim, "]");
}

Brackets$2.generate = generate$C;
Brackets$2.name = name$z;
Brackets$2.parse = parse$G;
Brackets$2.structure = structure$y;

var CDC$2 = {};

const types$C = types$U;

const name$y = "CDC";
const structure$x = [];

function parse$F() {
  const start = this.tokenStart;

  this.eat(types$C.CDC); // -->

  return {
    type: "CDC",
    loc: this.getLocation(start, this.tokenStart),
  };
}

function generate$B() {
  this.token(types$C.CDC, "-->");
}

CDC$2.generate = generate$B;
CDC$2.name = name$y;
CDC$2.parse = parse$F;
CDC$2.structure = structure$x;

var CDO$2 = {};

const types$B = types$U;

const name$x = "CDO";
const structure$w = [];

function parse$E() {
  const start = this.tokenStart;

  this.eat(types$B.CDO); // <!--

  return {
    type: "CDO",
    loc: this.getLocation(start, this.tokenStart),
  };
}

function generate$A() {
  this.token(types$B.CDO, "<!--");
}

CDO$2.generate = generate$A;
CDO$2.name = name$x;
CDO$2.parse = parse$E;
CDO$2.structure = structure$w;

var ClassSelector$2 = {};

const types$A = types$U;

const FULLSTOP$2 = 0x002e; // U+002E FULL STOP (.)

// '.' ident
const name$w = "ClassSelector";
const structure$v = {
  name: String,
};

function parse$D() {
  this.eatDelim(FULLSTOP$2);

  return {
    type: "ClassSelector",
    loc: this.getLocation(this.tokenStart - 1, this.tokenEnd),
    name: this.consume(types$A.Ident),
  };
}

function generate$z(node) {
  this.token(types$A.Delim, ".");
  this.token(types$A.Ident, node.name);
}

ClassSelector$2.generate = generate$z;
ClassSelector$2.name = name$w;
ClassSelector$2.parse = parse$D;
ClassSelector$2.structure = structure$v;

var Combinator$2 = {};

const types$z = types$U;

const PLUSSIGN$4 = 0x002b; // U+002B PLUS SIGN (+)
const SOLIDUS$5 = 0x002f; // U+002F SOLIDUS (/)
const GREATERTHANSIGN$1 = 0x003e; // U+003E GREATER-THAN SIGN (>)
const TILDE$1 = 0x007e; // U+007E TILDE (~)

const name$v = "Combinator";
const structure$u = {
  name: String,
};

// + | > | ~ | /deep/
function parse$C() {
  const start = this.tokenStart;
  let name;

  switch (this.tokenType) {
    case types$z.WhiteSpace:
      name = " ";
      break;

    case types$z.Delim:
      switch (this.charCodeAt(this.tokenStart)) {
        case GREATERTHANSIGN$1:
        case PLUSSIGN$4:
        case TILDE$1:
          this.next();
          break;

        case SOLIDUS$5:
          this.next();
          this.eatIdent("deep");
          this.eatDelim(SOLIDUS$5);
          break;

        default:
          this.error("Combinator is expected");
      }

      name = this.substrToCursor(start);
      break;
  }

  return {
    type: "Combinator",
    loc: this.getLocation(start, this.tokenStart),
    name,
  };
}

function generate$y(node) {
  this.tokenize(node.name);
}

Combinator$2.generate = generate$y;
Combinator$2.name = name$v;
Combinator$2.parse = parse$C;
Combinator$2.structure = structure$u;

var Comment$4 = {};

const types$y = types$U;

const ASTERISK$4 = 0x002a; // U+002A ASTERISK (*)
const SOLIDUS$4 = 0x002f; // U+002F SOLIDUS (/)

const name$u = "Comment";
const structure$t = {
  value: String,
};

function parse$B() {
  const start = this.tokenStart;
  let end = this.tokenEnd;

  this.eat(types$y.Comment);

  if (
    end - start + 2 >= 2 &&
    this.charCodeAt(end - 2) === ASTERISK$4 &&
    this.charCodeAt(end - 1) === SOLIDUS$4
  ) {
    end -= 2;
  }

  return {
    type: "Comment",
    loc: this.getLocation(start, this.tokenStart),
    value: this.substring(start + 2, end),
  };
}

function generate$x(node) {
  this.token(types$y.Comment, "/*" + node.value + "*/");
}

Comment$4.generate = generate$x;
Comment$4.name = name$u;
Comment$4.parse = parse$B;
Comment$4.structure = structure$t;

var Declaration$4 = {};

const names$2 = names$4;
const types$x = types$U;

const EXCLAMATIONMARK$1 = 0x0021; // U+0021 EXCLAMATION MARK (!)
const NUMBERSIGN$2 = 0x0023; // U+0023 NUMBER SIGN (#)
const DOLLARSIGN = 0x0024; // U+0024 DOLLAR SIGN ($)
const AMPERSAND = 0x0026; // U+0026 AMPERSAND (&)
const ASTERISK$3 = 0x002a; // U+002A ASTERISK (*)
const PLUSSIGN$3 = 0x002b; // U+002B PLUS SIGN (+)
const SOLIDUS$3 = 0x002f; // U+002F SOLIDUS (/)

function consumeValueRaw(startToken) {
  return this.Raw(
    startToken,
    this.consumeUntilExclamationMarkOrSemicolon,
    true,
  );
}

function consumeCustomPropertyRaw(startToken) {
  return this.Raw(
    startToken,
    this.consumeUntilExclamationMarkOrSemicolon,
    false,
  );
}

function consumeValue() {
  const startValueToken = this.tokenIndex;
  const value = this.Value();

  if (
    value.type !== "Raw" &&
    this.eof === false &&
    this.tokenType !== types$x.Semicolon &&
    this.isDelim(EXCLAMATIONMARK$1) === false &&
    this.isBalanceEdge(startValueToken) === false
  ) {
    this.error();
  }

  return value;
}

const name$t = "Declaration";
const walkContext$6 = "declaration";
const structure$s = {
  important: [Boolean, String],
  property: String,
  value: ["Value", "Raw"],
};

function parse$A() {
  const start = this.tokenStart;
  const startToken = this.tokenIndex;
  const property = readProperty.call(this);
  const customProperty = names$2.isCustomProperty(property);
  const parseValue = customProperty
    ? this.parseCustomProperty
    : this.parseValue;
  const consumeRaw = customProperty
    ? consumeCustomPropertyRaw
    : consumeValueRaw;
  let important = false;
  let value;

  this.skipSC();
  this.eat(types$x.Colon);

  const valueStart = this.tokenIndex;

  if (!customProperty) {
    this.skipSC();
  }

  if (parseValue) {
    value = this.parseWithFallback(consumeValue, consumeRaw);
  } else {
    value = consumeRaw.call(this, this.tokenIndex);
  }

  if (customProperty && value.type === "Value" && value.children.isEmpty) {
    for (let offset = valueStart - this.tokenIndex; offset <= 0; offset++) {
      if (this.lookupType(offset) === types$x.WhiteSpace) {
        value.children.appendData({
          type: "WhiteSpace",
          loc: null,
          value: " ",
        });
        break;
      }
    }
  }

  if (this.isDelim(EXCLAMATIONMARK$1)) {
    important = getImportant.call(this);
    this.skipSC();
  }

  // Do not include semicolon to range per spec
  // https://drafts.csswg.org/css-syntax/#declaration-diagram

  if (
    this.eof === false &&
    this.tokenType !== types$x.Semicolon &&
    this.isBalanceEdge(startToken) === false
  ) {
    this.error();
  }

  return {
    type: "Declaration",
    loc: this.getLocation(start, this.tokenStart),
    important,
    property,
    value,
  };
}

function generate$w(node) {
  this.token(types$x.Ident, node.property);
  this.token(types$x.Colon, ":");
  this.node(node.value);

  if (node.important) {
    this.token(types$x.Delim, "!");
    this.token(
      types$x.Ident,
      node.important === true ? "important" : node.important,
    );
  }
}

function readProperty() {
  const start = this.tokenStart;

  // hacks
  if (this.tokenType === types$x.Delim) {
    switch (this.charCodeAt(this.tokenStart)) {
      case ASTERISK$3:
      case DOLLARSIGN:
      case PLUSSIGN$3:
      case NUMBERSIGN$2:
      case AMPERSAND:
        this.next();
        break;

      // TODO: not sure we should support this hack
      case SOLIDUS$3:
        this.next();
        if (this.isDelim(SOLIDUS$3)) {
          this.next();
        }
        break;
    }
  }

  if (this.tokenType === types$x.Hash) {
    this.eat(types$x.Hash);
  } else {
    this.eat(types$x.Ident);
  }

  return this.substrToCursor(start);
}

// ! ws* important
function getImportant() {
  this.eat(types$x.Delim);
  this.skipSC();

  const important = this.consume(types$x.Ident);

  // store original value in case it differ from `important`
  // for better original source restoring and hacks like `!ie` support
  return important === "important" ? true : important;
}

Declaration$4.generate = generate$w;
Declaration$4.name = name$t;
Declaration$4.parse = parse$A;
Declaration$4.structure = structure$s;
Declaration$4.walkContext = walkContext$6;

var DeclarationList$2 = {};

const types$w = types$U;

function consumeRaw$3(startToken) {
  return this.Raw(startToken, this.consumeUntilSemicolonIncluded, true);
}

const name$s = "DeclarationList";
const structure$r = {
  children: [["Declaration"]],
};

function parse$z() {
  const children = this.createList();

  while (!this.eof) {
    switch (this.tokenType) {
      case types$w.WhiteSpace:
      case types$w.Comment:
      case types$w.Semicolon:
        this.next();
        break;

      default:
        children.push(this.parseWithFallback(this.Declaration, consumeRaw$3));
    }
  }

  return {
    type: "DeclarationList",
    loc: this.getLocationFromList(children),
    children,
  };
}

function generate$v(node) {
  this.children(node, (prev) => {
    if (prev.type === "Declaration") {
      this.token(types$w.Semicolon, ";");
    }
  });
}

DeclarationList$2.generate = generate$v;
DeclarationList$2.name = name$s;
DeclarationList$2.parse = parse$z;
DeclarationList$2.structure = structure$r;

var Dimension$4 = {};

const types$v = types$U;

const name$r = "Dimension";
const structure$q = {
  value: String,
  unit: String,
};

function parse$y() {
  const start = this.tokenStart;
  const value = this.consumeNumber(types$v.Dimension);

  return {
    type: "Dimension",
    loc: this.getLocation(start, this.tokenStart),
    value,
    unit: this.substring(start + value.length, this.tokenStart),
  };
}

function generate$u(node) {
  this.token(types$v.Dimension, node.value + node.unit);
}

Dimension$4.generate = generate$u;
Dimension$4.name = name$r;
Dimension$4.parse = parse$y;
Dimension$4.structure = structure$q;

var _Function = {};

const types$u = types$U;

const name$q = "Function";
const walkContext$5 = "function";
const structure$p = {
  name: String,
  children: [[]],
};

// <function-token> <sequence> )
function parse$x(readSequence, recognizer) {
  const start = this.tokenStart;
  const name = this.consumeFunctionName();
  const nameLowerCase = name.toLowerCase();
  let children;

  children = recognizer.hasOwnProperty(nameLowerCase)
    ? recognizer[nameLowerCase].call(this, recognizer)
    : readSequence.call(this, recognizer);

  if (!this.eof) {
    this.eat(types$u.RightParenthesis);
  }

  return {
    type: "Function",
    loc: this.getLocation(start, this.tokenStart),
    name,
    children,
  };
}

function generate$t(node) {
  this.token(types$u.Function, node.name + "(");
  this.children(node);
  this.token(types$u.RightParenthesis, ")");
}

_Function.generate = generate$t;
_Function.name = name$q;
_Function.parse = parse$x;
_Function.structure = structure$p;
_Function.walkContext = walkContext$5;

var Hash$2 = {};

const types$t = types$U;

// '#' ident
const xxx = "XXX";
const name$p = "Hash";
const structure$o = {
  value: String,
};
function parse$w() {
  const start = this.tokenStart;

  this.eat(types$t.Hash);

  return {
    type: "Hash",
    loc: this.getLocation(start, this.tokenStart),
    value: this.substrToCursor(start + 1),
  };
}
function generate$s(node) {
  this.token(types$t.Hash, "#" + node.value);
}

Hash$2.generate = generate$s;
Hash$2.name = name$p;
Hash$2.parse = parse$w;
Hash$2.structure = structure$o;
Hash$2.xxx = xxx;

var Identifier$2 = {};

const types$s = types$U;

const name$o = "Identifier";
const structure$n = {
  name: String,
};

function parse$v() {
  return {
    type: "Identifier",
    loc: this.getLocation(this.tokenStart, this.tokenEnd),
    name: this.consume(types$s.Ident),
  };
}

function generate$r(node) {
  this.token(types$s.Ident, node.name);
}

Identifier$2.generate = generate$r;
Identifier$2.name = name$o;
Identifier$2.parse = parse$v;
Identifier$2.structure = structure$n;

var IdSelector$2 = {};

const types$r = types$U;

const name$n = "IdSelector";
const structure$m = {
  name: String,
};

function parse$u() {
  const start = this.tokenStart;

  // TODO: check value is an ident
  this.eat(types$r.Hash);

  return {
    type: "IdSelector",
    loc: this.getLocation(start, this.tokenStart),
    name: this.substrToCursor(start + 1),
  };
}

function generate$q(node) {
  // Using Delim instead of Hash is a hack to avoid for a whitespace between ident and id-selector
  // in safe mode (e.g. "a#id"), because IE11 doesn't allow a sequence <ident-token> <hash-token>
  // without a whitespace in values (e.g. "1px solid#000")
  this.token(types$r.Delim, "#" + node.name);
}

IdSelector$2.generate = generate$q;
IdSelector$2.name = name$n;
IdSelector$2.parse = parse$u;
IdSelector$2.structure = structure$m;

var MediaFeature$2 = {};

const types$q = types$U;

const name$m = "MediaFeature";
const structure$l = {
  name: String,
  value: ["Identifier", "Number", "Dimension", "Ratio", null],
};

function parse$t() {
  const start = this.tokenStart;
  let name;
  let value = null;

  this.eat(types$q.LeftParenthesis);
  this.skipSC();

  name = this.consume(types$q.Ident);
  this.skipSC();

  if (this.tokenType !== types$q.RightParenthesis) {
    this.eat(types$q.Colon);
    this.skipSC();

    switch (this.tokenType) {
      case types$q.Number:
        if (this.lookupNonWSType(1) === types$q.Delim) {
          value = this.Ratio();
        } else {
          value = this.Number();
        }

        break;

      case types$q.Dimension:
        value = this.Dimension();
        break;

      case types$q.Ident:
        value = this.Identifier();
        break;

      default:
        this.error("Number, dimension, ratio or identifier is expected");
    }

    this.skipSC();
  }

  this.eat(types$q.RightParenthesis);

  return {
    type: "MediaFeature",
    loc: this.getLocation(start, this.tokenStart),
    name,
    value,
  };
}

function generate$p(node) {
  this.token(types$q.LeftParenthesis, "(");
  this.token(types$q.Ident, node.name);

  if (node.value !== null) {
    this.token(types$q.Colon, ":");
    this.node(node.value);
  }

  this.token(types$q.RightParenthesis, ")");
}

MediaFeature$2.generate = generate$p;
MediaFeature$2.name = name$m;
MediaFeature$2.parse = parse$t;
MediaFeature$2.structure = structure$l;

var MediaQuery$2 = {};

const types$p = types$U;

const name$l = "MediaQuery";
const structure$k = {
  children: [["Identifier", "MediaFeature", "WhiteSpace"]],
};

function parse$s() {
  const children = this.createList();
  let child = null;

  this.skipSC();

  scan: while (!this.eof) {
    switch (this.tokenType) {
      case types$p.Comment:
      case types$p.WhiteSpace:
        this.next();
        continue;

      case types$p.Ident:
        child = this.Identifier();
        break;

      case types$p.LeftParenthesis:
        child = this.MediaFeature();
        break;

      default:
        break scan;
    }

    children.push(child);
  }

  if (child === null) {
    this.error("Identifier or parenthesis is expected");
  }

  return {
    type: "MediaQuery",
    loc: this.getLocationFromList(children),
    children,
  };
}

function generate$o(node) {
  this.children(node);
}

MediaQuery$2.generate = generate$o;
MediaQuery$2.name = name$l;
MediaQuery$2.parse = parse$s;
MediaQuery$2.structure = structure$k;

var MediaQueryList$2 = {};

const types$o = types$U;

const name$k = "MediaQueryList";
const structure$j = {
  children: [["MediaQuery"]],
};

function parse$r() {
  const children = this.createList();

  this.skipSC();

  while (!this.eof) {
    children.push(this.MediaQuery());

    if (this.tokenType !== types$o.Comma) {
      break;
    }

    this.next();
  }

  return {
    type: "MediaQueryList",
    loc: this.getLocationFromList(children),
    children,
  };
}

function generate$n(node) {
  this.children(node, () => this.token(types$o.Comma, ","));
}

MediaQueryList$2.generate = generate$n;
MediaQueryList$2.name = name$k;
MediaQueryList$2.parse = parse$r;
MediaQueryList$2.structure = structure$j;

var Nth$2 = {};

const types$n = types$U;

const name$j = "Nth";
const structure$i = {
  nth: ["AnPlusB", "Identifier"],
  selector: ["SelectorList", null],
};

function parse$q() {
  this.skipSC();

  const start = this.tokenStart;
  let end = start;
  let selector = null;
  let nth;

  if (this.lookupValue(0, "odd") || this.lookupValue(0, "even")) {
    nth = this.Identifier();
  } else {
    nth = this.AnPlusB();
  }

  end = this.tokenStart;
  this.skipSC();

  if (this.lookupValue(0, "of")) {
    this.next();

    selector = this.SelectorList();
    end = this.tokenStart;
  }

  return {
    type: "Nth",
    loc: this.getLocation(start, end),
    nth,
    selector,
  };
}

function generate$m(node) {
  this.node(node.nth);
  if (node.selector !== null) {
    this.token(types$n.Ident, "of");
    this.node(node.selector);
  }
}

Nth$2.generate = generate$m;
Nth$2.name = name$j;
Nth$2.parse = parse$q;
Nth$2.structure = structure$i;

var _Number$5 = {};

const types$m = types$U;

const name$i = "Number";
const structure$h = {
  value: String,
};

function parse$p() {
  return {
    type: "Number",
    loc: this.getLocation(this.tokenStart, this.tokenEnd),
    value: this.consume(types$m.Number),
  };
}

function generate$l(node) {
  this.token(types$m.Number, node.value);
}

_Number$5.generate = generate$l;
_Number$5.name = name$i;
_Number$5.parse = parse$p;
_Number$5.structure = structure$h;

var Operator$2 = {};

// '/' | '*' | ',' | ':' | '+' | '-'
const name$h = "Operator";
const structure$g = {
  value: String,
};

function parse$o() {
  const start = this.tokenStart;

  this.next();

  return {
    type: "Operator",
    loc: this.getLocation(start, this.tokenStart),
    value: this.substrToCursor(start),
  };
}

function generate$k(node) {
  this.tokenize(node.value);
}

Operator$2.generate = generate$k;
Operator$2.name = name$h;
Operator$2.parse = parse$o;
Operator$2.structure = structure$g;

var Parentheses$2 = {};

const types$l = types$U;

const name$g = "Parentheses";
const structure$f = {
  children: [[]],
};

function parse$n(readSequence, recognizer) {
  const start = this.tokenStart;
  let children = null;

  this.eat(types$l.LeftParenthesis);

  children = readSequence.call(this, recognizer);

  if (!this.eof) {
    this.eat(types$l.RightParenthesis);
  }

  return {
    type: "Parentheses",
    loc: this.getLocation(start, this.tokenStart),
    children,
  };
}

function generate$j(node) {
  this.token(types$l.LeftParenthesis, "(");
  this.children(node);
  this.token(types$l.RightParenthesis, ")");
}

Parentheses$2.generate = generate$j;
Parentheses$2.name = name$g;
Parentheses$2.parse = parse$n;
Parentheses$2.structure = structure$f;

var Percentage$4 = {};

const types$k = types$U;

const name$f = "Percentage";
const structure$e = {
  value: String,
};

function parse$m() {
  return {
    type: "Percentage",
    loc: this.getLocation(this.tokenStart, this.tokenEnd),
    value: this.consumeNumber(types$k.Percentage),
  };
}

function generate$i(node) {
  this.token(types$k.Percentage, node.value + "%");
}

Percentage$4.generate = generate$i;
Percentage$4.name = name$f;
Percentage$4.parse = parse$m;
Percentage$4.structure = structure$e;

var PseudoClassSelector$2 = {};

const types$j = types$U;

const name$e = "PseudoClassSelector";
const walkContext$4 = "function";
const structure$d = {
  name: String,
  children: [["Raw"], null],
};

// : [ <ident> | <function-token> <any-value>? ) ]
function parse$l() {
  const start = this.tokenStart;
  let children = null;
  let name;
  let nameLowerCase;

  this.eat(types$j.Colon);

  if (this.tokenType === types$j.Function) {
    name = this.consumeFunctionName();
    nameLowerCase = name.toLowerCase();

    if (hasOwnProperty.call(this.pseudo, nameLowerCase)) {
      this.skipSC();
      children = this.pseudo[nameLowerCase].call(this);
      this.skipSC();
    } else {
      children = this.createList();
      children.push(this.Raw(this.tokenIndex, null, false));
    }

    this.eat(types$j.RightParenthesis);
  } else {
    name = this.consume(types$j.Ident);
  }

  return {
    type: "PseudoClassSelector",
    loc: this.getLocation(start, this.tokenStart),
    name,
    children,
  };
}

function generate$h(node) {
  this.token(types$j.Colon, ":");

  if (node.children === null) {
    this.token(types$j.Ident, node.name);
  } else {
    this.token(types$j.Function, node.name + "(");
    this.children(node);
    this.token(types$j.RightParenthesis, ")");
  }
}

PseudoClassSelector$2.generate = generate$h;
PseudoClassSelector$2.name = name$e;
PseudoClassSelector$2.parse = parse$l;
PseudoClassSelector$2.structure = structure$d;
PseudoClassSelector$2.walkContext = walkContext$4;

var PseudoElementSelector$2 = {};

const types$i = types$U;

const name$d = "PseudoElementSelector";
const walkContext$3 = "function";
const structure$c = {
  name: String,
  children: [["Raw"], null],
};

// :: [ <ident> | <function-token> <any-value>? ) ]
function parse$k() {
  const start = this.tokenStart;
  let children = null;
  let name;
  let nameLowerCase;

  this.eat(types$i.Colon);
  this.eat(types$i.Colon);

  if (this.tokenType === types$i.Function) {
    name = this.consumeFunctionName();
    nameLowerCase = name.toLowerCase();

    if (hasOwnProperty.call(this.pseudo, nameLowerCase)) {
      this.skipSC();
      children = this.pseudo[nameLowerCase].call(this);
      this.skipSC();
    } else {
      children = this.createList();
      children.push(this.Raw(this.tokenIndex, null, false));
    }

    this.eat(types$i.RightParenthesis);
  } else {
    name = this.consume(types$i.Ident);
  }

  return {
    type: "PseudoElementSelector",
    loc: this.getLocation(start, this.tokenStart),
    name,
    children,
  };
}

function generate$g(node) {
  this.token(types$i.Colon, ":");
  this.token(types$i.Colon, ":");

  if (node.children === null) {
    this.token(types$i.Ident, node.name);
  } else {
    this.token(types$i.Function, node.name + "(");
    this.children(node);
    this.token(types$i.RightParenthesis, ")");
  }
}

PseudoElementSelector$2.generate = generate$g;
PseudoElementSelector$2.name = name$d;
PseudoElementSelector$2.parse = parse$k;
PseudoElementSelector$2.structure = structure$c;
PseudoElementSelector$2.walkContext = walkContext$3;

var Ratio$2 = {};

const types$h = types$U;
const charCodeDefinitions$4 = charCodeDefinitions$c;

const SOLIDUS$2 = 0x002f; // U+002F SOLIDUS (/)
const FULLSTOP$1 = 0x002e; // U+002E FULL STOP (.)

// Terms of <ratio> should be a positive numbers (not zero or negative)
// (see https://drafts.csswg.org/mediaqueries-3/#values)
// However, -o-min-device-pixel-ratio takes fractional values as a ratio's term
// and this is using by various sites. Therefore we relax checking on parse
// to test a term is unsigned number without an exponent part.
// Additional checking may be applied on lexer validation.
function consumeNumber() {
  this.skipSC();

  const value = this.consume(types$h.Number);

  for (let i = 0; i < value.length; i++) {
    const code = value.charCodeAt(i);
    if (!charCodeDefinitions$4.isDigit(code) && code !== FULLSTOP$1) {
      this.error(
        "Unsigned number is expected",
        this.tokenStart - value.length + i,
      );
    }
  }

  if (Number(value) === 0) {
    this.error("Zero number is not allowed", this.tokenStart - value.length);
  }

  return value;
}

const name$c = "Ratio";
const structure$b = {
  left: String,
  right: String,
};

// <positive-integer> S* '/' S* <positive-integer>
function parse$j() {
  const start = this.tokenStart;
  const left = consumeNumber.call(this);
  let right;

  this.skipSC();
  this.eatDelim(SOLIDUS$2);
  right = consumeNumber.call(this);

  return {
    type: "Ratio",
    loc: this.getLocation(start, this.tokenStart),
    left,
    right,
  };
}

function generate$f(node) {
  this.token(types$h.Number, node.left);
  this.token(types$h.Delim, "/");
  this.token(types$h.Number, node.right);
}

Ratio$2.generate = generate$f;
Ratio$2.name = name$c;
Ratio$2.parse = parse$j;
Ratio$2.structure = structure$b;

var Raw$4 = {};

const types$g = types$U;

function getOffsetExcludeWS() {
  if (this.tokenIndex > 0) {
    if (this.lookupType(-1) === types$g.WhiteSpace) {
      return this.tokenIndex > 1
        ? this.getTokenStart(this.tokenIndex - 1)
        : this.firstCharOffset;
    }
  }

  return this.tokenStart;
}

const name$b = "Raw";
const structure$a = {
  value: String,
};

function parse$i(startToken, consumeUntil, excludeWhiteSpace) {
  const startOffset = this.getTokenStart(startToken);
  let endOffset;

  this.skipUntilBalanced(
    startToken,
    consumeUntil || this.consumeUntilBalanceEnd,
  );

  if (excludeWhiteSpace && this.tokenStart > startOffset) {
    endOffset = getOffsetExcludeWS.call(this);
  } else {
    endOffset = this.tokenStart;
  }

  return {
    type: "Raw",
    loc: this.getLocation(startOffset, endOffset),
    value: this.substring(startOffset, endOffset),
  };
}

function generate$e(node) {
  this.tokenize(node.value);
}

Raw$4.generate = generate$e;
Raw$4.name = name$b;
Raw$4.parse = parse$i;
Raw$4.structure = structure$a;

var Rule$4 = {};

const types$f = types$U;

function consumeRaw$2(startToken) {
  return this.Raw(startToken, this.consumeUntilLeftCurlyBracket, true);
}

function consumePrelude() {
  const prelude = this.SelectorList();

  if (
    prelude.type !== "Raw" &&
    this.eof === false &&
    this.tokenType !== types$f.LeftCurlyBracket
  ) {
    this.error();
  }

  return prelude;
}

const name$a = "Rule";
const walkContext$2 = "rule";
const structure$9 = {
  prelude: ["SelectorList", "Raw"],
  block: ["Block"],
};

function parse$h() {
  const startToken = this.tokenIndex;
  const startOffset = this.tokenStart;
  let prelude;
  let block;

  if (this.parseRulePrelude) {
    prelude = this.parseWithFallback(consumePrelude, consumeRaw$2);
  } else {
    prelude = consumeRaw$2.call(this, startToken);
  }

  block = this.Block(true);

  return {
    type: "Rule",
    loc: this.getLocation(startOffset, this.tokenStart),
    prelude,
    block,
  };
}
function generate$d(node) {
  this.node(node.prelude);
  this.node(node.block);
}

Rule$4.generate = generate$d;
Rule$4.name = name$a;
Rule$4.parse = parse$h;
Rule$4.structure = structure$9;
Rule$4.walkContext = walkContext$2;

var Selector$3 = {};

const name$9 = "Selector";
const structure$8 = {
  children: [
    [
      "TypeSelector",
      "IdSelector",
      "ClassSelector",
      "AttributeSelector",
      "PseudoClassSelector",
      "PseudoElementSelector",
      "Combinator",
      "WhiteSpace",
    ],
  ],
};

function parse$g() {
  const children = this.readSequence(this.scope.Selector);

  // nothing were consumed
  if (this.getFirstListNode(children) === null) {
    this.error("Selector is expected");
  }

  return {
    type: "Selector",
    loc: this.getLocationFromList(children),
    children,
  };
}

function generate$c(node) {
  this.children(node);
}

Selector$3.generate = generate$c;
Selector$3.name = name$9;
Selector$3.parse = parse$g;
Selector$3.structure = structure$8;

var SelectorList$2 = {};

const types$e = types$U;

const name$8 = "SelectorList";
const walkContext$1 = "selector";
const structure$7 = {
  children: [["Selector", "Raw"]],
};

function parse$f() {
  const children = this.createList();

  while (!this.eof) {
    children.push(this.Selector());

    if (this.tokenType === types$e.Comma) {
      this.next();
      continue;
    }

    break;
  }

  return {
    type: "SelectorList",
    loc: this.getLocationFromList(children),
    children,
  };
}

function generate$b(node) {
  this.children(node, () => this.token(types$e.Comma, ","));
}

SelectorList$2.generate = generate$b;
SelectorList$2.name = name$8;
SelectorList$2.parse = parse$f;
SelectorList$2.structure = structure$7;
SelectorList$2.walkContext = walkContext$1;

var _String = {};

var string$3 = {};

const charCodeDefinitions$3 = charCodeDefinitions$c;
const utils$d = utils$k;

const REVERSE_SOLIDUS$2 = 0x005c; // U+005C REVERSE SOLIDUS (\)
const QUOTATION_MARK$1 = 0x0022; // "
const APOSTROPHE$1 = 0x0027; // '

function decode$2(str) {
  const len = str.length;
  const firstChar = str.charCodeAt(0);
  const start =
    firstChar === QUOTATION_MARK$1 || firstChar === APOSTROPHE$1 ? 1 : 0;
  const end =
    start === 1 && len > 1 && str.charCodeAt(len - 1) === firstChar
      ? len - 2
      : len - 1;
  let decoded = "";

  for (let i = start; i <= end; i++) {
    let code = str.charCodeAt(i);

    if (code === REVERSE_SOLIDUS$2) {
      // special case at the ending
      if (i === end) {
        // if the next input code point is EOF, do nothing
        // otherwise include last quote as escaped
        if (i !== len - 1) {
          decoded = str.substr(i + 1);
        }
        break;
      }

      code = str.charCodeAt(++i);

      // consume escaped
      if (charCodeDefinitions$3.isValidEscape(REVERSE_SOLIDUS$2, code)) {
        const escapeStart = i - 1;
        const escapeEnd = utils$d.consumeEscaped(str, escapeStart);

        i = escapeEnd - 1;
        decoded += utils$d.decodeEscaped(
          str.substring(escapeStart + 1, escapeEnd),
        );
      } else {
        // \r\n
        if (code === 0x000d && str.charCodeAt(i + 1) === 0x000a) {
          i++;
        }
      }
    } else {
      decoded += str[i];
    }
  }

  return decoded;
}

// https://drafts.csswg.org/cssom/#serialize-a-string
//  2.1. Common Serializing Idioms
function encode$3(str, apostrophe) {
  const quote = apostrophe ? "'" : '"';
  const quoteCode = apostrophe ? APOSTROPHE$1 : QUOTATION_MARK$1;
  let encoded = "";
  let wsBeforeHexIsNeeded = false;

  for (let i = 0; i < str.length; i++) {
    const code = str.charCodeAt(i);

    // If the character is NULL (U+0000), then the REPLACEMENT CHARACTER (U+FFFD).
    if (code === 0x0000) {
      encoded += "\uFFFD";
      continue;
    }

    // If the character is in the range [\1-\1f] (U+0001 to U+001F) or is U+007F,
    // the character escaped as code point.
    // Note: Do not compare with 0x0001 since 0x0000 is precessed before
    if (code <= 0x001f || code === 0x007f) {
      encoded += "\\" + code.toString(16);
      wsBeforeHexIsNeeded = true;
      continue;
    }

    // If the character is '"' (U+0022) or "\" (U+005C), the escaped character.
    if (code === quoteCode || code === REVERSE_SOLIDUS$2) {
      encoded += "\\" + str.charAt(i);
      wsBeforeHexIsNeeded = false;
    } else {
      if (
        wsBeforeHexIsNeeded &&
        (charCodeDefinitions$3.isHexDigit(code) ||
          charCodeDefinitions$3.isWhiteSpace(code))
      ) {
        encoded += " ";
      }

      // Otherwise, the character itself.
      encoded += str.charAt(i);
      wsBeforeHexIsNeeded = false;
    }
  }

  return quote + encoded + quote;
}

string$3.decode = decode$2;
string$3.encode = encode$3;

const string$2 = string$3;
const types$d = types$U;

const name$7 = "String";
const structure$6 = {
  value: String,
};

function parse$e() {
  return {
    type: "String",
    loc: this.getLocation(this.tokenStart, this.tokenEnd),
    value: string$2.decode(this.consume(types$d.String)),
  };
}

function generate$a(node) {
  this.token(types$d.String, string$2.encode(node.value));
}

_String.generate = generate$a;
_String.name = name$7;
_String.parse = parse$e;
_String.structure = structure$6;

var StyleSheet$2 = {};

const types$c = types$U;

const EXCLAMATIONMARK = 0x0021; // U+0021 EXCLAMATION MARK (!)

function consumeRaw$1(startToken) {
  return this.Raw(startToken, null, false);
}

const name$6 = "StyleSheet";
const walkContext = "stylesheet";
const structure$5 = {
  children: [["Comment", "CDO", "CDC", "Atrule", "Rule", "Raw"]],
};

function parse$d() {
  const start = this.tokenStart;
  const children = this.createList();
  let child;

  while (!this.eof) {
    switch (this.tokenType) {
      case types$c.WhiteSpace:
        this.next();
        continue;

      case types$c.Comment:
        // ignore comments except exclamation comments (i.e. /*! .. */) on top level
        if (this.charCodeAt(this.tokenStart + 2) !== EXCLAMATIONMARK) {
          this.next();
          continue;
        }

        child = this.Comment();
        break;

      case types$c.CDO: // <!--
        child = this.CDO();
        break;

      case types$c.CDC: // -->
        child = this.CDC();
        break;

      // CSS Syntax Module Level 3
      // 2.2 Error handling
      // At the "top level" of a stylesheet, an <at-keyword-token> starts an at-rule.
      case types$c.AtKeyword:
        child = this.parseWithFallback(this.Atrule, consumeRaw$1);
        break;

      // Anything else starts a qualified rule ...
      default:
        child = this.parseWithFallback(this.Rule, consumeRaw$1);
    }

    children.push(child);
  }

  return {
    type: "StyleSheet",
    loc: this.getLocation(start, this.tokenStart),
    children,
  };
}

function generate$9(node) {
  this.children(node);
}

StyleSheet$2.generate = generate$9;
StyleSheet$2.name = name$6;
StyleSheet$2.parse = parse$d;
StyleSheet$2.structure = structure$5;
StyleSheet$2.walkContext = walkContext;

var TypeSelector$4 = {};

const types$b = types$U;

const ASTERISK$2 = 0x002a; // U+002A ASTERISK (*)
const VERTICALLINE$1 = 0x007c; // U+007C VERTICAL LINE (|)

function eatIdentifierOrAsterisk() {
  if (this.tokenType !== types$b.Ident && this.isDelim(ASTERISK$2) === false) {
    this.error("Identifier or asterisk is expected");
  }

  this.next();
}

const name$5 = "TypeSelector";
const structure$4 = {
  name: String,
};

// ident
// ident|ident
// ident|*
// *
// *|ident
// *|*
// |ident
// |*
function parse$c() {
  const start = this.tokenStart;

  if (this.isDelim(VERTICALLINE$1)) {
    this.next();
    eatIdentifierOrAsterisk.call(this);
  } else {
    eatIdentifierOrAsterisk.call(this);

    if (this.isDelim(VERTICALLINE$1)) {
      this.next();
      eatIdentifierOrAsterisk.call(this);
    }
  }

  return {
    type: "TypeSelector",
    loc: this.getLocation(start, this.tokenStart),
    name: this.substrToCursor(start),
  };
}

function generate$8(node) {
  this.tokenize(node.name);
}

TypeSelector$4.generate = generate$8;
TypeSelector$4.name = name$5;
TypeSelector$4.parse = parse$c;
TypeSelector$4.structure = structure$4;

var UnicodeRange$2 = {};

const types$a = types$U;
const charCodeDefinitions$2 = charCodeDefinitions$c;

const PLUSSIGN$2 = 0x002b; // U+002B PLUS SIGN (+)
const HYPHENMINUS$1 = 0x002d; // U+002D HYPHEN-MINUS (-)
const QUESTIONMARK = 0x003f; // U+003F QUESTION MARK (?)

function eatHexSequence(offset, allowDash) {
  let len = 0;

  for (let pos = this.tokenStart + offset; pos < this.tokenEnd; pos++) {
    const code = this.charCodeAt(pos);

    if (code === HYPHENMINUS$1 && allowDash && len !== 0) {
      eatHexSequence.call(this, offset + len + 1, false);
      return -1;
    }

    if (!charCodeDefinitions$2.isHexDigit(code)) {
      this.error(
        allowDash && len !== 0
          ? "Hyphen minus" + (len < 6 ? " or hex digit" : "") + " is expected"
          : len < 6
            ? "Hex digit is expected"
            : "Unexpected input",
        pos,
      );
    }

    if (++len > 6) {
      this.error("Too many hex digits", pos);
    }
  }

  this.next();
  return len;
}

function eatQuestionMarkSequence(max) {
  let count = 0;

  while (this.isDelim(QUESTIONMARK)) {
    if (++count > max) {
      this.error("Too many question marks");
    }

    this.next();
  }
}

function startsWith(code) {
  if (this.charCodeAt(this.tokenStart) !== code) {
    this.error(
      (code === PLUSSIGN$2 ? "Plus sign" : "Hyphen minus") + " is expected",
    );
  }
}

// https://drafts.csswg.org/css-syntax/#urange
// Informally, the <urange> production has three forms:
// U+0001
//      Defines a range consisting of a single code point, in this case the code point "1".
// U+0001-00ff
//      Defines a range of codepoints between the first and the second value, in this case
//      the range between "1" and "ff" (255 in decimal) inclusive.
// U+00??
//      Defines a range of codepoints where the "?" characters range over all hex digits,
//      in this case defining the same as the value U+0000-00ff.
// In each form, a maximum of 6 digits is allowed for each hexadecimal number (if you treat "?" as a hexadecimal digit).
//
// <urange> =
//   u '+' <ident-token> '?'* |
//   u <dimension-token> '?'* |
//   u <number-token> '?'* |
//   u <number-token> <dimension-token> |
//   u <number-token> <number-token> |
//   u '+' '?'+
function scanUnicodeRange() {
  let hexLength = 0;

  switch (this.tokenType) {
    case types$a.Number:
      // u <number-token> '?'*
      // u <number-token> <dimension-token>
      // u <number-token> <number-token>
      hexLength = eatHexSequence.call(this, 1, true);

      if (this.isDelim(QUESTIONMARK)) {
        eatQuestionMarkSequence.call(this, 6 - hexLength);
        break;
      }

      if (
        this.tokenType === types$a.Dimension ||
        this.tokenType === types$a.Number
      ) {
        startsWith.call(this, HYPHENMINUS$1);
        eatHexSequence.call(this, 1, false);
        break;
      }

      break;

    case types$a.Dimension:
      // u <dimension-token> '?'*
      hexLength = eatHexSequence.call(this, 1, true);

      if (hexLength > 0) {
        eatQuestionMarkSequence.call(this, 6 - hexLength);
      }

      break;

    default:
      // u '+' <ident-token> '?'*
      // u '+' '?'+
      this.eatDelim(PLUSSIGN$2);

      if (this.tokenType === types$a.Ident) {
        hexLength = eatHexSequence.call(this, 0, true);
        if (hexLength > 0) {
          eatQuestionMarkSequence.call(this, 6 - hexLength);
        }
        break;
      }

      if (this.isDelim(QUESTIONMARK)) {
        this.next();
        eatQuestionMarkSequence.call(this, 5);
        break;
      }

      this.error("Hex digit or question mark is expected");
  }
}

const name$4 = "UnicodeRange";
const structure$3 = {
  value: String,
};

function parse$b() {
  const start = this.tokenStart;

  // U or u
  this.eatIdent("u");
  scanUnicodeRange.call(this);

  return {
    type: "UnicodeRange",
    loc: this.getLocation(start, this.tokenStart),
    value: this.substrToCursor(start),
  };
}

function generate$7(node) {
  this.tokenize(node.value);
}

UnicodeRange$2.generate = generate$7;
UnicodeRange$2.name = name$4;
UnicodeRange$2.parse = parse$b;
UnicodeRange$2.structure = structure$3;

var Url$4 = {};

var url$2 = {};

const charCodeDefinitions$1 = charCodeDefinitions$c;
const utils$c = utils$k;

const SPACE$1 = 0x0020; // U+0020 SPACE
const REVERSE_SOLIDUS$1 = 0x005c; // U+005C REVERSE SOLIDUS (\)
const QUOTATION_MARK = 0x0022; // "
const APOSTROPHE = 0x0027; // '
const LEFTPARENTHESIS = 0x0028; // U+0028 LEFT PARENTHESIS (()
const RIGHTPARENTHESIS = 0x0029; // U+0029 RIGHT PARENTHESIS ())

function decode$1(str) {
  const len = str.length;
  let start = 4; // length of "url("
  let end = str.charCodeAt(len - 1) === RIGHTPARENTHESIS ? len - 2 : len - 1;
  let decoded = "";

  while (
    start < end &&
    charCodeDefinitions$1.isWhiteSpace(str.charCodeAt(start))
  ) {
    start++;
  }

  while (
    start < end &&
    charCodeDefinitions$1.isWhiteSpace(str.charCodeAt(end))
  ) {
    end--;
  }

  for (let i = start; i <= end; i++) {
    let code = str.charCodeAt(i);

    if (code === REVERSE_SOLIDUS$1) {
      // special case at the ending
      if (i === end) {
        // if the next input code point is EOF, do nothing
        // otherwise include last left parenthesis as escaped
        if (i !== len - 1) {
          decoded = str.substr(i + 1);
        }
        break;
      }

      code = str.charCodeAt(++i);

      // consume escaped
      if (charCodeDefinitions$1.isValidEscape(REVERSE_SOLIDUS$1, code)) {
        const escapeStart = i - 1;
        const escapeEnd = utils$c.consumeEscaped(str, escapeStart);

        i = escapeEnd - 1;
        decoded += utils$c.decodeEscaped(
          str.substring(escapeStart + 1, escapeEnd),
        );
      } else {
        // \r\n
        if (code === 0x000d && str.charCodeAt(i + 1) === 0x000a) {
          i++;
        }
      }
    } else {
      decoded += str[i];
    }
  }

  return decoded;
}

function encode$2(str) {
  let encoded = "";
  let wsBeforeHexIsNeeded = false;

  for (let i = 0; i < str.length; i++) {
    const code = str.charCodeAt(i);

    // If the character is NULL (U+0000), then the REPLACEMENT CHARACTER (U+FFFD).
    if (code === 0x0000) {
      encoded += "\uFFFD";
      continue;
    }

    // If the character is in the range [\1-\1f] (U+0001 to U+001F) or is U+007F,
    // the character escaped as code point.
    // Note: Do not compare with 0x0001 since 0x0000 is precessed before
    if (code <= 0x001f || code === 0x007f) {
      encoded += "\\" + code.toString(16);
      wsBeforeHexIsNeeded = true;
      continue;
    }

    if (
      code === SPACE$1 ||
      code === REVERSE_SOLIDUS$1 ||
      code === QUOTATION_MARK ||
      code === APOSTROPHE ||
      code === LEFTPARENTHESIS ||
      code === RIGHTPARENTHESIS
    ) {
      encoded += "\\" + str.charAt(i);
      wsBeforeHexIsNeeded = false;
    } else {
      if (wsBeforeHexIsNeeded && charCodeDefinitions$1.isHexDigit(code)) {
        encoded += " ";
      }

      encoded += str.charAt(i);
      wsBeforeHexIsNeeded = false;
    }
  }

  return "url(" + encoded + ")";
}

url$2.decode = decode$1;
url$2.encode = encode$2;

const url$1 = url$2;
const string$1 = string$3;
const types$9 = types$U;

const name$3 = "Url";
const structure$2 = {
  value: String,
};

// <url-token> | <function-token> <string> )
function parse$a() {
  const start = this.tokenStart;
  let value;

  switch (this.tokenType) {
    case types$9.Url:
      value = url$1.decode(this.consume(types$9.Url));
      break;

    case types$9.Function:
      if (!this.cmpStr(this.tokenStart, this.tokenEnd, "url(")) {
        this.error("Function name must be `url`");
      }

      this.eat(types$9.Function);
      this.skipSC();
      value = string$1.decode(this.consume(types$9.String));
      this.skipSC();
      if (!this.eof) {
        this.eat(types$9.RightParenthesis);
      }
      break;

    default:
      this.error("Url or Function is expected");
  }

  return {
    type: "Url",
    loc: this.getLocation(start, this.tokenStart),
    value,
  };
}

function generate$6(node) {
  this.token(types$9.Url, url$1.encode(node.value));
}

Url$4.generate = generate$6;
Url$4.name = name$3;
Url$4.parse = parse$a;
Url$4.structure = structure$2;

var Value$4 = {};

const name$2 = "Value";
const structure$1 = {
  children: [[]],
};

function parse$9() {
  const start = this.tokenStart;
  const children = this.readSequence(this.scope.Value);

  return {
    type: "Value",
    loc: this.getLocation(start, this.tokenStart),
    children,
  };
}

function generate$5(node) {
  this.children(node);
}

Value$4.generate = generate$5;
Value$4.name = name$2;
Value$4.parse = parse$9;
Value$4.structure = structure$1;

var WhiteSpace$4 = {};

const types$8 = types$U;

const SPACE = Object.freeze({
  type: "WhiteSpace",
  loc: null,
  value: " ",
});

const name$1 = "WhiteSpace";
const structure = {
  value: String,
};

function parse$8() {
  this.eat(types$8.WhiteSpace);
  return SPACE;

  // return {
  //     type: 'WhiteSpace',
  //     loc: this.getLocation(this.tokenStart, this.tokenEnd),
  //     value: this.consume(WHITESPACE)
  // };
}

function generate$4(node) {
  this.token(types$8.WhiteSpace, node.value);
}

WhiteSpace$4.generate = generate$4;
WhiteSpace$4.name = name$1;
WhiteSpace$4.parse = parse$8;
WhiteSpace$4.structure = structure;

const AnPlusB$1 = AnPlusB$2;
const Atrule$5 = Atrule$6;
const AtrulePrelude$1 = AtrulePrelude$2;
const AttributeSelector$3 = AttributeSelector$4;
const Block$1 = Block$2;
const Brackets$1 = Brackets$2;
const CDC$1 = CDC$2;
const CDO$1 = CDO$2;
const ClassSelector$1 = ClassSelector$2;
const Combinator$1 = Combinator$2;
const Comment$3 = Comment$4;
const Declaration$3 = Declaration$4;
const DeclarationList$1 = DeclarationList$2;
const Dimension$3 = Dimension$4;
const Function$2 = _Function;
const Hash$1 = Hash$2;
const Identifier$1 = Identifier$2;
const IdSelector$1 = IdSelector$2;
const MediaFeature$1 = MediaFeature$2;
const MediaQuery$1 = MediaQuery$2;
const MediaQueryList$1 = MediaQueryList$2;
const Nth$1 = Nth$2;
const Number$1$1 = _Number$5;
const Operator$1 = Operator$2;
const Parentheses$1 = Parentheses$2;
const Percentage$3 = Percentage$4;
const PseudoClassSelector$1 = PseudoClassSelector$2;
const PseudoElementSelector$1 = PseudoElementSelector$2;
const Ratio$1 = Ratio$2;
const Raw$3 = Raw$4;
const Rule$3 = Rule$4;
const Selector$2 = Selector$3;
const SelectorList$1 = SelectorList$2;
const String$1$1 = _String;
const StyleSheet$1 = StyleSheet$2;
const TypeSelector$3 = TypeSelector$4;
const UnicodeRange$1 = UnicodeRange$2;
const Url$3 = Url$4;
const Value$3 = Value$4;
const WhiteSpace$3 = WhiteSpace$4;

node.AnPlusB = AnPlusB$1;
node.Atrule = Atrule$5;
node.AtrulePrelude = AtrulePrelude$1;
node.AttributeSelector = AttributeSelector$3;
node.Block = Block$1;
node.Brackets = Brackets$1;
node.CDC = CDC$1;
node.CDO = CDO$1;
node.ClassSelector = ClassSelector$1;
node.Combinator = Combinator$1;
node.Comment = Comment$3;
node.Declaration = Declaration$3;
node.DeclarationList = DeclarationList$1;
node.Dimension = Dimension$3;
node.Function = Function$2;
node.Hash = Hash$1;
node.Identifier = Identifier$1;
node.IdSelector = IdSelector$1;
node.MediaFeature = MediaFeature$1;
node.MediaQuery = MediaQuery$1;
node.MediaQueryList = MediaQueryList$1;
node.Nth = Nth$1;
node.Number = Number$1$1;
node.Operator = Operator$1;
node.Parentheses = Parentheses$1;
node.Percentage = Percentage$3;
node.PseudoClassSelector = PseudoClassSelector$1;
node.PseudoElementSelector = PseudoElementSelector$1;
node.Ratio = Ratio$1;
node.Raw = Raw$3;
node.Rule = Rule$3;
node.Selector = Selector$2;
node.SelectorList = SelectorList$1;
node.String = String$1$1;
node.StyleSheet = StyleSheet$1;
node.TypeSelector = TypeSelector$3;
node.UnicodeRange = UnicodeRange$1;
node.Url = Url$3;
node.Value = Value$3;
node.WhiteSpace = WhiteSpace$3;

const data = data$1;
const index$7 = node;

const lexerConfig = {
  generic: true,
  ...data,
  node: index$7,
};

var lexer$3 = lexerConfig;

var scope = {};

const types$7 = types$U;

const NUMBERSIGN$1 = 0x0023; // U+0023 NUMBER SIGN (#)
const ASTERISK$1 = 0x002a; // U+002A ASTERISK (*)
const PLUSSIGN$1 = 0x002b; // U+002B PLUS SIGN (+)
const HYPHENMINUS = 0x002d; // U+002D HYPHEN-MINUS (-)
const SOLIDUS$1 = 0x002f; // U+002F SOLIDUS (/)
const U = 0x0075; // U+0075 LATIN SMALL LETTER U (u)

function defaultRecognizer(context) {
  switch (this.tokenType) {
    case types$7.Hash:
      return this.Hash();

    case types$7.Comma:
      return this.Operator();

    case types$7.LeftParenthesis:
      return this.Parentheses(this.readSequence, context.recognizer);

    case types$7.LeftSquareBracket:
      return this.Brackets(this.readSequence, context.recognizer);

    case types$7.String:
      return this.String();

    case types$7.Dimension:
      return this.Dimension();

    case types$7.Percentage:
      return this.Percentage();

    case types$7.Number:
      return this.Number();

    case types$7.Function:
      return this.cmpStr(this.tokenStart, this.tokenEnd, "url(")
        ? this.Url()
        : this.Function(this.readSequence, context.recognizer);

    case types$7.Url:
      return this.Url();

    case types$7.Ident:
      // check for unicode range, it should start with u+ or U+
      if (
        this.cmpChar(this.tokenStart, U) &&
        this.cmpChar(this.tokenStart + 1, PLUSSIGN$1)
      ) {
        return this.UnicodeRange();
      } else {
        return this.Identifier();
      }

    case types$7.Delim: {
      const code = this.charCodeAt(this.tokenStart);

      if (
        code === SOLIDUS$1 ||
        code === ASTERISK$1 ||
        code === PLUSSIGN$1 ||
        code === HYPHENMINUS
      ) {
        return this.Operator(); // TODO: replace with Delim
      }

      // TODO: produce a node with Delim node type

      if (code === NUMBERSIGN$1) {
        this.error("Hex or identifier is expected", this.tokenStart + 1);
      }

      break;
    }
  }
}

var _default$2 = defaultRecognizer;

const _default$1 = _default$2;

const atrulePrelude$1 = {
  getNode: _default$1,
};

var atrulePrelude_1 = atrulePrelude$1;

const types$6 = types$U;

const NUMBERSIGN = 0x0023; // U+0023 NUMBER SIGN (#)
const ASTERISK = 0x002a; // U+002A ASTERISK (*)
const PLUSSIGN = 0x002b; // U+002B PLUS SIGN (+)
const SOLIDUS = 0x002f; // U+002F SOLIDUS (/)
const FULLSTOP = 0x002e; // U+002E FULL STOP (.)
const GREATERTHANSIGN = 0x003e; // U+003E GREATER-THAN SIGN (>)
const VERTICALLINE = 0x007c; // U+007C VERTICAL LINE (|)
const TILDE = 0x007e; // U+007E TILDE (~)

function onWhiteSpace(next, children) {
  if (
    children.last !== null &&
    children.last.type !== "Combinator" &&
    next !== null &&
    next.type !== "Combinator"
  ) {
    children.push({
      // FIXME: this.Combinator() should be used instead
      type: "Combinator",
      loc: null,
      name: " ",
    });
  }
}

function getNode() {
  switch (this.tokenType) {
    case types$6.LeftSquareBracket:
      return this.AttributeSelector();

    case types$6.Hash:
      return this.IdSelector();

    case types$6.Colon:
      if (this.lookupType(1) === types$6.Colon) {
        return this.PseudoElementSelector();
      } else {
        return this.PseudoClassSelector();
      }

    case types$6.Ident:
      return this.TypeSelector();

    case types$6.Number:
    case types$6.Percentage:
      return this.Percentage();

    case types$6.Dimension:
      // throws when .123ident
      if (this.charCodeAt(this.tokenStart) === FULLSTOP) {
        this.error("Identifier is expected", this.tokenStart + 1);
      }
      break;

    case types$6.Delim: {
      const code = this.charCodeAt(this.tokenStart);

      switch (code) {
        case PLUSSIGN:
        case GREATERTHANSIGN:
        case TILDE:
        case SOLIDUS: // /deep/
          return this.Combinator();

        case FULLSTOP:
          return this.ClassSelector();

        case ASTERISK:
        case VERTICALLINE:
          return this.TypeSelector();

        case NUMBERSIGN:
          return this.IdSelector();
      }

      break;
    }
  }
}
const Selector$1 = {
  onWhiteSpace,
  getNode,
};

var selector$2 = Selector$1;

// legacy IE function
// expression( <any-value> )
function expressionFn() {
  return this.createSingleNodeList(this.Raw(this.tokenIndex, null, false));
}

var expression$1 = expressionFn;

const types$5 = types$U;

// var( <ident> , <value>? )
function varFn() {
  const children = this.createList();

  this.skipSC();

  // NOTE: Don't check more than a first argument is an ident, rest checks are for lexer
  children.push(this.Identifier());

  this.skipSC();

  if (this.tokenType === types$5.Comma) {
    children.push(this.Operator());

    const startIndex = this.tokenIndex;
    const value = this.parseCustomProperty
      ? this.Value(null)
      : this.Raw(
          this.tokenIndex,
          this.consumeUntilExclamationMarkOrSemicolon,
          false,
        );

    if (value.type === "Value" && value.children.isEmpty) {
      for (let offset = startIndex - this.tokenIndex; offset <= 0; offset++) {
        if (this.lookupType(offset) === types$5.WhiteSpace) {
          value.children.appendData({
            type: "WhiteSpace",
            loc: null,
            value: " ",
          });
          break;
        }
      }
    }

    children.push(value);
  }

  return children;
}

var _var$1 = varFn;

const _default = _default$2;
const expression = expression$1;
const _var = _var$1;

function isPlusMinusOperator(node) {
  return (
    node !== null &&
    node.type === "Operator" &&
    (node.value[node.value.length - 1] === "-" ||
      node.value[node.value.length - 1] === "+")
  );
}

const value$1 = {
  getNode: _default,
  onWhiteSpace(next, children) {
    if (isPlusMinusOperator(next)) {
      next.value = " " + next.value;
    }
    if (isPlusMinusOperator(children.last)) {
      children.last.value += " ";
    }
  },
  expression: expression,
  var: _var,
};

var value_1 = value$1;

const atrulePrelude = atrulePrelude_1;
const selector$1 = selector$2;
const value = value_1;

scope.AtrulePrelude = atrulePrelude;
scope.Selector = selector$1;
scope.Value = value;

const fontFace$1 = {
  parse: {
    prelude: null,
    block() {
      return this.Block(true);
    },
  },
};

var fontFace_1 = fontFace$1;

const types$4 = types$U;

const importAtrule = {
  parse: {
    prelude() {
      const children = this.createList();

      this.skipSC();

      switch (this.tokenType) {
        case types$4.String:
          children.push(this.String());
          break;

        case types$4.Url:
        case types$4.Function:
          children.push(this.Url());
          break;

        default:
          this.error("String or url() is expected");
      }

      if (
        this.lookupNonWSType(0) === types$4.Ident ||
        this.lookupNonWSType(0) === types$4.LeftParenthesis
      ) {
        children.push(this.MediaQueryList());
      }

      return children;
    },
    block: null,
  },
};

var _import$1 = importAtrule;

const media$1 = {
  parse: {
    prelude() {
      return this.createSingleNodeList(this.MediaQueryList());
    },
    block() {
      return this.Block(false);
    },
  },
};

var media_1 = media$1;

const page$1 = {
  parse: {
    prelude() {
      return this.createSingleNodeList(this.SelectorList());
    },
    block() {
      return this.Block(true);
    },
  },
};

var page_1 = page$1;

const types$3 = types$U;

function consumeRaw() {
  return this.createSingleNodeList(this.Raw(this.tokenIndex, null, false));
}

function parentheses() {
  this.skipSC();

  if (
    this.tokenType === types$3.Ident &&
    this.lookupNonWSType(1) === types$3.Colon
  ) {
    return this.createSingleNodeList(this.Declaration());
  }

  return readSequence.call(this);
}

function readSequence() {
  const children = this.createList();
  let child;

  this.skipSC();

  scan: while (!this.eof) {
    switch (this.tokenType) {
      case types$3.Comment:
      case types$3.WhiteSpace:
        this.next();
        continue;

      case types$3.Function:
        child = this.Function(consumeRaw, this.scope.AtrulePrelude);
        break;

      case types$3.Ident:
        child = this.Identifier();
        break;

      case types$3.LeftParenthesis:
        child = this.Parentheses(parentheses, this.scope.AtrulePrelude);
        break;

      default:
        break scan;
    }

    children.push(child);
  }

  return children;
}

const supports$1 = {
  parse: {
    prelude() {
      const children = readSequence.call(this);

      if (this.getFirstListNode(children) === null) {
        this.error("Condition is expected");
      }

      return children;
    },
    block() {
      return this.Block(false);
    },
  },
};

var supports_1 = supports$1;

const fontFace = fontFace_1;
const _import = _import$1;
const media = media_1;
const page = page_1;
const supports = supports_1;

const atrule = {
  "font-face": fontFace,
  import: _import,
  media,
  page,
  supports,
};

var atrule_1 = atrule;

const selectorList = {
  parse() {
    return this.createSingleNodeList(this.SelectorList());
  },
};

const selector = {
  parse() {
    return this.createSingleNodeList(this.Selector());
  },
};

const identList = {
  parse() {
    return this.createSingleNodeList(this.Identifier());
  },
};

const nth = {
  parse() {
    return this.createSingleNodeList(this.Nth());
  },
};

const pseudo = {
  dir: identList,
  has: selectorList,
  lang: identList,
  matches: selectorList,
  is: selectorList,
  "-moz-any": selectorList,
  "-webkit-any": selectorList,
  where: selectorList,
  not: selectorList,
  "nth-child": nth,
  "nth-last-child": nth,
  "nth-last-of-type": nth,
  "nth-of-type": nth,
  slotted: selector,
};

var pseudo_1 = pseudo;

var indexParse$1 = {};

const AnPlusB = AnPlusB$2;
const Atrule$4 = Atrule$6;
const AtrulePrelude = AtrulePrelude$2;
const AttributeSelector$2 = AttributeSelector$4;
const Block = Block$2;
const Brackets = Brackets$2;
const CDC = CDC$2;
const CDO = CDO$2;
const ClassSelector = ClassSelector$2;
const Combinator = Combinator$2;
const Comment$2 = Comment$4;
const Declaration$2 = Declaration$4;
const DeclarationList = DeclarationList$2;
const Dimension$2 = Dimension$4;
const Function$1 = _Function;
const Hash = Hash$2;
const Identifier = Identifier$2;
const IdSelector = IdSelector$2;
const MediaFeature = MediaFeature$2;
const MediaQuery = MediaQuery$2;
const MediaQueryList = MediaQueryList$2;
const Nth = Nth$2;
const Number$2 = _Number$5;
const Operator = Operator$2;
const Parentheses = Parentheses$2;
const Percentage$2 = Percentage$4;
const PseudoClassSelector = PseudoClassSelector$2;
const PseudoElementSelector = PseudoElementSelector$2;
const Ratio = Ratio$2;
const Raw$2 = Raw$4;
const Rule$2 = Rule$4;
const Selector = Selector$3;
const SelectorList = SelectorList$2;
const String$1 = _String;
const StyleSheet = StyleSheet$2;
const TypeSelector$2 = TypeSelector$4;
const UnicodeRange = UnicodeRange$2;
const Url$2 = Url$4;
const Value$2 = Value$4;
const WhiteSpace$2 = WhiteSpace$4;

indexParse$1.AnPlusB = AnPlusB.parse;
indexParse$1.Atrule = Atrule$4.parse;
indexParse$1.AtrulePrelude = AtrulePrelude.parse;
indexParse$1.AttributeSelector = AttributeSelector$2.parse;
indexParse$1.Block = Block.parse;
indexParse$1.Brackets = Brackets.parse;
indexParse$1.CDC = CDC.parse;
indexParse$1.CDO = CDO.parse;
indexParse$1.ClassSelector = ClassSelector.parse;
indexParse$1.Combinator = Combinator.parse;
indexParse$1.Comment = Comment$2.parse;
indexParse$1.Declaration = Declaration$2.parse;
indexParse$1.DeclarationList = DeclarationList.parse;
indexParse$1.Dimension = Dimension$2.parse;
indexParse$1.Function = Function$1.parse;
indexParse$1.Hash = Hash.parse;
indexParse$1.Identifier = Identifier.parse;
indexParse$1.IdSelector = IdSelector.parse;
indexParse$1.MediaFeature = MediaFeature.parse;
indexParse$1.MediaQuery = MediaQuery.parse;
indexParse$1.MediaQueryList = MediaQueryList.parse;
indexParse$1.Nth = Nth.parse;
indexParse$1.Number = Number$2.parse;
indexParse$1.Operator = Operator.parse;
indexParse$1.Parentheses = Parentheses.parse;
indexParse$1.Percentage = Percentage$2.parse;
indexParse$1.PseudoClassSelector = PseudoClassSelector.parse;
indexParse$1.PseudoElementSelector = PseudoElementSelector.parse;
indexParse$1.Ratio = Ratio.parse;
indexParse$1.Raw = Raw$2.parse;
indexParse$1.Rule = Rule$2.parse;
indexParse$1.Selector = Selector.parse;
indexParse$1.SelectorList = SelectorList.parse;
indexParse$1.String = String$1.parse;
indexParse$1.StyleSheet = StyleSheet.parse;
indexParse$1.TypeSelector = TypeSelector$2.parse;
indexParse$1.UnicodeRange = UnicodeRange.parse;
indexParse$1.Url = Url$2.parse;
indexParse$1.Value = Value$2.parse;
indexParse$1.WhiteSpace = WhiteSpace$2.parse;

const index$6 = scope;
const index$1$2 = atrule_1;
const index$2$1 = pseudo_1;
const indexParse = indexParse$1;

const config$1 = {
  parseContext: {
    default: "StyleSheet",
    stylesheet: "StyleSheet",
    atrule: "Atrule",
    atrulePrelude(options) {
      return this.AtrulePrelude(options.atrule ? String(options.atrule) : null);
    },
    mediaQueryList: "MediaQueryList",
    mediaQuery: "MediaQuery",
    rule: "Rule",
    selectorList: "SelectorList",
    selector: "Selector",
    block() {
      return this.Block(true);
    },
    declarationList: "DeclarationList",
    declaration: "Declaration",
    value: "Value",
  },
  scope: index$6,
  atrule: index$1$2,
  pseudo: index$2$1,
  node: indexParse,
};

var parser$1 = config$1;

const index$5 = node;

const config = {
  node: index$5,
};

var walker$1 = config;

const create$1 = create_1;
const lexer$2 = lexer$3;
const parser = parser$1;
const walker = walker$1;

const syntax$1 = create$1({
  ...lexer$2,
  ...parser,
  ...walker,
});

var syntax_1 = syntax$1;

var version$5 = {};

const name = "css-tree";
const version$4 = "2.2.1";
const description =
  "A tool set for CSS: fast detailed parser (CSS  AST), walker (AST traversal), generator (AST  CSS) and lexer (validation and matching) based on specs and browser implementations";
const author =
  "Roman Dvornov <rdvornov@gmail.com> (https://github.com/lahmatiy)";
const license = "MIT";
const repository = "csstree/csstree";
const keywords = [
  "css",
  "ast",
  "tokenizer",
  "parser",
  "walker",
  "lexer",
  "generator",
  "utils",
  "syntax",
  "validation",
];
const type = "module";
const module = "./lib/index.js";
const main = "./cjs/index.cjs";
const exports = {
  ".": {
    import: "./lib/index.js",
    require: "./cjs/index.cjs",
  },
  "./dist/*": "./dist/*.js",
  "./package.json": "./package.json",
  "./tokenizer": {
    import: "./lib/tokenizer/index.js",
    require: "./cjs/tokenizer/index.cjs",
  },
  "./parser": {
    import: "./lib/parser/index.js",
    require: "./cjs/parser/index.cjs",
  },
  "./selector-parser": {
    import: "./lib/parser/parse-selector.js",
    require: "./cjs/parser/parse-selector.cjs",
  },
  "./generator": {
    import: "./lib/generator/index.js",
    require: "./cjs/generator/index.cjs",
  },
  "./walker": {
    import: "./lib/walker/index.js",
    require: "./cjs/walker/index.cjs",
  },
  "./convertor": {
    import: "./lib/convertor/index.js",
    require: "./cjs/convertor/index.cjs",
  },
  "./lexer": {
    import: "./lib/lexer/index.js",
    require: "./cjs/lexer/index.cjs",
  },
  "./definition-syntax": {
    import: "./lib/definition-syntax/index.js",
    require: "./cjs/definition-syntax/index.cjs",
  },
  "./definition-syntax-data": {
    import: "./lib/data.js",
    require: "./cjs/data.cjs",
  },
  "./definition-syntax-data-patch": {
    import: "./lib/data-patch.js",
    require: "./cjs/data-patch.cjs",
  },
  "./utils": {
    import: "./lib/utils/index.js",
    require: "./cjs/utils/index.cjs",
  },
};
const browser = {
  "./cjs/data.cjs": "./dist/data.cjs",
  "./cjs/version.cjs": "./dist/version.cjs",
  "./lib/data.js": "./dist/data.js",
  "./lib/version.js": "./dist/version.js",
};
const unpkg = "dist/csstree.esm.js";
const jsdelivr = "dist/csstree.esm.js";
const scripts = {
  watch: "npm run build -- --watch",
  build: "npm run bundle && npm run esm-to-cjs --",
  "build-and-test": "npm run build && npm run test:dist && npm run test:cjs",
  bundle: "node scripts/bundle",
  "bundle-and-test": "npm run bundle && npm run test:dist",
  "esm-to-cjs": "node scripts/esm-to-cjs.cjs",
  "esm-to-cjs-and-test": "npm run esm-to-cjs && npm run test:cjs",
  lint: "eslint lib scripts && node scripts/review-syntax-patch --lint && node scripts/update-docs --lint",
  "lint-and-test": "npm run lint && npm test",
  "update:docs": "node scripts/update-docs",
  "review:syntax-patch": "node scripts/review-syntax-patch",
  test: "mocha lib/__tests --reporter ${REPORTER:-progress}",
  "test:cjs": "mocha cjs/__tests --reporter ${REPORTER:-progress}",
  "test:dist": "mocha dist/__tests --reporter ${REPORTER:-progress}",
  coverage: "c8 --exclude lib/__tests --reporter=lcovonly npm test",
  prepublishOnly: "npm run lint-and-test && npm run build-and-test",
  hydrogen:
    "node --trace-hydrogen --trace-phase=Z --trace-deopt --code-comments --hydrogen-track-positions --redirect-code-traces --redirect-code-traces-to=code.asm --trace_hydrogen_file=code.cfg --print-opt-code bin/parse --stat -o /dev/null",
};
const dependencies = {
  "mdn-data": "2.0.28",
  "source-map-js": "^1.0.1",
};
const devDependencies = {
  c8: "^7.7.1",
  clap: "^2.0.1",
  esbuild: "^0.14.53",
  eslint: "^8.4.1",
  "json-to-ast": "^2.1.0",
  mocha: "^9.1.4",
  rollup: "^2.68.0",
};
const engines = {
  node: "^10 || ^12.20.0 || ^14.13.0 || >=15.0.0",
  npm: ">=7.0.0",
};
const files = ["data", "dist", "cjs", "!cjs/__tests", "lib", "!lib/__tests"];
const require$$0 = {
  name: name,
  version: version$4,
  description: description,
  author: author,
  license: license,
  repository: repository,
  keywords: keywords,
  type: type,
  module: module,
  main: main,
  exports: exports,
  browser: browser,
  unpkg: unpkg,
  jsdelivr: jsdelivr,
  scripts: scripts,
  dependencies: dependencies,
  devDependencies: devDependencies,
  engines: engines,
  files: files,
};

const { version: version$3 } = require$$0;

version$5.version = version$3;

var definitionSyntax = {};

const SyntaxError$1 = _SyntaxError;
const generate$3 = generate$L;
const parse$7 = parse$P;
const walk$2 = walk$5;

definitionSyntax.SyntaxError = SyntaxError$1.SyntaxError;
definitionSyntax.generate = generate$3.generate;
definitionSyntax.parse = parse$7.parse;
definitionSyntax.walk = walk$2.walk;

var clone$2 = {};

const List$1 = List$7;

function clone$1(node) {
  const result = {};

  for (const key in node) {
    let value = node[key];

    if (value) {
      if (Array.isArray(value) || value instanceof List$1.List) {
        value = value.map(clone$1);
      } else if (value.constructor === Object) {
        value = clone$1(value);
      }
    }

    result[key] = value;
  }

  return result;
}

clone$2.clone = clone$1;

var ident$1 = {};

const charCodeDefinitions = charCodeDefinitions$c;
const utils$b = utils$k;

const REVERSE_SOLIDUS = 0x005c; // U+005C REVERSE SOLIDUS (\)

function decode(str) {
  const end = str.length - 1;
  let decoded = "";

  for (let i = 0; i < str.length; i++) {
    let code = str.charCodeAt(i);

    if (code === REVERSE_SOLIDUS) {
      // special case at the ending
      if (i === end) {
        // if the next input code point is EOF, do nothing
        break;
      }

      code = str.charCodeAt(++i);

      // consume escaped
      if (charCodeDefinitions.isValidEscape(REVERSE_SOLIDUS, code)) {
        const escapeStart = i - 1;
        const escapeEnd = utils$b.consumeEscaped(str, escapeStart);

        i = escapeEnd - 1;
        decoded += utils$b.decodeEscaped(
          str.substring(escapeStart + 1, escapeEnd),
        );
      } else {
        // \r\n
        if (code === 0x000d && str.charCodeAt(i + 1) === 0x000a) {
          i++;
        }
      }
    } else {
      decoded += str[i];
    }
  }

  return decoded;
}

// https://drafts.csswg.org/cssom/#serialize-an-identifier
//  2.1. Common Serializing Idioms
function encode$1(str) {
  let encoded = "";

  // If the character is the first character and is a "-" (U+002D),
  // and there is no second character, then the escaped character.
  // Note: That's means a single dash string "-" return as escaped dash,
  // so move the condition out of the main loop
  if (str.length === 1 && str.charCodeAt(0) === 0x002d) {
    return "\\-";
  }

  // To serialize an identifier means to create a string represented
  // by the concatenation of, for each character of the identifier:
  for (let i = 0; i < str.length; i++) {
    const code = str.charCodeAt(i);

    // If the character is NULL (U+0000), then the REPLACEMENT CHARACTER (U+FFFD).
    if (code === 0x0000) {
      encoded += "\uFFFD";
      continue;
    }

    if (
      // If the character is in the range [\1-\1f] (U+0001 to U+001F) or is U+007F ...
      // Note: Do not compare with 0x0001 since 0x0000 is precessed before
      code <= 0x001f ||
      code === 0x007f ||
      // [or] ... is in the range [0-9] (U+0030 to U+0039),
      (code >= 0x0030 &&
        code <= 0x0039 &&
        // If the character is the first character ...
        (i === 0 ||
          // If the character is the second character ... and the first character is a "-" (U+002D)
          (i === 1 && str.charCodeAt(0) === 0x002d)))
    ) {
      // ... then the character escaped as code point.
      encoded += "\\" + code.toString(16) + " ";
      continue;
    }

    // If the character is not handled by one of the above rules and is greater
    // than or equal to U+0080, is "-" (U+002D) or "_" (U+005F), or is in one
    // of the ranges [0-9] (U+0030 to U+0039), [A-Z] (U+0041 to U+005A),
    // or \[a-z] (U+0061 to U+007A), then the character itself.
    if (charCodeDefinitions.isName(code)) {
      encoded += str.charAt(i);
    } else {
      // Otherwise, the escaped character.
      encoded += "\\" + str.charAt(i);
    }
  }

  return encoded;
}

ident$1.decode = decode;
ident$1.encode = encode$1;

const index$1$1 = syntax_1;
const version$2 = version$5;
const create = create_1;
const List = List$7;
const Lexer = Lexer$3;
const index$4 = definitionSyntax;
const clone = clone$2;
const names$1 = names$4;
const ident = ident$1;
const string = string$3;
const url = url$2;
const types$2 = types$U;
const names = names$8;
const TokenStream = TokenStream$4;

const {
  tokenize: tokenize$1,
  parse: parse$6,
  generate: generate$2,
  lexer: lexer$1,
  createLexer,

  walk: walk$1,
  find: find$1,
  findLast: findLast$1,
  findAll: findAll$1,

  toPlainObject: toPlainObject$1,
  fromPlainObject: fromPlainObject$1,

  fork,
} = index$1$1;

cjs.version = version$2.version;
cjs.createSyntax = create;
cjs.List = List.List;
cjs.Lexer = Lexer.Lexer;
cjs.definitionSyntax = index$4;
cjs.clone = clone.clone;
cjs.isCustomProperty = names$1.isCustomProperty;
cjs.keyword = names$1.keyword;
cjs.property = names$1.property;
cjs.vendorPrefix = names$1.vendorPrefix;
cjs.ident = ident;
cjs.string = string;
cjs.url = url;
cjs.tokenTypes = types$2;
cjs.tokenNames = names;
cjs.TokenStream = TokenStream.TokenStream;
cjs.createLexer = createLexer;
cjs.find = find$1;
cjs.findAll = findAll$1;
cjs.findLast = findLast$1;
cjs.fork = fork;
cjs.fromPlainObject = fromPlainObject$1;
cjs.generate = generate$2;
cjs.lexer = lexer$1;
cjs.parse = parse$6;
cjs.toPlainObject = toPlainObject$1;
cjs.tokenize = tokenize$1;
cjs.walk = walk$1;

var usage$1 = {};

const { hasOwnProperty: hasOwnProperty$5 } = Object.prototype;

function buildMap(list, caseInsensitive) {
  const map = Object.create(null);

  if (!Array.isArray(list)) {
    return null;
  }

  for (let name of list) {
    if (caseInsensitive) {
      name = name.toLowerCase();
    }

    map[name] = true;
  }

  return map;
}

function buildList(data) {
  if (!data) {
    return null;
  }

  const tags = buildMap(data.tags, true);
  const ids = buildMap(data.ids);
  const classes = buildMap(data.classes);

  if (tags === null && ids === null && classes === null) {
    return null;
  }

  return {
    tags,
    ids,
    classes,
  };
}

function buildIndex(data) {
  let scopes = false;

  if (data.scopes && Array.isArray(data.scopes)) {
    scopes = Object.create(null);

    for (let i = 0; i < data.scopes.length; i++) {
      const list = data.scopes[i];

      if (!list || !Array.isArray(list)) {
        throw new Error("Wrong usage format");
      }

      for (const name of list) {
        if (hasOwnProperty$5.call(scopes, name)) {
          throw new Error(`Class can't be used for several scopes: ${name}`);
        }

        scopes[name] = i + 1;
      }
    }
  }

  return {
    whitelist: buildList(data),
    blacklist: buildList(data.blacklist),
    scopes,
  };
}

usage$1.buildIndex = buildIndex;

var utils$a = {};

function hasNoChildren(node) {
  return !node || !node.children || node.children.isEmpty;
}

function isNodeChildrenList(node, list) {
  return node !== null && node.children === list;
}

utils$a.hasNoChildren = hasNoChildren;
utils$a.isNodeChildrenList = isNodeChildrenList;

const cssTree$m = cjs;
const utils$9 = utils$a;

function cleanAtrule(node, item, list) {
  if (node.block) {
    // otherwise removed at-rule don't prevent @import for removal
    if (this.stylesheet !== null) {
      this.stylesheet.firstAtrulesAllowed = false;
    }

    if (utils$9.hasNoChildren(node.block)) {
      list.remove(item);
      return;
    }
  }

  switch (node.name) {
    case "charset":
      if (utils$9.hasNoChildren(node.prelude)) {
        list.remove(item);
        return;
      }

      // if there is any rule before @charset -> remove it
      if (item.prev) {
        list.remove(item);
        return;
      }

      break;

    case "import":
      if (this.stylesheet === null || !this.stylesheet.firstAtrulesAllowed) {
        list.remove(item);
        return;
      }

      // if there are some rules that not an @import or @charset before @import
      // remove it
      list.prevUntil(
        item.prev,
        function (rule) {
          if (rule.type === "Atrule") {
            if (rule.name === "import" || rule.name === "charset") {
              return;
            }
          }

          this.root.firstAtrulesAllowed = false;
          list.remove(item);

          return true;
        },
        this,
      );

      break;

    default: {
      const name = cssTree$m.keyword(node.name).basename;

      if (name === "keyframes" || name === "media" || name === "supports") {
        // drop at-rule with no prelude
        if (
          utils$9.hasNoChildren(node.prelude) ||
          utils$9.hasNoChildren(node.block)
        ) {
          list.remove(item);
        }
      }
    }
  }
}

var Atrule$3 = cleanAtrule;

function cleanComment(data, item, list) {
  list.remove(item);
}

var Comment$1 = cleanComment;

const cssTree$l = cjs;

function cleanDeclartion(node, item, list) {
  if (node.value.children && node.value.children.isEmpty) {
    list.remove(item);
    return;
  }

  if (cssTree$l.property(node.property).custom) {
    if (/\S/.test(node.value.value)) {
      node.value.value = node.value.value.trim();
    }
  }
}

var Declaration$1 = cleanDeclartion;

const utils$8 = utils$a;

function cleanRaw(node, item, list) {
  // raw in stylesheet or block children
  if (
    utils$8.isNodeChildrenList(this.stylesheet, list) ||
    utils$8.isNodeChildrenList(this.block, list)
  ) {
    list.remove(item);
  }
}

var Raw$1 = cleanRaw;

const cssTree$k = cjs;
const utils$7 = utils$a;

const { hasOwnProperty: hasOwnProperty$4 } = Object.prototype;
const skipUsageFilteringAtrule = new Set(["keyframes"]);

function cleanUnused(selectorList, usageData) {
  selectorList.children.forEach((selector, item, list) => {
    let shouldRemove = false;

    cssTree$k.walk(selector, function (node) {
      // ignore nodes in nested selectors
      if (this.selector === null || this.selector === selectorList) {
        switch (node.type) {
          case "SelectorList":
            // TODO: remove toLowerCase when pseudo selectors will be normalized
            // ignore selectors inside :not()
            if (
              this.function === null ||
              this.function.name.toLowerCase() !== "not"
            ) {
              if (cleanUnused(node, usageData)) {
                shouldRemove = true;
              }
            }
            break;

          case "ClassSelector":
            if (
              usageData.whitelist !== null &&
              usageData.whitelist.classes !== null &&
              !hasOwnProperty$4.call(usageData.whitelist.classes, node.name)
            ) {
              shouldRemove = true;
            }
            if (
              usageData.blacklist !== null &&
              usageData.blacklist.classes !== null &&
              hasOwnProperty$4.call(usageData.blacklist.classes, node.name)
            ) {
              shouldRemove = true;
            }
            break;

          case "IdSelector":
            if (
              usageData.whitelist !== null &&
              usageData.whitelist.ids !== null &&
              !hasOwnProperty$4.call(usageData.whitelist.ids, node.name)
            ) {
              shouldRemove = true;
            }
            if (
              usageData.blacklist !== null &&
              usageData.blacklist.ids !== null &&
              hasOwnProperty$4.call(usageData.blacklist.ids, node.name)
            ) {
              shouldRemove = true;
            }
            break;

          case "TypeSelector":
            // TODO: remove toLowerCase when type selectors will be normalized
            // ignore universal selectors
            if (node.name.charAt(node.name.length - 1) !== "*") {
              if (
                usageData.whitelist !== null &&
                usageData.whitelist.tags !== null &&
                !hasOwnProperty$4.call(
                  usageData.whitelist.tags,
                  node.name.toLowerCase(),
                )
              ) {
                shouldRemove = true;
              }
              if (
                usageData.blacklist !== null &&
                usageData.blacklist.tags !== null &&
                hasOwnProperty$4.call(
                  usageData.blacklist.tags,
                  node.name.toLowerCase(),
                )
              ) {
                shouldRemove = true;
              }
            }
            break;
        }
      }
    });

    if (shouldRemove) {
      list.remove(item);
    }
  });

  return selectorList.children.isEmpty;
}

function cleanRule(node, item, list, options) {
  if (
    utils$7.hasNoChildren(node.prelude) ||
    utils$7.hasNoChildren(node.block)
  ) {
    list.remove(item);
    return;
  }

  // avoid usage filtering for some at-rules
  if (
    this.atrule &&
    skipUsageFilteringAtrule.has(cssTree$k.keyword(this.atrule.name).basename)
  ) {
    return;
  }

  const { usage } = options;

  if (usage && (usage.whitelist !== null || usage.blacklist !== null)) {
    cleanUnused(node.prelude, usage);

    if (utils$7.hasNoChildren(node.prelude)) {
      list.remove(item);
      return;
    }
  }
}

var Rule$1 = cleanRule;

// remove useless universal selector
function cleanTypeSelector(node, item, list) {
  const name = item.data.name;

  // check it's a non-namespaced universal selector
  if (name !== "*") {
    return;
  }

  // remove when universal selector before other selectors
  const nextType = item.next && item.next.data.type;
  if (
    nextType === "IdSelector" ||
    nextType === "ClassSelector" ||
    nextType === "AttributeSelector" ||
    nextType === "PseudoClassSelector" ||
    nextType === "PseudoElementSelector"
  ) {
    list.remove(item);
  }
}

var TypeSelector$1 = cleanTypeSelector;

function cleanWhitespace(node, item, list) {
  list.remove(item);
}

var WhiteSpace$1 = cleanWhitespace;

const cssTree$j = cjs;
const Atrule$2 = Atrule$3;
const Comment = Comment$1;
const Declaration = Declaration$1;
const Raw = Raw$1;
const Rule = Rule$1;
const TypeSelector = TypeSelector$1;
const WhiteSpace = WhiteSpace$1;

const handlers$2 = {
  Atrule: Atrule$2,
  Comment,
  Declaration,
  Raw,
  Rule,
  TypeSelector,
  WhiteSpace,
};

function clean(ast, options) {
  cssTree$j.walk(ast, {
    leave(node, item, list) {
      if (handlers$2.hasOwnProperty(node.type)) {
        handlers$2[node.type].call(this, node, item, list, options);
      }
    },
  });
}

var clean_1 = clean;

function compressKeyframes(node) {
  node.block.children.forEach((rule) => {
    rule.prelude.children.forEach((simpleselector) => {
      simpleselector.children.forEach((data, item) => {
        if (data.type === "Percentage" && data.value === "100") {
          item.data = {
            type: "TypeSelector",
            loc: data.loc,
            name: "to",
          };
        } else if (data.type === "TypeSelector" && data.name === "from") {
          item.data = {
            type: "Percentage",
            loc: data.loc,
            value: "0",
          };
        }
      });
    });
  });
}

var keyframes$1 = compressKeyframes;

const cssTree$i = cjs;
const keyframes = keyframes$1;

function Atrule$1(node) {
  // compress @keyframe selectors
  if (cssTree$i.keyword(node.name).basename === "keyframes") {
    keyframes(node);
  }
}

var Atrule_1 = Atrule$1;

// Can unquote attribute detection
// Adopted implementation of Mathias Bynens
// https://github.com/mathiasbynens/mothereff.in/blob/master/unquoted-attributes/eff.js
const blockUnquoteRx =
  /^(-?\d|--)|[\u0000-\u002c\u002e\u002f\u003A-\u0040\u005B-\u005E\u0060\u007B-\u009f]/;

function canUnquote(value) {
  if (value === "" || value === "-") {
    return false;
  }

  return !blockUnquoteRx.test(value);
}

function AttributeSelector$1(node) {
  const attrValue = node.value;

  if (!attrValue || attrValue.type !== "String") {
    return;
  }

  if (canUnquote(attrValue.value)) {
    node.value = {
      type: "Identifier",
      loc: attrValue.loc,
      name: attrValue.value,
    };
  }
}

var AttributeSelector_1 = AttributeSelector$1;

function compressFont(node) {
  const list = node.children;

  list.forEachRight(function (node, item) {
    if (node.type === "Identifier") {
      if (node.name === "bold") {
        item.data = {
          type: "Number",
          loc: node.loc,
          value: "700",
        };
      } else if (node.name === "normal") {
        const prev = item.prev;

        if (prev && prev.data.type === "Operator" && prev.data.value === "/") {
          this.remove(prev);
        }

        this.remove(item);
      }
    }
  });

  if (list.isEmpty) {
    list.insert(
      list.createItem({
        type: "Identifier",
        name: "normal",
      }),
    );
  }
}

var font$1 = compressFont;

function compressFontWeight(node) {
  const value = node.children.head.data;

  if (value.type === "Identifier") {
    switch (value.name) {
      case "normal":
        node.children.head.data = {
          type: "Number",
          loc: value.loc,
          value: "400",
        };
        break;
      case "bold":
        node.children.head.data = {
          type: "Number",
          loc: value.loc,
          value: "700",
        };
        break;
    }
  }
}

var fontWeight$1 = compressFontWeight;

const cssTree$h = cjs;

function compressBackground(node) {
  function flush() {
    if (!buffer.length) {
      buffer.unshift(
        {
          type: "Number",
          loc: null,
          value: "0",
        },
        {
          type: "Number",
          loc: null,
          value: "0",
        },
      );
    }

    newValue.push.apply(newValue, buffer);

    buffer = [];
  }

  let newValue = [];
  let buffer = [];

  node.children.forEach((node) => {
    if (node.type === "Operator" && node.value === ",") {
      flush();
      newValue.push(node);
      return;
    }

    // remove defaults
    if (node.type === "Identifier") {
      if (
        node.name === "transparent" ||
        node.name === "none" ||
        node.name === "repeat" ||
        node.name === "scroll"
      ) {
        return;
      }
    }

    buffer.push(node);
  });

  flush();
  node.children = new cssTree$h.List().fromArray(newValue);
}

var background$1 = compressBackground;

function compressBorder(node) {
  node.children.forEach((node, item, list) => {
    if (node.type === "Identifier" && node.name.toLowerCase() === "none") {
      if (list.head === list.tail) {
        // replace `none` for zero when `none` is a single term
        item.data = {
          type: "Number",
          loc: node.loc,
          value: "0",
        };
      } else {
        list.remove(item);
      }
    }
  });
}

var border$1 = compressBorder;

const cssTree$g = cjs;
const font = font$1;
const fontWeight = fontWeight$1;
const background = background$1;
const border = border$1;

const handlers$1 = {
  font: font,
  "font-weight": fontWeight,
  background: background,
  border: border,
  outline: border,
};

function compressValue(node) {
  if (!this.declaration) {
    return;
  }

  const property = cssTree$g.property(this.declaration.property);

  if (handlers$1.hasOwnProperty(property.basename)) {
    handlers$1[property.basename](node);
  }
}

var Value$1 = compressValue;

var _Number$4 = {};

const OMIT_PLUSSIGN = /^(?:\+|(-))?0*(\d*)(?:\.0*|(\.\d*?)0*)?$/;
const KEEP_PLUSSIGN = /^([\+\-])?0*(\d*)(?:\.0*|(\.\d*?)0*)?$/;
const unsafeToRemovePlusSignAfter = new Set([
  "Dimension",
  "Hash",
  "Identifier",
  "Number",
  "Raw",
  "UnicodeRange",
]);

function packNumber(value, item) {
  // omit plus sign only if no prev or prev is safe type
  const regexp =
    item &&
    item.prev !== null &&
    unsafeToRemovePlusSignAfter.has(item.prev.data.type)
      ? KEEP_PLUSSIGN
      : OMIT_PLUSSIGN;

  // 100 -> '100'
  // 00100 -> '100'
  // +100 -> '100'
  // -100 -> '-100'
  // 0.123 -> '.123'
  // 0.12300 -> '.123'
  // 0.0 -> ''
  // 0 -> ''
  // -0 -> '-'
  value = String(value).replace(regexp, "$1$2$3");

  if (value === "" || value === "-") {
    value = "0";
  }
  // FIXME: is it solution simplier?
  // value = String(Number(value)).replace(/^(-?)0+\./, '$1.');

  return value;
}

function Number$1(node) {
  node.value = packNumber(node.value);
}

_Number$4.Number = Number$1;
_Number$4.packNumber = packNumber;

const _Number$3 = _Number$4;

const MATH_FUNCTIONS = new Set(["calc", "min", "max", "clamp"]);
const LENGTH_UNIT = new Set([
  // absolute length units
  "px",
  "mm",
  "cm",
  "in",
  "pt",
  "pc",

  // relative length units
  "em",
  "ex",
  "ch",
  "rem",

  // viewport-percentage lengths
  "vh",
  "vw",
  "vmin",
  "vmax",
  "vm",
]);

function compressDimension(node, item) {
  const value = _Number$3.packNumber(node.value);

  node.value = value;

  if (
    value === "0" &&
    this.declaration !== null &&
    this.atrulePrelude === null
  ) {
    const unit = node.unit.toLowerCase();

    // only length values can be compressed
    if (!LENGTH_UNIT.has(unit)) {
      return;
    }

    // issue #362: shouldn't remove unit in -ms-flex since it breaks flex in IE10/11
    // issue #200: shouldn't remove unit in flex since it breaks flex in IE10/11
    if (
      this.declaration.property === "-ms-flex" ||
      this.declaration.property === "flex"
    ) {
      return;
    }

    // issue #222: don't remove units inside calc
    if (this.function && MATH_FUNCTIONS.has(this.function.name)) {
      return;
    }

    item.data = {
      type: "Number",
      loc: node.loc,
      value,
    };
  }
}

var Dimension$1 = compressDimension;

const cssTree$f = cjs;
const _Number$2 = _Number$4;

const blacklist = new Set([
  // see https://github.com/jakubpawlowicz/clean-css/issues/957
  "width",
  "min-width",
  "max-width",
  "height",
  "min-height",
  "max-height",

  // issue #410: Dont remove units in flex-basis value for (-ms-)flex shorthand
  // issue #362: shouldn't remove unit in -ms-flex since it breaks flex in IE10/11
  // issue #200: shouldn't remove unit in flex since it breaks flex in IE10/11
  "flex",
  "-ms-flex",
]);

function compressPercentage(node, item) {
  node.value = _Number$2.packNumber(node.value);

  if (
    node.value === "0" &&
    this.declaration &&
    !blacklist.has(this.declaration.property)
  ) {
    // try to convert a number
    item.data = {
      type: "Number",
      loc: node.loc,
      value: node.value,
    };

    // that's ok only when new value matches on length
    if (
      !cssTree$f.lexer
        .matchDeclaration(this.declaration)
        .isType(item.data, "length")
    ) {
      // otherwise rollback changes
      item.data = node;
    }
  }
}

var Percentage$1 = compressPercentage;

function Url$1(node) {
  // convert `\\` to `/`
  node.value = node.value.replace(/\\/g, "/");
}

var Url_1 = Url$1;

var color$1 = {};

const cssTree$e = cjs;
const _Number$1 = _Number$4;

// http://www.w3.org/TR/css3-color/#svg-color
const NAME_TO_HEX = {
  aliceblue: "f0f8ff",
  antiquewhite: "faebd7",
  aqua: "0ff",
  aquamarine: "7fffd4",
  azure: "f0ffff",
  beige: "f5f5dc",
  bisque: "ffe4c4",
  black: "000",
  blanchedalmond: "ffebcd",
  blue: "00f",
  blueviolet: "8a2be2",
  brown: "a52a2a",
  burlywood: "deb887",
  cadetblue: "5f9ea0",
  chartreuse: "7fff00",
  chocolate: "d2691e",
  coral: "ff7f50",
  cornflowerblue: "6495ed",
  cornsilk: "fff8dc",
  crimson: "dc143c",
  cyan: "0ff",
  darkblue: "00008b",
  darkcyan: "008b8b",
  darkgoldenrod: "b8860b",
  darkgray: "a9a9a9",
  darkgrey: "a9a9a9",
  darkgreen: "006400",
  darkkhaki: "bdb76b",
  darkmagenta: "8b008b",
  darkolivegreen: "556b2f",
  darkorange: "ff8c00",
  darkorchid: "9932cc",
  darkred: "8b0000",
  darksalmon: "e9967a",
  darkseagreen: "8fbc8f",
  darkslateblue: "483d8b",
  darkslategray: "2f4f4f",
  darkslategrey: "2f4f4f",
  darkturquoise: "00ced1",
  darkviolet: "9400d3",
  deeppink: "ff1493",
  deepskyblue: "00bfff",
  dimgray: "696969",
  dimgrey: "696969",
  dodgerblue: "1e90ff",
  firebrick: "b22222",
  floralwhite: "fffaf0",
  forestgreen: "228b22",
  fuchsia: "f0f",
  gainsboro: "dcdcdc",
  ghostwhite: "f8f8ff",
  gold: "ffd700",
  goldenrod: "daa520",
  gray: "808080",
  grey: "808080",
  green: "008000",
  greenyellow: "adff2f",
  honeydew: "f0fff0",
  hotpink: "ff69b4",
  indianred: "cd5c5c",
  indigo: "4b0082",
  ivory: "fffff0",
  khaki: "f0e68c",
  lavender: "e6e6fa",
  lavenderblush: "fff0f5",
  lawngreen: "7cfc00",
  lemonchiffon: "fffacd",
  lightblue: "add8e6",
  lightcoral: "f08080",
  lightcyan: "e0ffff",
  lightgoldenrodyellow: "fafad2",
  lightgray: "d3d3d3",
  lightgrey: "d3d3d3",
  lightgreen: "90ee90",
  lightpink: "ffb6c1",
  lightsalmon: "ffa07a",
  lightseagreen: "20b2aa",
  lightskyblue: "87cefa",
  lightslategray: "789",
  lightslategrey: "789",
  lightsteelblue: "b0c4de",
  lightyellow: "ffffe0",
  lime: "0f0",
  limegreen: "32cd32",
  linen: "faf0e6",
  magenta: "f0f",
  maroon: "800000",
  mediumaquamarine: "66cdaa",
  mediumblue: "0000cd",
  mediumorchid: "ba55d3",
  mediumpurple: "9370db",
  mediumseagreen: "3cb371",
  mediumslateblue: "7b68ee",
  mediumspringgreen: "00fa9a",
  mediumturquoise: "48d1cc",
  mediumvioletred: "c71585",
  midnightblue: "191970",
  mintcream: "f5fffa",
  mistyrose: "ffe4e1",
  moccasin: "ffe4b5",
  navajowhite: "ffdead",
  navy: "000080",
  oldlace: "fdf5e6",
  olive: "808000",
  olivedrab: "6b8e23",
  orange: "ffa500",
  orangered: "ff4500",
  orchid: "da70d6",
  palegoldenrod: "eee8aa",
  palegreen: "98fb98",
  paleturquoise: "afeeee",
  palevioletred: "db7093",
  papayawhip: "ffefd5",
  peachpuff: "ffdab9",
  peru: "cd853f",
  pink: "ffc0cb",
  plum: "dda0dd",
  powderblue: "b0e0e6",
  purple: "800080",
  rebeccapurple: "639",
  red: "f00",
  rosybrown: "bc8f8f",
  royalblue: "4169e1",
  saddlebrown: "8b4513",
  salmon: "fa8072",
  sandybrown: "f4a460",
  seagreen: "2e8b57",
  seashell: "fff5ee",
  sienna: "a0522d",
  silver: "c0c0c0",
  skyblue: "87ceeb",
  slateblue: "6a5acd",
  slategray: "708090",
  slategrey: "708090",
  snow: "fffafa",
  springgreen: "00ff7f",
  steelblue: "4682b4",
  tan: "d2b48c",
  teal: "008080",
  thistle: "d8bfd8",
  tomato: "ff6347",
  turquoise: "40e0d0",
  violet: "ee82ee",
  wheat: "f5deb3",
  white: "fff",
  whitesmoke: "f5f5f5",
  yellow: "ff0",
  yellowgreen: "9acd32",
};

const HEX_TO_NAME = {
  800000: "maroon",
  800080: "purple",
  808000: "olive",
  808080: "gray",
  "00ffff": "cyan",
  f0ffff: "azure",
  f5f5dc: "beige",
  ffe4c4: "bisque",
  "000000": "black",
  "0000ff": "blue",
  a52a2a: "brown",
  ff7f50: "coral",
  ffd700: "gold",
  "008000": "green",
  "4b0082": "indigo",
  fffff0: "ivory",
  f0e68c: "khaki",
  "00ff00": "lime",
  faf0e6: "linen",
  "000080": "navy",
  ffa500: "orange",
  da70d6: "orchid",
  cd853f: "peru",
  ffc0cb: "pink",
  dda0dd: "plum",
  f00: "red",
  ff0000: "red",
  fa8072: "salmon",
  a0522d: "sienna",
  c0c0c0: "silver",
  fffafa: "snow",
  d2b48c: "tan",
  "008080": "teal",
  ff6347: "tomato",
  ee82ee: "violet",
  f5deb3: "wheat",
  ffffff: "white",
  ffff00: "yellow",
};

function hueToRgb(p, q, t) {
  if (t < 0) {
    t += 1;
  }
  if (t > 1) {
    t -= 1;
  }
  if (t < 1 / 6) {
    return p + (q - p) * 6 * t;
  }
  if (t < 1 / 2) {
    return q;
  }
  if (t < 2 / 3) {
    return p + (q - p) * (2 / 3 - t) * 6;
  }
  return p;
}

function hslToRgb(h, s, l, a) {
  let r;
  let g;
  let b;

  if (s === 0) {
    r = g = b = l; // achromatic
  } else {
    const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
    const p = 2 * l - q;

    r = hueToRgb(p, q, h + 1 / 3);
    g = hueToRgb(p, q, h);
    b = hueToRgb(p, q, h - 1 / 3);
  }

  return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255), a];
}

function toHex(value) {
  value = value.toString(16);

  return value.length === 1 ? "0" + value : value;
}

function parseFunctionArgs(functionArgs, count, rgb) {
  let cursor = functionArgs.head;
  let args = [];
  let wasValue = false;

  while (cursor !== null) {
    const { type, value } = cursor.data;

    switch (type) {
      case "Number":
      case "Percentage":
        if (wasValue) {
          return;
        }

        wasValue = true;
        args.push({
          type,
          value: Number(value),
        });

        break;

      case "Operator":
        if (value === ",") {
          if (!wasValue) {
            return;
          }
          wasValue = false;
        } else if (wasValue || value !== "+") {
          return;
        }

        break;

      default:
        // something we couldn't understand
        return;
    }

    cursor = cursor.next;
  }

  if (args.length !== count) {
    // invalid arguments count
    // TODO: remove those tokens
    return;
  }

  if (args.length === 4) {
    if (args[3].type !== "Number") {
      // 4th argument should be a number
      // TODO: remove those tokens
      return;
    }

    args[3].type = "Alpha";
  }

  if (rgb) {
    if (args[0].type !== args[1].type || args[0].type !== args[2].type) {
      // invalid color, numbers and percentage shouldn't be mixed
      // TODO: remove those tokens
      return;
    }
  } else {
    if (
      args[0].type !== "Number" ||
      args[1].type !== "Percentage" ||
      args[2].type !== "Percentage"
    ) {
      // invalid color, for hsl values should be: number, percentage, percentage
      // TODO: remove those tokens
      return;
    }

    args[0].type = "Angle";
  }

  return args.map(function (arg) {
    let value = Math.max(0, arg.value);

    switch (arg.type) {
      case "Number":
        // fit value to [0..255] range
        value = Math.min(value, 255);
        break;

      case "Percentage":
        // convert 0..100% to value in [0..255] range
        value = Math.min(value, 100) / 100;

        if (!rgb) {
          return value;
        }

        value = 255 * value;
        break;

      case "Angle":
        // fit value to (-360..360) range
        return (((value % 360) + 360) % 360) / 360;

      case "Alpha":
        // fit value to [0..1] range
        return Math.min(value, 1);
    }

    return Math.round(value);
  });
}

function compressFunction(node, item) {
  let functionName = node.name;
  let args;

  if (functionName === "rgba" || functionName === "hsla") {
    args = parseFunctionArgs(node.children, 4, functionName === "rgba");

    if (!args) {
      // something went wrong
      return;
    }

    if (functionName === "hsla") {
      args = hslToRgb(...args);
      node.name = "rgba";
    }

    if (args[3] === 0) {
      // try to replace `rgba(x, x, x, 0)` to `transparent`
      // always replace `rgba(0, 0, 0, 0)` to `transparent`
      // otherwise avoid replacement in gradients since it may break color transition
      // http://stackoverflow.com/questions/11829410/css3-gradient-rendering-issues-from-transparent-to-white
      const scopeFunctionName = this.function && this.function.name;

      if (
        (args[0] === 0 && args[1] === 0 && args[2] === 0) ||
        !/^(?:to|from|color-stop)$|gradient$/i.test(scopeFunctionName)
      ) {
        item.data = {
          type: "Identifier",
          loc: node.loc,
          name: "transparent",
        };

        return;
      }
    }

    if (args[3] !== 1) {
      // replace argument values for normalized/interpolated
      node.children.forEach((node, item, list) => {
        if (node.type === "Operator") {
          if (node.value !== ",") {
            list.remove(item);
          }
          return;
        }

        item.data = {
          type: "Number",
          loc: node.loc,
          value: _Number$1.packNumber(args.shift()),
        };
      });

      return;
    }

    // otherwise convert to rgb, i.e. rgba(255, 0, 0, 1) -> rgb(255, 0, 0)
    functionName = "rgb";
  }

  if (functionName === "hsl") {
    args = args || parseFunctionArgs(node.children, 3, false);

    if (!args) {
      // something went wrong
      return;
    }

    // convert to rgb
    args = hslToRgb(...args);
    functionName = "rgb";
  }

  if (functionName === "rgb") {
    args = args || parseFunctionArgs(node.children, 3, true);

    if (!args) {
      // something went wrong
      return;
    }

    item.data = {
      type: "Hash",
      loc: node.loc,
      value: toHex(args[0]) + toHex(args[1]) + toHex(args[2]),
    };

    compressHex(item.data, item);
  }
}

function compressIdent(node, item) {
  if (this.declaration === null) {
    return;
  }

  let color = node.name.toLowerCase();

  if (
    NAME_TO_HEX.hasOwnProperty(color) &&
    cssTree$e.lexer.matchDeclaration(this.declaration).isType(node, "color")
  ) {
    const hex = NAME_TO_HEX[color];

    if (hex.length + 1 <= color.length) {
      // replace for shorter hex value
      item.data = {
        type: "Hash",
        loc: node.loc,
        value: hex,
      };
    } else {
      // special case for consistent colors
      if (color === "grey") {
        color = "gray";
      }

      // just replace value for lower cased name
      node.name = color;
    }
  }
}

function compressHex(node, item) {
  let color = node.value.toLowerCase();

  // #112233 -> #123
  if (
    color.length === 6 &&
    color[0] === color[1] &&
    color[2] === color[3] &&
    color[4] === color[5]
  ) {
    color = color[0] + color[2] + color[4];
  }

  if (HEX_TO_NAME[color]) {
    item.data = {
      type: "Identifier",
      loc: node.loc,
      name: HEX_TO_NAME[color],
    };
  } else {
    node.value = color;
  }
}

color$1.compressFunction = compressFunction;
color$1.compressHex = compressHex;
color$1.compressIdent = compressIdent;

const cssTree$d = cjs;
const Atrule = Atrule_1;
const AttributeSelector = AttributeSelector_1;
const Value = Value$1;
const Dimension = Dimension$1;
const Percentage = Percentage$1;
const _Number = _Number$4;
const Url = Url_1;
const color = color$1;

const handlers = {
  Atrule,
  AttributeSelector,
  Value,
  Dimension,
  Percentage,
  Number: _Number.Number,
  Url,
  Hash: color.compressHex,
  Identifier: color.compressIdent,
  Function: color.compressFunction,
};

function replace(ast) {
  cssTree$d.walk(ast, {
    leave(node, item, list) {
      if (handlers.hasOwnProperty(node.type)) {
        handlers[node.type].call(this, node, item, list);
      }
    },
  });
}

var replace_1 = replace;

const cssTree$c = cjs;

class Index {
  constructor() {
    this.map = new Map();
  }
  resolve(str) {
    let index = this.map.get(str);

    if (index === undefined) {
      index = this.map.size + 1;
      this.map.set(str, index);
    }

    return index;
  }
}
function createDeclarationIndexer$1() {
  const ids = new Index();

  return function markDeclaration(node) {
    const id = cssTree$c.generate(node);

    node.id = ids.resolve(id);
    node.length = id.length;
    node.fingerprint = null;

    return node;
  };
}

var createDeclarationIndexer_1 = createDeclarationIndexer$1;

const cssTree$b = cjs;

function ensureSelectorList(node) {
  if (node.type === "Raw") {
    return cssTree$b.parse(node.value, { context: "selectorList" });
  }

  return node;
}

function maxSpecificity(a, b) {
  for (let i = 0; i < 3; i++) {
    if (a[i] !== b[i]) {
      return a[i] > b[i] ? a : b;
    }
  }

  return a;
}

function maxSelectorListSpecificity(selectorList) {
  return ensureSelectorList(selectorList).children.reduce(
    (result, node) => maxSpecificity(specificity$4(node), result),
    [0, 0, 0],
  );
}

// 16. Calculating a selectors specificity
// https://www.w3.org/TR/selectors-4/#specificity-rules
function specificity$4(simpleSelector) {
  let A = 0;
  let B = 0;
  let C = 0;

  // A selectors specificity is calculated for a given element as follows:
  simpleSelector.children.forEach((node) => {
    switch (node.type) {
      // count the number of ID selectors in the selector (= A)
      case "IdSelector":
        A++;
        break;

      // count the number of class selectors, attributes selectors, ...
      case "ClassSelector":
      case "AttributeSelector":
        B++;
        break;

      // ... and pseudo-classes in the selector (= B)
      case "PseudoClassSelector":
        switch (node.name.toLowerCase()) {
          // The specificity of an :is(), :not(), or :has() pseudo-class is replaced
          // by the specificity of the most specific complex selector in its selector list argument.
          case "not":
          case "has":
          case "is":
          // :matches() is used before it was renamed to :is()
          // https://github.com/w3c/csswg-drafts/issues/3258
          case "matches":
          // Older browsers support :is() functionality as prefixed pseudo-class :any()
          // https://developer.mozilla.org/en-US/docs/Web/CSS/:is
          case "-webkit-any":
          case "-moz-any": {
            const [a, b, c] = maxSelectorListSpecificity(node.children.first);

            A += a;
            B += b;
            C += c;

            break;
          }

          // Analogously, the specificity of an :nth-child() or :nth-last-child() selector
          // is the specificity of the pseudo class itself (counting as one pseudo-class selector)
          // plus the specificity of the most specific complex selector in its selector list argument (if any).
          case "nth-child":
          case "nth-last-child": {
            const arg = node.children.first;

            if (arg.type === "Nth" && arg.selector) {
              const [a, b, c] = maxSelectorListSpecificity(arg.selector);

              A += a;
              B += b + 1;
              C += c;
            } else {
              B++;
            }

            break;
          }

          // The specificity of a :where() pseudo-class is replaced by zero.
          case "where":
            break;

          // The four Level 2 pseudo-elements (::before, ::after, ::first-line, and ::first-letter) may,
          // for legacy reasons, be represented using the <pseudo-class-selector> grammar,
          // with only a single ":" character at their start.
          // https://www.w3.org/TR/selectors-4/#single-colon-pseudos
          case "before":
          case "after":
          case "first-line":
          case "first-letter":
            C++;
            break;

          default:
            B++;
        }
        break;

      // count the number of type selectors ...
      case "TypeSelector":
        // ignore the universal selector
        if (!node.name.endsWith("*")) {
          C++;
        }
        break;

      // ... and pseudo-elements in the selector (= C)
      case "PseudoElementSelector":
        C++;
        break;
    }
  });

  return [A, B, C];
}

var specificity_1 = specificity$4;

const cssTree$a = cjs;
const specificity$3 = specificity_1;

const nonFreezePseudoElements = new Set([
  "first-letter",
  "first-line",
  "after",
  "before",
]);
const nonFreezePseudoClasses = new Set([
  "link",
  "visited",
  "hover",
  "active",
  "first-letter",
  "first-line",
  "after",
  "before",
]);

function processSelector$2(node, usageData) {
  const pseudos = new Set();

  node.prelude.children.forEach(function (simpleSelector) {
    let tagName = "*";
    let scope = 0;

    simpleSelector.children.forEach(function (node) {
      switch (node.type) {
        case "ClassSelector":
          if (usageData && usageData.scopes) {
            const classScope = usageData.scopes[node.name] || 0;

            if (scope !== 0 && classScope !== scope) {
              throw new Error(
                "Selector can't has classes from different scopes: " +
                  cssTree$a.generate(simpleSelector),
              );
            }

            scope = classScope;
          }

          break;

        case "PseudoClassSelector": {
          const name = node.name.toLowerCase();

          if (!nonFreezePseudoClasses.has(name)) {
            pseudos.add(`:${name}`);
          }

          break;
        }

        case "PseudoElementSelector": {
          const name = node.name.toLowerCase();

          if (!nonFreezePseudoElements.has(name)) {
            pseudos.add(`::${name}`);
          }

          break;
        }

        case "TypeSelector":
          tagName = node.name.toLowerCase();
          break;

        case "AttributeSelector":
          if (node.flags) {
            pseudos.add(`[${node.flags.toLowerCase()}]`);
          }

          break;

        case "Combinator":
          tagName = "*";
          break;
      }
    });

    simpleSelector.compareMarker = specificity$3(simpleSelector).toString();
    simpleSelector.id = null; // pre-init property to avoid multiple hidden class
    simpleSelector.id = cssTree$a.generate(simpleSelector);

    if (scope) {
      simpleSelector.compareMarker += ":" + scope;
    }

    if (tagName !== "*") {
      simpleSelector.compareMarker += "," + tagName;
    }
  });

  // add property to all rule nodes to avoid multiple hidden class
  node.pseudoSignature =
    pseudos.size > 0 ? [...pseudos].sort().join(",") : false;
}

var processSelector_1 = processSelector$2;

const cssTree$9 = cjs;
const createDeclarationIndexer = createDeclarationIndexer_1;
const processSelector$1 = processSelector_1;

function prepare(ast, options) {
  const markDeclaration = createDeclarationIndexer();

  cssTree$9.walk(ast, {
    visit: "Rule",
    enter(node) {
      node.block.children.forEach(markDeclaration);
      processSelector$1(node, options.usage);
    },
  });

  cssTree$9.walk(ast, {
    visit: "Atrule",
    enter(node) {
      if (node.prelude) {
        node.prelude.id = null; // pre-init property to avoid multiple hidden class for generate
        node.prelude.id = cssTree$9.generate(node.prelude);
      }

      // compare keyframe selectors by its values
      // NOTE: still no clarification about problems with keyframes selector grouping (issue #197)
      if (cssTree$9.keyword(node.name).basename === "keyframes") {
        node.block.avoidRulesMerge = true; /* probably we don't need to prevent those merges for @keyframes
                                                       TODO: need to be checked */
        node.block.children.forEach(function (rule) {
          rule.prelude.children.forEach(function (simpleselector) {
            simpleselector.compareMarker = simpleselector.id;
          });
        });
      }
    },
  });

  return {
    declaration: markDeclaration,
  };
}

var prepare_1 = prepare;

const cssTree$8 = cjs;

const { hasOwnProperty: hasOwnProperty$3 } = Object.prototype;

function addRuleToMap(map, item, list, single) {
  const node = item.data;
  const name = cssTree$8.keyword(node.name).basename;
  const id =
    node.name.toLowerCase() + "/" + (node.prelude ? node.prelude.id : null);

  if (!hasOwnProperty$3.call(map, name)) {
    map[name] = Object.create(null);
  }

  if (single) {
    delete map[name][id];
  }

  if (!hasOwnProperty$3.call(map[name], id)) {
    map[name][id] = new cssTree$8.List();
  }

  map[name][id].append(list.remove(item));
}

function relocateAtrules(ast, options) {
  const collected = Object.create(null);
  let topInjectPoint = null;

  ast.children.forEach(function (node, item, list) {
    if (node.type === "Atrule") {
      const name = cssTree$8.keyword(node.name).basename;

      switch (name) {
        case "keyframes":
          addRuleToMap(collected, item, list, true);
          return;

        case "media":
          if (options.forceMediaMerge) {
            addRuleToMap(collected, item, list, false);
            return;
          }
          break;
      }

      if (topInjectPoint === null && name !== "charset" && name !== "import") {
        topInjectPoint = item;
      }
    } else {
      if (topInjectPoint === null) {
        topInjectPoint = item;
      }
    }
  });

  for (const atrule in collected) {
    for (const id in collected[atrule]) {
      ast.children.insertList(
        collected[atrule][id],
        atrule === "media" ? null : topInjectPoint,
      );
    }
  }
}
function isMediaRule(node) {
  return node.type === "Atrule" && node.name === "media";
}

function processAtrule(node, item, list) {
  if (!isMediaRule(node)) {
    return;
  }

  const prev = item.prev && item.prev.data;

  if (!prev || !isMediaRule(prev)) {
    return;
  }

  // merge @media with same query
  if (node.prelude && prev.prelude && node.prelude.id === prev.prelude.id) {
    prev.block.children.appendList(node.block.children);
    list.remove(item);

    // TODO: use it when we can refer to several points in source
    // prev.loc = {
    //     primary: prev.loc,
    //     merged: node.loc
    // };
  }
}

function rejoinAtrule(ast, options) {
  relocateAtrules(ast, options);

  cssTree$8.walk(ast, {
    visit: "Atrule",
    reverse: true,
    enter: processAtrule,
  });
}

var _1MergeAtrule$1 = rejoinAtrule;

var utils$6 = {};

const { hasOwnProperty: hasOwnProperty$2 } = Object.prototype;

function isEqualSelectors(a, b) {
  let cursor1 = a.head;
  let cursor2 = b.head;

  while (
    cursor1 !== null &&
    cursor2 !== null &&
    cursor1.data.id === cursor2.data.id
  ) {
    cursor1 = cursor1.next;
    cursor2 = cursor2.next;
  }

  return cursor1 === null && cursor2 === null;
}

function isEqualDeclarations(a, b) {
  let cursor1 = a.head;
  let cursor2 = b.head;

  while (
    cursor1 !== null &&
    cursor2 !== null &&
    cursor1.data.id === cursor2.data.id
  ) {
    cursor1 = cursor1.next;
    cursor2 = cursor2.next;
  }

  return cursor1 === null && cursor2 === null;
}

function compareDeclarations(declarations1, declarations2) {
  const result = {
    eq: [],
    ne1: [],
    ne2: [],
    ne2overrided: [],
  };

  const fingerprints = Object.create(null);
  const declarations2hash = Object.create(null);

  for (let cursor = declarations2.head; cursor; cursor = cursor.next) {
    declarations2hash[cursor.data.id] = true;
  }

  for (let cursor = declarations1.head; cursor; cursor = cursor.next) {
    const data = cursor.data;

    if (data.fingerprint) {
      fingerprints[data.fingerprint] = data.important;
    }

    if (declarations2hash[data.id]) {
      declarations2hash[data.id] = false;
      result.eq.push(data);
    } else {
      result.ne1.push(data);
    }
  }

  for (let cursor = declarations2.head; cursor; cursor = cursor.next) {
    const data = cursor.data;

    if (declarations2hash[data.id]) {
      // when declarations1 has an overriding declaration, this is not a difference
      // unless no !important is used on prev and !important is used on the following
      if (
        !hasOwnProperty$2.call(fingerprints, data.fingerprint) ||
        (!fingerprints[data.fingerprint] && data.important)
      ) {
        result.ne2.push(data);
      }

      result.ne2overrided.push(data);
    }
  }

  return result;
}

function addSelectors(dest, source) {
  source.forEach((sourceData) => {
    const newStr = sourceData.id;
    let cursor = dest.head;

    while (cursor) {
      const nextStr = cursor.data.id;

      if (nextStr === newStr) {
        return;
      }

      if (nextStr > newStr) {
        break;
      }

      cursor = cursor.next;
    }

    dest.insert(dest.createItem(sourceData), cursor);
  });

  return dest;
}

// check if simpleselectors has no equal specificity and element selector
function hasSimilarSelectors(selectors1, selectors2) {
  let cursor1 = selectors1.head;

  while (cursor1 !== null) {
    let cursor2 = selectors2.head;

    while (cursor2 !== null) {
      if (cursor1.data.compareMarker === cursor2.data.compareMarker) {
        return true;
      }

      cursor2 = cursor2.next;
    }

    cursor1 = cursor1.next;
  }

  return false;
}

// test node can't to be skipped
function unsafeToSkipNode(node) {
  switch (node.type) {
    case "Rule":
      // unsafe skip ruleset with selector similarities
      return hasSimilarSelectors(node.prelude.children, this);

    case "Atrule":
      // can skip at-rules with blocks
      if (node.block) {
        // unsafe skip at-rule if block contains something unsafe to skip
        return node.block.children.some(unsafeToSkipNode, this);
      }
      break;

    case "Declaration":
      return false;
  }

  // unsafe by default
  return true;
}

utils$6.addSelectors = addSelectors;
utils$6.compareDeclarations = compareDeclarations;
utils$6.hasSimilarSelectors = hasSimilarSelectors;
utils$6.isEqualDeclarations = isEqualDeclarations;
utils$6.isEqualSelectors = isEqualSelectors;
utils$6.unsafeToSkipNode = unsafeToSkipNode;

const cssTree$7 = cjs;
const utils$5 = utils$6;

function processRule$5(node, item, list) {
  const selectors = node.prelude.children;
  const declarations = node.block.children;

  list.prevUntil(item.prev, function (prev) {
    // skip non-ruleset node if safe
    if (prev.type !== "Rule") {
      return utils$5.unsafeToSkipNode.call(selectors, prev);
    }

    const prevSelectors = prev.prelude.children;
    const prevDeclarations = prev.block.children;

    // try to join rulesets with equal pseudo signature
    if (node.pseudoSignature === prev.pseudoSignature) {
      // try to join by selectors
      if (utils$5.isEqualSelectors(prevSelectors, selectors)) {
        prevDeclarations.appendList(declarations);
        list.remove(item);
        return true;
      }

      // try to join by declarations
      if (utils$5.isEqualDeclarations(declarations, prevDeclarations)) {
        utils$5.addSelectors(prevSelectors, selectors);
        list.remove(item);
        return true;
      }
    }

    // go to prev ruleset if has no selector similarities
    return utils$5.hasSimilarSelectors(selectors, prevSelectors);
  });
}

// NOTE: direction should be left to right, since rulesets merge to left
// ruleset. When direction right to left unmerged rulesets may prevent lookup
// TODO: remove initial merge
function initialMergeRule(ast) {
  cssTree$7.walk(ast, {
    visit: "Rule",
    enter: processRule$5,
  });
}

var _2InitialMergeRuleset$1 = initialMergeRule;

const cssTree$6 = cjs;

function processRule$4(node, item, list) {
  const selectors = node.prelude.children;

  // generate new rule sets:
  // .a, .b { color: red; }
  // ->
  // .a { color: red; }
  // .b { color: red; }

  // while there are more than 1 simple selector split for rulesets
  while (selectors.head !== selectors.tail) {
    const newSelectors = new cssTree$6.List();

    newSelectors.insert(selectors.remove(selectors.head));

    list.insert(
      list.createItem({
        type: "Rule",
        loc: node.loc,
        prelude: {
          type: "SelectorList",
          loc: node.prelude.loc,
          children: newSelectors,
        },
        block: {
          type: "Block",
          loc: node.block.loc,
          children: node.block.children.copy(),
        },
        pseudoSignature: node.pseudoSignature,
      }),
      item,
    );
  }
}

function disjoinRule(ast) {
  cssTree$6.walk(ast, {
    visit: "Rule",
    reverse: true,
    enter: processRule$4,
  });
}

var _3DisjoinRuleset$1 = disjoinRule;

const cssTree$5 = cjs;

const REPLACE = 1;
const REMOVE = 2;
const TOP = 0;
const RIGHT = 1;
const BOTTOM = 2;
const LEFT = 3;
const SIDES = ["top", "right", "bottom", "left"];
const SIDE = {
  "margin-top": "top",
  "margin-right": "right",
  "margin-bottom": "bottom",
  "margin-left": "left",

  "padding-top": "top",
  "padding-right": "right",
  "padding-bottom": "bottom",
  "padding-left": "left",

  "border-top-color": "top",
  "border-right-color": "right",
  "border-bottom-color": "bottom",
  "border-left-color": "left",
  "border-top-width": "top",
  "border-right-width": "right",
  "border-bottom-width": "bottom",
  "border-left-width": "left",
  "border-top-style": "top",
  "border-right-style": "right",
  "border-bottom-style": "bottom",
  "border-left-style": "left",
};
const MAIN_PROPERTY = {
  margin: "margin",
  "margin-top": "margin",
  "margin-right": "margin",
  "margin-bottom": "margin",
  "margin-left": "margin",

  padding: "padding",
  "padding-top": "padding",
  "padding-right": "padding",
  "padding-bottom": "padding",
  "padding-left": "padding",

  "border-color": "border-color",
  "border-top-color": "border-color",
  "border-right-color": "border-color",
  "border-bottom-color": "border-color",
  "border-left-color": "border-color",
  "border-width": "border-width",
  "border-top-width": "border-width",
  "border-right-width": "border-width",
  "border-bottom-width": "border-width",
  "border-left-width": "border-width",
  "border-style": "border-style",
  "border-top-style": "border-style",
  "border-right-style": "border-style",
  "border-bottom-style": "border-style",
  "border-left-style": "border-style",
};

class TRBL {
  constructor(name) {
    this.name = name;
    this.loc = null;
    this.iehack = undefined;
    this.sides = {
      top: null,
      right: null,
      bottom: null,
      left: null,
    };
  }

  getValueSequence(declaration, count) {
    const values = [];
    let iehack = "";
    const hasBadValues =
      declaration.value.type !== "Value" ||
      declaration.value.children.some(function (child) {
        let special = false;

        switch (child.type) {
          case "Identifier":
            switch (child.name) {
              case "\\0":
              case "\\9":
                iehack = child.name;
                return;

              case "inherit":
              case "initial":
              case "unset":
              case "revert":
                special = child.name;
                break;
            }
            break;

          case "Dimension":
            switch (child.unit) {
              // is not supported until IE11
              case "rem":

              // v* units is too buggy across browsers and better
              // don't merge values with those units
              case "vw":
              case "vh":
              case "vmin":
              case "vmax":
              case "vm": // IE9 supporting "vm" instead of "vmin".
                special = child.unit;
                break;
            }
            break;

          case "Hash": // color
          case "Number":
          case "Percentage":
            break;

          case "Function":
            if (child.name === "var") {
              return true;
            }

            special = child.name;
            break;

          default:
            return true; // bad value
        }

        values.push({
          node: child,
          special,
          important: declaration.important,
        });
      });

    if (hasBadValues || values.length > count) {
      return false;
    }

    if (typeof this.iehack === "string" && this.iehack !== iehack) {
      return false;
    }

    this.iehack = iehack; // move outside

    return values;
  }

  canOverride(side, value) {
    const currentValue = this.sides[side];

    return !currentValue || (value.important && !currentValue.important);
  }

  add(name, declaration) {
    function attemptToAdd() {
      const sides = this.sides;
      const side = SIDE[name];

      if (side) {
        if (side in sides === false) {
          return false;
        }

        const values = this.getValueSequence(declaration, 1);

        if (!values || !values.length) {
          return false;
        }

        // can mix only if specials are equal
        for (const key in sides) {
          if (sides[key] !== null && sides[key].special !== values[0].special) {
            return false;
          }
        }

        if (!this.canOverride(side, values[0])) {
          return true;
        }

        sides[side] = values[0];

        return true;
      } else if (name === this.name) {
        const values = this.getValueSequence(declaration, 4);

        if (!values || !values.length) {
          return false;
        }

        switch (values.length) {
          case 1:
            values[RIGHT] = values[TOP];
            values[BOTTOM] = values[TOP];
            values[LEFT] = values[TOP];
            break;

          case 2:
            values[BOTTOM] = values[TOP];
            values[LEFT] = values[RIGHT];
            break;

          case 3:
            values[LEFT] = values[RIGHT];
            break;
        }

        // can mix only if specials are equal
        for (let i = 0; i < 4; i++) {
          for (const key in sides) {
            if (
              sides[key] !== null &&
              sides[key].special !== values[i].special
            ) {
              return false;
            }
          }
        }

        for (let i = 0; i < 4; i++) {
          if (this.canOverride(SIDES[i], values[i])) {
            sides[SIDES[i]] = values[i];
          }
        }

        return true;
      }
    }

    if (!attemptToAdd.call(this)) {
      return false;
    }

    // TODO: use it when we can refer to several points in source
    // if (this.loc) {
    //     this.loc = {
    //         primary: this.loc,
    //         merged: declaration.loc
    //     };
    // } else {
    //     this.loc = declaration.loc;
    // }
    if (!this.loc) {
      this.loc = declaration.loc;
    }

    return true;
  }

  isOkToMinimize() {
    const top = this.sides.top;
    const right = this.sides.right;
    const bottom = this.sides.bottom;
    const left = this.sides.left;

    if (top && right && bottom && left) {
      const important =
        top.important + right.important + bottom.important + left.important;

      return important === 0 || important === 4;
    }

    return false;
  }

  getValue() {
    const result = new cssTree$5.List();
    const sides = this.sides;
    const values = [sides.top, sides.right, sides.bottom, sides.left];
    const stringValues = [
      cssTree$5.generate(sides.top.node),
      cssTree$5.generate(sides.right.node),
      cssTree$5.generate(sides.bottom.node),
      cssTree$5.generate(sides.left.node),
    ];

    if (stringValues[LEFT] === stringValues[RIGHT]) {
      values.pop();
      if (stringValues[BOTTOM] === stringValues[TOP]) {
        values.pop();
        if (stringValues[RIGHT] === stringValues[TOP]) {
          values.pop();
        }
      }
    }

    for (let i = 0; i < values.length; i++) {
      result.appendData(values[i].node);
    }

    if (this.iehack) {
      result.appendData({
        type: "Identifier",
        loc: null,
        name: this.iehack,
      });
    }

    return {
      type: "Value",
      loc: null,
      children: result,
    };
  }

  getDeclaration() {
    return {
      type: "Declaration",
      loc: this.loc,
      important: this.sides.top.important,
      property: this.name,
      value: this.getValue(),
    };
  }
}

function processRule$3(rule, shorts, shortDeclarations, lastShortSelector) {
  const declarations = rule.block.children;
  const selector = rule.prelude.children.first.id;

  rule.block.children.forEachRight(function (declaration, item) {
    const property = declaration.property;

    if (!MAIN_PROPERTY.hasOwnProperty(property)) {
      return;
    }

    const key = MAIN_PROPERTY[property];
    let shorthand;
    let operation;

    if (!lastShortSelector || selector === lastShortSelector) {
      if (key in shorts) {
        operation = REMOVE;
        shorthand = shorts[key];
      }
    }

    if (!shorthand || !shorthand.add(property, declaration)) {
      operation = REPLACE;
      shorthand = new TRBL(key);

      // if can't parse value ignore it and break shorthand children
      if (!shorthand.add(property, declaration)) {
        lastShortSelector = null;
        return;
      }
    }

    shorts[key] = shorthand;
    shortDeclarations.push({
      operation,
      block: declarations,
      item,
      shorthand,
    });

    lastShortSelector = selector;
  });

  return lastShortSelector;
}

function processShorthands(shortDeclarations, markDeclaration) {
  shortDeclarations.forEach(function (item) {
    const shorthand = item.shorthand;

    if (!shorthand.isOkToMinimize()) {
      return;
    }

    if (item.operation === REPLACE) {
      item.item.data = markDeclaration(shorthand.getDeclaration());
    } else {
      item.block.remove(item.item);
    }
  });
}

function restructBlock$1(ast, indexer) {
  const stylesheetMap = {};
  const shortDeclarations = [];

  cssTree$5.walk(ast, {
    visit: "Rule",
    reverse: true,
    enter(node) {
      const stylesheet = this.block || this.stylesheet;
      const ruleId =
        (node.pseudoSignature || "") + "|" + node.prelude.children.first.id;
      let ruleMap;
      let shorts;

      if (!stylesheetMap.hasOwnProperty(stylesheet.id)) {
        ruleMap = {
          lastShortSelector: null,
        };
        stylesheetMap[stylesheet.id] = ruleMap;
      } else {
        ruleMap = stylesheetMap[stylesheet.id];
      }

      if (ruleMap.hasOwnProperty(ruleId)) {
        shorts = ruleMap[ruleId];
      } else {
        shorts = {};
        ruleMap[ruleId] = shorts;
      }

      ruleMap.lastShortSelector = processRule$3.call(
        this,
        node,
        shorts,
        shortDeclarations,
        ruleMap.lastShortSelector,
      );
    },
  });

  processShorthands(shortDeclarations, indexer.declaration);
}

var _4RestructShorthand$1 = restructBlock$1;

const cssTree$4 = cjs;

let fingerprintId = 1;
const dontRestructure = new Set([
  "src", // https://github.com/afelix/csso/issues/50
]);

const DONT_MIX_VALUE = {
  // https://developer.mozilla.org/en-US/docs/Web/CSS/display#Browser_compatibility
  display: /table|ruby|flex|-(flex)?box$|grid|contents|run-in/i,
  // https://developer.mozilla.org/en/docs/Web/CSS/text-align
  "text-align": /^(start|end|match-parent|justify-all)$/i,
};

const SAFE_VALUES = {
  cursor: [
    "auto",
    "crosshair",
    "default",
    "move",
    "text",
    "wait",
    "help",
    "n-resize",
    "e-resize",
    "s-resize",
    "w-resize",
    "ne-resize",
    "nw-resize",
    "se-resize",
    "sw-resize",
    "pointer",
    "progress",
    "not-allowed",
    "no-drop",
    "vertical-text",
    "all-scroll",
    "col-resize",
    "row-resize",
  ],
  overflow: ["hidden", "visible", "scroll", "auto"],
  position: ["static", "relative", "absolute", "fixed"],
};

const NEEDLESS_TABLE = {
  "border-width": ["border"],
  "border-style": ["border"],
  "border-color": ["border"],
  "border-top": ["border"],
  "border-right": ["border"],
  "border-bottom": ["border"],
  "border-left": ["border"],
  "border-top-width": ["border-top", "border-width", "border"],
  "border-right-width": ["border-right", "border-width", "border"],
  "border-bottom-width": ["border-bottom", "border-width", "border"],
  "border-left-width": ["border-left", "border-width", "border"],
  "border-top-style": ["border-top", "border-style", "border"],
  "border-right-style": ["border-right", "border-style", "border"],
  "border-bottom-style": ["border-bottom", "border-style", "border"],
  "border-left-style": ["border-left", "border-style", "border"],
  "border-top-color": ["border-top", "border-color", "border"],
  "border-right-color": ["border-right", "border-color", "border"],
  "border-bottom-color": ["border-bottom", "border-color", "border"],
  "border-left-color": ["border-left", "border-color", "border"],
  "margin-top": ["margin"],
  "margin-right": ["margin"],
  "margin-bottom": ["margin"],
  "margin-left": ["margin"],
  "padding-top": ["padding"],
  "padding-right": ["padding"],
  "padding-bottom": ["padding"],
  "padding-left": ["padding"],
  "font-style": ["font"],
  "font-variant": ["font"],
  "font-weight": ["font"],
  "font-size": ["font"],
  "font-family": ["font"],
  "list-style-type": ["list-style"],
  "list-style-position": ["list-style"],
  "list-style-image": ["list-style"],
};

function getPropertyFingerprint(propertyName, declaration, fingerprints) {
  const realName = cssTree$4.property(propertyName).basename;

  if (realName === "background") {
    return propertyName + ":" + cssTree$4.generate(declaration.value);
  }

  const declarationId = declaration.id;
  let fingerprint = fingerprints[declarationId];

  if (!fingerprint) {
    switch (declaration.value.type) {
      case "Value":
        const special = {};
        let vendorId = "";
        let iehack = "";
        let raw = false;

        declaration.value.children.forEach(function walk(node) {
          switch (node.type) {
            case "Value":
            case "Brackets":
            case "Parentheses":
              node.children.forEach(walk);
              break;

            case "Raw":
              raw = true;
              break;

            case "Identifier": {
              const { name } = node;

              if (!vendorId) {
                vendorId = cssTree$4.keyword(name).vendor;
              }

              if (/\\[09]/.test(name)) {
                iehack = RegExp.lastMatch;
              }

              if (SAFE_VALUES.hasOwnProperty(realName)) {
                if (SAFE_VALUES[realName].indexOf(name) === -1) {
                  special[name] = true;
                }
              } else if (DONT_MIX_VALUE.hasOwnProperty(realName)) {
                if (DONT_MIX_VALUE[realName].test(name)) {
                  special[name] = true;
                }
              }

              break;
            }

            case "Function": {
              let { name } = node;

              if (!vendorId) {
                vendorId = cssTree$4.keyword(name).vendor;
              }

              if (name === "rect") {
                // there are 2 forms of rect:
                //   rect(<top>, <right>, <bottom>, <left>) - standart
                //   rect(<top> <right> <bottom> <left>)  backwards compatible syntax
                // only the same form values can be merged
                const hasComma = node.children.some(
                  (node) => node.type === "Operator" && node.value === ",",
                );

                if (!hasComma) {
                  name = "rect-backward";
                }
              }

              special[name + "()"] = true;

              // check nested tokens too
              node.children.forEach(walk);

              break;
            }

            case "Dimension": {
              const { unit } = node;

              if (/\\[09]/.test(unit)) {
                iehack = RegExp.lastMatch;
              }

              switch (unit) {
                // is not supported until IE11
                case "rem":

                // v* units is too buggy across browsers and better
                // don't merge values with those units
                case "vw":
                case "vh":
                case "vmin":
                case "vmax":
                case "vm": // IE9 supporting "vm" instead of "vmin".
                  special[unit] = true;
                  break;
              }

              break;
            }
          }
        });

        fingerprint = raw
          ? "!" + fingerprintId++
          : "!" + Object.keys(special).sort() + "|" + iehack + vendorId;
        break;

      case "Raw":
        fingerprint = "!" + declaration.value.value;
        break;

      default:
        fingerprint = cssTree$4.generate(declaration.value);
    }

    fingerprints[declarationId] = fingerprint;
  }

  return propertyName + fingerprint;
}

function needless(props, declaration, fingerprints) {
  const property = cssTree$4.property(declaration.property);

  if (NEEDLESS_TABLE.hasOwnProperty(property.basename)) {
    const table = NEEDLESS_TABLE[property.basename];

    for (const entry of table) {
      const ppre = getPropertyFingerprint(
        property.prefix + entry,
        declaration,
        fingerprints,
      );
      const prev = props.hasOwnProperty(ppre) ? props[ppre] : null;

      if (prev && (!declaration.important || prev.item.data.important)) {
        return prev;
      }
    }
  }
}

function processRule$2(rule, item, list, props, fingerprints) {
  const declarations = rule.block.children;

  declarations.forEachRight(function (declaration, declarationItem) {
    const { property } = declaration;
    const fingerprint = getPropertyFingerprint(
      property,
      declaration,
      fingerprints,
    );
    const prev = props[fingerprint];

    if (prev && !dontRestructure.has(property)) {
      if (declaration.important && !prev.item.data.important) {
        props[fingerprint] = {
          block: declarations,
          item: declarationItem,
        };

        prev.block.remove(prev.item);

        // TODO: use it when we can refer to several points in source
        // declaration.loc = {
        //     primary: declaration.loc,
        //     merged: prev.item.data.loc
        // };
      } else {
        declarations.remove(declarationItem);

        // TODO: use it when we can refer to several points in source
        // prev.item.data.loc = {
        //     primary: prev.item.data.loc,
        //     merged: declaration.loc
        // };
      }
    } else {
      const prev = needless(props, declaration, fingerprints);

      if (prev) {
        declarations.remove(declarationItem);

        // TODO: use it when we can refer to several points in source
        // prev.item.data.loc = {
        //     primary: prev.item.data.loc,
        //     merged: declaration.loc
        // };
      } else {
        declaration.fingerprint = fingerprint;

        props[fingerprint] = {
          block: declarations,
          item: declarationItem,
        };
      }
    }
  });

  if (declarations.isEmpty) {
    list.remove(item);
  }
}

function restructBlock(ast) {
  const stylesheetMap = {};
  const fingerprints = Object.create(null);

  cssTree$4.walk(ast, {
    visit: "Rule",
    reverse: true,
    enter(node, item, list) {
      const stylesheet = this.block || this.stylesheet;
      const ruleId =
        (node.pseudoSignature || "") + "|" + node.prelude.children.first.id;
      let ruleMap;
      let props;

      if (!stylesheetMap.hasOwnProperty(stylesheet.id)) {
        ruleMap = {};
        stylesheetMap[stylesheet.id] = ruleMap;
      } else {
        ruleMap = stylesheetMap[stylesheet.id];
      }

      if (ruleMap.hasOwnProperty(ruleId)) {
        props = ruleMap[ruleId];
      } else {
        props = {};
        ruleMap[ruleId] = props;
      }

      processRule$2.call(this, node, item, list, props, fingerprints);
    },
  });
}

var _6RestructBlock$1 = restructBlock;

const cssTree$3 = cjs;
const utils$4 = utils$6;

/*
    At this step all rules has single simple selector. We try to join by equal
    declaration blocks to first rule, e.g.

    .a { color: red }
    b { ... }
    .b { color: red }
    ->
    .a, .b { color: red }
    b { ... }
*/

function processRule$1(node, item, list) {
  const selectors = node.prelude.children;
  const declarations = node.block.children;
  const nodeCompareMarker = selectors.first.compareMarker;
  const skippedCompareMarkers = {};

  list.nextUntil(item.next, function (next, nextItem) {
    // skip non-ruleset node if safe
    if (next.type !== "Rule") {
      return utils$4.unsafeToSkipNode.call(selectors, next);
    }

    if (node.pseudoSignature !== next.pseudoSignature) {
      return true;
    }

    const nextFirstSelector = next.prelude.children.head;
    const nextDeclarations = next.block.children;
    const nextCompareMarker = nextFirstSelector.data.compareMarker;

    // if next ruleset has same marked as one of skipped then stop joining
    if (nextCompareMarker in skippedCompareMarkers) {
      return true;
    }

    // try to join by selectors
    if (selectors.head === selectors.tail) {
      if (selectors.first.id === nextFirstSelector.data.id) {
        declarations.appendList(nextDeclarations);
        list.remove(nextItem);
        return;
      }
    }

    // try to join by properties
    if (utils$4.isEqualDeclarations(declarations, nextDeclarations)) {
      const nextStr = nextFirstSelector.data.id;

      selectors.some((data, item) => {
        const curStr = data.id;

        if (nextStr < curStr) {
          selectors.insert(nextFirstSelector, item);
          return true;
        }

        if (!item.next) {
          selectors.insert(nextFirstSelector);
          return true;
        }
      });

      list.remove(nextItem);
      return;
    }

    // go to next ruleset if current one can be skipped (has no equal specificity nor element selector)
    if (nextCompareMarker === nodeCompareMarker) {
      return true;
    }

    skippedCompareMarkers[nextCompareMarker] = true;
  });
}

function mergeRule(ast) {
  cssTree$3.walk(ast, {
    visit: "Rule",
    enter: processRule$1,
  });
}

var _7MergeRuleset$1 = mergeRule;

const cssTree$2 = cjs;
const utils$3 = utils$6;

function calcSelectorLength(list) {
  return list.reduce((res, data) => res + data.id.length + 1, 0) - 1;
}

function calcDeclarationsLength(tokens) {
  let length = 0;

  for (const token of tokens) {
    length += token.length;
  }

  return (
    length + // declarations
    tokens.length -
    1 // delimeters
  );
}

function processRule(node, item, list) {
  const avoidRulesMerge =
    this.block !== null ? this.block.avoidRulesMerge : false;
  const selectors = node.prelude.children;
  const block = node.block;
  const disallowDownMarkers = Object.create(null);
  let allowMergeUp = true;
  let allowMergeDown = true;

  list.prevUntil(item.prev, function (prev, prevItem) {
    const prevBlock = prev.block;
    const prevType = prev.type;

    if (prevType !== "Rule") {
      const unsafe = utils$3.unsafeToSkipNode.call(selectors, prev);

      if (!unsafe && prevType === "Atrule" && prevBlock) {
        cssTree$2.walk(prevBlock, {
          visit: "Rule",
          enter(node) {
            node.prelude.children.forEach((data) => {
              disallowDownMarkers[data.compareMarker] = true;
            });
          },
        });
      }

      return unsafe;
    }

    if (node.pseudoSignature !== prev.pseudoSignature) {
      return true;
    }

    const prevSelectors = prev.prelude.children;

    allowMergeDown = !prevSelectors.some(
      (selector) => selector.compareMarker in disallowDownMarkers,
    );

    // try prev ruleset if simpleselectors has no equal specifity and element selector
    if (!allowMergeDown && !allowMergeUp) {
      return true;
    }

    // try to join by selectors
    if (allowMergeUp && utils$3.isEqualSelectors(prevSelectors, selectors)) {
      prevBlock.children.appendList(block.children);
      list.remove(item);

      return true;
    }

    // try to join by properties
    const diff = utils$3.compareDeclarations(
      block.children,
      prevBlock.children,
    );

    // console.log(diff.eq, diff.ne1, diff.ne2);

    if (diff.eq.length) {
      if (!diff.ne1.length && !diff.ne2.length) {
        // equal blocks
        if (allowMergeDown) {
          utils$3.addSelectors(selectors, prevSelectors);
          list.remove(prevItem);
        }

        return true;
      } else if (!avoidRulesMerge) {
        /* probably we don't need to prevent those merges for @keyframes
                                              TODO: need to be checked */

        if (diff.ne1.length && !diff.ne2.length) {
          // prevBlock is subset block
          const selectorLength = calcSelectorLength(selectors);
          const blockLength = calcDeclarationsLength(diff.eq); // declarations length

          if (allowMergeUp && selectorLength < blockLength) {
            utils$3.addSelectors(prevSelectors, selectors);
            block.children.fromArray(diff.ne1);
          }
        } else if (!diff.ne1.length && diff.ne2.length) {
          // node is subset of prevBlock
          const selectorLength = calcSelectorLength(prevSelectors);
          const blockLength = calcDeclarationsLength(diff.eq); // declarations length

          if (allowMergeDown && selectorLength < blockLength) {
            utils$3.addSelectors(selectors, prevSelectors);
            prevBlock.children.fromArray(diff.ne2);
          }
        } else {
          // diff.ne1.length && diff.ne2.length
          // extract equal block
          const newSelector = {
            type: "SelectorList",
            loc: null,
            children: utils$3.addSelectors(prevSelectors.copy(), selectors),
          };
          const newBlockLength = calcSelectorLength(newSelector.children) + 2; // selectors length + curly braces length
          const blockLength = calcDeclarationsLength(diff.eq); // declarations length

          // create new ruleset if declarations length greater than
          // ruleset description overhead
          if (blockLength >= newBlockLength) {
            const newItem = list.createItem({
              type: "Rule",
              loc: null,
              prelude: newSelector,
              block: {
                type: "Block",
                loc: null,
                children: new cssTree$2.List().fromArray(diff.eq),
              },
              pseudoSignature: node.pseudoSignature,
            });

            block.children.fromArray(diff.ne1);
            prevBlock.children.fromArray(diff.ne2overrided);

            if (allowMergeUp) {
              list.insert(newItem, prevItem);
            } else {
              list.insert(newItem, item);
            }

            return true;
          }
        }
      }
    }

    if (allowMergeUp) {
      // TODO: disallow up merge only if any property interception only (i.e. diff.ne2overrided.length > 0);
      // await property families to find property interception correctly
      allowMergeUp = !prevSelectors.some((prevSelector) =>
        selectors.some(
          (selector) => selector.compareMarker === prevSelector.compareMarker,
        ),
      );
    }

    prevSelectors.forEach((data) => {
      disallowDownMarkers[data.compareMarker] = true;
    });
  });
}

function restructRule(ast) {
  cssTree$2.walk(ast, {
    visit: "Rule",
    reverse: true,
    enter: processRule,
  });
}

var _8RestructRuleset$1 = restructRule;

const index$3 = prepare_1;
const _1MergeAtrule = _1MergeAtrule$1;
const _2InitialMergeRuleset = _2InitialMergeRuleset$1;
const _3DisjoinRuleset = _3DisjoinRuleset$1;
const _4RestructShorthand = _4RestructShorthand$1;
const _6RestructBlock = _6RestructBlock$1;
const _7MergeRuleset = _7MergeRuleset$1;
const _8RestructRuleset = _8RestructRuleset$1;

function restructure(ast, options) {
  // prepare ast for restructing
  const indexer = index$3(ast, options);
  options.logger("prepare", ast);

  _1MergeAtrule(ast, options);
  options.logger("mergeAtrule", ast);

  _2InitialMergeRuleset(ast);
  options.logger("initialMergeRuleset", ast);

  _3DisjoinRuleset(ast);
  options.logger("disjoinRuleset", ast);

  _4RestructShorthand(ast, indexer);
  options.logger("restructShorthand", ast);

  _6RestructBlock(ast);
  options.logger("restructBlock", ast);

  _7MergeRuleset(ast);
  options.logger("mergeRuleset", ast);

  _8RestructRuleset(ast);
  options.logger("restructRuleset", ast);
}

var restructure_1 = restructure;

const cssTree$1 = cjs;
const usage = usage$1;
const index = clean_1;
const index$1 = replace_1;
const index$2 = restructure_1;

function readChunk(input, specialComments) {
  const children = new cssTree$1.List();
  let nonSpaceTokenInBuffer = false;
  let protectedComment;

  input.nextUntil(input.head, (node, item, list) => {
    if (node.type === "Comment") {
      if (!specialComments || node.value.charAt(0) !== "!") {
        list.remove(item);
        return;
      }

      if (nonSpaceTokenInBuffer || protectedComment) {
        return true;
      }

      list.remove(item);
      protectedComment = node;

      return;
    }

    if (node.type !== "WhiteSpace") {
      nonSpaceTokenInBuffer = true;
    }

    children.insert(list.remove(item));
  });

  return {
    comment: protectedComment,
    stylesheet: {
      type: "StyleSheet",
      loc: null,
      children,
    },
  };
}

function compressChunk(ast, firstAtrulesAllowed, num, options) {
  options.logger(`Compress block #${num}`, null, true);

  let seed = 1;

  if (ast.type === "StyleSheet") {
    ast.firstAtrulesAllowed = firstAtrulesAllowed;
    ast.id = seed++;
  }

  cssTree$1.walk(ast, {
    visit: "Atrule",
    enter(node) {
      if (node.block !== null) {
        node.block.id = seed++;
      }
    },
  });
  options.logger("init", ast);

  // remove redundant
  index(ast, options);
  options.logger("clean", ast);

  // replace nodes for shortened forms
  index$1(ast);
  options.logger("replace", ast);

  // structure optimisations
  if (options.restructuring) {
    index$2(ast, options);
  }

  return ast;
}

function getCommentsOption(options) {
  let comments = "comments" in options ? options.comments : "exclamation";

  if (typeof comments === "boolean") {
    comments = comments ? "exclamation" : false;
  } else if (comments !== "exclamation" && comments !== "first-exclamation") {
    comments = false;
  }

  return comments;
}

function getRestructureOption(options) {
  if ("restructure" in options) {
    return options.restructure;
  }

  return "restructuring" in options ? options.restructuring : true;
}

function wrapBlock(block) {
  return new cssTree$1.List().appendData({
    type: "Rule",
    loc: null,
    prelude: {
      type: "SelectorList",
      loc: null,
      children: new cssTree$1.List().appendData({
        type: "Selector",
        loc: null,
        children: new cssTree$1.List().appendData({
          type: "TypeSelector",
          loc: null,
          name: "x",
        }),
      }),
    },
    block,
  });
}

function compress$2(ast, options) {
  ast = ast || {
    type: "StyleSheet",
    loc: null,
    children: new cssTree$1.List(),
  };
  options = options || {};

  const compressOptions = {
    logger:
      typeof options.logger === "function" ? options.logger : function () {},
    restructuring: getRestructureOption(options),
    forceMediaMerge: Boolean(options.forceMediaMerge),
    usage: options.usage ? usage.buildIndex(options.usage) : false,
  };
  const output = new cssTree$1.List();
  let specialComments = getCommentsOption(options);
  let firstAtrulesAllowed = true;
  let input;
  let chunk;
  let chunkNum = 1;
  let chunkChildren;

  if (options.clone) {
    ast = cssTree$1.clone(ast);
  }

  if (ast.type === "StyleSheet") {
    input = ast.children;
    ast.children = output;
  } else {
    input = wrapBlock(ast);
  }

  do {
    chunk = readChunk(input, Boolean(specialComments));
    compressChunk(
      chunk.stylesheet,
      firstAtrulesAllowed,
      chunkNum++,
      compressOptions,
    );
    chunkChildren = chunk.stylesheet.children;

    if (chunk.comment) {
      // add \n before comment if there is another content in output
      if (!output.isEmpty) {
        output.insert(
          cssTree$1.List.createItem({
            type: "Raw",
            value: "\n",
          }),
        );
      }

      output.insert(cssTree$1.List.createItem(chunk.comment));

      // add \n after comment if chunk is not empty
      if (!chunkChildren.isEmpty) {
        output.insert(
          cssTree$1.List.createItem({
            type: "Raw",
            value: "\n",
          }),
        );
      }
    }

    if (firstAtrulesAllowed && !chunkChildren.isEmpty) {
      const lastRule = chunkChildren.last;

      if (
        lastRule.type !== "Atrule" ||
        (lastRule.name !== "import" && lastRule.name !== "charset")
      ) {
        firstAtrulesAllowed = false;
      }
    }

    if (specialComments !== "exclamation") {
      specialComments = false;
    }

    output.appendList(chunkChildren);
  } while (!input.isEmpty);

  return {
    ast,
  };
}

var compress_1 = compress$2;

const cssTree = cjs;
const compress$1 = compress_1;
const specificity$2 = specificity_1;

function encodeString(value) {
  const stringApostrophe = cssTree.string.encode(value, true);
  const stringQuote = cssTree.string.encode(value);

  return stringApostrophe.length < stringQuote.length
    ? stringApostrophe
    : stringQuote;
}

const {
  lexer,
  tokenize,
  parse: parse$5,
  generate: generate$1,
  walk,
  find,
  findLast,
  findAll,
  fromPlainObject,
  toPlainObject,
} = cssTree.fork({
  node: {
    String: {
      generate(node) {
        this.token(cssTree.tokenTypes.String, encodeString(node.value));
      },
    },
    Url: {
      generate(node) {
        const encodedUrl = cssTree.url.encode(node.value);
        const string = encodeString(node.value);

        this.token(
          cssTree.tokenTypes.Url,
          encodedUrl.length <= string.length + 5 /* "url()".length */
            ? encodedUrl
            : "url(" + string + ")",
        );
      },
    },
  },
});

syntax$2.compress = compress$1;
syntax$2.specificity = specificity$2;
syntax$2.find = find;
syntax$2.findAll = findAll;
syntax$2.findLast = findLast;
syntax$2.fromPlainObject = fromPlainObject;
syntax$2.generate = generate$1;
syntax$2.lexer = lexer;
syntax$2.parse = parse$5;
syntax$2.toPlainObject = toPlainObject;
syntax$2.tokenize = tokenize;
syntax$2.walk = walk;

var utils$2 = {};

const processSelector = processSelector_1;
const utils$1 = utils$6;

utils$2.processSelector = processSelector;
utils$2.addSelectors = utils$1.addSelectors;
utils$2.compareDeclarations = utils$1.compareDeclarations;
utils$2.hasSimilarSelectors = utils$1.hasSimilarSelectors;
utils$2.isEqualDeclarations = utils$1.isEqualDeclarations;
utils$2.isEqualSelectors = utils$1.isEqualSelectors;
utils$2.unsafeToSkipNode = utils$1.unsafeToSkipNode;

const version$1 = version$8;
const syntax = syntax$2;
const utils = utils$2;

const { parse: parse$4, generate, compress } = syntax;

function debugOutput(name, options, startTime, data) {
  if (options.debug) {
    console.error(`## ${name} done in %d ms\n`, Date.now() - startTime);
  }

  return data;
}

function createDefaultLogger(level) {
  let lastDebug;

  return function logger(title, ast) {
    let line = title;

    if (ast) {
      line = `[${((Date.now() - lastDebug) / 1000).toFixed(3)}s] ${line}`;
    }

    if (level > 1 && ast) {
      let css = generate(ast);

      // when level 2, limit css to 256 symbols
      if (level === 2 && css.length > 256) {
        css = css.substr(0, 256) + "...";
      }

      line += `\n  ${css}\n`;
    }

    console.error(line);
    lastDebug = Date.now();
  };
}

function buildCompressOptions(options) {
  options = { ...options };

  if (typeof options.logger !== "function" && options.debug) {
    options.logger = createDefaultLogger(options.debug);
  }

  return options;
}

function runHandler(ast, options, handlers) {
  if (!Array.isArray(handlers)) {
    handlers = [handlers];
  }

  handlers.forEach((fn) => fn(ast, options));
}

function minify(context, source, options) {
  options = options || {};

  const filename = options.filename || "<unknown>";
  let result;

  // parse
  const ast = debugOutput(
    "parsing",
    options,
    Date.now(),
    parse$4(source, {
      context,
      filename,
      positions: Boolean(options.sourceMap),
    }),
  );

  // before compress handlers
  if (options.beforeCompress) {
    debugOutput(
      "beforeCompress",
      options,
      Date.now(),
      runHandler(ast, options, options.beforeCompress),
    );
  }

  // compress
  const compressResult = debugOutput(
    "compress",
    options,
    Date.now(),
    compress(ast, buildCompressOptions(options)),
  );

  // after compress handlers
  if (options.afterCompress) {
    debugOutput(
      "afterCompress",
      options,
      Date.now(),
      runHandler(compressResult, options, options.afterCompress),
    );
  }

  // generate
  if (options.sourceMap) {
    result = debugOutput(
      "generate(sourceMap: true)",
      options,
      Date.now(),
      (() => {
        const tmp = generate(compressResult.ast, { sourceMap: true });

        tmp.map._file = filename; // since other tools can relay on file in source map transform chain
        tmp.map.setSourceContent(filename, source);

        return tmp;
      })(),
    );
  } else {
    result = debugOutput("generate", options, Date.now(), {
      css: generate(compressResult.ast),
      map: null,
    });
  }

  return result;
}

function minifyStylesheet(source, options) {
  return minify("stylesheet", source, options);
}

function minifyBlock(source, options) {
  return minify("declarationList", source, options);
}

cjs$1.version = version$1.version;
cjs$1.syntax = syntax;
cjs$1.utils = utils;
cjs$1.minify = minifyStylesheet;
cjs$1.minifyBlock = minifyBlock;

var style = {};

/**
 * @typedef {import('css-tree').Rule} CsstreeRule
 * @typedef {import('./types').Specificity} Specificity
 * @typedef {import('./types').Stylesheet} Stylesheet
 * @typedef {import('./types').StylesheetRule} StylesheetRule
 * @typedef {import('./types').StylesheetDeclaration} StylesheetDeclaration
 * @typedef {import('./types').ComputedStyles} ComputedStyles
 * @typedef {import('./types').XastRoot} XastRoot
 * @typedef {import('./types').XastElement} XastElement
 * @typedef {import('./types').XastParent} XastParent
 * @typedef {import('./types').XastChild} XastChild
 */

const csstree$3 = cjs$2;
const csswhat = require$$1$2;
const {
  syntax: { specificity: specificity$1 },
} = cjs$1;
const { visit: visit$5, matches } = xast;
const {
  attrsGroups: attrsGroups$7,
  inheritableAttrs: inheritableAttrs$3,
  presentationNonInheritableGroupAttrs: presentationNonInheritableGroupAttrs$2,
} = _collections;

// @ts-ignore not defined in @types/csstree
const csstreeWalkSkip = csstree$3.walk.skip;

/**
 * @type {(ruleNode: CsstreeRule, dynamic: boolean) => StylesheetRule[]}
 */
const parseRule = (ruleNode, dynamic) => {
  /**
   * @type {StylesheetDeclaration[]}
   */
  const declarations = [];
  // collect declarations
  ruleNode.block.children.forEach((cssNode) => {
    if (cssNode.type === "Declaration") {
      declarations.push({
        name: cssNode.property,
        value: csstree$3.generate(cssNode.value),
        important: cssNode.important === true,
      });
    }
  });

  /** @type {StylesheetRule[]} */
  const rules = [];
  csstree$3.walk(ruleNode.prelude, (node) => {
    if (node.type === "Selector") {
      const newNode = csstree$3.clone(node);
      let hasPseudoClasses = false;
      csstree$3.walk(newNode, (pseudoClassNode, item, list) => {
        if (pseudoClassNode.type === "PseudoClassSelector") {
          hasPseudoClasses = true;
          list.remove(item);
        }
      });
      rules.push({
        specificity: specificity$1(node),
        dynamic: hasPseudoClasses || dynamic,
        // compute specificity from original node to consider pseudo classes
        selector: csstree$3.generate(newNode),
        declarations,
      });
    }
  });

  return rules;
};

/**
 * @type {(css: string, dynamic: boolean) => StylesheetRule[]}
 */
const parseStylesheet = (css, dynamic) => {
  /** @type {StylesheetRule[]} */
  const rules = [];
  const ast = csstree$3.parse(css, {
    parseValue: false,
    parseAtrulePrelude: false,
  });
  csstree$3.walk(ast, (cssNode) => {
    if (cssNode.type === "Rule") {
      rules.push(...parseRule(cssNode, dynamic || false));
      return csstreeWalkSkip;
    }
    if (cssNode.type === "Atrule") {
      if (
        cssNode.name === "keyframes" ||
        cssNode.name === "-webkit-keyframes"
      ) {
        return csstreeWalkSkip;
      }
      csstree$3.walk(cssNode, (ruleNode) => {
        if (ruleNode.type === "Rule") {
          rules.push(...parseRule(ruleNode, dynamic || true));
          return csstreeWalkSkip;
        }
      });
      return csstreeWalkSkip;
    }
  });
  return rules;
};

/**
 * @type {(css: string) => StylesheetDeclaration[]}
 */
const parseStyleDeclarations = (css) => {
  /** @type {StylesheetDeclaration[]} */
  const declarations = [];
  const ast = csstree$3.parse(css, {
    context: "declarationList",
    parseValue: false,
  });
  csstree$3.walk(ast, (cssNode) => {
    if (cssNode.type === "Declaration") {
      declarations.push({
        name: cssNode.property,
        value: csstree$3.generate(cssNode.value),
        important: cssNode.important === true,
      });
    }
  });
  return declarations;
};

/**
 * @param {Stylesheet} stylesheet
 * @param {XastElement} node
 * @returns {ComputedStyles}
 */
const computeOwnStyle = (stylesheet, node) => {
  /** @type {ComputedStyles} */
  const computedStyle = {};
  const importantStyles = new Map();

  // collect attributes
  for (const [name, value] of Object.entries(node.attributes)) {
    if (attrsGroups$7.presentation.has(name)) {
      computedStyle[name] = { type: "static", inherited: false, value };
      importantStyles.set(name, false);
    }
  }

  // collect matching rules
  for (const { selector, declarations, dynamic } of stylesheet.rules) {
    if (matches(node, selector)) {
      for (const { name, value, important } of declarations) {
        const computed = computedStyle[name];
        if (computed && computed.type === "dynamic") {
          continue;
        }
        if (dynamic) {
          computedStyle[name] = { type: "dynamic", inherited: false };
          continue;
        }
        if (
          computed == null ||
          important === true ||
          importantStyles.get(name) === false
        ) {
          computedStyle[name] = { type: "static", inherited: false, value };
          importantStyles.set(name, important);
        }
      }
    }
  }

  // collect inline styles
  const styleDeclarations =
    node.attributes.style == null
      ? []
      : parseStyleDeclarations(node.attributes.style);
  for (const { name, value, important } of styleDeclarations) {
    const computed = computedStyle[name];
    if (computed && computed.type === "dynamic") {
      continue;
    }
    if (
      computed == null ||
      important === true ||
      importantStyles.get(name) === false
    ) {
      computedStyle[name] = { type: "static", inherited: false, value };
      importantStyles.set(name, important);
    }
  }

  return computedStyle;
};

/**
 * Compares selector specificities.
 * Derived from https://github.com/keeganstreet/specificity/blob/8757133ddd2ed0163f120900047ff0f92760b536/specificity.js#L207
 *
 * @param {Specificity} a
 * @param {Specificity} b
 * @returns {number}
 */
const compareSpecificity$1 = (a, b) => {
  for (let i = 0; i < 4; i += 1) {
    if (a[i] < b[i]) {
      return -1;
    } else if (a[i] > b[i]) {
      return 1;
    }
  }

  return 0;
};
style.compareSpecificity = compareSpecificity$1;

/**
 * @type {(root: XastRoot) => Stylesheet}
 */
const collectStylesheet$8 = (root) => {
  /** @type {StylesheetRule[]} */
  const rules = [];
  /** @type {Map<XastElement, XastParent>} */
  const parents = new Map();

  visit$5(root, {
    element: {
      enter: (node, parentNode) => {
        parents.set(node, parentNode);

        if (node.name !== "style") {
          return;
        }

        if (
          node.attributes.type == null ||
          node.attributes.type === "" ||
          node.attributes.type === "text/css"
        ) {
          const dynamic =
            node.attributes.media != null && node.attributes.media !== "all";

          for (const child of node.children) {
            if (child.type === "text" || child.type === "cdata") {
              rules.push(...parseStylesheet(child.value, dynamic));
            }
          }
        }
      },
    },
  });
  // sort by selectors specificity
  rules.sort((a, b) => compareSpecificity$1(a.specificity, b.specificity));
  return { rules, parents };
};
style.collectStylesheet = collectStylesheet$8;

/**
 * @param {Stylesheet} stylesheet
 * @param {XastElement} node
 * @returns {ComputedStyles}
 */
const computeStyle$7 = (stylesheet, node) => {
  const { parents } = stylesheet;
  const computedStyles = computeOwnStyle(stylesheet, node);
  let parent = parents.get(node);
  while (parent != null && parent.type !== "root") {
    const inheritedStyles = computeOwnStyle(stylesheet, parent);
    for (const [name, computed] of Object.entries(inheritedStyles)) {
      if (
        computedStyles[name] == null &&
        inheritableAttrs$3.has(name) &&
        !presentationNonInheritableGroupAttrs$2.has(name)
      ) {
        computedStyles[name] = { ...computed, inherited: true };
      }
    }
    parent = parents.get(parent);
  }
  return computedStyles;
};
style.computeStyle = computeStyle$7;

/**
 * Determines if the CSS selector includes or traverses the given attribute.
 *
 * Classes and IDs are generated as attribute selectors, so you can check for
 * if a `.class` or `#id` is included by passing `name=class` or `name=id`
 * respectively.
 *
 * @param {csstree.ListItem<csstree.CssNode>|string} selector
 * @param {string} name
 * @param {?string} value
 * @param {boolean} traversed
 * @returns {boolean}
 */
const includesAttrSelector$1 = (
  selector,
  name,
  value = null,
  traversed = false,
) => {
  const selectors =
    typeof selector === "string"
      ? csswhat.parse(selector)
      : csswhat.parse(csstree$3.generate(selector.data));

  for (const subselector of selectors) {
    const hasAttrSelector = subselector.some((segment, index) => {
      if (traversed) {
        if (index === subselector.length - 1) {
          return false;
        }

        const isNextTraversal = csswhat.isTraversal(subselector[index + 1]);

        if (!isNextTraversal) {
          return false;
        }
      }

      if (segment.type !== "attribute" || segment.name !== name) {
        return false;
      }

      return value == null ? true : segment.value === value;
    });

    if (hasAttrSelector) {
      return true;
    }
  }

  return false;
};
style.includesAttrSelector = includesAttrSelector$1;

/**
 * @typedef {import('../lib/types').XastElement} XastElement
 * @typedef {import('../lib/types').XastParent} XastParent
 */

const csstree$2 = cjs$2;
const {
  syntax: { specificity },
} = cjs$1;
const {
  visitSkip: visitSkip$5,
  querySelectorAll: querySelectorAll$3,
  detachNodeFromParent: detachNodeFromParent$h,
} = xast;
const { compareSpecificity, includesAttrSelector } = style;
const { attrsGroups: attrsGroups$6, pseudoClasses } = _collections;

inlineStyles$1.name = "inlineStyles";
inlineStyles$1.description = "inline styles (additional options)";

/**
 * Some pseudo-classes can only be calculated by clients, like :visited,
 * :future, or :hover, but there are other pseudo-classes that we can evaluate
 * during optimization.
 *
 * The list of pseudo-classes that we can evaluate during optimization, and so
 * shouldn't be toggled conditionally through the `usePseudos` parameter.
 *
 * @see https://developer.mozilla.org/docs/Web/CSS/Pseudo-classes
 */
const preservedPseudos = [
  ...pseudoClasses.functional,
  ...pseudoClasses.treeStructural,
];

/**
 * Merges styles from style nodes into inline styles.
 *
 * @type {import('./plugins-types').Plugin<'inlineStyles'>}
 * @author strarsis <strarsis@gmail.com>
 */
inlineStyles$1.fn = (root, params) => {
  const {
    onlyMatchedOnce = true,
    removeMatchedSelectors = true,
    useMqs = ["", "screen"],
    usePseudos = [""],
  } = params;

  /**
   * @type {{ node: XastElement, parentNode: XastParent, cssAst: csstree.StyleSheet }[]}
   */
  const styles = [];
  /**
   * @type {{
   *   node: csstree.Selector,
   *   item: csstree.ListItem<csstree.CssNode>,
   *   rule: csstree.Rule,
   *   matchedElements?: XastElement[]
   * }[]}
   */
  let selectors = [];

  return {
    element: {
      enter: (node, parentNode) => {
        if (node.name === "foreignObject") {
          return visitSkip$5;
        }
        if (node.name !== "style" || node.children.length === 0) {
          return;
        }
        if (
          node.attributes.type != null &&
          node.attributes.type !== "" &&
          node.attributes.type !== "text/css"
        ) {
          return;
        }

        const cssText = node.children
          .filter((child) => child.type === "text" || child.type === "cdata")
          // @ts-ignore
          .map((child) => child.value)
          .join("");

        /** @type {?csstree.CssNode} */
        let cssAst = null;
        try {
          cssAst = csstree$2.parse(cssText, {
            parseValue: false,
            parseCustomProperty: false,
          });
        } catch {
          return;
        }
        if (cssAst.type === "StyleSheet") {
          styles.push({ node, parentNode, cssAst });
        }

        // collect selectors
        csstree$2.walk(cssAst, {
          visit: "Rule",
          enter(node) {
            const atrule = this.atrule;

            // skip media queries not included into useMqs param
            let mediaQuery = "";
            if (atrule != null) {
              mediaQuery = atrule.name;
              if (atrule.prelude != null) {
                mediaQuery += ` ${csstree$2.generate(atrule.prelude)}`;
              }
            }
            if (!useMqs.includes(mediaQuery)) {
              return;
            }

            if (node.prelude.type === "SelectorList") {
              node.prelude.children.forEach((childNode, item) => {
                if (childNode.type === "Selector") {
                  /**
                   * @type {{
                   *   item: csstree.ListItem<csstree.CssNode>,
                   *   list: csstree.List<csstree.CssNode>
                   * }[]}
                   */
                  const pseudos = [];

                  childNode.children.forEach(
                    (grandchildNode, grandchildItem, grandchildList) => {
                      const isPseudo =
                        grandchildNode.type === "PseudoClassSelector" ||
                        grandchildNode.type === "PseudoElementSelector";

                      if (
                        isPseudo &&
                        !preservedPseudos.includes(grandchildNode.name)
                      ) {
                        pseudos.push({
                          item: grandchildItem,
                          list: grandchildList,
                        });
                      }
                    },
                  );

                  const pseudoSelectors = csstree$2.generate({
                    type: "Selector",
                    children: new csstree$2.List().fromArray(
                      pseudos.map((pseudo) => pseudo.item.data),
                    ),
                  });

                  if (usePseudos.includes(pseudoSelectors)) {
                    for (const pseudo of pseudos) {
                      pseudo.list.remove(pseudo.item);
                    }
                  }

                  selectors.push({ node: childNode, rule: node, item: item });
                }
              });
            }
          },
        });
      },
    },

    root: {
      exit: () => {
        if (styles.length === 0) {
          return;
        }
        const sortedSelectors = selectors
          .slice()
          .sort((a, b) => {
            const aSpecificity = specificity(a.item.data);
            const bSpecificity = specificity(b.item.data);
            return compareSpecificity(aSpecificity, bSpecificity);
          })
          .reverse();

        for (const selector of sortedSelectors) {
          // match selectors
          const selectorText = csstree$2.generate(selector.item.data);
          /** @type {XastElement[]} */
          const matchedElements = [];
          try {
            for (const node of querySelectorAll$3(root, selectorText)) {
              if (node.type === "element") {
                matchedElements.push(node);
              }
            }
          } catch (selectError) {
            continue;
          }
          // nothing selected
          if (matchedElements.length === 0) {
            continue;
          }

          // apply styles to matched elements
          // skip selectors that match more than once if option onlyMatchedOnce is enabled
          if (onlyMatchedOnce && matchedElements.length > 1) {
            continue;
          }

          // apply <style/> to matched elements
          for (const selectedEl of matchedElements) {
            const styleDeclarationList = csstree$2.parse(
              selectedEl.attributes.style ?? "",
              {
                context: "declarationList",
                parseValue: false,
              },
            );
            if (styleDeclarationList.type !== "DeclarationList") {
              continue;
            }
            const styleDeclarationItems = new Map();

            /** @type {csstree.ListItem<csstree.CssNode>} */
            let firstListItem;

            csstree$2.walk(styleDeclarationList, {
              visit: "Declaration",
              enter(node, item) {
                if (firstListItem == null) {
                  firstListItem = item;
                }

                styleDeclarationItems.set(node.property.toLowerCase(), item);
              },
            });
            // merge declarations
            csstree$2.walk(selector.rule, {
              visit: "Declaration",
              enter(ruleDeclaration) {
                // existing inline styles have higher priority
                // no inline styles, external styles,                                    external styles used
                // inline styles,    external styles same   priority as inline styles,   inline   styles used
                // inline styles,    external styles higher priority than inline styles, external styles used
                const property = ruleDeclaration.property;

                if (
                  attrsGroups$6.presentation.has(property) &&
                  !selectors.some((selector) =>
                    includesAttrSelector(selector.item, property),
                  )
                ) {
                  delete selectedEl.attributes[property];
                }

                const matchedItem = styleDeclarationItems.get(property);
                const ruleDeclarationItem =
                  styleDeclarationList.children.createItem(ruleDeclaration);
                if (matchedItem == null) {
                  styleDeclarationList.children.insert(
                    ruleDeclarationItem,
                    firstListItem,
                  );
                } else if (
                  matchedItem.data.important !== true &&
                  ruleDeclaration.important === true
                ) {
                  styleDeclarationList.children.replace(
                    matchedItem,
                    ruleDeclarationItem,
                  );
                  styleDeclarationItems.set(property, ruleDeclarationItem);
                }
              },
            });

            const newStyles = csstree$2.generate(styleDeclarationList);
            if (newStyles.length !== 0) {
              selectedEl.attributes.style = newStyles;
            }
          }

          if (
            removeMatchedSelectors &&
            matchedElements.length !== 0 &&
            selector.rule.prelude.type === "SelectorList"
          ) {
            // clean up matching simple selectors if option removeMatchedSelectors is enabled
            selector.rule.prelude.children.remove(selector.item);
          }
          selector.matchedElements = matchedElements;
        }

        // no further processing required
        if (!removeMatchedSelectors) {
          return;
        }

        // clean up matched class + ID attribute values
        for (const selector of sortedSelectors) {
          if (selector.matchedElements == null) {
            continue;
          }

          if (onlyMatchedOnce && selector.matchedElements.length > 1) {
            // skip selectors that match more than once if option onlyMatchedOnce is enabled
            continue;
          }

          for (const selectedEl of selector.matchedElements) {
            // class
            const classList = new Set(
              selectedEl.attributes.class == null
                ? null
                : selectedEl.attributes.class.split(" "),
            );

            for (const child of selector.node.children) {
              if (
                child.type === "ClassSelector" &&
                !selectors.some((selector) =>
                  includesAttrSelector(
                    selector.item,
                    "class",
                    child.name,
                    true,
                  ),
                )
              ) {
                classList.delete(child.name);
              }
            }

            if (classList.size === 0) {
              delete selectedEl.attributes.class;
            } else {
              selectedEl.attributes.class = Array.from(classList).join(" ");
            }

            // ID
            const firstSubSelector = selector.node.children.first;
            if (
              firstSubSelector?.type === "IdSelector" &&
              selectedEl.attributes.id === firstSubSelector.name &&
              !selectors.some((selector) =>
                includesAttrSelector(
                  selector.item,
                  "id",
                  firstSubSelector.name,
                  true,
                ),
              )
            ) {
              delete selectedEl.attributes.id;
            }
          }
        }

        for (const style of styles) {
          csstree$2.walk(style.cssAst, {
            visit: "Rule",
            enter: function (node, item, list) {
              // clean up <style/> rulesets without any css selectors left
              if (
                node.type === "Rule" &&
                node.prelude.type === "SelectorList" &&
                node.prelude.children.isEmpty
              ) {
                list.remove(item);
              }
            },
          });

          // csstree v2 changed this type
          if (style.cssAst.children.isEmpty) {
            // remove empty style element
            detachNodeFromParent$h(style.node, style.parentNode);
          } else {
            // update style element if any styles left
            const firstChild = style.node.children[0];
            if (firstChild.type === "text" || firstChild.type === "cdata") {
              firstChild.value = csstree$2.generate(style.cssAst);
            }
          }
        }
      },
    },
  };
};

var minifyStyles$1 = {};

var tools = {};

/**
 * @typedef {import('../../lib/types').XastElement} XastElement
 * @typedef {import('../types').PathDataCommand} PathDataCommand
 * @typedef {import('../types').DataUri} DataUri
 */

const { attrsGroups: attrsGroups$5, referencesProps: referencesProps$3 } =
  _collections;

const regReferencesUrl = /\burl\((["'])?#(.+?)\1\)/g;
const regReferencesHref = /^#(.+?)$/;
const regReferencesBegin = /(\w+)\.[a-zA-Z]/;

/**
 * Encode plain SVG data string into Data URI string.
 *
 * @type {(str: string, type?: DataUri) => string}
 */
tools.encodeSVGDatauri = (str, type) => {
  var prefix = "data:image/svg+xml";
  if (!type || type === "base64") {
    // base64
    prefix += ";base64,";
    str = prefix + Buffer.from(str).toString("base64");
  } else if (type === "enc") {
    // URI encoded
    str = prefix + "," + encodeURIComponent(str);
  } else if (type === "unenc") {
    // unencoded
    str = prefix + "," + str;
  }
  return str;
};

/**
 * Decode SVG Data URI string into plain SVG string.
 *
 * @type {(str: string) => string}
 */
tools.decodeSVGDatauri = (str) => {
  var regexp = /data:image\/svg\+xml(;charset=[^;,]*)?(;base64)?,(.*)/;
  var match = regexp.exec(str);

  // plain string
  if (!match) return str;

  var data = match[3];

  if (match[2]) {
    // base64
    str = Buffer.from(data, "base64").toString("utf8");
  } else if (data.charAt(0) === "%") {
    // URI encoded
    str = decodeURIComponent(data);
  } else if (data.charAt(0) === "<") {
    // unencoded
    str = data;
  }
  return str;
};

/**
 * @typedef {{
 *   noSpaceAfterFlags?: boolean,
 *   leadingZero?: boolean,
 *   negativeExtraSpace?: boolean
 * }} CleanupOutDataParams
 */

/**
 * Convert a row of numbers to an optimized string view.
 *
 * @example
 * [0, -1, .5, .5]  "0-1 .5.5"
 *
 * @type {(data: number[], params: CleanupOutDataParams, command?: PathDataCommand) => string}
 */
tools.cleanupOutData = (data, params, command) => {
  let str = "";
  let delimiter;
  /**
   * @type {number}
   */
  let prev;

  data.forEach((item, i) => {
    // space delimiter by default
    delimiter = " ";

    // no extra space in front of first number
    if (i == 0) delimiter = "";

    // no extra space after 'arcto' command flags(large-arc and sweep flags)
    // a20 60 45 0 1 30 20  a20 60 45 0130 20
    if (params.noSpaceAfterFlags && (command == "A" || command == "a")) {
      var pos = i % 7;
      if (pos == 4 || pos == 5) delimiter = "";
    }

    // remove floating-point numbers leading zeros
    // 0.5  .5
    // -0.5  -.5
    const itemStr = params.leadingZero
      ? removeLeadingZero$4(item)
      : item.toString();

    // no extra space in front of negative number or
    // in front of a floating number if a previous number is floating too
    if (
      params.negativeExtraSpace &&
      delimiter != "" &&
      (item < 0 || (itemStr.charAt(0) === "." && prev % 1 !== 0))
    ) {
      delimiter = "";
    }
    // save prev item value
    prev = item;
    str += delimiter + itemStr;
  });
  return str;
};

/**
 * Remove floating-point numbers leading zero.
 *
 * @param {number} value
 * @returns {string}
 * @example
 * 0.5  .5
 * -0.5  -.5
 */
const removeLeadingZero$4 = (value) => {
  const strValue = value.toString();

  if (0 < value && value < 1 && strValue.startsWith("0")) {
    return strValue.slice(1);
  }

  if (-1 < value && value < 0 && strValue[1] === "0") {
    return strValue[0] + strValue.slice(2);
  }

  return strValue;
};
tools.removeLeadingZero = removeLeadingZero$4;

/**
 * If the current node contains any scripts. This does not check parents or
 * children of the node, only the properties and attributes of the node itself.
 *
 * @param {XastElement} node Current node to check against.
 * @returns {boolean} If the current node contains scripts.
 */
const hasScripts$4 = (node) => {
  if (node.name === "script" && node.children.length !== 0) {
    return true;
  }

  if (node.name === "a") {
    const hasJsLinks = Object.entries(node.attributes).some(
      ([attrKey, attrValue]) =>
        (attrKey === "href" || attrKey.endsWith(":href")) &&
        attrValue != null &&
        attrValue.trimStart().startsWith("javascript:"),
    );

    if (hasJsLinks) {
      return true;
    }
  }

  const eventAttrs = [
    ...attrsGroups$5.animationEvent,
    ...attrsGroups$5.documentEvent,
    ...attrsGroups$5.documentElementEvent,
    ...attrsGroups$5.globalEvent,
    ...attrsGroups$5.graphicalEvent,
  ];

  return eventAttrs.some((attr) => node.attributes[attr] != null);
};
tools.hasScripts = hasScripts$4;

/**
 * For example, a string that contains one or more of following would match and
 * return true:
 *
 * * `url(#gradient001)`
 * * `url('#gradient001')`
 *
 * @param {string} body
 * @returns {boolean} If the given string includes a URL reference.
 */
const includesUrlReference$2 = (body) => {
  return new RegExp(regReferencesUrl).test(body);
};
tools.includesUrlReference = includesUrlReference$2;

/**
 * @param {string} attribute
 * @param {string} value
 * @returns {string[]}
 */
const findReferences$2 = (attribute, value) => {
  const results = [];

  if (referencesProps$3.has(attribute)) {
    const matches = value.matchAll(regReferencesUrl);
    for (const match of matches) {
      results.push(match[2]);
    }
  }

  if (attribute === "href" || attribute.endsWith(":href")) {
    const match = regReferencesHref.exec(value);
    if (match != null) {
      results.push(match[1]);
    }
  }

  if (attribute === "begin") {
    const match = regReferencesBegin.exec(value);
    if (match != null) {
      results.push(match[1]);
    }
  }

  return results.map((body) => decodeURI(body));
};
tools.findReferences = findReferences$2;

/**
 * Does the same as {@link Number.toFixed} but without casting
 * the return value to a string.
 *
 * @param {number} num
 * @param {number} precision
 * @returns {number}
 */
const toFixed$4 = (num, precision) => {
  const pow = 10 ** precision;
  return Math.round(num * pow) / pow;
};
tools.toFixed = toFixed$4;

/**
 * @typedef {import('../lib/types').XastElement} XastElement
 * @typedef {import('../lib/types').XastParent} XastParent
 */

const csso = cjs$1;
const { detachNodeFromParent: detachNodeFromParent$g } = xast;
const { hasScripts: hasScripts$3 } = tools;

minifyStyles$1.name = "minifyStyles";
minifyStyles$1.description = "minifies styles and removes unused styles";

/**
 * Minifies styles (<style> element + style attribute) using CSSO.
 *
 * @author strarsis <strarsis@gmail.com>
 * @type {import('./plugins-types').Plugin<'minifyStyles'>}
 */
minifyStyles$1.fn = (_root, { usage, ...params }) => {
  /** @type {Map<XastElement, XastParent>} */
  const styleElements = new Map();

  /** @type {XastElement[]} */
  const elementsWithStyleAttributes = [];

  /** @type {Set<string>} */
  const tagsUsage = new Set();

  /** @type {Set<string>} */
  const idsUsage = new Set();

  /** @type {Set<string>} */
  const classesUsage = new Set();

  let enableTagsUsage = true;
  let enableIdsUsage = true;
  let enableClassesUsage = true;

  /**
   * Force to use usage data even if it unsafe. For example, the document
   * contains scripts or in attributes..
   */
  let forceUsageDeoptimized = false;

  if (typeof usage === "boolean") {
    enableTagsUsage = usage;
    enableIdsUsage = usage;
    enableClassesUsage = usage;
  } else if (usage) {
    enableTagsUsage = usage.tags == null ? true : usage.tags;
    enableIdsUsage = usage.ids == null ? true : usage.ids;
    enableClassesUsage = usage.classes == null ? true : usage.classes;
    forceUsageDeoptimized = usage.force == null ? false : usage.force;
  }

  let deoptimized = false;

  return {
    element: {
      enter: (node, parentNode) => {
        // detect deoptimisations
        if (hasScripts$3(node)) {
          deoptimized = true;
        }

        // collect tags, ids and classes usage
        tagsUsage.add(node.name);
        if (node.attributes.id != null) {
          idsUsage.add(node.attributes.id);
        }
        if (node.attributes.class != null) {
          for (const className of node.attributes.class.split(/\s+/)) {
            classesUsage.add(className);
          }
        }
        // collect style elements or elements with style attribute
        if (node.name === "style" && node.children.length !== 0) {
          styleElements.set(node, parentNode);
        } else if (node.attributes.style != null) {
          elementsWithStyleAttributes.push(node);
        }
      },
    },

    root: {
      exit: () => {
        /** @type {csso.Usage} */
        const cssoUsage = {};
        if (!deoptimized || forceUsageDeoptimized) {
          if (enableTagsUsage) {
            cssoUsage.tags = Array.from(tagsUsage);
          }
          if (enableIdsUsage) {
            cssoUsage.ids = Array.from(idsUsage);
          }
          if (enableClassesUsage) {
            cssoUsage.classes = Array.from(classesUsage);
          }
        }
        // minify style elements
        for (const [styleNode, styleNodeParent] of styleElements.entries()) {
          if (
            styleNode.children[0].type === "text" ||
            styleNode.children[0].type === "cdata"
          ) {
            const cssText = styleNode.children[0].value;
            const minified = csso.minify(cssText, {
              ...params,
              usage: cssoUsage,
            }).css;

            if (minified.length === 0) {
              detachNodeFromParent$g(styleNode, styleNodeParent);
              continue;
            }

            // preserve cdata if necessary
            // TODO split cdata -> text optimisation into separate plugin
            if (cssText.indexOf(">") >= 0 || cssText.indexOf("<") >= 0) {
              styleNode.children[0].type = "cdata";
              styleNode.children[0].value = minified;
            } else {
              styleNode.children[0].type = "text";
              styleNode.children[0].value = minified;
            }
          }
        }
        // minify style attributes
        for (const node of elementsWithStyleAttributes) {
          // style attribute
          const elemStyle = node.attributes.style;
          node.attributes.style = csso.minifyBlock(elemStyle, {
            ...params,
          }).css;
        }
      },
    },
  };
};

var cleanupIds$1 = {};

/**
 * @typedef {import('../lib/types').XastElement} XastElement
 */

const { visitSkip: visitSkip$4 } = xast;
const { hasScripts: hasScripts$2, findReferences: findReferences$1 } = tools;

cleanupIds$1.name = "cleanupIds";
cleanupIds$1.description = "removes unused IDs and minifies used";

const generateIdChars = [
  "a",
  "b",
  "c",
  "d",
  "e",
  "f",
  "g",
  "h",
  "i",
  "j",
  "k",
  "l",
  "m",
  "n",
  "o",
  "p",
  "q",
  "r",
  "s",
  "t",
  "u",
  "v",
  "w",
  "x",
  "y",
  "z",
  "A",
  "B",
  "C",
  "D",
  "E",
  "F",
  "G",
  "H",
  "I",
  "J",
  "K",
  "L",
  "M",
  "N",
  "O",
  "P",
  "Q",
  "R",
  "S",
  "T",
  "U",
  "V",
  "W",
  "X",
  "Y",
  "Z",
];
const maxIdIndex = generateIdChars.length - 1;

/**
 * Check if an ID starts with any one of a list of strings.
 *
 * @type {(string: string, prefixes: string[]) => boolean}
 */
const hasStringPrefix = (string, prefixes) => {
  for (const prefix of prefixes) {
    if (string.startsWith(prefix)) {
      return true;
    }
  }
  return false;
};

/**
 * Generate unique minimal ID.
 *
 * @param {?number[]} currentId
 * @returns {number[]}
 */
const generateId = (currentId) => {
  if (currentId == null) {
    return [0];
  }
  currentId[currentId.length - 1] += 1;
  for (let i = currentId.length - 1; i > 0; i--) {
    if (currentId[i] > maxIdIndex) {
      currentId[i] = 0;
      if (currentId[i - 1] !== undefined) {
        currentId[i - 1]++;
      }
    }
  }
  if (currentId[0] > maxIdIndex) {
    currentId[0] = 0;
    currentId.unshift(0);
  }
  return currentId;
};

/**
 * Get string from generated ID array.
 *
 * @type {(arr: number[]) => string}
 */
const getIdString = (arr) => {
  return arr.map((i) => generateIdChars[i]).join("");
};

/**
 * Remove unused and minify used IDs
 * (only if there are no any <style> or <script>).
 *
 * @author Kir Belevich
 *
 * @type {import('./plugins-types').Plugin<'cleanupIds'>}
 */
cleanupIds$1.fn = (_root, params) => {
  const {
    remove = true,
    minify = true,
    preserve = [],
    preservePrefixes = [],
    force = false,
  } = params;
  const preserveIds = new Set(
    Array.isArray(preserve) ? preserve : preserve ? [preserve] : [],
  );
  const preserveIdPrefixes = Array.isArray(preservePrefixes)
    ? preservePrefixes
    : preservePrefixes
      ? [preservePrefixes]
      : [];
  /**
   * @type {Map<string, XastElement>}
   */
  const nodeById = new Map();
  /**
   * @type {Map<string, {element: XastElement, name: string }[]>}
   */
  const referencesById = new Map();
  let deoptimized = false;

  return {
    element: {
      enter: (node) => {
        if (!force) {
          // deoptimize if style or scripts are present
          if (
            (node.name === "style" && node.children.length !== 0) ||
            hasScripts$2(node)
          ) {
            deoptimized = true;
            return;
          }

          // avoid removing IDs if the whole SVG consists only of defs
          if (node.name === "svg") {
            let hasDefsOnly = true;
            for (const child of node.children) {
              if (child.type !== "element" || child.name !== "defs") {
                hasDefsOnly = false;
                break;
              }
            }
            if (hasDefsOnly) {
              return visitSkip$4;
            }
          }
        }

        for (const [name, value] of Object.entries(node.attributes)) {
          if (name === "id") {
            // collect all ids
            const id = value;
            if (nodeById.has(id)) {
              delete node.attributes.id; // remove repeated id
            } else {
              nodeById.set(id, node);
            }
          } else {
            const ids = findReferences$1(name, value);
            for (const id of ids) {
              let refs = referencesById.get(id);
              if (refs == null) {
                refs = [];
                referencesById.set(id, refs);
              }
              refs.push({ element: node, name });
            }
          }
        }
      },
    },

    root: {
      exit: () => {
        if (deoptimized) {
          return;
        }
        /**
         * @param {string} id
         * @returns {boolean}
         */
        const isIdPreserved = (id) =>
          preserveIds.has(id) || hasStringPrefix(id, preserveIdPrefixes);
        /** @type {?number[]} */
        let currentId = null;
        for (const [id, refs] of referencesById) {
          const node = nodeById.get(id);
          if (node != null) {
            // replace referenced IDs with the minified ones
            if (minify && isIdPreserved(id) === false) {
              /** @type {?string} */
              let currentIdString = null;
              do {
                currentId = generateId(currentId);
                currentIdString = getIdString(currentId);
              } while (
                isIdPreserved(currentIdString) ||
                (referencesById.has(currentIdString) &&
                  nodeById.get(currentIdString) == null)
              );
              node.attributes.id = currentIdString;
              for (const { element, name } of refs) {
                const value = element.attributes[name];
                if (value.includes("#")) {
                  // replace id in href and url()
                  element.attributes[name] = value.replace(
                    `#${encodeURI(id)}`,
                    `#${currentIdString}`,
                  );
                } else {
                  // replace id in begin attribute
                  element.attributes[name] = value.replace(
                    `${id}.`,
                    `${currentIdString}.`,
                  );
                }
              }
            }
            // keep referenced node
            nodeById.delete(id);
          }
        }
        // remove non-referenced IDs attributes from elements
        if (remove) {
          for (const [id, node] of nodeById) {
            if (isIdPreserved(id) === false) {
              delete node.attributes.id;
            }
          }
        }
      },
    },
  };
};

var removeUselessDefs$1 = {};

/**
 * @typedef {import('../lib/types').XastElement} XastElement
 */

const { detachNodeFromParent: detachNodeFromParent$f } = xast;
const { elemsGroups: elemsGroups$5 } = _collections;

removeUselessDefs$1.name = "removeUselessDefs";
removeUselessDefs$1.description = "removes elements in <defs> without id";

/**
 * Removes content of defs and properties that aren't rendered directly without ids.
 *
 * @author Lev Solntsev
 *
 * @type {import('./plugins-types').Plugin<'removeUselessDefs'>}
 */
removeUselessDefs$1.fn = () => {
  return {
    element: {
      enter: (node, parentNode) => {
        if (node.name === "defs") {
          /**
           * @type {XastElement[]}
           */
          const usefulNodes = [];
          collectUsefulNodes(node, usefulNodes);
          if (usefulNodes.length === 0) {
            detachNodeFromParent$f(node, parentNode);
          }
          // TODO remove legacy parentNode in v4
          for (const usefulNode of usefulNodes) {
            Object.defineProperty(usefulNode, "parentNode", {
              writable: true,
              value: node,
            });
          }
          node.children = usefulNodes;
        } else if (
          elemsGroups$5.nonRendering.has(node.name) &&
          node.attributes.id == null
        ) {
          detachNodeFromParent$f(node, parentNode);
        }
      },
    },
  };
};

/**
 * @type {(node: XastElement, usefulNodes: XastElement[]) => void}
 */
const collectUsefulNodes = (node, usefulNodes) => {
  for (const child of node.children) {
    if (child.type === "element") {
      if (child.attributes.id != null || child.name === "style") {
        usefulNodes.push(child);
      } else {
        collectUsefulNodes(child, usefulNodes);
      }
    }
  }
};

var cleanupNumericValues$1 = {};

const { removeLeadingZero: removeLeadingZero$3 } = tools;

cleanupNumericValues$1.name = "cleanupNumericValues";
cleanupNumericValues$1.description =
  "rounds numeric values to the fixed precision, removes default px units";

const regNumericValues$3 =
  /^([-+]?\d*\.?\d+([eE][-+]?\d+)?)(px|pt|pc|mm|cm|m|in|ft|em|ex|%)?$/;

const absoluteLengths$1 = {
  // relative to px
  cm: 96 / 2.54,
  mm: 96 / 25.4,
  in: 96,
  pt: 4 / 3,
  pc: 16,
  px: 1,
};

/**
 * Round numeric values to the fixed precision,
 * remove default 'px' units.
 *
 * @author Kir Belevich
 *
 * @type {import('./plugins-types').Plugin<'cleanupNumericValues'>}
 */
cleanupNumericValues$1.fn = (_root, params) => {
  const {
    floatPrecision = 3,
    leadingZero = true,
    defaultPx = true,
    convertToPx = true,
  } = params;

  return {
    element: {
      enter: (node) => {
        if (node.attributes.viewBox != null) {
          const nums = node.attributes.viewBox.split(/\s,?\s*|,\s*/g);
          node.attributes.viewBox = nums
            .map((value) => {
              const num = Number(value);
              return Number.isNaN(num)
                ? value
                : Number(num.toFixed(floatPrecision));
            })
            .join(" ");
        }

        for (const [name, value] of Object.entries(node.attributes)) {
          // The `version` attribute is a text string and cannot be rounded
          if (name === "version") {
            continue;
          }

          const match = value.match(regNumericValues$3);

          // if attribute value matches regNumericValues
          if (match) {
            // round it to the fixed precision
            let num = Number(Number(match[1]).toFixed(floatPrecision));
            /**
             * @type {any}
             */
            let matchedUnit = match[3] || "";
            /**
             * @type{'' | keyof typeof absoluteLengths}
             */
            let units = matchedUnit;

            // convert absolute values to pixels
            if (convertToPx && units !== "" && units in absoluteLengths$1) {
              const pxNum = Number(
                (absoluteLengths$1[units] * Number(match[1])).toFixed(
                  floatPrecision,
                ),
              );
              if (pxNum.toString().length < match[0].length) {
                num = pxNum;
                units = "px";
              }
            }

            // and remove leading zero
            let str;
            if (leadingZero) {
              str = removeLeadingZero$3(num);
            } else {
              str = num.toString();
            }

            // remove default 'px' units
            if (defaultPx && units === "px") {
              units = "";
            }

            node.attributes[name] = str + units;
          }
        }
      },
    },
  };
};

var convertColors$1 = {};

const collections = _collections;

convertColors$1.name = "convertColors";
convertColors$1.description =
  "converts colors: rgb() to #rrggbb and #rrggbb to #rgb";

const rNumber = "([+-]?(?:\\d*\\.\\d+|\\d+\\.?)%?)";
const rComma = "\\s*,\\s*";
const regRGB = new RegExp(
  "^rgb\\(\\s*" + rNumber + rComma + rNumber + rComma + rNumber + "\\s*\\)$",
);
const regHEX = /^#(([a-fA-F0-9])\2){3}$/;

/**
 * Convert [r, g, b] to #rrggbb.
 *
 * @see https://gist.github.com/983535
 *
 * @example
 * rgb2hex([255, 255, 255]) // '#ffffff'
 *
 * @author Jed Schmidt
 *
 * @type {(rgb: number[]) => string}
 */
const convertRgbToHex = ([r, g, b]) => {
  // combine the octets into a 32-bit integer as: [1][r][g][b]
  const hexNumber =
    // operator precedence is (+) > (<<) > (|)
    ((((256 + // [1][0]
      r) << // [1][r]
      8) | // [1][r][0]
      g) << // [1][r][g]
      8) | // [1][r][g][0]
    b;
  // serialize [1][r][g][b] to a hex string, and
  // remove the 1 to get the number with 0s intact
  return "#" + hexNumber.toString(16).slice(1).toUpperCase();
};

/**
 * Convert different colors formats in element attributes to hex.
 *
 * @see https://www.w3.org/TR/SVG11/types.html#DataTypeColor
 * @see https://www.w3.org/TR/SVG11/single-page.html#types-ColorKeywords
 *
 * @example
 * Convert color name keyword to long hex:
 * fuchsia  #ff00ff
 *
 * Convert rgb() to long hex:
 * rgb(255, 0, 255)  #ff00ff
 * rgb(50%, 100, 100%)  #7f64ff
 *
 * Convert long hex to short hex:
 * #aabbcc  #abc
 *
 * Convert hex to short name
 * #000080  navy
 *
 * @author Kir Belevich
 *
 * @type {import('./plugins-types').Plugin<'convertColors'>}
 */
convertColors$1.fn = (_root, params) => {
  const {
    currentColor = false,
    names2hex = true,
    rgb2hex = true,
    shorthex = true,
    shortname = true,
  } = params;

  return {
    element: {
      enter: (node) => {
        for (const [name, value] of Object.entries(node.attributes)) {
          if (collections.colorsProps.has(name)) {
            let val = value;

            // convert colors to currentColor
            if (currentColor) {
              let matched;
              if (typeof currentColor === "string") {
                matched = val === currentColor;
              } else if (currentColor instanceof RegExp) {
                matched = currentColor.exec(val) != null;
              } else {
                matched = val !== "none";
              }
              if (matched) {
                val = "currentColor";
              }
            }

            // convert color name keyword to long hex
            if (names2hex) {
              const colorName = val.toLowerCase();
              if (collections.colorsNames[colorName] != null) {
                val = collections.colorsNames[colorName];
              }
            }

            // convert rgb() to long hex
            if (rgb2hex) {
              let match = val.match(regRGB);
              if (match != null) {
                let nums = match.slice(1, 4).map((m) => {
                  let n;
                  if (m.indexOf("%") > -1) {
                    n = Math.round(parseFloat(m) * 2.55);
                  } else {
                    n = Number(m);
                  }
                  return Math.max(0, Math.min(n, 255));
                });
                val = convertRgbToHex(nums);
              }
            }

            // convert long hex to short hex
            if (shorthex) {
              let match = val.match(regHEX);
              if (match != null) {
                val = "#" + match[0][1] + match[0][3] + match[0][5];
              }
            }

            // convert hex to short name
            if (shortname) {
              const colorName = val.toLowerCase();
              if (collections.colorsShortNames[colorName] != null) {
                val = collections.colorsShortNames[colorName];
              }
            }

            node.attributes[name] = val;
          }
        }
      },
    },
  };
};

var removeUnknownsAndDefaults$1 = {};

const { visitSkip: visitSkip$3, detachNodeFromParent: detachNodeFromParent$e } =
  xast;
const { collectStylesheet: collectStylesheet$7, computeStyle: computeStyle$6 } =
  style;
const {
  elems: elems$1,
  attrsGroups: attrsGroups$4,
  elemsGroups: elemsGroups$4,
  attrsGroupsDefaults: attrsGroupsDefaults$2,
  presentationNonInheritableGroupAttrs: presentationNonInheritableGroupAttrs$1,
} = _collections;

removeUnknownsAndDefaults$1.name = "removeUnknownsAndDefaults";
removeUnknownsAndDefaults$1.description =
  "removes unknown elements content and attributes, removes attrs with default values";

// resolve all groups references

/**
 * @type {Map<string, Set<string>>}
 */
const allowedChildrenPerElement = new Map();
/**
 * @type {Map<string, Set<string>>}
 */
const allowedAttributesPerElement = new Map();
/**
 * @type {Map<string, Map<string, string>>}
 */
const attributesDefaultsPerElement = new Map();

for (const [name, config] of Object.entries(elems$1)) {
  /**
   * @type {Set<string>}
   */
  const allowedChildren = new Set();
  if (config.content) {
    for (const elementName of config.content) {
      allowedChildren.add(elementName);
    }
  }
  if (config.contentGroups) {
    for (const contentGroupName of config.contentGroups) {
      const elemsGroup = elemsGroups$4[contentGroupName];
      if (elemsGroup) {
        for (const elementName of elemsGroup) {
          allowedChildren.add(elementName);
        }
      }
    }
  }
  /**
   * @type {Set<string>}
   */
  const allowedAttributes = new Set();
  if (config.attrs) {
    for (const attrName of config.attrs) {
      allowedAttributes.add(attrName);
    }
  }
  /**
   * @type {Map<string, string>}
   */
  const attributesDefaults = new Map();
  if (config.defaults) {
    for (const [attrName, defaultValue] of Object.entries(config.defaults)) {
      attributesDefaults.set(attrName, defaultValue);
    }
  }
  for (const attrsGroupName of config.attrsGroups) {
    const attrsGroup = attrsGroups$4[attrsGroupName];
    if (attrsGroup) {
      for (const attrName of attrsGroup) {
        allowedAttributes.add(attrName);
      }
    }
    const groupDefaults = attrsGroupsDefaults$2[attrsGroupName];
    if (groupDefaults) {
      for (const [attrName, defaultValue] of Object.entries(groupDefaults)) {
        attributesDefaults.set(attrName, defaultValue);
      }
    }
  }
  allowedChildrenPerElement.set(name, allowedChildren);
  allowedAttributesPerElement.set(name, allowedAttributes);
  attributesDefaultsPerElement.set(name, attributesDefaults);
}

/**
 * Remove unknown elements content and attributes,
 * remove attributes with default values.
 *
 * @author Kir Belevich
 *
 * @type {import('./plugins-types').Plugin<'removeUnknownsAndDefaults'>}
 */
removeUnknownsAndDefaults$1.fn = (root, params) => {
  const {
    unknownContent = true,
    unknownAttrs = true,
    defaultAttrs = true,
    defaultMarkupDeclarations = true,
    uselessOverrides = true,
    keepDataAttrs = true,
    keepAriaAttrs = true,
    keepRoleAttr = false,
  } = params;
  const stylesheet = collectStylesheet$7(root);

  return {
    instruction: {
      enter: (node) => {
        if (defaultMarkupDeclarations) {
          node.value = node.value.replace(/\s*standalone\s*=\s*(["'])no\1/, "");
        }
      },
    },
    element: {
      enter: (node, parentNode) => {
        // skip namespaced elements
        if (node.name.includes(":")) {
          return;
        }
        // skip visiting foreignObject subtree
        if (node.name === "foreignObject") {
          return visitSkip$3;
        }

        // remove unknown element's content
        if (unknownContent && parentNode.type === "element") {
          const allowedChildren = allowedChildrenPerElement.get(
            parentNode.name,
          );
          if (allowedChildren == null || allowedChildren.size === 0) {
            // remove unknown elements
            if (allowedChildrenPerElement.get(node.name) == null) {
              detachNodeFromParent$e(node, parentNode);
              return;
            }
          } else {
            // remove not allowed children
            if (allowedChildren.has(node.name) === false) {
              detachNodeFromParent$e(node, parentNode);
              return;
            }
          }
        }

        const allowedAttributes = allowedAttributesPerElement.get(node.name);
        const attributesDefaults = attributesDefaultsPerElement.get(node.name);
        const computedParentStyle =
          parentNode.type === "element"
            ? computeStyle$6(stylesheet, parentNode)
            : null;

        // remove element's unknown attrs and attrs with default values
        for (const [name, value] of Object.entries(node.attributes)) {
          if (keepDataAttrs && name.startsWith("data-")) {
            continue;
          }
          if (keepAriaAttrs && name.startsWith("aria-")) {
            continue;
          }
          if (keepRoleAttr && name === "role") {
            continue;
          }
          // skip xmlns attribute
          if (name === "xmlns") {
            continue;
          }
          // skip namespaced attributes except xml:* and xlink:*
          if (name.includes(":")) {
            const [prefix] = name.split(":");
            if (prefix !== "xml" && prefix !== "xlink") {
              continue;
            }
          }

          if (
            unknownAttrs &&
            allowedAttributes &&
            allowedAttributes.has(name) === false
          ) {
            delete node.attributes[name];
          }
          if (
            defaultAttrs &&
            node.attributes.id == null &&
            attributesDefaults &&
            attributesDefaults.get(name) === value
          ) {
            // keep defaults if parent has own or inherited style
            if (computedParentStyle?.[name] == null) {
              delete node.attributes[name];
            }
          }
          if (uselessOverrides && node.attributes.id == null) {
            const style = computedParentStyle?.[name];
            if (
              presentationNonInheritableGroupAttrs$1.has(name) === false &&
              style != null &&
              style.type === "static" &&
              style.value === value
            ) {
              delete node.attributes[name];
            }
          }
        }
      },
    },
  };
};

var removeNonInheritableGroupAttrs$1 = {};

const {
  inheritableAttrs: inheritableAttrs$2,
  attrsGroups: attrsGroups$3,
  presentationNonInheritableGroupAttrs,
} = _collections;

removeNonInheritableGroupAttrs$1.name = "removeNonInheritableGroupAttrs";
removeNonInheritableGroupAttrs$1.description =
  "removes non-inheritable groups presentational attributes";

/**
 * Remove non-inheritable group's "presentation" attributes.
 *
 * @author Kir Belevich
 *
 * @type {import('./plugins-types').Plugin<'removeNonInheritableGroupAttrs'>}
 */
removeNonInheritableGroupAttrs$1.fn = () => {
  return {
    element: {
      enter: (node) => {
        if (node.name === "g") {
          for (const name of Object.keys(node.attributes)) {
            if (
              attrsGroups$3.presentation.has(name) &&
              !inheritableAttrs$2.has(name) &&
              !presentationNonInheritableGroupAttrs.has(name)
            ) {
              delete node.attributes[name];
            }
          }
        }
      },
    },
  };
};

var removeUselessStrokeAndFill$1 = {};

const {
  visit: visit$4,
  visitSkip: visitSkip$2,
  detachNodeFromParent: detachNodeFromParent$d,
} = xast;
const { collectStylesheet: collectStylesheet$6, computeStyle: computeStyle$5 } =
  style;
const { hasScripts: hasScripts$1 } = tools;
const { elemsGroups: elemsGroups$3 } = _collections;

removeUselessStrokeAndFill$1.name = "removeUselessStrokeAndFill";
removeUselessStrokeAndFill$1.description =
  "removes useless stroke and fill attributes";

/**
 * Remove useless stroke and fill attrs.
 *
 * @author Kir Belevich
 *
 * @type {import('./plugins-types').Plugin<'removeUselessStrokeAndFill'>}
 */
removeUselessStrokeAndFill$1.fn = (root, params) => {
  const {
    stroke: removeStroke = true,
    fill: removeFill = true,
    removeNone = false,
  } = params;

  // style and script elements deoptimise this plugin
  let hasStyleOrScript = false;
  visit$4(root, {
    element: {
      enter: (node) => {
        if (node.name === "style" || hasScripts$1(node)) {
          hasStyleOrScript = true;
        }
      },
    },
  });
  if (hasStyleOrScript) {
    return null;
  }

  const stylesheet = collectStylesheet$6(root);

  return {
    element: {
      enter: (node, parentNode) => {
        // id attribute deoptimise the whole subtree
        if (node.attributes.id != null) {
          return visitSkip$2;
        }
        if (!elemsGroups$3.shape.has(node.name)) {
          return;
        }
        const computedStyle = computeStyle$5(stylesheet, node);
        const stroke = computedStyle.stroke;
        const strokeOpacity = computedStyle["stroke-opacity"];
        const strokeWidth = computedStyle["stroke-width"];
        const markerEnd = computedStyle["marker-end"];
        const fill = computedStyle.fill;
        const fillOpacity = computedStyle["fill-opacity"];
        const computedParentStyle =
          parentNode.type === "element"
            ? computeStyle$5(stylesheet, parentNode)
            : null;
        const parentStroke =
          computedParentStyle == null ? null : computedParentStyle.stroke;

        // remove stroke*
        if (removeStroke) {
          if (
            stroke == null ||
            (stroke.type === "static" && stroke.value == "none") ||
            (strokeOpacity != null &&
              strokeOpacity.type === "static" &&
              strokeOpacity.value === "0") ||
            (strokeWidth != null &&
              strokeWidth.type === "static" &&
              strokeWidth.value === "0")
          ) {
            // stroke-width may affect the size of marker-end
            // marker is not visible when stroke-width is 0
            if (
              (strokeWidth != null &&
                strokeWidth.type === "static" &&
                strokeWidth.value === "0") ||
              markerEnd == null
            ) {
              for (const name of Object.keys(node.attributes)) {
                if (name.startsWith("stroke")) {
                  delete node.attributes[name];
                }
              }
              // set explicit none to not inherit from parent
              if (
                parentStroke != null &&
                parentStroke.type === "static" &&
                parentStroke.value !== "none"
              ) {
                node.attributes.stroke = "none";
              }
            }
          }
        }

        // remove fill*
        if (removeFill) {
          if (
            (fill != null && fill.type === "static" && fill.value === "none") ||
            (fillOpacity != null &&
              fillOpacity.type === "static" &&
              fillOpacity.value === "0")
          ) {
            for (const name of Object.keys(node.attributes)) {
              if (name.startsWith("fill-")) {
                delete node.attributes[name];
              }
            }
            if (
              fill == null ||
              (fill.type === "static" && fill.value !== "none")
            ) {
              node.attributes.fill = "none";
            }
          }
        }

        if (removeNone) {
          if (
            (stroke == null || node.attributes.stroke === "none") &&
            ((fill != null &&
              fill.type === "static" &&
              fill.value === "none") ||
              node.attributes.fill === "none")
          ) {
            detachNodeFromParent$d(node, parentNode);
          }
        }
      },
    },
  };
};

var removeViewBox$1 = {};

removeViewBox$1.name = "removeViewBox";
removeViewBox$1.description = "removes viewBox attribute when possible";

const viewBoxElems = new Set(["pattern", "svg", "symbol"]);

/**
 * Remove viewBox attr which coincides with a width/height box.
 *
 * @see https://www.w3.org/TR/SVG11/coords.html#ViewBoxAttribute
 *
 * @example
 * <svg width="100" height="50" viewBox="0 0 100 50">
 *             
 * <svg width="100" height="50">
 *
 * @author Kir Belevich
 *
 * @type {import('./plugins-types').Plugin<'removeViewBox'>}
 */
removeViewBox$1.fn = () => {
  return {
    element: {
      enter: (node, parentNode) => {
        if (
          viewBoxElems.has(node.name) &&
          node.attributes.viewBox != null &&
          node.attributes.width != null &&
          node.attributes.height != null
        ) {
          // TODO remove width/height for such case instead
          if (node.name === "svg" && parentNode.type !== "root") {
            return;
          }
          const nums = node.attributes.viewBox.split(/[ ,]+/g);
          if (
            nums[0] === "0" &&
            nums[1] === "0" &&
            node.attributes.width.replace(/px$/, "") === nums[2] && // could use parseFloat too
            node.attributes.height.replace(/px$/, "") === nums[3]
          ) {
            delete node.attributes.viewBox;
          }
        }
      },
    },
  };
};

var cleanupEnableBackground$1 = {};

const csstree$1 = cjs$2;
const { visit: visit$3 } = xast;

cleanupEnableBackground$1.name = "cleanupEnableBackground";
cleanupEnableBackground$1.description =
  "remove or cleanup enable-background attribute when possible";

const regEnableBackground =
  /^new\s0\s0\s([-+]?\d*\.?\d+([eE][-+]?\d+)?)\s([-+]?\d*\.?\d+([eE][-+]?\d+)?)$/;

/**
 * Remove or cleanup enable-background attr which coincides with a width/height box.
 *
 * @see https://www.w3.org/TR/SVG11/filters.html#EnableBackgroundProperty
 * @example
 * <svg width="100" height="50" enable-background="new 0 0 100 50">
 *             
 * <svg width="100" height="50">
 * @author Kir Belevich
 * @type {import('./plugins-types').Plugin<'cleanupEnableBackground'>}
 */
cleanupEnableBackground$1.fn = (root) => {
  let hasFilter = false;

  visit$3(root, {
    element: {
      enter: (node) => {
        if (node.name === "filter") {
          hasFilter = true;
        }
      },
    },
  });

  return {
    element: {
      enter: (node) => {
        /** @type {?csstree.CssNode} */
        let newStyle = null;
        /** @type {?csstree.ListItem<csstree.CssNode>} */
        let enableBackgroundDeclaration = null;

        if (node.attributes.style != null) {
          newStyle = csstree$1.parse(node.attributes.style, {
            context: "declarationList",
          });

          if (newStyle.type === "DeclarationList") {
            /** @type {csstree.ListItem<csstree.CssNode>[]} */
            const enableBackgroundDeclarations = [];

            csstree$1.walk(newStyle, (node, nodeItem) => {
              if (
                node.type === "Declaration" &&
                node.property === "enable-background"
              ) {
                enableBackgroundDeclarations.push(nodeItem);
                enableBackgroundDeclaration = nodeItem;
              }
            });

            for (let i = 0; i < enableBackgroundDeclarations.length - 1; i++) {
              newStyle.children.remove(enableBackgroundDeclarations[i]);
            }
          }
        }

        if (!hasFilter) {
          delete node.attributes["enable-background"];

          if (newStyle?.type === "DeclarationList") {
            if (enableBackgroundDeclaration) {
              newStyle.children.remove(enableBackgroundDeclaration);
            }

            if (newStyle.children.isEmpty) {
              delete node.attributes.style;
            } else {
              node.attributes.style = csstree$1.generate(newStyle);
            }
          }

          return;
        }

        const hasDimensions =
          node.attributes.width != null && node.attributes.height != null;

        if (
          (node.name === "svg" ||
            node.name === "mask" ||
            node.name === "pattern") &&
          hasDimensions
        ) {
          const attrValue = node.attributes["enable-background"];
          const attrCleaned = cleanupValue(
            attrValue,
            node.name,
            node.attributes.width,
            node.attributes.height,
          );

          if (attrCleaned) {
            node.attributes["enable-background"] = attrCleaned;
          } else {
            delete node.attributes["enable-background"];
          }

          if (
            newStyle?.type === "DeclarationList" &&
            enableBackgroundDeclaration
          ) {
            const styleValue = csstree$1.generate(
              // @ts-ignore
              enableBackgroundDeclaration.data.value,
            );
            const styleCleaned = cleanupValue(
              styleValue,
              node.name,
              node.attributes.width,
              node.attributes.height,
            );

            if (styleCleaned) {
              // @ts-ignore
              enableBackgroundDeclaration.data.value = {
                type: "Raw",
                value: styleCleaned,
              };
            } else {
              newStyle.children.remove(enableBackgroundDeclaration);
            }
          }
        }

        if (newStyle?.type === "DeclarationList") {
          if (newStyle.children.isEmpty) {
            delete node.attributes.style;
          } else {
            node.attributes.style = csstree$1.generate(newStyle);
          }
        }
      },
    },
  };
};

/**
 * @param {string} value Value of a enable-background attribute or style declaration.
 * @param {string} nodeName Name of the node the value was assigned to.
 * @param {string} width Width of the node the value was assigned to.
 * @param {string} height Height of the node the value was assigned to.
 * @returns {string | undefined} Cleaned up value, or undefined if it's redundant.
 */
const cleanupValue = (value, nodeName, width, height) => {
  const match = regEnableBackground.exec(value);

  if (match != null && width === match[1] && height === match[3]) {
    return nodeName === "svg" ? undefined : "new";
  }

  return value;
};

var removeHiddenElems$1 = {};

var path$6 = {};

const { removeLeadingZero: removeLeadingZero$2, toFixed: toFixed$3 } = tools;

/**
 * @typedef {import('./types').PathDataItem} PathDataItem
 * @typedef {import('./types').PathDataCommand} PathDataCommand
 */

// Based on https://www.w3.org/TR/SVG11/paths.html#PathDataBNF

const argsCountPerCommand = {
  M: 2,
  m: 2,
  Z: 0,
  z: 0,
  L: 2,
  l: 2,
  H: 1,
  h: 1,
  V: 1,
  v: 1,
  C: 6,
  c: 6,
  S: 4,
  s: 4,
  Q: 4,
  q: 4,
  T: 2,
  t: 2,
  A: 7,
  a: 7,
};

/**
 * @type {(c: string) => c is PathDataCommand}
 */
const isCommand = (c) => {
  return c in argsCountPerCommand;
};

/**
 * @type {(c: string) => boolean}
 */
const isWsp = (c) => {
  const codePoint = c.codePointAt(0);
  return (
    codePoint === 0x20 ||
    codePoint === 0x9 ||
    codePoint === 0xd ||
    codePoint === 0xa
  );
};

/**
 * @type {(c: string) => boolean}
 */
const isDigit = (c) => {
  const codePoint = c.codePointAt(0);
  if (codePoint == null) {
    return false;
  }
  return 48 <= codePoint && codePoint <= 57;
};

/**
 * @typedef {'none' | 'sign' | 'whole' | 'decimal_point' | 'decimal' | 'e' | 'exponent_sign' | 'exponent'} ReadNumberState
 */

/**
 * @type {(string: string, cursor: number) => [number, ?number]}
 */
const readNumber = (string, cursor) => {
  let i = cursor;
  let value = "";
  let state = /** @type {ReadNumberState} */ ("none");
  for (; i < string.length; i += 1) {
    const c = string[i];
    if (c === "+" || c === "-") {
      if (state === "none") {
        state = "sign";
        value += c;
        continue;
      }
      if (state === "e") {
        state = "exponent_sign";
        value += c;
        continue;
      }
    }
    if (isDigit(c)) {
      if (state === "none" || state === "sign" || state === "whole") {
        state = "whole";
        value += c;
        continue;
      }
      if (state === "decimal_point" || state === "decimal") {
        state = "decimal";
        value += c;
        continue;
      }
      if (state === "e" || state === "exponent_sign" || state === "exponent") {
        state = "exponent";
        value += c;
        continue;
      }
    }
    if (c === ".") {
      if (state === "none" || state === "sign" || state === "whole") {
        state = "decimal_point";
        value += c;
        continue;
      }
    }
    if (c === "E" || c == "e") {
      if (
        state === "whole" ||
        state === "decimal_point" ||
        state === "decimal"
      ) {
        state = "e";
        value += c;
        continue;
      }
    }
    break;
  }
  const number = Number.parseFloat(value);
  if (Number.isNaN(number)) {
    return [cursor, null];
  } else {
    // step back to delegate iteration to parent loop
    return [i - 1, number];
  }
};

/**
 * @type {(string: string) => PathDataItem[]}
 */
const parsePathData$3 = (string) => {
  /**
   * @type {PathDataItem[]}
   */
  const pathData = [];
  /**
   * @type {?PathDataCommand}
   */
  let command = null;
  let args = /** @type {number[]} */ ([]);
  let argsCount = 0;
  let canHaveComma = false;
  let hadComma = false;
  for (let i = 0; i < string.length; i += 1) {
    const c = string.charAt(i);
    if (isWsp(c)) {
      continue;
    }
    // allow comma only between arguments
    if (canHaveComma && c === ",") {
      if (hadComma) {
        break;
      }
      hadComma = true;
      continue;
    }
    if (isCommand(c)) {
      if (hadComma) {
        return pathData;
      }
      if (command == null) {
        // moveto should be leading command
        if (c !== "M" && c !== "m") {
          return pathData;
        }
      } else {
        // stop if previous command arguments are not flushed
        if (args.length !== 0) {
          return pathData;
        }
      }
      command = c;
      args = [];
      argsCount = argsCountPerCommand[command];
      canHaveComma = false;
      // flush command without arguments
      if (argsCount === 0) {
        pathData.push({ command, args });
      }
      continue;
    }
    // avoid parsing arguments if no command detected
    if (command == null) {
      return pathData;
    }
    // read next argument
    let newCursor = i;
    let number = null;
    if (command === "A" || command === "a") {
      const position = args.length;
      if (position === 0 || position === 1) {
        // allow only positive number without sign as first two arguments
        if (c !== "+" && c !== "-") {
          [newCursor, number] = readNumber(string, i);
        }
      }
      if (position === 2 || position === 5 || position === 6) {
        [newCursor, number] = readNumber(string, i);
      }
      if (position === 3 || position === 4) {
        // read flags
        if (c === "0") {
          number = 0;
        }
        if (c === "1") {
          number = 1;
        }
      }
    } else {
      [newCursor, number] = readNumber(string, i);
    }
    if (number == null) {
      return pathData;
    }
    args.push(number);
    canHaveComma = true;
    hadComma = false;
    i = newCursor;
    // flush arguments when necessary count is reached
    if (args.length === argsCount) {
      pathData.push({ command, args });
      // subsequent moveto coordinates are treated as implicit lineto commands
      if (command === "M") {
        command = "L";
      }
      if (command === "m") {
        command = "l";
      }
      args = [];
    }
  }
  return pathData;
};
path$6.parsePathData = parsePathData$3;

/**
 * @type {(number: number, precision?: number) => {
 *   roundedStr: string,
 *   rounded: number
 * }}
 */
const roundAndStringify = (number, precision) => {
  if (precision != null) {
    number = toFixed$3(number, precision);
  }

  return {
    roundedStr: removeLeadingZero$2(number),
    rounded: number,
  };
};

/**
 * Elliptical arc large-arc and sweep flags are rendered with spaces
 * because many non-browser environments are not able to parse such paths
 *
 * @type {(
 *   command: string,
 *   args: number[],
 *   precision?: number,
 *   disableSpaceAfterFlags?: boolean
 * ) => string}
 */
const stringifyArgs = (command, args, precision, disableSpaceAfterFlags) => {
  let result = "";
  let previous;

  for (let i = 0; i < args.length; i++) {
    const { roundedStr, rounded } = roundAndStringify(args[i], precision);
    if (
      disableSpaceAfterFlags &&
      (command === "A" || command === "a") &&
      // consider combined arcs
      (i % 7 === 4 || i % 7 === 5)
    ) {
      result += roundedStr;
    } else if (i === 0 || rounded < 0) {
      // avoid space before first and negative numbers
      result += roundedStr;
    } else if (
      !Number.isInteger(previous) &&
      rounded != 0 &&
      rounded < 1 &&
      rounded > -1
    ) {
      // remove space before decimal with zero whole
      // only when previous number is also decimal
      result += roundedStr;
    } else {
      result += ` ${roundedStr}`;
    }
    previous = rounded;
  }

  return result;
};

/**
 * @typedef {{
 *   pathData: PathDataItem[];
 *   precision?: number;
 *   disableSpaceAfterFlags?: boolean;
 * }} StringifyPathDataOptions
 */

/**
 * @param {StringifyPathDataOptions} options
 * @returns {string}
 */
const stringifyPathData$2 = ({
  pathData,
  precision,
  disableSpaceAfterFlags,
}) => {
  if (pathData.length === 1) {
    const { command, args } = pathData[0];
    return (
      command + stringifyArgs(command, args, precision, disableSpaceAfterFlags)
    );
  }

  let result = "";
  let prev = { ...pathData[0] };

  // match leading moveto with following lineto
  if (pathData[1].command === "L") {
    prev.command = "M";
  } else if (pathData[1].command === "l") {
    prev.command = "m";
  }

  for (let i = 1; i < pathData.length; i++) {
    const { command, args } = pathData[i];
    if (
      (prev.command === command &&
        prev.command !== "M" &&
        prev.command !== "m") ||
      // combine matching moveto and lineto sequences
      (prev.command === "M" && command === "L") ||
      (prev.command === "m" && command === "l")
    ) {
      prev.args = [...prev.args, ...args];
      if (i === pathData.length - 1) {
        result +=
          prev.command +
          stringifyArgs(
            prev.command,
            prev.args,
            precision,
            disableSpaceAfterFlags,
          );
      }
    } else {
      result +=
        prev.command +
        stringifyArgs(
          prev.command,
          prev.args,
          precision,
          disableSpaceAfterFlags,
        );

      if (i === pathData.length - 1) {
        result +=
          command +
          stringifyArgs(command, args, precision, disableSpaceAfterFlags);
      } else {
        prev = { command, args };
      }
    }
  }

  return result;
};
path$6.stringifyPathData = stringifyPathData$2;

/**
 * @typedef {import('../lib/types').XastChild} XastChild
 * @typedef {import('../lib/types').XastElement} XastElement
 * @typedef {import('../lib/types').XastParent} XastParent
 */

const { elemsGroups: elemsGroups$2 } = _collections;
const {
  visit: visit$2,
  visitSkip: visitSkip$1,
  querySelector: querySelector$1,
  detachNodeFromParent: detachNodeFromParent$c,
} = xast;
const { collectStylesheet: collectStylesheet$5, computeStyle: computeStyle$4 } =
  style;
const { parsePathData: parsePathData$2 } = path$6;
const { hasScripts, findReferences } = tools;

const nonRendering = elemsGroups$2.nonRendering;

removeHiddenElems$1.name = "removeHiddenElems";
removeHiddenElems$1.description =
  "removes hidden elements (zero sized, with absent attributes)";

/**
 * Remove hidden elements with disabled rendering:
 * - display="none"
 * - opacity="0"
 * - circle with zero radius
 * - ellipse with zero x-axis or y-axis radius
 * - rectangle with zero width or height
 * - pattern with zero width or height
 * - image with zero width or height
 * - path with empty data
 * - polyline with empty points
 * - polygon with empty points
 *
 * @author Kir Belevich
 *
 * @type {import('./plugins-types').Plugin<'removeHiddenElems'>}
 */
removeHiddenElems$1.fn = (root, params) => {
  const {
    isHidden = true,
    displayNone = true,
    opacity0 = true,
    circleR0 = true,
    ellipseRX0 = true,
    ellipseRY0 = true,
    rectWidth0 = true,
    rectHeight0 = true,
    patternWidth0 = true,
    patternHeight0 = true,
    imageWidth0 = true,
    imageHeight0 = true,
    pathEmptyD = true,
    polylineEmptyPoints = true,
    polygonEmptyPoints = true,
  } = params;
  const stylesheet = collectStylesheet$5(root);

  /**
   * Skip non-rendered nodes initially, and only detach if they have no ID, or
   * their ID is not referenced by another node.
   *
   * @type {Map<XastElement, XastParent>}
   */
  const nonRenderedNodes = new Map();

  /**
   * IDs for removed hidden definitions.
   *
   * @type {Set<string>}
   */
  const removedDefIds = new Set();

  /**
   * @type {Map<XastElement, XastParent>}
   */
  const allDefs = new Map();

  /** @type {Set<string>} */
  const allReferences = new Set();

  /**
   * @type {Map<string, Array<{ node: XastElement, parentNode: XastParent }>>}
   */
  const referencesById = new Map();

  /**
   * If styles are present, we can't be sure if a definition is unused or not
   */
  let deoptimized = false;

  /**
   * @param {XastChild} node
   * @param {XastParent} parentNode
   */
  function removeElement(node, parentNode) {
    if (
      node.type === "element" &&
      node.attributes.id != null &&
      parentNode.type === "element" &&
      parentNode.name === "defs"
    ) {
      removedDefIds.add(node.attributes.id);
    }

    detachNodeFromParent$c(node, parentNode);
  }

  visit$2(root, {
    element: {
      enter: (node, parentNode) => {
        // transparent non-rendering elements still apply where referenced
        if (nonRendering.has(node.name)) {
          if (node.attributes.id == null) {
            detachNodeFromParent$c(node, parentNode);
            return visitSkip$1;
          }

          nonRenderedNodes.set(node, parentNode);
          return visitSkip$1;
        }
        const computedStyle = computeStyle$4(stylesheet, node);
        // opacity="0"
        //
        // https://www.w3.org/TR/SVG11/masking.html#ObjectAndGroupOpacityProperties
        if (
          opacity0 &&
          computedStyle.opacity &&
          computedStyle.opacity.type === "static" &&
          computedStyle.opacity.value === "0"
        ) {
          removeElement(node, parentNode);
        }
      },
    },
  });

  return {
    element: {
      enter: (node, parentNode) => {
        if (
          (node.name === "style" && node.children.length !== 0) ||
          hasScripts(node)
        ) {
          deoptimized = true;
          return;
        }

        if (node.name === "defs") {
          allDefs.set(node, parentNode);
        }

        if (node.name === "use") {
          for (const attr of Object.keys(node.attributes)) {
            if (attr !== "href" && !attr.endsWith(":href")) continue;
            const value = node.attributes[attr];
            const id = value.slice(1);

            let refs = referencesById.get(id);
            if (!refs) {
              refs = [];
              referencesById.set(id, refs);
            }
            refs.push({ node, parentNode });
          }
        }

        // Removes hidden elements
        // https://www.w3schools.com/cssref/pr_class_visibility.asp
        const computedStyle = computeStyle$4(stylesheet, node);
        if (
          isHidden &&
          computedStyle.visibility &&
          computedStyle.visibility.type === "static" &&
          computedStyle.visibility.value === "hidden" &&
          // keep if any descendant enables visibility
          querySelector$1(node, "[visibility=visible]") == null
        ) {
          removeElement(node, parentNode);
          return;
        }

        // display="none"
        //
        // https://www.w3.org/TR/SVG11/painting.html#DisplayProperty
        // "A value of display: none indicates that the given element
        // and its children shall not be rendered directly"
        if (
          displayNone &&
          computedStyle.display &&
          computedStyle.display.type === "static" &&
          computedStyle.display.value === "none" &&
          // markers with display: none still rendered
          node.name !== "marker"
        ) {
          removeElement(node, parentNode);
          return;
        }

        // Circles with zero radius
        //
        // https://www.w3.org/TR/SVG11/shapes.html#CircleElementRAttribute
        // "A value of zero disables rendering of the element"
        //
        // <circle r="0">
        if (
          circleR0 &&
          node.name === "circle" &&
          node.children.length === 0 &&
          node.attributes.r === "0"
        ) {
          removeElement(node, parentNode);
          return;
        }

        // Ellipse with zero x-axis radius
        //
        // https://www.w3.org/TR/SVG11/shapes.html#EllipseElementRXAttribute
        // "A value of zero disables rendering of the element"
        //
        // <ellipse rx="0">
        if (
          ellipseRX0 &&
          node.name === "ellipse" &&
          node.children.length === 0 &&
          node.attributes.rx === "0"
        ) {
          removeElement(node, parentNode);
          return;
        }

        // Ellipse with zero y-axis radius
        //
        // https://www.w3.org/TR/SVG11/shapes.html#EllipseElementRYAttribute
        // "A value of zero disables rendering of the element"
        //
        // <ellipse ry="0">
        if (
          ellipseRY0 &&
          node.name === "ellipse" &&
          node.children.length === 0 &&
          node.attributes.ry === "0"
        ) {
          removeElement(node, parentNode);
          return;
        }

        // Rectangle with zero width
        //
        // https://www.w3.org/TR/SVG11/shapes.html#RectElementWidthAttribute
        // "A value of zero disables rendering of the element"
        //
        // <rect width="0">
        if (
          rectWidth0 &&
          node.name === "rect" &&
          node.children.length === 0 &&
          node.attributes.width === "0"
        ) {
          removeElement(node, parentNode);
          return;
        }

        // Rectangle with zero height
        //
        // https://www.w3.org/TR/SVG11/shapes.html#RectElementHeightAttribute
        // "A value of zero disables rendering of the element"
        //
        // <rect height="0">
        if (
          rectHeight0 &&
          rectWidth0 &&
          node.name === "rect" &&
          node.children.length === 0 &&
          node.attributes.height === "0"
        ) {
          removeElement(node, parentNode);
          return;
        }

        // Pattern with zero width
        //
        // https://www.w3.org/TR/SVG11/pservers.html#PatternElementWidthAttribute
        // "A value of zero disables rendering of the element (i.e., no paint is applied)"
        //
        // <pattern width="0">
        if (
          patternWidth0 &&
          node.name === "pattern" &&
          node.attributes.width === "0"
        ) {
          removeElement(node, parentNode);
          return;
        }

        // Pattern with zero height
        //
        // https://www.w3.org/TR/SVG11/pservers.html#PatternElementHeightAttribute
        // "A value of zero disables rendering of the element (i.e., no paint is applied)"
        //
        // <pattern height="0">
        if (
          patternHeight0 &&
          node.name === "pattern" &&
          node.attributes.height === "0"
        ) {
          removeElement(node, parentNode);
          return;
        }

        // Image with zero width
        //
        // https://www.w3.org/TR/SVG11/struct.html#ImageElementWidthAttribute
        // "A value of zero disables rendering of the element"
        //
        // <image width="0">
        if (
          imageWidth0 &&
          node.name === "image" &&
          node.attributes.width === "0"
        ) {
          removeElement(node, parentNode);
          return;
        }

        // Image with zero height
        //
        // https://www.w3.org/TR/SVG11/struct.html#ImageElementHeightAttribute
        // "A value of zero disables rendering of the element"
        //
        // <image height="0">
        if (
          imageHeight0 &&
          node.name === "image" &&
          node.attributes.height === "0"
        ) {
          removeElement(node, parentNode);
          return;
        }

        // Path with empty data
        //
        // https://www.w3.org/TR/SVG11/paths.html#DAttribute
        //
        // <path d=""/>
        if (pathEmptyD && node.name === "path") {
          if (node.attributes.d == null) {
            removeElement(node, parentNode);
            return;
          }
          const pathData = parsePathData$2(node.attributes.d);
          if (pathData.length === 0) {
            removeElement(node, parentNode);
            return;
          }
          // keep single point paths for markers
          if (
            pathData.length === 1 &&
            computedStyle["marker-start"] == null &&
            computedStyle["marker-end"] == null
          ) {
            removeElement(node, parentNode);
            return;
          }
        }

        // Polyline with empty points
        //
        // https://www.w3.org/TR/SVG11/shapes.html#PolylineElementPointsAttribute
        //
        // <polyline points="">
        if (
          polylineEmptyPoints &&
          node.name === "polyline" &&
          node.attributes.points == null
        ) {
          removeElement(node, parentNode);
          return;
        }

        // Polygon with empty points
        //
        // https://www.w3.org/TR/SVG11/shapes.html#PolygonElementPointsAttribute
        //
        // <polygon points="">
        if (
          polygonEmptyPoints &&
          node.name === "polygon" &&
          node.attributes.points == null
        ) {
          removeElement(node, parentNode);
          return;
        }

        for (const [name, value] of Object.entries(node.attributes)) {
          const ids = findReferences(name, value);

          for (const id of ids) {
            allReferences.add(id);
          }
        }
      },
    },
    root: {
      exit: () => {
        for (const id of removedDefIds) {
          const refs = referencesById.get(id);
          if (refs) {
            for (const { node, parentNode } of refs) {
              detachNodeFromParent$c(node, parentNode);
            }
          }
        }

        if (!deoptimized) {
          for (const [
            nonRenderedNode,
            nonRenderedParent,
          ] of nonRenderedNodes.entries()) {
            const id = nonRenderedNode.attributes.id;

            if (!allReferences.has(id)) {
              detachNodeFromParent$c(nonRenderedNode, nonRenderedParent);
            }
          }
        }

        for (const [node, parentNode] of allDefs.entries()) {
          if (node.children.length === 0) {
            detachNodeFromParent$c(node, parentNode);
          }
        }
      },
    },
  };
};

var removeEmptyText$1 = {};

const { detachNodeFromParent: detachNodeFromParent$b } = xast;

removeEmptyText$1.name = "removeEmptyText";
removeEmptyText$1.description = "removes empty <text> elements";

/**
 * Remove empty Text elements.
 *
 * @see https://www.w3.org/TR/SVG11/text.html
 *
 * @example
 * Remove empty text element:
 * <text/>
 *
 * Remove empty tspan element:
 * <tspan/>
 *
 * Remove tref with empty xlink:href attribute:
 * <tref xlink:href=""/>
 *
 * @author Kir Belevich
 *
 * @type {import('./plugins-types').Plugin<'removeEmptyText'>}
 */
removeEmptyText$1.fn = (root, params) => {
  const { text = true, tspan = true, tref = true } = params;
  return {
    element: {
      enter: (node, parentNode) => {
        // Remove empty text element
        if (text && node.name === "text" && node.children.length === 0) {
          detachNodeFromParent$b(node, parentNode);
        }
        // Remove empty tspan element
        if (tspan && node.name === "tspan" && node.children.length === 0) {
          detachNodeFromParent$b(node, parentNode);
        }
        // Remove tref with empty xlink:href attribute
        if (
          tref &&
          node.name === "tref" &&
          node.attributes["xlink:href"] == null
        ) {
          detachNodeFromParent$b(node, parentNode);
        }
      },
    },
  };
};

var convertShapeToPath$1 = {};

/**
 * @typedef {import('../lib/types').PathDataItem} PathDataItem
 */

const { stringifyPathData: stringifyPathData$1 } = path$6;
const { detachNodeFromParent: detachNodeFromParent$a } = xast;

convertShapeToPath$1.name = "convertShapeToPath";
convertShapeToPath$1.description =
  "converts basic shapes to more compact path form";

const regNumber = /[-+]?(?:\d*\.\d+|\d+\.?)(?:[eE][-+]?\d+)?/g;

/**
 * Converts basic shape to more compact path.
 * It also allows further optimizations like
 * combining paths with similar attributes.
 *
 * @see https://www.w3.org/TR/SVG11/shapes.html
 *
 * @author Lev Solntsev
 *
 * @type {import('./plugins-types').Plugin<'convertShapeToPath'>}
 */
convertShapeToPath$1.fn = (root, params) => {
  const { convertArcs = false, floatPrecision: precision } = params;

  return {
    element: {
      enter: (node, parentNode) => {
        // convert rect to path
        if (
          node.name === "rect" &&
          node.attributes.width != null &&
          node.attributes.height != null &&
          node.attributes.rx == null &&
          node.attributes.ry == null
        ) {
          const x = Number(node.attributes.x || "0");
          const y = Number(node.attributes.y || "0");
          const width = Number(node.attributes.width);
          const height = Number(node.attributes.height);
          // Values like '100%' compute to NaN, thus running after
          // cleanupNumericValues when 'px' units has already been removed.
          // TODO: Calculate sizes from % and non-px units if possible.
          if (Number.isNaN(x - y + width - height)) return;
          /**
           * @type {PathDataItem[]}
           */
          const pathData = [
            { command: "M", args: [x, y] },
            { command: "H", args: [x + width] },
            { command: "V", args: [y + height] },
            { command: "H", args: [x] },
            { command: "z", args: [] },
          ];
          node.name = "path";
          node.attributes.d = stringifyPathData$1({ pathData, precision });
          delete node.attributes.x;
          delete node.attributes.y;
          delete node.attributes.width;
          delete node.attributes.height;
        }

        // convert line to path
        if (node.name === "line") {
          const x1 = Number(node.attributes.x1 || "0");
          const y1 = Number(node.attributes.y1 || "0");
          const x2 = Number(node.attributes.x2 || "0");
          const y2 = Number(node.attributes.y2 || "0");
          if (Number.isNaN(x1 - y1 + x2 - y2)) return;
          /**
           * @type {PathDataItem[]}
           */
          const pathData = [
            { command: "M", args: [x1, y1] },
            { command: "L", args: [x2, y2] },
          ];
          node.name = "path";
          node.attributes.d = stringifyPathData$1({ pathData, precision });
          delete node.attributes.x1;
          delete node.attributes.y1;
          delete node.attributes.x2;
          delete node.attributes.y2;
        }

        // convert polyline and polygon to path
        if (
          (node.name === "polyline" || node.name === "polygon") &&
          node.attributes.points != null
        ) {
          const coords = (node.attributes.points.match(regNumber) || []).map(
            Number,
          );
          if (coords.length < 4) {
            detachNodeFromParent$a(node, parentNode);
            return;
          }
          /**
           * @type {PathDataItem[]}
           */
          const pathData = [];
          for (let i = 0; i < coords.length; i += 2) {
            pathData.push({
              command: i === 0 ? "M" : "L",
              args: coords.slice(i, i + 2),
            });
          }
          if (node.name === "polygon") {
            pathData.push({ command: "z", args: [] });
          }
          node.name = "path";
          node.attributes.d = stringifyPathData$1({ pathData, precision });
          delete node.attributes.points;
        }

        //  optionally convert circle
        if (node.name === "circle" && convertArcs) {
          const cx = Number(node.attributes.cx || "0");
          const cy = Number(node.attributes.cy || "0");
          const r = Number(node.attributes.r || "0");
          if (Number.isNaN(cx - cy + r)) {
            return;
          }
          /**
           * @type {PathDataItem[]}
           */
          const pathData = [
            { command: "M", args: [cx, cy - r] },
            { command: "A", args: [r, r, 0, 1, 0, cx, cy + r] },
            { command: "A", args: [r, r, 0, 1, 0, cx, cy - r] },
            { command: "z", args: [] },
          ];
          node.name = "path";
          node.attributes.d = stringifyPathData$1({ pathData, precision });
          delete node.attributes.cx;
          delete node.attributes.cy;
          delete node.attributes.r;
        }

        // optionally convert ellipse
        if (node.name === "ellipse" && convertArcs) {
          const ecx = Number(node.attributes.cx || "0");
          const ecy = Number(node.attributes.cy || "0");
          const rx = Number(node.attributes.rx || "0");
          const ry = Number(node.attributes.ry || "0");
          if (Number.isNaN(ecx - ecy + rx - ry)) {
            return;
          }
          /**
           * @type {PathDataItem[]}
           */
          const pathData = [
            { command: "M", args: [ecx, ecy - ry] },
            { command: "A", args: [rx, ry, 0, 1, 0, ecx, ecy + ry] },
            { command: "A", args: [rx, ry, 0, 1, 0, ecx, ecy - ry] },
            { command: "z", args: [] },
          ];
          node.name = "path";
          node.attributes.d = stringifyPathData$1({ pathData, precision });
          delete node.attributes.cx;
          delete node.attributes.cy;
          delete node.attributes.rx;
          delete node.attributes.ry;
        }
      },
    },
  };
};

var convertEllipseToCircle$1 = {};

convertEllipseToCircle$1.name = "convertEllipseToCircle";
convertEllipseToCircle$1.description =
  "converts non-eccentric <ellipse>s to <circle>s";

/**
 * Converts non-eccentric <ellipse>s to <circle>s.
 *
 * @see https://www.w3.org/TR/SVG11/shapes.html
 *
 * @author Taylor Hunt
 *
 * @type {import('./plugins-types').Plugin<'convertEllipseToCircle'>}
 */
convertEllipseToCircle$1.fn = () => {
  return {
    element: {
      enter: (node) => {
        if (node.name === "ellipse") {
          const rx = node.attributes.rx || "0";
          const ry = node.attributes.ry || "0";
          if (
            rx === ry ||
            rx === "auto" ||
            ry === "auto" // SVG2
          ) {
            node.name = "circle";
            const radius = rx === "auto" ? ry : rx;
            delete node.attributes.rx;
            delete node.attributes.ry;
            node.attributes.r = radius;
          }
        }
      },
    },
  };
};

var moveElemsAttrsToGroup$1 = {};

const { visit: visit$1 } = xast;
const { inheritableAttrs: inheritableAttrs$1, pathElems: pathElems$2 } =
  _collections;

moveElemsAttrsToGroup$1.name = "moveElemsAttrsToGroup";
moveElemsAttrsToGroup$1.description =
  "Move common attributes of group children to the group";

/**
 * Move common attributes of group children to the group
 *
 * @example
 * <g attr1="val1">
 *     <g attr2="val2">
 *         text
 *     </g>
 *     <circle attr2="val2" attr3="val3"/>
 * </g>
 *              
 * <g attr1="val1" attr2="val2">
 *     <g>
 *         text
 *     </g>
 *    <circle attr3="val3"/>
 * </g>
 *
 * @author Kir Belevich
 *
 * @type {import('./plugins-types').Plugin<'moveElemsAttrsToGroup'>}
 */
moveElemsAttrsToGroup$1.fn = (root) => {
  // find if any style element is present
  let deoptimizedWithStyles = false;
  visit$1(root, {
    element: {
      enter: (node) => {
        if (node.name === "style") {
          deoptimizedWithStyles = true;
        }
      },
    },
  });

  return {
    element: {
      exit: (node) => {
        // process only groups with more than 1 children
        if (node.name !== "g" || node.children.length <= 1) {
          return;
        }

        // deoptimize the plugin when style elements are present
        // selectors may rely on id, classes or tag names
        if (deoptimizedWithStyles) {
          return;
        }

        /**
         * find common attributes in group children
         * @type {Map<string, string>}
         */
        const commonAttributes = new Map();
        let initial = true;
        let everyChildIsPath = true;
        for (const child of node.children) {
          if (child.type === "element") {
            if (!pathElems$2.has(child.name)) {
              everyChildIsPath = false;
            }
            if (initial) {
              initial = false;
              // collect all inheritable attributes from first child element
              for (const [name, value] of Object.entries(child.attributes)) {
                // consider only inheritable attributes
                if (inheritableAttrs$1.has(name)) {
                  commonAttributes.set(name, value);
                }
              }
            } else {
              // exclude uncommon attributes from initial list
              for (const [name, value] of commonAttributes) {
                if (child.attributes[name] !== value) {
                  commonAttributes.delete(name);
                }
              }
            }
          }
        }

        // preserve transform on children when group has clip-path or mask
        if (
          node.attributes["clip-path"] != null ||
          node.attributes.mask != null
        ) {
          commonAttributes.delete("transform");
        }

        // preserve transform when all children are paths
        // so the transform could be applied to path data by other plugins
        if (everyChildIsPath) {
          commonAttributes.delete("transform");
        }

        // add common children attributes to group
        for (const [name, value] of commonAttributes) {
          if (name === "transform") {
            if (node.attributes.transform != null) {
              node.attributes.transform = `${node.attributes.transform} ${value}`;
            } else {
              node.attributes.transform = value;
            }
          } else {
            node.attributes[name] = value;
          }
        }

        // delete common attributes from children
        for (const child of node.children) {
          if (child.type === "element") {
            for (const [name] of commonAttributes) {
              delete child.attributes[name];
            }
          }
        }
      },
    },
  };
};

var moveGroupAttrsToElems$1 = {};

const { pathElems: pathElems$1, referencesProps: referencesProps$2 } =
  _collections;
const { includesUrlReference: includesUrlReference$1 } = tools;

moveGroupAttrsToElems$1.name = "moveGroupAttrsToElems";
moveGroupAttrsToElems$1.description =
  "moves some group attributes to the content elements";

const pathElemsWithGroupsAndText = [...pathElems$1, "g", "text"];

/**
 * Move group attrs to the content elements.
 *
 * @example
 * <g transform="scale(2)">
 *     <path transform="rotate(45)" d="M0,0 L10,20"/>
 *     <path transform="translate(10, 20)" d="M0,10 L20,30"/>
 * </g>
 *                          
 * <g>
 *     <path transform="scale(2) rotate(45)" d="M0,0 L10,20"/>
 *     <path transform="scale(2) translate(10, 20)" d="M0,10 L20,30"/>
 * </g>
 *
 * @author Kir Belevich
 *
 * @type {import('./plugins-types').Plugin<'moveGroupAttrsToElems'>}
 */
moveGroupAttrsToElems$1.fn = () => {
  return {
    element: {
      enter: (node) => {
        // move group transform attr to content's pathElems
        if (
          node.name === "g" &&
          node.children.length !== 0 &&
          node.attributes.transform != null &&
          Object.entries(node.attributes).some(
            ([name, value]) =>
              referencesProps$2.has(name) && includesUrlReference$1(value),
          ) === false &&
          node.children.every(
            (child) =>
              child.type === "element" &&
              pathElemsWithGroupsAndText.includes(child.name) &&
              child.attributes.id == null,
          )
        ) {
          for (const child of node.children) {
            const value = node.attributes.transform;
            if (child.type === "element") {
              if (child.attributes.transform != null) {
                child.attributes.transform = `${value} ${child.attributes.transform}`;
              } else {
                child.attributes.transform = value;
              }
            }
          }

          delete node.attributes.transform;
        }
      },
    },
  };
};

var collapseGroups$1 = {};

/**
 * @typedef {import('../lib/types').XastNode} XastNode
 */

const { inheritableAttrs, elemsGroups: elemsGroups$1 } = _collections;

collapseGroups$1.name = "collapseGroups";
collapseGroups$1.description = "collapses useless groups";

/**
 * @type {(node: XastNode, name: string) => boolean}
 */
const hasAnimatedAttr = (node, name) => {
  if (node.type === "element") {
    if (
      elemsGroups$1.animation.has(node.name) &&
      node.attributes.attributeName === name
    ) {
      return true;
    }
    for (const child of node.children) {
      if (hasAnimatedAttr(child, name)) {
        return true;
      }
    }
  }
  return false;
};

/**
 * Collapse useless groups.
 *
 * @example
 * <g>
 *     <g attr1="val1">
 *         <path d="..."/>
 *     </g>
 * </g>
 *         
 * <g>
 *     <g>
 *         <path attr1="val1" d="..."/>
 *     </g>
 * </g>
 *         
 * <path attr1="val1" d="..."/>
 *
 * @author Kir Belevich
 *
 * @type {import('./plugins-types').Plugin<'collapseGroups'>}
 */
collapseGroups$1.fn = () => {
  return {
    element: {
      exit: (node, parentNode) => {
        if (parentNode.type === "root" || parentNode.name === "switch") {
          return;
        }
        // non-empty groups
        if (node.name !== "g" || node.children.length === 0) {
          return;
        }

        // move group attributes to the single child element
        if (
          Object.keys(node.attributes).length !== 0 &&
          node.children.length === 1
        ) {
          const firstChild = node.children[0];
          // TODO untangle this mess
          if (
            firstChild.type === "element" &&
            firstChild.attributes.id == null &&
            node.attributes.filter == null &&
            (node.attributes.class == null ||
              firstChild.attributes.class == null) &&
            ((node.attributes["clip-path"] == null &&
              node.attributes.mask == null) ||
              (firstChild.name === "g" &&
                node.attributes.transform == null &&
                firstChild.attributes.transform == null))
          ) {
            for (const [name, value] of Object.entries(node.attributes)) {
              // avoid copying to not conflict with animated attribute
              if (hasAnimatedAttr(firstChild, name)) {
                return;
              }
              if (firstChild.attributes[name] == null) {
                firstChild.attributes[name] = value;
              } else if (name === "transform") {
                firstChild.attributes[name] =
                  value + " " + firstChild.attributes[name];
              } else if (firstChild.attributes[name] === "inherit") {
                firstChild.attributes[name] = value;
              } else if (
                inheritableAttrs.has(name) === false &&
                firstChild.attributes[name] !== value
              ) {
                return;
              }
              delete node.attributes[name];
            }
          }
        }

        // collapse groups without attributes
        if (Object.keys(node.attributes).length === 0) {
          // animation elements "add" attributes to group
          // group should be preserved
          for (const child of node.children) {
            if (
              child.type === "element" &&
              elemsGroups$1.animation.has(child.name)
            ) {
              return;
            }
          }
          // replace current node with all its children
          const index = parentNode.children.indexOf(node);
          parentNode.children.splice(index, 1, ...node.children);
          // TODO remove legacy parentNode in v4
          for (const child of node.children) {
            Object.defineProperty(child, "parentNode", {
              writable: true,
              value: parentNode,
            });
          }
        }
      },
    },
  };
};

var convertPathData$1 = {};

var _path$1 = {};

/**
 * @typedef {import('../lib/types').XastElement} XastElement
 * @typedef {import('../lib/types').PathDataItem} PathDataItem
 */

const { parsePathData: parsePathData$1, stringifyPathData } = path$6;

/**
 * @type {[number, number]}
 */
var prevCtrlPoint;

/**
 * Convert path string to JS representation.
 *
 * @type {(path: XastElement) => PathDataItem[]}
 */
const path2js$3 = (path) => {
  // @ts-ignore legacy
  if (path.pathJS) return path.pathJS;
  /**
   * @type {PathDataItem[]}
   */
  const pathData = []; // JS representation of the path data
  const newPathData = parsePathData$1(path.attributes.d);
  for (const { command, args } of newPathData) {
    pathData.push({ command, args });
  }
  // First moveto is actually absolute. Subsequent coordinates were separated above.
  if (pathData.length && pathData[0].command == "m") {
    pathData[0].command = "M";
  }
  // @ts-ignore legacy
  path.pathJS = pathData;
  return pathData;
};
_path$1.path2js = path2js$3;

/**
 * Convert relative Path data to absolute.
 *
 * @type {(data: PathDataItem[]) => PathDataItem[]}
 *
 */
const convertRelativeToAbsolute = (data) => {
  /**
   * @type {PathDataItem[]}
   */
  const newData = [];
  let start = [0, 0];
  let cursor = [0, 0];

  for (let { command, args } of data) {
    args = args.slice();

    // moveto (x y)
    if (command === "m") {
      args[0] += cursor[0];
      args[1] += cursor[1];
      command = "M";
    }
    if (command === "M") {
      cursor[0] = args[0];
      cursor[1] = args[1];
      start[0] = cursor[0];
      start[1] = cursor[1];
    }

    // horizontal lineto (x)
    if (command === "h") {
      args[0] += cursor[0];
      command = "H";
    }
    if (command === "H") {
      cursor[0] = args[0];
    }

    // vertical lineto (y)
    if (command === "v") {
      args[0] += cursor[1];
      command = "V";
    }
    if (command === "V") {
      cursor[1] = args[0];
    }

    // lineto (x y)
    if (command === "l") {
      args[0] += cursor[0];
      args[1] += cursor[1];
      command = "L";
    }
    if (command === "L") {
      cursor[0] = args[0];
      cursor[1] = args[1];
    }

    // curveto (x1 y1 x2 y2 x y)
    if (command === "c") {
      args[0] += cursor[0];
      args[1] += cursor[1];
      args[2] += cursor[0];
      args[3] += cursor[1];
      args[4] += cursor[0];
      args[5] += cursor[1];
      command = "C";
    }
    if (command === "C") {
      cursor[0] = args[4];
      cursor[1] = args[5];
    }

    // smooth curveto (x2 y2 x y)
    if (command === "s") {
      args[0] += cursor[0];
      args[1] += cursor[1];
      args[2] += cursor[0];
      args[3] += cursor[1];
      command = "S";
    }
    if (command === "S") {
      cursor[0] = args[2];
      cursor[1] = args[3];
    }

    // quadratic Bzier curveto (x1 y1 x y)
    if (command === "q") {
      args[0] += cursor[0];
      args[1] += cursor[1];
      args[2] += cursor[0];
      args[3] += cursor[1];
      command = "Q";
    }
    if (command === "Q") {
      cursor[0] = args[2];
      cursor[1] = args[3];
    }

    // smooth quadratic Bzier curveto (x y)
    if (command === "t") {
      args[0] += cursor[0];
      args[1] += cursor[1];
      command = "T";
    }
    if (command === "T") {
      cursor[0] = args[0];
      cursor[1] = args[1];
    }

    // elliptical arc (rx ry x-axis-rotation large-arc-flag sweep-flag x y)
    if (command === "a") {
      args[5] += cursor[0];
      args[6] += cursor[1];
      command = "A";
    }
    if (command === "A") {
      cursor[0] = args[5];
      cursor[1] = args[6];
    }

    // closepath
    if (command === "z" || command === "Z") {
      cursor[0] = start[0];
      cursor[1] = start[1];
      command = "z";
    }

    newData.push({ command, args });
  }
  return newData;
};

/**
 * @typedef {{ floatPrecision?: number, noSpaceAfterFlags?: boolean }} Js2PathParams
 */

/**
 * Convert path array to string.
 *
 * @type {(path: XastElement, data: PathDataItem[], params: Js2PathParams) => void}
 */
_path$1.js2path = function (path, data, params) {
  // @ts-ignore legacy
  path.pathJS = data;

  const pathData = [];
  for (const item of data) {
    // remove moveto commands which are followed by moveto commands
    if (
      pathData.length !== 0 &&
      (item.command === "M" || item.command === "m")
    ) {
      const last = pathData[pathData.length - 1];
      if (last.command === "M" || last.command === "m") {
        pathData.pop();
      }
    }
    pathData.push({
      command: item.command,
      args: item.args,
    });
  }

  path.attributes.d = stringifyPathData({
    pathData,
    precision: params.floatPrecision,
    disableSpaceAfterFlags: params.noSpaceAfterFlags,
  });
};

/**
 * @type {(dest: number[], source: number[]) => number[]}
 */
function set(dest, source) {
  dest[0] = source[source.length - 2];
  dest[1] = source[source.length - 1];
  return dest;
}

/**
 * Checks if two paths have an intersection by checking convex hulls
 * collision using Gilbert-Johnson-Keerthi distance algorithm
 * https://web.archive.org/web/20180822200027/http://entropyinteractive.com/2011/04/gjk-algorithm/
 *
 * @type {(path1: PathDataItem[], path2: PathDataItem[]) => boolean}
 */
_path$1.intersects = function (path1, path2) {
  // Collect points of every subpath.
  const points1 = gatherPoints(convertRelativeToAbsolute(path1));
  const points2 = gatherPoints(convertRelativeToAbsolute(path2));

  // Axis-aligned bounding box check.
  if (
    points1.maxX <= points2.minX ||
    points2.maxX <= points1.minX ||
    points1.maxY <= points2.minY ||
    points2.maxY <= points1.minY ||
    points1.list.every((set1) => {
      return points2.list.every((set2) => {
        return (
          set1.list[set1.maxX][0] <= set2.list[set2.minX][0] ||
          set2.list[set2.maxX][0] <= set1.list[set1.minX][0] ||
          set1.list[set1.maxY][1] <= set2.list[set2.minY][1] ||
          set2.list[set2.maxY][1] <= set1.list[set1.minY][1]
        );
      });
    })
  )
    return false;

  // Get a convex hull from points of each subpath. Has the most complexity O(nlog n).
  const hullNest1 = points1.list.map(convexHull);
  const hullNest2 = points2.list.map(convexHull);

  // Check intersection of every subpath of the first path with every subpath of the second.
  return hullNest1.some(function (hull1) {
    if (hull1.list.length < 3) return false;

    return hullNest2.some(function (hull2) {
      if (hull2.list.length < 3) return false;

      var simplex = [getSupport(hull1, hull2, [1, 0])], // create the initial simplex
        direction = minus(simplex[0]); // set the direction to point towards the origin

      var iterations = 1e4; // infinite loop protection, 10 000 iterations is more than enough
      // eslint-disable-next-line no-constant-condition
      while (true) {
        if (iterations-- == 0) {
          console.error(
            "Error: infinite loop while processing mergePaths plugin.",
          );
          return true; // true is the safe value that means do nothing with paths
        }
        // add a new point
        simplex.push(getSupport(hull1, hull2, direction));
        // see if the new point was on the correct side of the origin
        if (dot(direction, simplex[simplex.length - 1]) <= 0) return false;
        // process the simplex
        if (processSimplex(simplex, direction)) return true;
      }
    });
  });

  /**
   * @type {(a: Point, b: Point, direction: number[]) => number[]}
   */
  function getSupport(a, b, direction) {
    return sub(supportPoint(a, direction), supportPoint(b, minus(direction)));
  }

  // Computes farthest polygon point in particular direction.
  // Thanks to knowledge of min/max x and y coordinates we can choose a quadrant to search in.
  // Since we're working on convex hull, the dot product is increasing until we find the farthest point.
  /**
   * @type {(polygon: Point, direction: number[]) => number[]}
   */
  function supportPoint(polygon, direction) {
    var index =
        direction[1] >= 0
          ? direction[0] < 0
            ? polygon.maxY
            : polygon.maxX
          : direction[0] < 0
            ? polygon.minX
            : polygon.minY,
      max = -Infinity,
      value;
    while ((value = dot(polygon.list[index], direction)) > max) {
      max = value;
      index = ++index % polygon.list.length;
    }
    return polygon.list[(index || polygon.list.length) - 1];
  }
};

/**
 * @type {(simplex: number[][], direction: number[]) => boolean}
 */
function processSimplex(simplex, direction) {
  // we only need to handle to 1-simplex and 2-simplex
  if (simplex.length == 2) {
    // 1-simplex
    let a = simplex[1],
      b = simplex[0],
      AO = minus(simplex[1]),
      AB = sub(b, a);
    // AO is in the same direction as AB
    if (dot(AO, AB) > 0) {
      // get the vector perpendicular to AB facing O
      set(direction, orth(AB, a));
    } else {
      set(direction, AO);
      // only A remains in the simplex
      simplex.shift();
    }
  } else {
    // 2-simplex
    let a = simplex[2], // [a, b, c] = simplex
      b = simplex[1],
      c = simplex[0],
      AB = sub(b, a),
      AC = sub(c, a),
      AO = minus(a),
      ACB = orth(AB, AC), // the vector perpendicular to AB facing away from C
      ABC = orth(AC, AB); // the vector perpendicular to AC facing away from B

    if (dot(ACB, AO) > 0) {
      if (dot(AB, AO) > 0) {
        // region 4
        set(direction, ACB);
        simplex.shift(); // simplex = [b, a]
      } else {
        // region 5
        set(direction, AO);
        simplex.splice(0, 2); // simplex = [a]
      }
    } else if (dot(ABC, AO) > 0) {
      if (dot(AC, AO) > 0) {
        // region 6
        set(direction, ABC);
        simplex.splice(1, 1); // simplex = [c, a]
      } else {
        // region 5 (again)
        set(direction, AO);
        simplex.splice(0, 2); // simplex = [a]
      }
    } // region 7
    else return true;
  }
  return false;
}

/**
 * @type {(v: number[]) => number[]}
 */
function minus(v) {
  return [-v[0], -v[1]];
}

/**
 * @type {(v1: number[], v2: number[]) => number[]}
 */
function sub(v1, v2) {
  return [v1[0] - v2[0], v1[1] - v2[1]];
}

/**
 * @type {(v1: number[], v2: number[]) => number}
 */
function dot(v1, v2) {
  return v1[0] * v2[0] + v1[1] * v2[1];
}

/**
 * @type {(v1: number[], v2: number[]) => number[]}
 */
function orth(v, from) {
  var o = [-v[1], v[0]];
  return dot(o, minus(from)) < 0 ? minus(o) : o;
}

/**
 * @typedef {{
 *   list: number[][],
 *   minX: number,
 *   minY: number,
 *   maxX: number,
 *   maxY: number
 * }} Point
 */

/**
 * @typedef {{
 *   list: Point[],
 *   minX: number,
 *   minY: number,
 *   maxX: number,
 *   maxY: number
 * }} Points
 */

/**
 * @type {(pathData: PathDataItem[]) => Points}
 */
function gatherPoints(pathData) {
  /**
   * @type {Points}
   */
  const points = { list: [], minX: 0, minY: 0, maxX: 0, maxY: 0 };

  // Writes data about the extreme points on each axle
  /**
   * @type {(path: Point, point: number[]) => void}
   */
  const addPoint = (path, point) => {
    if (!path.list.length || point[1] > path.list[path.maxY][1]) {
      path.maxY = path.list.length;
      points.maxY = points.list.length
        ? Math.max(point[1], points.maxY)
        : point[1];
    }
    if (!path.list.length || point[0] > path.list[path.maxX][0]) {
      path.maxX = path.list.length;
      points.maxX = points.list.length
        ? Math.max(point[0], points.maxX)
        : point[0];
    }
    if (!path.list.length || point[1] < path.list[path.minY][1]) {
      path.minY = path.list.length;
      points.minY = points.list.length
        ? Math.min(point[1], points.minY)
        : point[1];
    }
    if (!path.list.length || point[0] < path.list[path.minX][0]) {
      path.minX = path.list.length;
      points.minX = points.list.length
        ? Math.min(point[0], points.minX)
        : point[0];
    }
    path.list.push(point);
  };

  for (let i = 0; i < pathData.length; i += 1) {
    const pathDataItem = pathData[i];
    let subPath =
      points.list.length === 0
        ? { list: [], minX: 0, minY: 0, maxX: 0, maxY: 0 }
        : points.list[points.list.length - 1];
    let prev = i === 0 ? null : pathData[i - 1];
    let basePoint =
      subPath.list.length === 0 ? null : subPath.list[subPath.list.length - 1];
    let data = pathDataItem.args;
    let ctrlPoint = basePoint;

    /**
     * @type {(n: number, i: number) => number}
     * TODO fix null hack
     */
    const toAbsolute = (n, i) => n + (basePoint == null ? 0 : basePoint[i % 2]);

    switch (pathDataItem.command) {
      case "M":
        subPath = { list: [], minX: 0, minY: 0, maxX: 0, maxY: 0 };
        points.list.push(subPath);
        break;

      case "H":
        if (basePoint != null) {
          addPoint(subPath, [data[0], basePoint[1]]);
        }
        break;

      case "V":
        if (basePoint != null) {
          addPoint(subPath, [basePoint[0], data[0]]);
        }
        break;

      case "Q":
        addPoint(subPath, data.slice(0, 2));
        prevCtrlPoint = [data[2] - data[0], data[3] - data[1]]; // Save control point for shorthand
        break;

      case "T":
        if (
          basePoint != null &&
          prev != null &&
          (prev.command == "Q" || prev.command == "T")
        ) {
          ctrlPoint = [
            basePoint[0] + prevCtrlPoint[0],
            basePoint[1] + prevCtrlPoint[1],
          ];
          addPoint(subPath, ctrlPoint);
          prevCtrlPoint = [data[0] - ctrlPoint[0], data[1] - ctrlPoint[1]];
        }
        break;

      case "C":
        if (basePoint != null) {
          // Approximate quibic Bezier curve with middle points between control points
          addPoint(subPath, [
            0.5 * (basePoint[0] + data[0]),
            0.5 * (basePoint[1] + data[1]),
          ]);
        }
        addPoint(subPath, [
          0.5 * (data[0] + data[2]),
          0.5 * (data[1] + data[3]),
        ]);
        addPoint(subPath, [
          0.5 * (data[2] + data[4]),
          0.5 * (data[3] + data[5]),
        ]);
        prevCtrlPoint = [data[4] - data[2], data[5] - data[3]]; // Save control point for shorthand
        break;

      case "S":
        if (
          basePoint != null &&
          prev != null &&
          (prev.command == "C" || prev.command == "S")
        ) {
          addPoint(subPath, [
            basePoint[0] + 0.5 * prevCtrlPoint[0],
            basePoint[1] + 0.5 * prevCtrlPoint[1],
          ]);
          ctrlPoint = [
            basePoint[0] + prevCtrlPoint[0],
            basePoint[1] + prevCtrlPoint[1],
          ];
        }
        if (ctrlPoint != null) {
          addPoint(subPath, [
            0.5 * (ctrlPoint[0] + data[0]),
            0.5 * (ctrlPoint[1] + data[1]),
          ]);
        }
        addPoint(subPath, [
          0.5 * (data[0] + data[2]),
          0.5 * (data[1] + data[3]),
        ]);
        prevCtrlPoint = [data[2] - data[0], data[3] - data[1]];
        break;

      case "A":
        if (basePoint != null) {
          // Convert the arc to bezier curves and use the same approximation
          // @ts-ignore no idea what's going on here
          var curves = a2c.apply(0, basePoint.concat(data));
          for (
            var cData;
            (cData = curves.splice(0, 6).map(toAbsolute)).length;

          ) {
            if (basePoint != null) {
              addPoint(subPath, [
                0.5 * (basePoint[0] + cData[0]),
                0.5 * (basePoint[1] + cData[1]),
              ]);
            }
            addPoint(subPath, [
              0.5 * (cData[0] + cData[2]),
              0.5 * (cData[1] + cData[3]),
            ]);
            addPoint(subPath, [
              0.5 * (cData[2] + cData[4]),
              0.5 * (cData[3] + cData[5]),
            ]);
            if (curves.length) addPoint(subPath, (basePoint = cData.slice(-2)));
          }
        }
        break;
    }

    // Save final command coordinates
    if (data.length >= 2) addPoint(subPath, data.slice(-2));
  }

  return points;
}

/**
 * Forms a convex hull from set of points of every subpath using monotone chain convex hull algorithm.
 * https://en.wikibooks.org/wiki/Algorithm_Implementation/Geometry/Convex_hull/Monotone_chain
 *
 * @type {(points: Point) => Point}
 */
function convexHull(points) {
  points.list.sort(function (a, b) {
    return a[0] == b[0] ? a[1] - b[1] : a[0] - b[0];
  });

  var lower = [],
    minY = 0,
    bottom = 0;
  for (let i = 0; i < points.list.length; i++) {
    while (
      lower.length >= 2 &&
      cross(lower[lower.length - 2], lower[lower.length - 1], points.list[i]) <=
        0
    ) {
      lower.pop();
    }
    if (points.list[i][1] < points.list[minY][1]) {
      minY = i;
      bottom = lower.length;
    }
    lower.push(points.list[i]);
  }

  var upper = [],
    maxY = points.list.length - 1,
    top = 0;
  for (let i = points.list.length; i--; ) {
    while (
      upper.length >= 2 &&
      cross(upper[upper.length - 2], upper[upper.length - 1], points.list[i]) <=
        0
    ) {
      upper.pop();
    }
    if (points.list[i][1] > points.list[maxY][1]) {
      maxY = i;
      top = upper.length;
    }
    upper.push(points.list[i]);
  }

  // last points are equal to starting points of the other part
  upper.pop();
  lower.pop();

  const hullList = lower.concat(upper);

  /**
   * @type {Point}
   */
  const hull = {
    list: hullList,
    minX: 0, // by sorting
    maxX: lower.length,
    minY: bottom,
    maxY: (lower.length + top) % hullList.length,
  };

  return hull;
}

/**
 * @type {(o: number[], a: number[], b: number[]) => number}
 */
function cross(o, a, b) {
  return (a[0] - o[0]) * (b[1] - o[1]) - (a[1] - o[1]) * (b[0] - o[0]);
}

/**
 * Based on code from Snap.svg (Apache 2 license). http://snapsvg.io/
 * Thanks to Dmitry Baranovskiy for his great work!
 *
 * @type {(
 *  x1: number,
 *  y1: number,
 *  rx: number,
 *  ry: number,
 *  angle: number,
 *  large_arc_flag: number,
 *  sweep_flag: number,
 *  x2: number,
 *  y2: number,
 *  recursive: number[]
 * ) => number[]}
 */
const a2c = (
  x1,
  y1,
  rx,
  ry,
  angle,
  large_arc_flag,
  sweep_flag,
  x2,
  y2,
  recursive,
) => {
  // for more information of where this Math came from visit:
  // https://www.w3.org/TR/SVG11/implnote.html#ArcImplementationNotes
  const _120 = (Math.PI * 120) / 180;
  const rad = (Math.PI / 180) * (+angle || 0);
  /**
   * @type {number[]}
   */
  let res = [];
  /**
   * @type {(x: number, y: number, rad: number) => number}
   */
  const rotateX = (x, y, rad) => {
    return x * Math.cos(rad) - y * Math.sin(rad);
  };
  /**
   * @type {(x: number, y: number, rad: number) => number}
   */
  const rotateY = (x, y, rad) => {
    return x * Math.sin(rad) + y * Math.cos(rad);
  };
  if (!recursive) {
    x1 = rotateX(x1, y1, -rad);
    y1 = rotateY(x1, y1, -rad);
    x2 = rotateX(x2, y2, -rad);
    y2 = rotateY(x2, y2, -rad);
    var x = (x1 - x2) / 2,
      y = (y1 - y2) / 2;
    var h = (x * x) / (rx * rx) + (y * y) / (ry * ry);
    if (h > 1) {
      h = Math.sqrt(h);
      rx = h * rx;
      ry = h * ry;
    }
    var rx2 = rx * rx;
    var ry2 = ry * ry;
    var k =
      (large_arc_flag == sweep_flag ? -1 : 1) *
      Math.sqrt(
        Math.abs(
          (rx2 * ry2 - rx2 * y * y - ry2 * x * x) / (rx2 * y * y + ry2 * x * x),
        ),
      );
    var cx = (k * rx * y) / ry + (x1 + x2) / 2;
    var cy = (k * -ry * x) / rx + (y1 + y2) / 2;
    var f1 = Math.asin(Number(((y1 - cy) / ry).toFixed(9)));
    var f2 = Math.asin(Number(((y2 - cy) / ry).toFixed(9)));

    f1 = x1 < cx ? Math.PI - f1 : f1;
    f2 = x2 < cx ? Math.PI - f2 : f2;
    f1 < 0 && (f1 = Math.PI * 2 + f1);
    f2 < 0 && (f2 = Math.PI * 2 + f2);
    if (sweep_flag && f1 > f2) {
      f1 = f1 - Math.PI * 2;
    }
    if (!sweep_flag && f2 > f1) {
      f2 = f2 - Math.PI * 2;
    }
  } else {
    f1 = recursive[0];
    f2 = recursive[1];
    cx = recursive[2];
    cy = recursive[3];
  }
  var df = f2 - f1;
  if (Math.abs(df) > _120) {
    var f2old = f2,
      x2old = x2,
      y2old = y2;
    f2 = f1 + _120 * (sweep_flag && f2 > f1 ? 1 : -1);
    x2 = cx + rx * Math.cos(f2);
    y2 = cy + ry * Math.sin(f2);
    res = a2c(x2, y2, rx, ry, angle, 0, sweep_flag, x2old, y2old, [
      f2,
      f2old,
      cx,
      cy,
    ]);
  }
  df = f2 - f1;
  var c1 = Math.cos(f1),
    s1 = Math.sin(f1),
    c2 = Math.cos(f2),
    s2 = Math.sin(f2),
    t = Math.tan(df / 4),
    hx = (4 / 3) * rx * t,
    hy = (4 / 3) * ry * t,
    m = [
      -hx * s1,
      hy * c1,
      x2 + hx * s2 - x1,
      y2 - hy * c2 - y1,
      x2 - x1,
      y2 - y1,
    ];
  if (recursive) {
    return m.concat(res);
  } else {
    res = m.concat(res);
    var newres = [];
    for (var i = 0, n = res.length; i < n; i++) {
      newres[i] =
        i % 2
          ? rotateY(res[i - 1], res[i], rad)
          : rotateX(res[i], res[i + 1], rad);
    }
    return newres;
  }
};

var applyTransforms$2 = {};

var _transforms = {};

const { toFixed: toFixed$2 } = tools;

/**
 * @typedef {{ name: string, data: number[] }} TransformItem
 * @typedef {{
 *   convertToShorts: boolean,
 *   floatPrecision: number,
 *   transformPrecision: number,
 *   matrixToTransform: boolean,
 *   shortTranslate: boolean,
 *   shortScale: boolean,
 *   shortRotate: boolean,
 *   removeUseless: boolean,
 *   collapseIntoOne: boolean,
 *   leadingZero: boolean,
 *   negativeExtraSpace: boolean,
 * }} TransformParams
 */

const transformTypes = new Set([
  "matrix",
  "rotate",
  "scale",
  "skewX",
  "skewY",
  "translate",
]);

const regTransformSplit =
  /\s*(matrix|translate|scale|rotate|skewX|skewY)\s*\(\s*(.+?)\s*\)[\s,]*/;
const regNumericValues$2 = /[-+]?(?:\d*\.\d+|\d+\.?)(?:[eE][-+]?\d+)?/g;

/**
 * Convert transform string to JS representation.
 *
 * @param {string} transformString
 * @returns {TransformItem[]} Object representation of transform, or an empty array if it was malformed.
 */
_transforms.transform2js = (transformString) => {
  /** @type {TransformItem[]} */
  const transforms = [];
  /** @type {?TransformItem} */
  let currentTransform = null;

  // split value into ['', 'translate', '10 50', '', 'scale', '2', '', 'rotate', '-45', '']
  for (const item of transformString.split(regTransformSplit)) {
    if (!item) {
      continue;
    }

    if (transformTypes.has(item)) {
      currentTransform = { name: item, data: [] };
      transforms.push(currentTransform);
    } else {
      let num;
      // then split it into [10, 50] and collect as context.data
      while ((num = regNumericValues$2.exec(item))) {
        num = Number(num);
        if (currentTransform != null) {
          currentTransform.data.push(num);
        }
      }
    }
  }

  return currentTransform == null || currentTransform.data.length == 0
    ? []
    : transforms;
};

/**
 * Multiply transforms into one.
 *
 * @param {TransformItem[]} transforms
 * @returns {TransformItem}
 */
_transforms.transformsMultiply = (transforms) => {
  const matrixData = transforms.map((transform) => {
    if (transform.name === "matrix") {
      return transform.data;
    }
    return transformToMatrix(transform);
  });

  const matrixTransform = {
    name: "matrix",
    data:
      matrixData.length > 0 ? matrixData.reduce(multiplyTransformMatrices) : [],
  };

  return matrixTransform;
};

/**
 * Math utilities in radians.
 */
const mth = {
  /**
   * @param {number} deg
   * @returns {number}
   */
  rad: (deg) => {
    return (deg * Math.PI) / 180;
  },

  /**
   * @param {number} rad
   * @returns {number}
   */
  deg: (rad) => {
    return (rad * 180) / Math.PI;
  },

  /**
   * @param {number} deg
   * @returns {number}
   */
  cos: (deg) => {
    return Math.cos(mth.rad(deg));
  },

  /**
   * @param {number} val
   * @param {number} floatPrecision
   * @returns {number}
   */
  acos: (val, floatPrecision) => {
    return toFixed$2(mth.deg(Math.acos(val)), floatPrecision);
  },

  /**
   * @param {number} deg
   * @returns {number}
   */
  sin: (deg) => {
    return Math.sin(mth.rad(deg));
  },

  /**
   * @param {number} val
   * @param {number} floatPrecision
   * @returns {number}
   */
  asin: (val, floatPrecision) => {
    return toFixed$2(mth.deg(Math.asin(val)), floatPrecision);
  },

  /**
   * @param {number} deg
   * @returns {number}
   */
  tan: (deg) => {
    return Math.tan(mth.rad(deg));
  },

  /**
   * @param {number} val
   * @param {number} floatPrecision
   * @returns {number}
   */
  atan: (val, floatPrecision) => {
    return toFixed$2(mth.deg(Math.atan(val)), floatPrecision);
  },
};

/**
 * Decompose matrix into simple transforms.
 *
 * @param {TransformItem} transform
 * @param {TransformParams} params
 * @returns {TransformItem[]}
 * @see https://frederic-wang.fr/decomposition-of-2d-transform-matrices.html
 */
_transforms.matrixToTransform = (transform, params) => {
  const floatPrecision = params.floatPrecision;
  const data = transform.data;
  const transforms = [];

  // [..., ..., ..., ..., tx, ty]  translate(tx, ty)
  if (data[4] || data[5]) {
    transforms.push({
      name: "translate",
      data: data.slice(4, data[5] ? 6 : 5),
    });
  }

  let sx = toFixed$2(Math.hypot(data[0], data[1]), params.transformPrecision);
  let sy = toFixed$2(
    (data[0] * data[3] - data[1] * data[2]) / sx,
    params.transformPrecision,
  );
  const colsSum = data[0] * data[2] + data[1] * data[3];
  const rowsSum = data[0] * data[1] + data[2] * data[3];
  const scaleBefore = rowsSum !== 0 || sx === sy;

  // [sx, 0, tan(a)sy, sy, 0, 0]  skewX(a)scale(sx, sy)
  if (!data[1] && data[2]) {
    transforms.push({
      name: "skewX",
      data: [mth.atan(data[2] / sy, floatPrecision)],
    });

    // [sx, sxtan(a), 0, sy, 0, 0]  skewY(a)scale(sx, sy)
  } else if (data[1] && !data[2]) {
    transforms.push({
      name: "skewY",
      data: [mth.atan(data[1] / data[0], floatPrecision)],
    });
    sx = data[0];
    sy = data[3];

    // [sxcos(a), sxsin(a), sy-sin(a), sycos(a), x, y]  rotate(a[, cx, cy])(scale or skewX) or
    // [sxcos(a), sysin(a), sx-sin(a), sycos(a), x, y]  scale(sx, sy)rotate(a[, cx, cy]) (if !scaleBefore)
  } else if (!colsSum || (sx === 1 && sy === 1) || !scaleBefore) {
    if (!scaleBefore) {
      sx = Math.hypot(data[0], data[2]);
      sy = Math.hypot(data[1], data[3]);

      if (toFixed$2(data[0], params.transformPrecision) < 0) {
        sx = -sx;
      }

      if (
        data[3] < 0 ||
        (Math.sign(data[1]) === Math.sign(data[2]) &&
          toFixed$2(data[3], params.transformPrecision) === 0)
      ) {
        sy = -sy;
      }

      transforms.push({ name: "scale", data: [sx, sy] });
    }
    const angle = Math.min(Math.max(-1, data[0] / sx), 1);
    const rotate = [
      mth.acos(angle, floatPrecision) *
        ((scaleBefore ? 1 : sy) * data[1] < 0 ? -1 : 1),
    ];

    if (rotate[0]) {
      transforms.push({ name: "rotate", data: rotate });
    }

    if (rowsSum && colsSum)
      transforms.push({
        name: "skewX",
        data: [mth.atan(colsSum / (sx * sx), floatPrecision)],
      });

    // rotate(a, cx, cy) can consume translate() within optional arguments cx, cy (rotation point)
    if (rotate[0] && (data[4] || data[5])) {
      transforms.shift();
      const oneOverCos = 1 - data[0] / sx;
      const sin = data[1] / (scaleBefore ? sx : sy);
      const x = data[4] * (scaleBefore ? 1 : sy);
      const y = data[5] * (scaleBefore ? 1 : sx);
      const denom = (oneOverCos ** 2 + sin ** 2) * (scaleBefore ? 1 : sx * sy);
      rotate.push(
        (oneOverCos * x - sin * y) / denom,
        (oneOverCos * y + sin * x) / denom,
      );
    }

    // Too many transformations, return original matrix if it isn't just a scale/translate
  } else if (data[1] || data[2]) {
    return [transform];
  }

  if ((scaleBefore && (sx != 1 || sy != 1)) || !transforms.length) {
    transforms.push({
      name: "scale",
      data: sx == sy ? [sx] : [sx, sy],
    });
  }

  return transforms;
};

/**
 * Convert transform to the matrix data.
 *
 * @type {(transform: TransformItem) => number[] }
 */
const transformToMatrix = (transform) => {
  if (transform.name === "matrix") {
    return transform.data;
  }
  switch (transform.name) {
    case "translate":
      // [1, 0, 0, 1, tx, ty]
      return [1, 0, 0, 1, transform.data[0], transform.data[1] || 0];
    case "scale":
      // [sx, 0, 0, sy, 0, 0]
      return [
        transform.data[0],
        0,
        0,
        transform.data[1] || transform.data[0],
        0,
        0,
      ];
    case "rotate":
      // [cos(a), sin(a), -sin(a), cos(a), x, y]
      var cos = mth.cos(transform.data[0]),
        sin = mth.sin(transform.data[0]),
        cx = transform.data[1] || 0,
        cy = transform.data[2] || 0;
      return [
        cos,
        sin,
        -sin,
        cos,
        (1 - cos) * cx + sin * cy,
        (1 - cos) * cy - sin * cx,
      ];
    case "skewX":
      // [1, 0, tan(a), 1, 0, 0]
      return [1, 0, mth.tan(transform.data[0]), 1, 0, 0];
    case "skewY":
      // [1, tan(a), 0, 1, 0, 0]
      return [1, mth.tan(transform.data[0]), 0, 1, 0, 0];
    default:
      throw Error(`Unknown transform ${transform.name}`);
  }
};

/**
 * Applies transformation to an arc. To do so, we represent ellipse as a matrix, multiply it
 * by the transformation matrix and use a singular value decomposition to represent in a form
 * rotate()scale(a b)rotate(). This gives us new ellipse params a, b and .
 * SVD is being done with the formulae provided by Wolffram|Alpha (svd {{m0, m2}, {m1, m3}})
 *
 * @type {(
 *   cursor: [x: number, y: number],
 *   arc: number[],
 *   transform: number[]
 * ) => number[]}
 */
_transforms.transformArc = (cursor, arc, transform) => {
  const x = arc[5] - cursor[0];
  const y = arc[6] - cursor[1];
  let a = arc[0];
  let b = arc[1];
  const rot = (arc[2] * Math.PI) / 180;
  const cos = Math.cos(rot);
  const sin = Math.sin(rot);
  // skip if radius is 0
  if (a > 0 && b > 0) {
    let h =
      Math.pow(x * cos + y * sin, 2) / (4 * a * a) +
      Math.pow(y * cos - x * sin, 2) / (4 * b * b);
    if (h > 1) {
      h = Math.sqrt(h);
      a *= h;
      b *= h;
    }
  }
  const ellipse = [a * cos, a * sin, -b * sin, b * cos, 0, 0];
  const m = multiplyTransformMatrices(transform, ellipse);
  // Decompose the new ellipse matrix
  const lastCol = m[2] * m[2] + m[3] * m[3];
  const squareSum = m[0] * m[0] + m[1] * m[1] + lastCol;
  const root =
    Math.hypot(m[0] - m[3], m[1] + m[2]) * Math.hypot(m[0] + m[3], m[1] - m[2]);

  if (!root) {
    // circle
    arc[0] = arc[1] = Math.sqrt(squareSum / 2);
    arc[2] = 0;
  } else {
    const majorAxisSqr = (squareSum + root) / 2;
    const minorAxisSqr = (squareSum - root) / 2;
    const major = Math.abs(majorAxisSqr - lastCol) > 1e-6;
    const sub = (major ? majorAxisSqr : minorAxisSqr) - lastCol;
    const rowsSum = m[0] * m[2] + m[1] * m[3];
    const term1 = m[0] * sub + m[2] * rowsSum;
    const term2 = m[1] * sub + m[3] * rowsSum;
    arc[0] = Math.sqrt(majorAxisSqr);
    arc[1] = Math.sqrt(minorAxisSqr);
    arc[2] =
      (((major ? term2 < 0 : term1 > 0) ? -1 : 1) *
        Math.acos((major ? term1 : term2) / Math.hypot(term1, term2)) *
        180) /
      Math.PI;
  }

  if (transform[0] < 0 !== transform[3] < 0) {
    // Flip the sweep flag if coordinates are being flipped horizontally XOR vertically
    arc[4] = 1 - arc[4];
  }

  return arc;
};

/**
 * Multiply transformation matrices.
 *
 * @type {(a: number[], b: number[]) => number[]}
 */
const multiplyTransformMatrices = (a, b) => {
  return [
    a[0] * b[0] + a[2] * b[1],
    a[1] * b[0] + a[3] * b[1],
    a[0] * b[2] + a[2] * b[3],
    a[1] * b[2] + a[3] * b[3],
    a[0] * b[4] + a[2] * b[5] + a[4],
    a[1] * b[4] + a[3] * b[5] + a[5],
  ];
};

/**
 * @typedef {import('../lib/types').PathDataItem} PathDataItem
 * @typedef {import('../lib/types').XastElement} XastElement
 */

const { collectStylesheet: collectStylesheet$4, computeStyle: computeStyle$3 } =
  style;
const {
  transformsMultiply: transformsMultiply$1,
  transform2js: transform2js$1,
  transformArc,
} = _transforms;
const { path2js: path2js$2 } = _path$1;
const { removeLeadingZero: removeLeadingZero$1, includesUrlReference } = tools;
const {
  referencesProps: referencesProps$1,
  attrsGroupsDefaults: attrsGroupsDefaults$1,
} = _collections;

/**
 * @typedef {PathDataItem[]} PathData
 * @typedef {number[]} Matrix
 */

const regNumericValues$1 = /[-+]?(\d*\.\d+|\d+\.?)(?:[eE][-+]?\d+)?/g;

/**
 * Apply transformation(s) to the Path data.
 *
 * @type {import('../lib/types').Plugin<{
 *   transformPrecision: number,
 *   applyTransformsStroked: boolean,
 * }>}
 */
const applyTransforms$1 = (root, params) => {
  const stylesheet = collectStylesheet$4(root);
  return {
    element: {
      enter: (node) => {
        if (node.attributes.d == null) {
          return;
        }

        // stroke and stroke-width can be redefined with <use>
        if (node.attributes.id != null) {
          return;
        }

        // if there are no 'stroke' attr and references to other objects such as
        // gradients or clip-path which are also subjects to transform.
        if (
          node.attributes.transform == null ||
          node.attributes.transform === "" ||
          // styles are not considered when applying transform
          // can be fixed properly with new style engine
          node.attributes.style != null ||
          Object.entries(node.attributes).some(
            ([name, value]) =>
              referencesProps$1.has(name) && includesUrlReference(value),
          )
        ) {
          return;
        }

        const computedStyle = computeStyle$3(stylesheet, node);
        const transformStyle = computedStyle.transform;

        // Transform overridden in <style> tag which is not considered
        if (
          transformStyle.type === "static" &&
          transformStyle.value !== node.attributes.transform
        ) {
          return;
        }

        const matrix = transformsMultiply$1(
          transform2js$1(node.attributes.transform),
        );

        const stroke =
          computedStyle.stroke?.type === "static"
            ? computedStyle.stroke.value
            : null;

        const strokeWidth =
          computedStyle["stroke-width"]?.type === "static"
            ? computedStyle["stroke-width"].value
            : null;
        const transformPrecision = params.transformPrecision;

        if (
          computedStyle.stroke?.type === "dynamic" ||
          computedStyle["stroke-width"]?.type === "dynamic"
        ) {
          return;
        }

        const scale = Number(
          Math.sqrt(
            matrix.data[0] * matrix.data[0] + matrix.data[1] * matrix.data[1],
          ).toFixed(transformPrecision),
        );

        if (stroke && stroke != "none") {
          if (!params.applyTransformsStroked) {
            return;
          }

          // stroke cannot be transformed with different vertical and horizontal scale or skew
          if (
            (matrix.data[0] !== matrix.data[3] ||
              matrix.data[1] !== -matrix.data[2]) &&
            (matrix.data[0] !== -matrix.data[3] ||
              matrix.data[1] !== matrix.data[2])
          ) {
            return;
          }

          // apply transform to stroke-width, stroke-dashoffset and stroke-dasharray
          if (scale !== 1) {
            if (node.attributes["vector-effect"] !== "non-scaling-stroke") {
              node.attributes["stroke-width"] = (
                strokeWidth ||
                attrsGroupsDefaults$1.presentation["stroke-width"]
              )
                .trim()
                .replace(regNumericValues$1, (num) =>
                  removeLeadingZero$1(Number(num) * scale),
                );

              if (node.attributes["stroke-dashoffset"] != null) {
                node.attributes["stroke-dashoffset"] = node.attributes[
                  "stroke-dashoffset"
                ]
                  .trim()
                  .replace(regNumericValues$1, (num) =>
                    removeLeadingZero$1(Number(num) * scale),
                  );
              }

              if (node.attributes["stroke-dasharray"] != null) {
                node.attributes["stroke-dasharray"] = node.attributes[
                  "stroke-dasharray"
                ]
                  .trim()
                  .replace(regNumericValues$1, (num) =>
                    removeLeadingZero$1(Number(num) * scale),
                  );
              }
            }
          }
        }

        const pathData = path2js$2(node);
        applyMatrixToPathData(pathData, matrix.data);

        // remove transform attr
        delete node.attributes.transform;
      },
    },
  };
};
applyTransforms$2.applyTransforms = applyTransforms$1;

/**
 * @type {(matrix: Matrix, x: number, y: number) => [number, number]}
 */
const transformAbsolutePoint = (matrix, x, y) => {
  const newX = matrix[0] * x + matrix[2] * y + matrix[4];
  const newY = matrix[1] * x + matrix[3] * y + matrix[5];
  return [newX, newY];
};

/**
 * @type {(matrix: Matrix, x: number, y: number) => [number, number]}
 */
const transformRelativePoint = (matrix, x, y) => {
  const newX = matrix[0] * x + matrix[2] * y;
  const newY = matrix[1] * x + matrix[3] * y;
  return [newX, newY];
};

/**
 * @type {(pathData: PathData, matrix: Matrix) => void}
 */
const applyMatrixToPathData = (pathData, matrix) => {
  /**
   * @type {[number, number]}
   */
  const start = [0, 0];
  /**
   * @type {[number, number]}
   */
  const cursor = [0, 0];

  for (const pathItem of pathData) {
    let { command, args } = pathItem;

    // moveto (x y)
    if (command === "M") {
      cursor[0] = args[0];
      cursor[1] = args[1];
      start[0] = cursor[0];
      start[1] = cursor[1];
      const [x, y] = transformAbsolutePoint(matrix, args[0], args[1]);
      args[0] = x;
      args[1] = y;
    }
    if (command === "m") {
      cursor[0] += args[0];
      cursor[1] += args[1];
      start[0] = cursor[0];
      start[1] = cursor[1];
      const [x, y] = transformRelativePoint(matrix, args[0], args[1]);
      args[0] = x;
      args[1] = y;
    }

    // horizontal lineto (x)
    // convert to lineto to handle two-dimentional transforms
    if (command === "H") {
      command = "L";
      args = [args[0], cursor[1]];
    }
    if (command === "h") {
      command = "l";
      args = [args[0], 0];
    }

    // vertical lineto (y)
    // convert to lineto to handle two-dimentional transforms
    if (command === "V") {
      command = "L";
      args = [cursor[0], args[0]];
    }
    if (command === "v") {
      command = "l";
      args = [0, args[0]];
    }

    // lineto (x y)
    if (command === "L") {
      cursor[0] = args[0];
      cursor[1] = args[1];
      const [x, y] = transformAbsolutePoint(matrix, args[0], args[1]);
      args[0] = x;
      args[1] = y;
    }
    if (command === "l") {
      cursor[0] += args[0];
      cursor[1] += args[1];
      const [x, y] = transformRelativePoint(matrix, args[0], args[1]);
      args[0] = x;
      args[1] = y;
    }

    // curveto (x1 y1 x2 y2 x y)
    if (command === "C") {
      cursor[0] = args[4];
      cursor[1] = args[5];
      const [x1, y1] = transformAbsolutePoint(matrix, args[0], args[1]);
      const [x2, y2] = transformAbsolutePoint(matrix, args[2], args[3]);
      const [x, y] = transformAbsolutePoint(matrix, args[4], args[5]);
      args[0] = x1;
      args[1] = y1;
      args[2] = x2;
      args[3] = y2;
      args[4] = x;
      args[5] = y;
    }
    if (command === "c") {
      cursor[0] += args[4];
      cursor[1] += args[5];
      const [x1, y1] = transformRelativePoint(matrix, args[0], args[1]);
      const [x2, y2] = transformRelativePoint(matrix, args[2], args[3]);
      const [x, y] = transformRelativePoint(matrix, args[4], args[5]);
      args[0] = x1;
      args[1] = y1;
      args[2] = x2;
      args[3] = y2;
      args[4] = x;
      args[5] = y;
    }

    // smooth curveto (x2 y2 x y)
    if (command === "S") {
      cursor[0] = args[2];
      cursor[1] = args[3];
      const [x2, y2] = transformAbsolutePoint(matrix, args[0], args[1]);
      const [x, y] = transformAbsolutePoint(matrix, args[2], args[3]);
      args[0] = x2;
      args[1] = y2;
      args[2] = x;
      args[3] = y;
    }
    if (command === "s") {
      cursor[0] += args[2];
      cursor[1] += args[3];
      const [x2, y2] = transformRelativePoint(matrix, args[0], args[1]);
      const [x, y] = transformRelativePoint(matrix, args[2], args[3]);
      args[0] = x2;
      args[1] = y2;
      args[2] = x;
      args[3] = y;
    }

    // quadratic Bzier curveto (x1 y1 x y)
    if (command === "Q") {
      cursor[0] = args[2];
      cursor[1] = args[3];
      const [x1, y1] = transformAbsolutePoint(matrix, args[0], args[1]);
      const [x, y] = transformAbsolutePoint(matrix, args[2], args[3]);
      args[0] = x1;
      args[1] = y1;
      args[2] = x;
      args[3] = y;
    }
    if (command === "q") {
      cursor[0] += args[2];
      cursor[1] += args[3];
      const [x1, y1] = transformRelativePoint(matrix, args[0], args[1]);
      const [x, y] = transformRelativePoint(matrix, args[2], args[3]);
      args[0] = x1;
      args[1] = y1;
      args[2] = x;
      args[3] = y;
    }

    // smooth quadratic Bzier curveto (x y)
    if (command === "T") {
      cursor[0] = args[0];
      cursor[1] = args[1];
      const [x, y] = transformAbsolutePoint(matrix, args[0], args[1]);
      args[0] = x;
      args[1] = y;
    }
    if (command === "t") {
      cursor[0] += args[0];
      cursor[1] += args[1];
      const [x, y] = transformRelativePoint(matrix, args[0], args[1]);
      args[0] = x;
      args[1] = y;
    }

    // elliptical arc (rx ry x-axis-rotation large-arc-flag sweep-flag x y)
    if (command === "A") {
      transformArc(cursor, args, matrix);
      cursor[0] = args[5];
      cursor[1] = args[6];
      // reduce number of digits in rotation angle
      if (Math.abs(args[2]) > 80) {
        const a = args[0];
        const rotation = args[2];
        args[0] = args[1];
        args[1] = a;
        args[2] = rotation + (rotation > 0 ? -90 : 90);
      }
      const [x, y] = transformAbsolutePoint(matrix, args[5], args[6]);
      args[5] = x;
      args[6] = y;
    }
    if (command === "a") {
      transformArc([0, 0], args, matrix);
      cursor[0] += args[5];
      cursor[1] += args[6];
      // reduce number of digits in rotation angle
      if (Math.abs(args[2]) > 80) {
        const a = args[0];
        const rotation = args[2];
        args[0] = args[1];
        args[1] = a;
        args[2] = rotation + (rotation > 0 ? -90 : 90);
      }
      const [x, y] = transformRelativePoint(matrix, args[5], args[6]);
      args[5] = x;
      args[6] = y;
    }

    // closepath
    if (command === "z" || command === "Z") {
      cursor[0] = start[0];
      cursor[1] = start[1];
    }

    pathItem.command = command;
    pathItem.args = args;
  }
};

/**
 * @typedef {import('../lib//types').PathDataItem} PathDataItem
 */

const { collectStylesheet: collectStylesheet$3, computeStyle: computeStyle$2 } =
  style;
const { visit } = xast;
const { pathElems } = _collections;
const { path2js: path2js$1, js2path: js2path$1 } = _path$1;
const { applyTransforms } = applyTransforms$2;
const { cleanupOutData: cleanupOutData$1, toFixed: toFixed$1 } = tools;

convertPathData$1.name = "convertPathData";
convertPathData$1.description =
  "optimizes path data: writes in shorter form, applies transformations";

/** @type {(data: number[]) => number[]} */
let roundData;
/** @type {number | false} */
let precision;
/** @type {number} */
let error;
/** @type {number} */
let arcThreshold;
/** @type {number} */
let arcTolerance;

/**
 * @typedef {{
 *   applyTransforms: boolean,
 *   applyTransformsStroked: boolean,
 *   makeArcs: {
 *     threshold: number,
 *     tolerance: number,
 *   },
 *   straightCurves: boolean,
 *   convertToQ: boolean,
 *   lineShorthands: boolean,
 *   convertToZ: boolean,
 *   curveSmoothShorthands: boolean,
 *   floatPrecision: number | false,
 *   transformPrecision: number,
 *   smartArcRounding: boolean,
 *   removeUseless: boolean,
 *   collapseRepeated: boolean,
 *   utilizeAbsolute: boolean,
 *   leadingZero: boolean,
 *   negativeExtraSpace: boolean,
 *   noSpaceAfterFlags: boolean,
 *   forceAbsolutePath: boolean,
 * }} InternalParams
 */

/**
 * @typedef {[number, number]} Point
 */

/**
 * @typedef {{
 *   center: Point,
 *   radius: number
 * }} Circle
 */

/**
 * Convert absolute Path to relative,
 * collapse repeated instructions,
 * detect and convert Lineto shorthands,
 * remove useless instructions like "l0,0",
 * trim useless delimiters and leading zeros,
 * decrease accuracy of floating-point numbers.
 *
 * @see https://www.w3.org/TR/SVG11/paths.html#PathData
 *
 * @author Kir Belevich
 *
 * @type {import('./plugins-types').Plugin<'convertPathData'>}
 */
convertPathData$1.fn = (root, params) => {
  const {
    // TODO convert to separate plugin in v3
    applyTransforms: _applyTransforms = true,
    applyTransformsStroked = true,
    makeArcs = {
      threshold: 2.5, // coefficient of rounding error
      tolerance: 0.5, // percentage of radius
    },
    straightCurves = true,
    convertToQ = true,
    lineShorthands = true,
    convertToZ = true,
    curveSmoothShorthands = true,
    floatPrecision = 3,
    transformPrecision = 5,
    smartArcRounding = true,
    removeUseless = true,
    collapseRepeated = true,
    utilizeAbsolute = true,
    leadingZero = true,
    negativeExtraSpace = true,
    noSpaceAfterFlags = false, // a20 60 45 0 1 30 20  a20 60 45 0130 20
    forceAbsolutePath = false,
  } = params;

  /**
   * @type {InternalParams}
   */
  const newParams = {
    applyTransforms: _applyTransforms,
    applyTransformsStroked,
    makeArcs,
    straightCurves,
    convertToQ,
    lineShorthands,
    convertToZ,
    curveSmoothShorthands,
    floatPrecision,
    transformPrecision,
    smartArcRounding,
    removeUseless,
    collapseRepeated,
    utilizeAbsolute,
    leadingZero,
    negativeExtraSpace,
    noSpaceAfterFlags,
    forceAbsolutePath,
  };

  // invoke applyTransforms plugin
  if (_applyTransforms) {
    visit(
      root,
      // @ts-ignore
      applyTransforms(root, {
        transformPrecision,
        applyTransformsStroked,
      }),
    );
  }

  const stylesheet = collectStylesheet$3(root);
  return {
    element: {
      enter: (node) => {
        if (pathElems.has(node.name) && node.attributes.d != null) {
          const computedStyle = computeStyle$2(stylesheet, node);
          precision = floatPrecision;
          error =
            precision !== false
              ? +Math.pow(0.1, precision).toFixed(precision)
              : 1e-2;
          roundData =
            precision && precision > 0 && precision < 20
              ? strongRound
              : round$1;
          if (makeArcs) {
            arcThreshold = makeArcs.threshold;
            arcTolerance = makeArcs.tolerance;
          }
          const hasMarkerMid = computedStyle["marker-mid"] != null;

          const maybeHasStroke =
            computedStyle.stroke &&
            (computedStyle.stroke.type === "dynamic" ||
              computedStyle.stroke.value !== "none");
          const maybeHasLinecap =
            computedStyle["stroke-linecap"] &&
            (computedStyle["stroke-linecap"].type === "dynamic" ||
              computedStyle["stroke-linecap"].value !== "butt");
          const maybeHasStrokeAndLinecap = maybeHasStroke && maybeHasLinecap;
          const isSafeToUseZ = maybeHasStroke
            ? computedStyle["stroke-linecap"]?.type === "static" &&
              computedStyle["stroke-linecap"].value === "round" &&
              computedStyle["stroke-linejoin"]?.type === "static" &&
              computedStyle["stroke-linejoin"].value === "round"
            : true;

          var data = path2js$1(node);

          // TODO: get rid of functions returns
          if (data.length) {
            convertToRelative(data);

            data = filters(data, newParams, {
              isSafeToUseZ,
              maybeHasStrokeAndLinecap,
              hasMarkerMid,
            });

            if (utilizeAbsolute) {
              data = convertToMixed(data, newParams);
            }

            // @ts-ignore
            js2path$1(node, data, newParams);
          }
        }
      },
    },
  };
};

/**
 * Convert absolute path data coordinates to relative.
 *
 * @type {(pathData: PathDataItem[]) => PathDataItem[]}
 */
const convertToRelative = (pathData) => {
  let start = [0, 0];
  let cursor = [0, 0];
  let prevCoords = [0, 0];

  for (let i = 0; i < pathData.length; i += 1) {
    const pathItem = pathData[i];
    let { command, args } = pathItem;

    // moveto (x y)
    if (command === "m") {
      // update start and cursor
      cursor[0] += args[0];
      cursor[1] += args[1];
      start[0] = cursor[0];
      start[1] = cursor[1];
    }
    if (command === "M") {
      // M  m
      // skip first moveto
      if (i !== 0) {
        command = "m";
      }
      args[0] -= cursor[0];
      args[1] -= cursor[1];
      // update start and cursor
      cursor[0] += args[0];
      cursor[1] += args[1];
      start[0] = cursor[0];
      start[1] = cursor[1];
    }

    // lineto (x y)
    if (command === "l") {
      cursor[0] += args[0];
      cursor[1] += args[1];
    }
    if (command === "L") {
      // L  l
      command = "l";
      args[0] -= cursor[0];
      args[1] -= cursor[1];
      cursor[0] += args[0];
      cursor[1] += args[1];
    }

    // horizontal lineto (x)
    if (command === "h") {
      cursor[0] += args[0];
    }
    if (command === "H") {
      // H  h
      command = "h";
      args[0] -= cursor[0];
      cursor[0] += args[0];
    }

    // vertical lineto (y)
    if (command === "v") {
      cursor[1] += args[0];
    }
    if (command === "V") {
      // V  v
      command = "v";
      args[0] -= cursor[1];
      cursor[1] += args[0];
    }

    // curveto (x1 y1 x2 y2 x y)
    if (command === "c") {
      cursor[0] += args[4];
      cursor[1] += args[5];
    }
    if (command === "C") {
      // C  c
      command = "c";
      args[0] -= cursor[0];
      args[1] -= cursor[1];
      args[2] -= cursor[0];
      args[3] -= cursor[1];
      args[4] -= cursor[0];
      args[5] -= cursor[1];
      cursor[0] += args[4];
      cursor[1] += args[5];
    }

    // smooth curveto (x2 y2 x y)
    if (command === "s") {
      cursor[0] += args[2];
      cursor[1] += args[3];
    }
    if (command === "S") {
      // S  s
      command = "s";
      args[0] -= cursor[0];
      args[1] -= cursor[1];
      args[2] -= cursor[0];
      args[3] -= cursor[1];
      cursor[0] += args[2];
      cursor[1] += args[3];
    }

    // quadratic Bzier curveto (x1 y1 x y)
    if (command === "q") {
      cursor[0] += args[2];
      cursor[1] += args[3];
    }
    if (command === "Q") {
      // Q  q
      command = "q";
      args[0] -= cursor[0];
      args[1] -= cursor[1];
      args[2] -= cursor[0];
      args[3] -= cursor[1];
      cursor[0] += args[2];
      cursor[1] += args[3];
    }

    // smooth quadratic Bzier curveto (x y)
    if (command === "t") {
      cursor[0] += args[0];
      cursor[1] += args[1];
    }
    if (command === "T") {
      // T  t
      command = "t";
      args[0] -= cursor[0];
      args[1] -= cursor[1];
      cursor[0] += args[0];
      cursor[1] += args[1];
    }

    // elliptical arc (rx ry x-axis-rotation large-arc-flag sweep-flag x y)
    if (command === "a") {
      cursor[0] += args[5];
      cursor[1] += args[6];
    }
    if (command === "A") {
      // A  a
      command = "a";
      args[5] -= cursor[0];
      args[6] -= cursor[1];
      cursor[0] += args[5];
      cursor[1] += args[6];
    }

    // closepath
    if (command === "Z" || command === "z") {
      // reset cursor
      cursor[0] = start[0];
      cursor[1] = start[1];
    }

    pathItem.command = command;
    pathItem.args = args;
    // store absolute coordinates for later use
    // base should preserve reference from other element
    // @ts-ignore
    pathItem.base = prevCoords;
    // @ts-ignore
    pathItem.coords = [cursor[0], cursor[1]];
    // @ts-ignore
    prevCoords = pathItem.coords;
  }

  return pathData;
};

/**
 * Main filters loop.
 *
 * @type {(
 *   path: PathDataItem[],
 *   params: InternalParams,
 *   aux: { isSafeToUseZ: boolean, maybeHasStrokeAndLinecap: boolean, hasMarkerMid: boolean }
 * ) => PathDataItem[]}
 */
function filters(
  path,
  params,
  { isSafeToUseZ, maybeHasStrokeAndLinecap, hasMarkerMid },
) {
  const stringify = data2Path.bind(null, params);
  const relSubpoint = [0, 0];
  const pathBase = [0, 0];
  /** @type {any} */
  let prev = {};
  /** @type {Point | undefined} */
  let prevQControlPoint;

  path = path.filter(function (item, index, path) {
    const qControlPoint = prevQControlPoint;
    prevQControlPoint = undefined;

    let command = item.command;
    let data = item.args;
    let next = path[index + 1];

    if (command !== "Z" && command !== "z") {
      var sdata = data,
        circle;

      if (command === "s") {
        sdata = [0, 0].concat(data);

        const pdata = prev.args;
        const n = pdata.length;

        // (-x, -y) of the prev tangent point relative to the current point
        sdata[0] = pdata[n - 2] - pdata[n - 4];
        sdata[1] = pdata[n - 1] - pdata[n - 3];
      }

      // convert curves to arcs if possible
      if (
        params.makeArcs &&
        (command == "c" || command == "s") &&
        isConvex(sdata) &&
        (circle = findCircle(sdata))
      ) {
        var r = roundData([circle.radius])[0],
          angle = findArcAngle(sdata, circle),
          sweep = sdata[5] * sdata[0] - sdata[4] * sdata[1] > 0 ? 1 : 0,
          /**
           * @type {PathDataItem}
           */
          arc = {
            command: "a",
            args: [r, r, 0, 0, sweep, sdata[4], sdata[5]],
            // @ts-ignore
            coords: item.coords.slice(),
            // @ts-ignore
            base: item.base,
          },
          /**
           * @type {PathDataItem[]}
           */
          output = [arc],
          // relative coordinates to adjust the found circle
          /**
           * @type {Point}
           */
          relCenter = [
            circle.center[0] - sdata[4],
            circle.center[1] - sdata[5],
          ],
          relCircle = { center: relCenter, radius: circle.radius },
          arcCurves = [item],
          hasPrev = 0,
          suffix = "",
          nextLonghand;

        if (
          (prev.command == "c" &&
            isConvex(prev.args) &&
            isArcPrev(prev.args, circle)) ||
          (prev.command == "a" && prev.sdata && isArcPrev(prev.sdata, circle))
        ) {
          arcCurves.unshift(prev);
          // @ts-ignore
          arc.base = prev.base;
          // @ts-ignore
          arc.args[5] = arc.coords[0] - arc.base[0];
          // @ts-ignore
          arc.args[6] = arc.coords[1] - arc.base[1];
          var prevData = prev.command == "a" ? prev.sdata : prev.args;
          var prevAngle = findArcAngle(prevData, {
            center: [
              prevData[4] + circle.center[0],
              prevData[5] + circle.center[1],
            ],
            radius: circle.radius,
          });
          angle += prevAngle;
          if (angle > Math.PI) arc.args[3] = 1;
          hasPrev = 1;
        }

        // check if next curves are fitting the arc
        for (
          var j = index;
          (next = path[++j]) && (next.command === "c" || next.command === "s");

        ) {
          var nextData = next.args;
          if (next.command == "s") {
            nextLonghand = makeLonghand(
              { command: "s", args: next.args.slice() },
              path[j - 1].args,
            );
            nextData = nextLonghand.args;
            nextLonghand.args = nextData.slice(0, 2);
            suffix = stringify([nextLonghand]);
          }
          if (isConvex(nextData) && isArc(nextData, relCircle)) {
            angle += findArcAngle(nextData, relCircle);
            if (angle - 2 * Math.PI > 1e-3) break; // more than 360
            if (angle > Math.PI) arc.args[3] = 1;
            arcCurves.push(next);
            if (2 * Math.PI - angle > 1e-3) {
              // less than 360
              // @ts-ignore
              arc.coords = next.coords;
              // @ts-ignore
              arc.args[5] = arc.coords[0] - arc.base[0];
              // @ts-ignore
              arc.args[6] = arc.coords[1] - arc.base[1];
            } else {
              // full circle, make a half-circle arc and add a second one
              arc.args[5] = 2 * (relCircle.center[0] - nextData[4]);
              arc.args[6] = 2 * (relCircle.center[1] - nextData[5]);
              // @ts-ignore
              arc.coords = [
                // @ts-ignore
                arc.base[0] + arc.args[5],
                // @ts-ignore
                arc.base[1] + arc.args[6],
              ];
              arc = {
                command: "a",
                args: [
                  r,
                  r,
                  0,
                  0,
                  sweep,
                  // @ts-ignore
                  next.coords[0] - arc.coords[0],
                  // @ts-ignore
                  next.coords[1] - arc.coords[1],
                ],
                // @ts-ignore
                coords: next.coords,
                // @ts-ignore
                base: arc.coords,
              };
              output.push(arc);
              j++;
              break;
            }
            relCenter[0] -= nextData[4];
            relCenter[1] -= nextData[5];
          } else break;
        }

        if ((stringify(output) + suffix).length < stringify(arcCurves).length) {
          if (path[j] && path[j].command == "s") {
            makeLonghand(path[j], path[j - 1].args);
          }
          if (hasPrev) {
            var prevArc = output.shift();
            // @ts-ignore
            roundData(prevArc.args);
            // @ts-ignore
            relSubpoint[0] += prevArc.args[5] - prev.args[prev.args.length - 2];
            // @ts-ignore
            relSubpoint[1] += prevArc.args[6] - prev.args[prev.args.length - 1];
            prev.command = "a";
            // @ts-ignore
            prev.args = prevArc.args;
            // @ts-ignore
            item.base = prev.coords = prevArc.coords;
          }
          // @ts-ignore
          arc = output.shift();
          if (arcCurves.length == 1) {
            // @ts-ignore
            item.sdata = sdata.slice(); // preserve curve data for future checks
          } else if (arcCurves.length - 1 - hasPrev > 0) {
            // filter out consumed next items
            path.splice(index + 1, arcCurves.length - 1 - hasPrev, ...output);
          }
          if (!arc) return false;
          command = "a";
          data = arc.args;
          // @ts-ignore
          item.coords = arc.coords;
        }
      }

      // Rounding relative coordinates, taking in account accumulating error
      // to get closer to absolute coordinates. Sum of rounded value remains same:
      // l .25 3 .25 2 .25 3 .25 2 -> l .3 3 .2 2 .3 3 .2 2
      if (precision !== false) {
        if (
          command === "m" ||
          command === "l" ||
          command === "t" ||
          command === "q" ||
          command === "s" ||
          command === "c"
        ) {
          for (var i = data.length; i--; ) {
            // @ts-ignore
            data[i] += item.base[i % 2] - relSubpoint[i % 2];
          }
        } else if (command == "h") {
          // @ts-ignore
          data[0] += item.base[0] - relSubpoint[0];
        } else if (command == "v") {
          // @ts-ignore
          data[0] += item.base[1] - relSubpoint[1];
        } else if (command == "a") {
          // @ts-ignore
          data[5] += item.base[0] - relSubpoint[0];
          // @ts-ignore
          data[6] += item.base[1] - relSubpoint[1];
        }
        roundData(data);

        if (command == "h") relSubpoint[0] += data[0];
        else if (command == "v") relSubpoint[1] += data[0];
        else {
          relSubpoint[0] += data[data.length - 2];
          relSubpoint[1] += data[data.length - 1];
        }
        roundData(relSubpoint);

        if (command === "M" || command === "m") {
          pathBase[0] = relSubpoint[0];
          pathBase[1] = relSubpoint[1];
        }
      }

      // round arc radius more accurately
      // eg m 0 0 a 1234.567 1234.567 0 0 1 10 0 -> m 0 0 a 1235 1235 0 0 1 10 0
      const sagitta = command === "a" ? calculateSagitta(data) : undefined;
      if (params.smartArcRounding && sagitta !== undefined && precision) {
        for (let precisionNew = precision; precisionNew >= 0; precisionNew--) {
          const radius = toFixed$1(data[0], precisionNew);
          const sagittaNew = /** @type {number} */ (
            calculateSagitta([radius, radius, ...data.slice(2)])
          );
          if (Math.abs(sagitta - sagittaNew) < error) {
            data[0] = radius;
            data[1] = radius;
          } else {
            break;
          }
        }
      }

      // convert straight curves into lines segments
      if (params.straightCurves) {
        if (
          (command === "c" && isCurveStraightLine(data)) ||
          (command === "s" && isCurveStraightLine(sdata))
        ) {
          if (next && next.command == "s") makeLonghand(next, data); // fix up next curve
          command = "l";
          data = data.slice(-2);
        } else if (command === "q" && isCurveStraightLine(data)) {
          if (next && next.command == "t") makeLonghand(next, data); // fix up next curve
          command = "l";
          data = data.slice(-2);
        } else if (
          command === "t" &&
          prev.command !== "q" &&
          prev.command !== "t"
        ) {
          command = "l";
          data = data.slice(-2);
        } else if (
          command === "a" &&
          (data[0] === 0 ||
            data[1] === 0 ||
            (sagitta !== undefined && sagitta < error))
        ) {
          command = "l";
          data = data.slice(-2);
        }
      }

      // degree-lower c to q when possible
      // m 0 12 C 4 4 8 4 12 12  M 0 12 Q 6 0 12 12
      if (params.convertToQ && command == "c") {
        const x1 =
          // @ts-ignore
          0.75 * (item.base[0] + data[0]) - 0.25 * item.base[0];
        const x2 =
          // @ts-ignore
          0.75 * (item.base[0] + data[2]) - 0.25 * (item.base[0] + data[4]);
        if (Math.abs(x1 - x2) < error * 2) {
          const y1 =
            // @ts-ignore
            0.75 * (item.base[1] + data[1]) - 0.25 * item.base[1];
          const y2 =
            // @ts-ignore
            0.75 * (item.base[1] + data[3]) - 0.25 * (item.base[1] + data[5]);
          if (Math.abs(y1 - y2) < error * 2) {
            const newData = data.slice();
            newData.splice(
              0,
              4,
              // @ts-ignore
              x1 + x2 - item.base[0],
              // @ts-ignore
              y1 + y2 - item.base[1],
            );
            roundData(newData);
            const originalLength = cleanupOutData$1(data, params).length,
              newLength = cleanupOutData$1(newData, params).length;
            if (newLength < originalLength) {
              command = "q";
              data = newData;
              if (next && next.command == "s") makeLonghand(next, data); // fix up next curve
            }
          }
        }
      }

      // horizontal and vertical line shorthands
      // l 50 0  h 50
      // l 0 50  v 50
      if (params.lineShorthands && command === "l") {
        if (data[1] === 0) {
          command = "h";
          data.pop();
        } else if (data[0] === 0) {
          command = "v";
          data.shift();
        }
      }

      // collapse repeated commands
      // h 20 h 30 -> h 50
      if (
        params.collapseRepeated &&
        hasMarkerMid === false &&
        (command === "m" || command === "h" || command === "v") &&
        prev.command &&
        command == prev.command.toLowerCase() &&
        ((command != "h" && command != "v") ||
          prev.args[0] >= 0 == data[0] >= 0)
      ) {
        prev.args[0] += data[0];
        if (command != "h" && command != "v") {
          prev.args[1] += data[1];
        }
        // @ts-ignore
        prev.coords = item.coords;
        path[index] = prev;
        return false;
      }

      // convert curves into smooth shorthands
      if (params.curveSmoothShorthands && prev.command) {
        // curveto
        if (command === "c") {
          // c + c  c + s
          if (
            prev.command === "c" &&
            Math.abs(data[0] - -(prev.args[2] - prev.args[4])) < error &&
            Math.abs(data[1] - -(prev.args[3] - prev.args[5])) < error
          ) {
            command = "s";
            data = data.slice(2);
          }

          // s + c  s + s
          else if (
            prev.command === "s" &&
            Math.abs(data[0] - -(prev.args[0] - prev.args[2])) < error &&
            Math.abs(data[1] - -(prev.args[1] - prev.args[3])) < error
          ) {
            command = "s";
            data = data.slice(2);
          }

          // [^cs] + c  [^cs] + s
          else if (
            prev.command !== "c" &&
            prev.command !== "s" &&
            Math.abs(data[0]) < error &&
            Math.abs(data[1]) < error
          ) {
            command = "s";
            data = data.slice(2);
          }
        }

        // quadratic Bzier curveto
        else if (command === "q") {
          // q + q  q + t
          if (
            prev.command === "q" &&
            Math.abs(data[0] - (prev.args[2] - prev.args[0])) < error &&
            Math.abs(data[1] - (prev.args[3] - prev.args[1])) < error
          ) {
            command = "t";
            data = data.slice(2);
          }

          // t + q  t + t
          else if (prev.command === "t") {
            const predictedControlPoint = reflectPoint(
              // @ts-ignore
              qControlPoint,
              // @ts-ignore
              item.base,
            );
            const realControlPoint = [
              // @ts-ignore
              data[0] + item.base[0],
              // @ts-ignore
              data[1] + item.base[1],
            ];
            if (
              Math.abs(predictedControlPoint[0] - realControlPoint[0]) <
                error &&
              Math.abs(predictedControlPoint[1] - realControlPoint[1]) < error
            ) {
              command = "t";
              data = data.slice(2);
            }
          }
        }
      }

      // remove useless non-first path segments
      if (params.removeUseless && !maybeHasStrokeAndLinecap) {
        // l 0,0 / h 0 / v 0 / q 0,0 0,0 / t 0,0 / c 0,0 0,0 0,0 / s 0,0 0,0
        if (
          (command === "l" ||
            command === "h" ||
            command === "v" ||
            command === "q" ||
            command === "t" ||
            command === "c" ||
            command === "s") &&
          data.every(function (i) {
            return i === 0;
          })
        ) {
          path[index] = prev;
          return false;
        }

        // a 25,25 -30 0,1 0,0
        if (command === "a" && data[5] === 0 && data[6] === 0) {
          path[index] = prev;
          return false;
        }
      }

      // convert going home to z
      // m 0 0 h 5 v 5 l -5 -5 -> m 0 0 h 5 v 5 z
      if (
        params.convertToZ &&
        (isSafeToUseZ || next?.command === "Z" || next?.command === "z") &&
        (command === "l" || command === "h" || command === "v")
      ) {
        if (
          // @ts-ignore
          Math.abs(pathBase[0] - item.coords[0]) < error &&
          // @ts-ignore
          Math.abs(pathBase[1] - item.coords[1]) < error
        ) {
          command = "z";
          data = [];
        }
      }

      item.command = command;
      item.args = data;
    } else {
      // z resets coordinates
      relSubpoint[0] = pathBase[0];
      relSubpoint[1] = pathBase[1];
      if (prev.command === "Z" || prev.command === "z") return false;
    }
    if (
      (command === "Z" || command === "z") &&
      params.removeUseless &&
      isSafeToUseZ &&
      // @ts-ignore
      Math.abs(item.base[0] - item.coords[0]) < error / 10 &&
      // @ts-ignore
      Math.abs(item.base[1] - item.coords[1]) < error / 10
    )
      return false;

    if (command === "q") {
      // @ts-ignore
      prevQControlPoint = [data[0] + item.base[0], data[1] + item.base[1]];
    } else if (command === "t") {
      if (qControlPoint) {
        // @ts-ignore
        prevQControlPoint = reflectPoint(qControlPoint, item.base);
      } else {
        // @ts-ignore
        prevQControlPoint = item.coords;
      }
    }
    prev = item;
    return true;
  });

  return path;
}

/**
 * Writes data in shortest form using absolute or relative coordinates.
 *
 * @type {(path: PathDataItem[], params: InternalParams) => PathDataItem[]}
 */
function convertToMixed(path, params) {
  var prev = path[0];

  path = path.filter(function (item, index) {
    if (index == 0) return true;
    if (item.command === "Z" || item.command === "z") {
      prev = item;
      return true;
    }

    var command = item.command,
      data = item.args,
      adata = data.slice(),
      rdata = data.slice();

    if (
      command === "m" ||
      command === "l" ||
      command === "t" ||
      command === "q" ||
      command === "s" ||
      command === "c"
    ) {
      for (var i = adata.length; i--; ) {
        // @ts-ignore
        adata[i] += item.base[i % 2];
      }
    } else if (command == "h") {
      // @ts-ignore
      adata[0] += item.base[0];
    } else if (command == "v") {
      // @ts-ignore
      adata[0] += item.base[1];
    } else if (command == "a") {
      // @ts-ignore
      adata[5] += item.base[0];
      // @ts-ignore
      adata[6] += item.base[1];
    }

    roundData(adata);
    roundData(rdata);

    var absoluteDataStr = cleanupOutData$1(adata, params),
      relativeDataStr = cleanupOutData$1(rdata, params);

    // Convert to absolute coordinates if it's shorter or forceAbsolutePath is true.
    // v-20 -> V0
    // Don't convert if it fits following previous command.
    // l20 30-10-50 instead of l20 30L20 30
    if (
      params.forceAbsolutePath ||
      (absoluteDataStr.length < relativeDataStr.length &&
        !(
          params.negativeExtraSpace &&
          command == prev.command &&
          prev.command.charCodeAt(0) > 96 &&
          absoluteDataStr.length == relativeDataStr.length - 1 &&
          (data[0] < 0 ||
            (Math.floor(data[0]) === 0 &&
              !Number.isInteger(data[0]) &&
              prev.args[prev.args.length - 1] % 1))
        ))
    ) {
      // @ts-ignore
      item.command = command.toUpperCase();
      item.args = adata;
    }

    prev = item;
    return true;
  });

  return path;
}

/**
 * Checks if curve is convex. Control points of such a curve must form
 * a convex quadrilateral with diagonals crosspoint inside of it.
 *
 * @type {(data: number[]) => boolean}
 */
function isConvex(data) {
  var center = getIntersection([
    0,
    0,
    data[2],
    data[3],
    data[0],
    data[1],
    data[4],
    data[5],
  ]);

  return (
    center != null &&
    data[2] < center[0] == center[0] < 0 &&
    data[3] < center[1] == center[1] < 0 &&
    data[4] < center[0] == center[0] < data[0] &&
    data[5] < center[1] == center[1] < data[1]
  );
}

/**
 * Computes lines equations by two points and returns their intersection point.
 *
 * @type {(coords: number[]) => undefined | Point}
 */
function getIntersection(coords) {
  // Prev line equation parameters.
  var a1 = coords[1] - coords[3], // y1 - y2
    b1 = coords[2] - coords[0], // x2 - x1
    c1 = coords[0] * coords[3] - coords[2] * coords[1], // x1 * y2 - x2 * y1
    // Next line equation parameters
    a2 = coords[5] - coords[7], // y1 - y2
    b2 = coords[6] - coords[4], // x2 - x1
    c2 = coords[4] * coords[7] - coords[5] * coords[6], // x1 * y2 - x2 * y1
    denom = a1 * b2 - a2 * b1;

  if (!denom) return; // parallel lines haven't an intersection

  /**
   * @type {Point}
   */
  var cross = [(b1 * c2 - b2 * c1) / denom, (a1 * c2 - a2 * c1) / -denom];
  if (
    !isNaN(cross[0]) &&
    !isNaN(cross[1]) &&
    isFinite(cross[0]) &&
    isFinite(cross[1])
  ) {
    return cross;
  }
}

/**
 * Decrease accuracy of floating-point numbers
 * in path data keeping a specified number of decimals.
 * Smart rounds values like 2.3491 to 2.35 instead of 2.349.
 * Doesn't apply "smartness" if the number precision fits already.
 *
 * @type {(data: number[]) => number[]}
 */
function strongRound(data) {
  const precisionNum = precision || 0;
  for (let i = data.length; i-- > 0; ) {
    const fixed = toFixed$1(data[i], precisionNum);
    if (fixed !== data[i]) {
      const rounded = toFixed$1(data[i], precisionNum - 1);
      data[i] =
        toFixed$1(Math.abs(rounded - data[i]), precisionNum + 1) >= error
          ? fixed
          : rounded;
    }
  }
  return data;
}

/**
 * Simple rounding function if precision is 0.
 *
 * @type {(data: number[]) => number[]}
 */
function round$1(data) {
  for (var i = data.length; i-- > 0; ) {
    data[i] = Math.round(data[i]);
  }
  return data;
}

/**
 * Checks if a curve is a straight line by measuring distance
 * from middle points to the line formed by end points.
 *
 * @type {(data: number[]) => boolean}
 */
function isCurveStraightLine(data) {
  // Get line equation ax + by + c = 0 coefficients a, b (c = 0) by start and end points.
  var i = data.length - 2,
    a = -data[i + 1], // y1  y2 (y1 = 0)
    b = data[i], // x2  x1 (x1 = 0)
    d = 1 / (a * a + b * b); // same part for all points

  if (i <= 1 || !isFinite(d)) return false; // curve that ends at start point isn't the case

  // Distance from point (x0, y0) to the line is sqrt((c  ax0  by0) / (a + b))
  while ((i -= 2) >= 0) {
    if (Math.sqrt(Math.pow(a * data[i] + b * data[i + 1], 2) * d) > error)
      return false;
  }

  return true;
}

/**
 * Calculates the sagitta of an arc if possible.
 *
 * @type {(data: number[]) => number | undefined}
 * @see https://wikipedia.org/wiki/Sagitta_(geometry)#Formulas
 */
function calculateSagitta(data) {
  if (data[3] === 1) return undefined;
  const [rx, ry] = data;
  if (Math.abs(rx - ry) > error) return undefined;
  const chord = Math.sqrt(data[5] ** 2 + data[6] ** 2);
  if (chord > rx * 2) return undefined;
  return rx - Math.sqrt(rx ** 2 - 0.25 * chord ** 2);
}

/**
 * Converts next curve from shorthand to full form using the current curve data.
 *
 * @type {(item: PathDataItem, data: number[]) => PathDataItem}
 */
function makeLonghand(item, data) {
  switch (item.command) {
    case "s":
      item.command = "c";
      break;
    case "t":
      item.command = "q";
      break;
  }
  item.args.unshift(
    data[data.length - 2] - data[data.length - 4],
    data[data.length - 1] - data[data.length - 3],
  );
  return item;
}

/**
 * Returns distance between two points
 *
 * @type {(point1: Point, point2: Point) => number}
 */
function getDistance(point1, point2) {
  return Math.sqrt((point1[0] - point2[0]) ** 2 + (point1[1] - point2[1]) ** 2);
}

/**
 * Reflects point across another point.
 *
 * @param {Point} controlPoint
 * @param {Point} base
 * @returns {Point}
 */
function reflectPoint(controlPoint, base) {
  return [2 * base[0] - controlPoint[0], 2 * base[1] - controlPoint[1]];
}

/**
 * Returns coordinates of the curve point corresponding to the certain t
 * a(1 - t)p1 + b(1 - t)tp2 + c(1 - t)tp3 + dtp4,
 * where pN are control points and p1 is zero due to relative coordinates.
 *
 * @type {(curve: number[], t: number) => Point}
 */
function getCubicBezierPoint(curve, t) {
  var sqrT = t * t,
    cubT = sqrT * t,
    mt = 1 - t,
    sqrMt = mt * mt;

  return [
    3 * sqrMt * t * curve[0] + 3 * mt * sqrT * curve[2] + cubT * curve[4],
    3 * sqrMt * t * curve[1] + 3 * mt * sqrT * curve[3] + cubT * curve[5],
  ];
}

/**
 * Finds circle by 3 points of the curve and checks if the curve fits the found circle.
 *
 * @type {(curve: number[]) => undefined | Circle}
 */
function findCircle(curve) {
  var midPoint = getCubicBezierPoint(curve, 1 / 2),
    m1 = [midPoint[0] / 2, midPoint[1] / 2],
    m2 = [(midPoint[0] + curve[4]) / 2, (midPoint[1] + curve[5]) / 2],
    center = getIntersection([
      m1[0],
      m1[1],
      m1[0] + m1[1],
      m1[1] - m1[0],
      m2[0],
      m2[1],
      m2[0] + (m2[1] - midPoint[1]),
      m2[1] - (m2[0] - midPoint[0]),
    ]),
    radius = center && getDistance([0, 0], center),
    // @ts-ignore
    tolerance = Math.min(arcThreshold * error, (arcTolerance * radius) / 100);

  if (
    center &&
    // @ts-ignore
    radius < 1e15 &&
    [1 / 4, 3 / 4].every(function (point) {
      return (
        Math.abs(
          // @ts-ignore
          getDistance(getCubicBezierPoint(curve, point), center) - radius,
        ) <= tolerance
      );
    })
  )
    // @ts-ignore
    return { center: center, radius: radius };
}

/**
 * Checks if a curve fits the given circle.
 *
 * @type {(curve: number[], circle: Circle) => boolean}
 */
function isArc(curve, circle) {
  var tolerance = Math.min(
    arcThreshold * error,
    (arcTolerance * circle.radius) / 100,
  );

  return [0, 1 / 4, 1 / 2, 3 / 4, 1].every(function (point) {
    return (
      Math.abs(
        getDistance(getCubicBezierPoint(curve, point), circle.center) -
          circle.radius,
      ) <= tolerance
    );
  });
}

/**
 * Checks if a previous curve fits the given circle.
 *
 * @type {(curve: number[], circle: Circle) => boolean}
 */
function isArcPrev(curve, circle) {
  return isArc(curve, {
    center: [circle.center[0] + curve[4], circle.center[1] + curve[5]],
    radius: circle.radius,
  });
}

/**
 * Finds angle of a curve fitting the given arc.

 * @type {(curve: number[], relCircle: Circle) => number}
 */
function findArcAngle(curve, relCircle) {
  var x1 = -relCircle.center[0],
    y1 = -relCircle.center[1],
    x2 = curve[4] - relCircle.center[0],
    y2 = curve[5] - relCircle.center[1];

  return Math.acos(
    (x1 * x2 + y1 * y2) / Math.sqrt((x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2)),
  );
}

/**
 * Converts given path data to string.
 *
 * @type {(params: InternalParams, pathData: PathDataItem[]) => string}
 */
function data2Path(params, pathData) {
  return pathData.reduce(function (pathString, item) {
    var strData = "";
    if (item.args) {
      strData = cleanupOutData$1(roundData(item.args.slice()), params);
    }
    return pathString + item.command + strData;
  }, "");
}

var convertTransform$2 = {};

/**
 * @typedef {import('../lib/types').XastChild} XastChild
 * @typedef {import('../lib/types').XastElement} XastElement
 * @typedef {import('../lib/types').XastParent} XastParent
 */

const { cleanupOutData, toFixed } = tools;
const { transform2js, transformsMultiply, matrixToTransform } = _transforms;

convertTransform$2.name = "convertTransform";
convertTransform$2.description =
  "collapses multiple transformations and optimizes it";

/**
 * Convert matrices to the short aliases,
 * convert long translate, scale or rotate transform notations to the shorts ones,
 * convert transforms to the matrices and multiply them all into one,
 * remove useless transforms.
 *
 * @see https://www.w3.org/TR/SVG11/coords.html#TransformMatrixDefined
 *
 * @author Kir Belevich
 *
 * @type {import('./plugins-types').Plugin<'convertTransform'>}
 */
convertTransform$2.fn = (_root, params) => {
  const {
    convertToShorts = true,
    // degPrecision = 3, // transformPrecision (or matrix precision) - 2 by default
    degPrecision,
    floatPrecision = 3,
    transformPrecision = 5,
    matrixToTransform = true,
    shortTranslate = true,
    shortScale = true,
    shortRotate = true,
    removeUseless = true,
    collapseIntoOne = true,
    leadingZero = true,
    negativeExtraSpace = false,
  } = params;
  const newParams = {
    convertToShorts,
    degPrecision,
    floatPrecision,
    transformPrecision,
    matrixToTransform,
    shortTranslate,
    shortScale,
    shortRotate,
    removeUseless,
    collapseIntoOne,
    leadingZero,
    negativeExtraSpace,
  };
  return {
    element: {
      enter: (node) => {
        if (node.attributes.transform != null) {
          convertTransform$1(node, "transform", newParams);
        }

        if (node.attributes.gradientTransform != null) {
          convertTransform$1(node, "gradientTransform", newParams);
        }

        if (node.attributes.patternTransform != null) {
          convertTransform$1(node, "patternTransform", newParams);
        }
      },
    },
  };
};

/**
 * @typedef {{
 *   convertToShorts: boolean,
 *   degPrecision?: number,
 *   floatPrecision: number,
 *   transformPrecision: number,
 *   matrixToTransform: boolean,
 *   shortTranslate: boolean,
 *   shortScale: boolean,
 *   shortRotate: boolean,
 *   removeUseless: boolean,
 *   collapseIntoOne: boolean,
 *   leadingZero: boolean,
 *   negativeExtraSpace: boolean,
 * }} TransformParams
 */

/**
 * @typedef {{ name: string, data: number[] }} TransformItem
 */

/**
 * @param {XastElement} item
 * @param {string} attrName
 * @param {TransformParams} params
 */
const convertTransform$1 = (item, attrName, params) => {
  let data = transform2js(item.attributes[attrName]);
  params = definePrecision(data, params);

  if (params.collapseIntoOne && data.length > 1) {
    data = [transformsMultiply(data)];
  }

  if (params.convertToShorts) {
    data = convertToShorts(data, params);
  } else {
    data.forEach((item) => roundTransform(item, params));
  }

  if (params.removeUseless) {
    data = removeUseless(data);
  }

  if (data.length) {
    item.attributes[attrName] = js2transform(data, params);
  } else {
    delete item.attributes[attrName];
  }
};

/**
 * Defines precision to work with certain parts.
 * transformPrecision - for scale and four first matrix parameters (needs a better precision due to multiplying),
 * floatPrecision - for translate including two last matrix and rotate parameters,
 * degPrecision - for rotate and skew. By default it's equal to (roughly)
 * transformPrecision - 2 or floatPrecision whichever is lower. Can be set in params.
 *
 * @type {(data: TransformItem[], params: TransformParams) => TransformParams}
 *
 * clone params so it don't affect other elements transformations.
 */
const definePrecision = (data, { ...newParams }) => {
  const matrixData = [];
  for (const item of data) {
    if (item.name == "matrix") {
      matrixData.push(...item.data.slice(0, 4));
    }
  }
  let numberOfDigits = newParams.transformPrecision;
  // Limit transform precision with matrix one. Calculating with larger precision doesn't add any value.
  if (matrixData.length) {
    newParams.transformPrecision = Math.min(
      newParams.transformPrecision,
      Math.max.apply(Math, matrixData.map(floatDigits)) ||
        newParams.transformPrecision,
    );
    numberOfDigits = Math.max.apply(
      Math,
      matrixData.map(
        (n) => n.toString().replace(/\D+/g, "").length, // Number of digits in a number. 123.45  5
      ),
    );
  }
  // No sense in angle precision more then number of significant digits in matrix.
  if (newParams.degPrecision == null) {
    newParams.degPrecision = Math.max(
      0,
      Math.min(newParams.floatPrecision, numberOfDigits - 2),
    );
  }
  return newParams;
};

/**
 * @type {(data: number[], params: TransformParams) => number[]}
 */
const degRound = (data, params) => {
  if (
    params.degPrecision != null &&
    params.degPrecision >= 1 &&
    params.floatPrecision < 20
  ) {
    return smartRound(params.degPrecision, data);
  } else {
    return round(data);
  }
};
/**
 * @type {(data: number[], params: TransformParams) => number[]}
 */
const floatRound = (data, params) => {
  if (params.floatPrecision >= 1 && params.floatPrecision < 20) {
    return smartRound(params.floatPrecision, data);
  } else {
    return round(data);
  }
};

/**
 * @type {(data: number[], params: TransformParams) => number[]}
 */
const transformRound = (data, params) => {
  if (params.transformPrecision >= 1 && params.floatPrecision < 20) {
    return smartRound(params.transformPrecision, data);
  } else {
    return round(data);
  }
};

/**
 * Returns number of digits after the point. 0.125  3
 *
 * @type {(n: number) => number}
 */
const floatDigits = (n) => {
  const str = n.toString();
  return str.slice(str.indexOf(".")).length - 1;
};

/**
 * Convert transforms to the shorthand alternatives.
 *
 * @param {TransformItem[]} transforms
 * @param {TransformParams} params
 * @returns {TransformItem[]}
 */
const convertToShorts = (transforms, params) => {
  for (var i = 0; i < transforms.length; i++) {
    let transform = transforms[i];

    // convert matrix to the short aliases
    if (params.matrixToTransform && transform.name === "matrix") {
      var decomposed = matrixToTransform(transform, params);
      if (
        js2transform(decomposed, params).length <=
        js2transform([transform], params).length
      ) {
        transforms.splice(i, 1, ...decomposed);
      }
      transform = transforms[i];
    }

    // fixed-point numbers
    // 12.754997  12.755
    roundTransform(transform, params);

    // convert long translate transform notation to the shorts one
    // translate(10 0)  translate(10)
    if (
      params.shortTranslate &&
      transform.name === "translate" &&
      transform.data.length === 2 &&
      !transform.data[1]
    ) {
      transform.data.pop();
    }

    // convert long scale transform notation to the shorts one
    // scale(2 2)  scale(2)
    if (
      params.shortScale &&
      transform.name === "scale" &&
      transform.data.length === 2 &&
      transform.data[0] === transform.data[1]
    ) {
      transform.data.pop();
    }

    // convert long rotate transform notation to the short one
    // translate(cx cy) rotate(a) translate(-cx -cy)  rotate(a cx cy)
    if (
      params.shortRotate &&
      transforms[i - 2]?.name === "translate" &&
      transforms[i - 1].name === "rotate" &&
      transforms[i].name === "translate" &&
      transforms[i - 2].data[0] === -transforms[i].data[0] &&
      transforms[i - 2].data[1] === -transforms[i].data[1]
    ) {
      transforms.splice(i - 2, 3, {
        name: "rotate",
        data: [
          transforms[i - 1].data[0],
          transforms[i - 2].data[0],
          transforms[i - 2].data[1],
        ],
      });

      // splice compensation
      i -= 2;
    }
  }

  return transforms;
};

/**
 * Remove useless transforms.
 *
 * @type {(transforms: TransformItem[]) => TransformItem[]}
 */
const removeUseless = (transforms) => {
  return transforms.filter((transform) => {
    // translate(0), rotate(0[, cx, cy]), skewX(0), skewY(0)
    if (
      (["translate", "rotate", "skewX", "skewY"].indexOf(transform.name) > -1 &&
        (transform.data.length == 1 || transform.name == "rotate") &&
        !transform.data[0]) ||
      // translate(0, 0)
      (transform.name == "translate" &&
        !transform.data[0] &&
        !transform.data[1]) ||
      // scale(1)
      (transform.name == "scale" &&
        transform.data[0] == 1 &&
        (transform.data.length < 2 || transform.data[1] == 1)) ||
      // matrix(1 0 0 1 0 0)
      (transform.name == "matrix" &&
        transform.data[0] == 1 &&
        transform.data[3] == 1 &&
        !(
          transform.data[1] ||
          transform.data[2] ||
          transform.data[4] ||
          transform.data[5]
        ))
    ) {
      return false;
    }

    return true;
  });
};

/**
 * Convert transforms JS representation to string.
 *
 * @param {TransformItem[]} transformJS
 * @param {TransformParams} params
 * @returns {string}
 */
const js2transform = (transformJS, params) => {
  const transformString = transformJS
    .map((transform) => {
      roundTransform(transform, params);
      return `${transform.name}(${cleanupOutData(transform.data, params)})`;
    })
    .join("");

  return transformString;
};

/**
 * @type {(transform: TransformItem, params: TransformParams) => TransformItem}
 */
const roundTransform = (transform, params) => {
  switch (transform.name) {
    case "translate":
      transform.data = floatRound(transform.data, params);
      break;
    case "rotate":
      transform.data = [
        ...degRound(transform.data.slice(0, 1), params),
        ...floatRound(transform.data.slice(1), params),
      ];
      break;
    case "skewX":
    case "skewY":
      transform.data = degRound(transform.data, params);
      break;
    case "scale":
      transform.data = transformRound(transform.data, params);
      break;
    case "matrix":
      transform.data = [
        ...transformRound(transform.data.slice(0, 4), params),
        ...floatRound(transform.data.slice(4), params),
      ];
      break;
  }
  return transform;
};

/**
 * Rounds numbers in array.
 *
 * @type {(data: number[]) => number[]}
 */
const round = (data) => {
  return data.map(Math.round);
};

/**
 * Decrease accuracy of floating-point numbers
 * in transforms keeping a specified number of decimals.
 * Smart rounds values like 2.349 to 2.35.
 *
 * @param {number} precision
 * @param {number[]} data
 * @returns {number[]}
 */
const smartRound = (precision, data) => {
  for (
    var i = data.length,
      tolerance = +Math.pow(0.1, precision).toFixed(precision);
    i--;

  ) {
    if (toFixed(data[i], precision) !== data[i]) {
      var rounded = +data[i].toFixed(precision - 1);
      data[i] =
        +Math.abs(rounded - data[i]).toFixed(precision + 1) >= tolerance
          ? +data[i].toFixed(precision)
          : rounded;
    }
  }

  return data;
};

var removeEmptyAttrs$1 = {};

const { attrsGroups: attrsGroups$2 } = _collections;

removeEmptyAttrs$1.name = "removeEmptyAttrs";
removeEmptyAttrs$1.description = "removes empty attributes";

/**
 * Remove attributes with empty values.
 *
 * @author Kir Belevich
 *
 * @type {import('./plugins-types').Plugin<'removeEmptyAttrs'>}
 */
removeEmptyAttrs$1.fn = () => {
  return {
    element: {
      enter: (node) => {
        for (const [name, value] of Object.entries(node.attributes)) {
          if (
            value === "" &&
            // empty conditional processing attributes prevents elements from rendering
            !attrsGroups$2.conditionalProcessing.has(name)
          ) {
            delete node.attributes[name];
          }
        }
      },
    },
  };
};

var removeEmptyContainers$1 = {};

const { detachNodeFromParent: detachNodeFromParent$9 } = xast;
const { elemsGroups } = _collections;

removeEmptyContainers$1.name = "removeEmptyContainers";
removeEmptyContainers$1.description = "removes empty container elements";

/**
 * Remove empty containers.
 *
 * @see https://www.w3.org/TR/SVG11/intro.html#TermContainerElement
 *
 * @example
 * <defs/>
 *
 * @example
 * <g><marker><a/></marker></g>
 *
 * @author Kir Belevich
 *
 * @type {import('./plugins-types').Plugin<'removeEmptyContainers'>}
 */
removeEmptyContainers$1.fn = () => {
  return {
    element: {
      exit: (node, parentNode) => {
        // remove only empty non-svg containers
        if (
          node.name === "svg" ||
          !elemsGroups.container.has(node.name) ||
          node.children.length !== 0
        ) {
          return;
        }
        // empty patterns may contain reusable configuration
        if (
          node.name === "pattern" &&
          Object.keys(node.attributes).length !== 0
        ) {
          return;
        }
        // The <g> may not have content, but the filter may cause a rectangle
        // to be created and filled with pattern.
        if (node.name === "g" && node.attributes.filter != null) {
          return;
        }
        // empty <mask> hides masked element
        if (node.name === "mask" && node.attributes.id != null) {
          return;
        }
        if (parentNode.type === "element" && parentNode.name === "switch") {
          return;
        }
        detachNodeFromParent$9(node, parentNode);
      },
    },
  };
};

var mergePaths$1 = {};

/**
 * @typedef {import("../lib/types").PathDataItem} PathDataItem
 * @typedef {import('../lib/types').XastChild} XastChild
 * @typedef {import('../lib/types').XastElement} XastElement
 */

const { collectStylesheet: collectStylesheet$2, computeStyle: computeStyle$1 } =
  style;
const { path2js, js2path, intersects: intersects$1 } = _path$1;

mergePaths$1.name = "mergePaths";
mergePaths$1.description = "merges multiple paths in one if possible";

/**
 * Merge multiple Paths into one.
 *
 * @author Kir Belevich, Lev Solntsev
 *
 * @type {import('./plugins-types').Plugin<'mergePaths'>}
 */
mergePaths$1.fn = (root, params) => {
  const {
    force = false,
    floatPrecision,
    noSpaceAfterFlags = false, // a20 60 45 0 1 30 20  a20 60 45 0130 20
  } = params;
  const stylesheet = collectStylesheet$2(root);

  return {
    element: {
      enter: (node) => {
        if (node.children.length <= 1) {
          return;
        }

        /** @type {XastChild[]} */
        const elementsToRemove = [];
        let prevChild = node.children[0];
        let prevPathData = null;

        /**
         * @param {XastElement} child
         * @param {PathDataItem[]} pathData
         */
        const updatePreviousPath = (child, pathData) => {
          js2path(child, pathData, {
            floatPrecision,
            noSpaceAfterFlags,
          });
          prevPathData = null;
        };

        for (let i = 1; i < node.children.length; i++) {
          const child = node.children[i];

          if (
            prevChild.type !== "element" ||
            prevChild.name !== "path" ||
            prevChild.children.length !== 0 ||
            prevChild.attributes.d == null
          ) {
            if (prevPathData && prevChild.type === "element") {
              updatePreviousPath(prevChild, prevPathData);
            }
            prevChild = child;
            continue;
          }

          if (
            child.type !== "element" ||
            child.name !== "path" ||
            child.children.length !== 0 ||
            child.attributes.d == null
          ) {
            if (prevPathData) {
              updatePreviousPath(prevChild, prevPathData);
            }
            prevChild = child;
            continue;
          }

          const computedStyle = computeStyle$1(stylesheet, child);
          if (
            computedStyle["marker-start"] ||
            computedStyle["marker-mid"] ||
            computedStyle["marker-end"]
          ) {
            if (prevPathData) {
              updatePreviousPath(prevChild, prevPathData);
            }
            prevChild = child;
            continue;
          }
          const childAttrs = Object.keys(child.attributes);
          if (childAttrs.length !== Object.keys(prevChild.attributes).length) {
            if (prevPathData) {
              updatePreviousPath(prevChild, prevPathData);
            }
            prevChild = child;
            continue;
          }

          const areAttrsEqual = childAttrs.some((attr) => {
            return (
              attr !== "d" &&
              prevChild.type === "element" &&
              prevChild.attributes[attr] !== child.attributes[attr]
            );
          });

          if (areAttrsEqual) {
            if (prevPathData) {
              updatePreviousPath(prevChild, prevPathData);
            }
            prevChild = child;
            continue;
          }

          const hasPrevPath = prevPathData != null;
          const currentPathData = path2js(child);
          prevPathData = prevPathData ?? path2js(prevChild);

          if (force || !intersects$1(prevPathData, currentPathData)) {
            prevPathData.push(...currentPathData);
            elementsToRemove.push(child);
            continue;
          }

          if (hasPrevPath) {
            updatePreviousPath(prevChild, prevPathData);
          }

          prevChild = child;
          prevPathData = null;
        }

        if (prevPathData && prevChild.type === "element") {
          updatePreviousPath(prevChild, prevPathData);
        }

        node.children = node.children.filter(
          (child) => !elementsToRemove.includes(child),
        );
      },
    },
  };
};

var removeUnusedNS$1 = {};

removeUnusedNS$1.name = "removeUnusedNS";
removeUnusedNS$1.description = "removes unused namespaces declaration";

/**
 * Remove unused namespaces declaration from svg element
 * which are not used in elements or attributes
 *
 * @author Kir Belevich
 *
 * @type {import('./plugins-types').Plugin<'removeUnusedNS'>}
 */
removeUnusedNS$1.fn = () => {
  /**
   * @type {Set<string>}
   */
  const unusedNamespaces = new Set();
  return {
    element: {
      enter: (node, parentNode) => {
        // collect all namespaces from svg element
        // (such as xmlns:xlink="http://www.w3.org/1999/xlink")
        if (node.name === "svg" && parentNode.type === "root") {
          for (const name of Object.keys(node.attributes)) {
            if (name.startsWith("xmlns:")) {
              const local = name.slice("xmlns:".length);
              unusedNamespaces.add(local);
            }
          }
        }
        if (unusedNamespaces.size !== 0) {
          // preserve namespace used in nested elements names
          if (node.name.includes(":")) {
            const [ns] = node.name.split(":");
            if (unusedNamespaces.has(ns)) {
              unusedNamespaces.delete(ns);
            }
          }
          // preserve namespace used in nested elements attributes
          for (const name of Object.keys(node.attributes)) {
            if (name.includes(":")) {
              const [ns] = name.split(":");
              unusedNamespaces.delete(ns);
            }
          }
        }
      },
      exit: (node, parentNode) => {
        // remove unused namespace attributes from svg element
        if (node.name === "svg" && parentNode.type === "root") {
          for (const name of unusedNamespaces) {
            delete node.attributes[`xmlns:${name}`];
          }
        }
      },
    },
  };
};

var sortAttrs$1 = {};

sortAttrs$1.name = "sortAttrs";
sortAttrs$1.description = "Sort element attributes for better compression";

/**
 * Sort element attributes for better compression
 *
 * @author Nikolay Frantsev
 *
 * @type {import('./plugins-types').Plugin<'sortAttrs'>}
 */
sortAttrs$1.fn = (_root, params) => {
  const {
    order = [
      "id",
      "width",
      "height",
      "x",
      "x1",
      "x2",
      "y",
      "y1",
      "y2",
      "cx",
      "cy",
      "r",
      "fill",
      "stroke",
      "marker",
      "d",
      "points",
    ],
    xmlnsOrder = "front",
  } = params;

  /**
   * @type {(name: string) => number}
   */
  const getNsPriority = (name) => {
    if (xmlnsOrder === "front") {
      // put xmlns first
      if (name === "xmlns") {
        return 3;
      }
      // xmlns:* attributes second
      if (name.startsWith("xmlns:")) {
        return 2;
      }
    }
    // other namespaces after and sort them alphabetically
    if (name.includes(":")) {
      return 1;
    }
    // other attributes
    return 0;
  };

  /**
   * @type {(a: [string, string], b: [string, string]) => number}
   */
  const compareAttrs = ([aName], [bName]) => {
    // sort namespaces
    const aPriority = getNsPriority(aName);
    const bPriority = getNsPriority(bName);
    const priorityNs = bPriority - aPriority;
    if (priorityNs !== 0) {
      return priorityNs;
    }
    // extract the first part from attributes
    // for example "fill" from "fill" and "fill-opacity"
    const [aPart] = aName.split("-");
    const [bPart] = bName.split("-");
    // rely on alphabetical sort when the first part is the same
    if (aPart !== bPart) {
      const aInOrderFlag = order.includes(aPart) ? 1 : 0;
      const bInOrderFlag = order.includes(bPart) ? 1 : 0;
      // sort by position in order param
      if (aInOrderFlag === 1 && bInOrderFlag === 1) {
        return order.indexOf(aPart) - order.indexOf(bPart);
      }
      // put attributes from order param before others
      const priorityOrder = bInOrderFlag - aInOrderFlag;
      if (priorityOrder !== 0) {
        return priorityOrder;
      }
    }
    // sort alphabetically
    return aName < bName ? -1 : 1;
  };

  return {
    element: {
      enter: (node) => {
        const attrs = Object.entries(node.attributes);
        attrs.sort(compareAttrs);
        /**
         * @type {Record<string, string>}
         */
        const sortedAttributes = {};
        for (const [name, value] of attrs) {
          sortedAttributes[name] = value;
        }
        node.attributes = sortedAttributes;
      },
    },
  };
};

var sortDefsChildren$1 = {};

sortDefsChildren$1.name = "sortDefsChildren";
sortDefsChildren$1.description =
  "Sorts children of <defs> to improve compression";

/**
 * Sorts children of defs in order to improve compression.
 * Sorted first by frequency then by element name length then by element name (to ensure grouping).
 *
 * @author David Leston
 *
 * @type {import('./plugins-types').Plugin<'sortDefsChildren'>}
 */
sortDefsChildren$1.fn = () => {
  return {
    element: {
      enter: (node) => {
        if (node.name === "defs") {
          /**
           * @type {Map<string, number>}
           */
          const frequencies = new Map();
          for (const child of node.children) {
            if (child.type === "element") {
              const frequency = frequencies.get(child.name);
              if (frequency == null) {
                frequencies.set(child.name, 1);
              } else {
                frequencies.set(child.name, frequency + 1);
              }
            }
          }
          node.children.sort((a, b) => {
            if (a.type !== "element" || b.type !== "element") {
              return 0;
            }
            const aFrequency = frequencies.get(a.name);
            const bFrequency = frequencies.get(b.name);
            if (aFrequency != null && bFrequency != null) {
              const frequencyComparison = bFrequency - aFrequency;
              if (frequencyComparison !== 0) {
                return frequencyComparison;
              }
            }
            const lengthComparison = b.name.length - a.name.length;
            if (lengthComparison !== 0) {
              return lengthComparison;
            }
            if (a.name !== b.name) {
              return a.name > b.name ? -1 : 1;
            }
            return 0;
          });
        }
      },
    },
  };
};

var removeTitle$1 = {};

const { detachNodeFromParent: detachNodeFromParent$8 } = xast;

removeTitle$1.name = "removeTitle";
removeTitle$1.description = "removes <title>";

/**
 * Remove <title>.
 *
 * https://developer.mozilla.org/docs/Web/SVG/Element/title
 *
 * @author Igor Kalashnikov
 *
 * @type {import('./plugins-types').Plugin<'removeTitle'>}
 */
removeTitle$1.fn = () => {
  return {
    element: {
      enter: (node, parentNode) => {
        if (node.name === "title") {
          detachNodeFromParent$8(node, parentNode);
        }
      },
    },
  };
};

var removeDesc$1 = {};

const { detachNodeFromParent: detachNodeFromParent$7 } = xast;

removeDesc$1.name = "removeDesc";
removeDesc$1.description = "removes <desc>";

const standardDescs = /^(Created with|Created using)/;

/**
 * Removes <desc>.
 * Removes only standard editors content or empty elements 'cause it can be used for accessibility.
 * Enable parameter 'removeAny' to remove any description.
 *
 * https://developer.mozilla.org/docs/Web/SVG/Element/desc
 *
 * @author Daniel Wabyick
 *
 * @type {import('./plugins-types').Plugin<'removeDesc'>}
 */
removeDesc$1.fn = (root, params) => {
  const { removeAny = false } = params;
  return {
    element: {
      enter: (node, parentNode) => {
        if (node.name === "desc") {
          if (
            removeAny ||
            node.children.length === 0 ||
            (node.children[0].type === "text" &&
              standardDescs.test(node.children[0].value))
          ) {
            detachNodeFromParent$7(node, parentNode);
          }
        }
      },
    },
  };
};

const { createPreset } = plugins;

const removeDoctype = removeDoctype$1;
const removeXMLProcInst = removeXMLProcInst$1;
const removeComments = removeComments$1;
const removeMetadata = removeMetadata$1;
const removeEditorsNSData = removeEditorsNSData$1;
const cleanupAttrs = cleanupAttrs$1;
const mergeStyles = mergeStyles$1;
const inlineStyles = inlineStyles$1;
const minifyStyles = minifyStyles$1;
const cleanupIds = cleanupIds$1;
const removeUselessDefs = removeUselessDefs$1;
const cleanupNumericValues = cleanupNumericValues$1;
const convertColors = convertColors$1;
const removeUnknownsAndDefaults = removeUnknownsAndDefaults$1;
const removeNonInheritableGroupAttrs = removeNonInheritableGroupAttrs$1;
const removeUselessStrokeAndFill = removeUselessStrokeAndFill$1;
const removeViewBox = removeViewBox$1;
const cleanupEnableBackground = cleanupEnableBackground$1;
const removeHiddenElems = removeHiddenElems$1;
const removeEmptyText = removeEmptyText$1;
const convertShapeToPath = convertShapeToPath$1;
const convertEllipseToCircle = convertEllipseToCircle$1;
const moveElemsAttrsToGroup = moveElemsAttrsToGroup$1;
const moveGroupAttrsToElems = moveGroupAttrsToElems$1;
const collapseGroups = collapseGroups$1;
const convertPathData = convertPathData$1;
const convertTransform = convertTransform$2;
const removeEmptyAttrs = removeEmptyAttrs$1;
const removeEmptyContainers = removeEmptyContainers$1;
const mergePaths = mergePaths$1;
const removeUnusedNS = removeUnusedNS$1;
const sortAttrs = sortAttrs$1;
const sortDefsChildren = sortDefsChildren$1;
const removeTitle = removeTitle$1;
const removeDesc = removeDesc$1;

const presetDefault = createPreset({
  name: "preset-default",
  plugins: [
    removeDoctype,
    removeXMLProcInst,
    removeComments,
    removeMetadata,
    removeEditorsNSData,
    cleanupAttrs,
    mergeStyles,
    inlineStyles,
    minifyStyles,
    cleanupIds,
    removeUselessDefs,
    cleanupNumericValues,
    convertColors,
    removeUnknownsAndDefaults,
    removeNonInheritableGroupAttrs,
    removeUselessStrokeAndFill,
    removeViewBox,
    cleanupEnableBackground,
    removeHiddenElems,
    removeEmptyText,
    convertShapeToPath,
    convertEllipseToCircle,
    moveElemsAttrsToGroup,
    moveGroupAttrsToElems,
    collapseGroups,
    convertPathData,
    convertTransform,
    removeEmptyAttrs,
    removeEmptyContainers,
    mergePaths,
    removeUnusedNS,
    sortAttrs,
    sortDefsChildren,
    removeTitle,
    removeDesc,
  ],
});

var presetDefault_1 = presetDefault;

var addAttributesToSVGElement = {};

addAttributesToSVGElement.name = "addAttributesToSVGElement";
addAttributesToSVGElement.description =
  "adds attributes to an outer <svg> element";

var ENOCLS$1 = `Error in plugin "addAttributesToSVGElement": absent parameters.
It should have a list of "attributes" or one "attribute".
Config example:

plugins: [
  {
    name: 'addAttributesToSVGElement',
    params: {
      attribute: "mySvg"
    }
  }
]

plugins: [
  {
    name: 'addAttributesToSVGElement',
    params: {
      attributes: ["mySvg", "size-big"]
    }
  }
]

plugins: [
  {
    name: 'addAttributesToSVGElement',
    params: {
      attributes: [
        {
          focusable: false
        },
        {
          'data-image': icon
        }
      ]
    }
  }
]
`;

/**
 * Add attributes to an outer <svg> element. Example config:
 *
 * @author April Arcus
 *
 * @type {import('./plugins-types').Plugin<'addAttributesToSVGElement'>}
 */
addAttributesToSVGElement.fn = (root, params) => {
  if (!Array.isArray(params.attributes) && !params.attribute) {
    console.error(ENOCLS$1);
    return null;
  }
  const attributes = params.attributes || [params.attribute];
  return {
    element: {
      enter: (node, parentNode) => {
        if (node.name === "svg" && parentNode.type === "root") {
          for (const attribute of attributes) {
            if (typeof attribute === "string") {
              if (node.attributes[attribute] == null) {
                // @ts-ignore disallow explicit nullable attribute value
                node.attributes[attribute] = undefined;
              }
            }
            if (typeof attribute === "object") {
              for (const key of Object.keys(attribute)) {
                if (node.attributes[key] == null) {
                  // @ts-ignore disallow explicit nullable attribute value
                  node.attributes[key] = attribute[key];
                }
              }
            }
          }
        }
      },
    },
  };
};

var addClassesToSVGElement = {};

addClassesToSVGElement.name = "addClassesToSVGElement";
addClassesToSVGElement.description =
  "adds classnames to an outer <svg> element";

var ENOCLS = `Error in plugin "addClassesToSVGElement": absent parameters.
It should have a list of classes in "classNames" or one "className".
Config example:

plugins: [
  {
    name: "addClassesToSVGElement",
    params: {
      className: "mySvg"
    }
  }
]

plugins: [
  {
    name: "addClassesToSVGElement",
    params: {
      classNames: ["mySvg", "size-big"]
    }
  }
]
`;

/**
 * Add classnames to an outer <svg> element. Example config:
 *
 * plugins: [
 *   {
 *     name: "addClassesToSVGElement",
 *     params: {
 *       className: "mySvg"
 *     }
 *   }
 * ]
 *
 * plugins: [
 *   {
 *     name: "addClassesToSVGElement",
 *     params: {
 *       classNames: ["mySvg", "size-big"]
 *     }
 *   }
 * ]
 *
 * @author April Arcus
 *
 * @type {import('./plugins-types').Plugin<'addClassesToSVGElement'>}
 */
addClassesToSVGElement.fn = (root, params) => {
  if (
    !(Array.isArray(params.classNames) && params.classNames.some(String)) &&
    !params.className
  ) {
    console.error(ENOCLS);
    return null;
  }
  const classNames = params.classNames || [params.className];
  return {
    element: {
      enter: (node, parentNode) => {
        if (node.name === "svg" && parentNode.type === "root") {
          const classList = new Set(
            node.attributes.class == null
              ? null
              : node.attributes.class.split(" "),
          );
          for (const className of classNames) {
            if (className != null) {
              classList.add(className);
            }
          }
          node.attributes.class = Array.from(classList).join(" ");
        }
      },
    },
  };
};

var cleanupListOfValues = {};

const { removeLeadingZero } = tools;

cleanupListOfValues.name = "cleanupListOfValues";
cleanupListOfValues.description =
  "rounds list of values to the fixed precision";

const regNumericValues =
  /^([-+]?\d*\.?\d+([eE][-+]?\d+)?)(px|pt|pc|mm|cm|m|in|ft|em|ex|%)?$/;
const regSeparator = /\s+,?\s*|,\s*/;
const absoluteLengths = {
  // relative to px
  cm: 96 / 2.54,
  mm: 96 / 25.4,
  in: 96,
  pt: 4 / 3,
  pc: 16,
  px: 1,
};

/**
 * Round list of values to the fixed precision.
 *
 * @example
 * <svg viewBox="0 0 200.28423 200.28423" enable-background="new 0 0 200.28423 200.28423">
 *         
 * <svg viewBox="0 0 200.284 200.284" enable-background="new 0 0 200.284 200.284">
 *
 * <polygon points="208.250977 77.1308594 223.069336 ... "/>
 *         
 * <polygon points="208.251 77.131 223.069 ... "/>
 *
 * @author kiyopikko
 *
 * @type {import('./plugins-types').Plugin<'cleanupListOfValues'>}
 */
cleanupListOfValues.fn = (_root, params) => {
  const {
    floatPrecision = 3,
    leadingZero = true,
    defaultPx = true,
    convertToPx = true,
  } = params;

  /**
   * @type {(lists: string) => string}
   */
  const roundValues = (lists) => {
    const roundedList = [];

    for (const elem of lists.split(regSeparator)) {
      const match = elem.match(regNumericValues);
      const matchNew = elem.match(/new/);

      // if attribute value matches regNumericValues
      if (match) {
        // round it to the fixed precision
        let num = Number(Number(match[1]).toFixed(floatPrecision));
        /**
         * @type {any}
         */
        let matchedUnit = match[3] || "";
        /**
         * @type{'' | keyof typeof absoluteLengths}
         */
        let units = matchedUnit;

        // convert absolute values to pixels
        if (convertToPx && units && units in absoluteLengths) {
          const pxNum = Number(
            (absoluteLengths[units] * Number(match[1])).toFixed(floatPrecision),
          );

          if (pxNum.toString().length < match[0].length) {
            num = pxNum;
            units = "px";
          }
        }

        // and remove leading zero
        let str;
        if (leadingZero) {
          str = removeLeadingZero(num);
        } else {
          str = num.toString();
        }

        // remove default 'px' units
        if (defaultPx && units === "px") {
          units = "";
        }

        roundedList.push(str + units);
      }
      // if attribute value is "new"(only enable-background).
      else if (matchNew) {
        roundedList.push("new");
      } else if (elem) {
        roundedList.push(elem);
      }
    }

    return roundedList.join(" ");
  };

  return {
    element: {
      enter: (node) => {
        if (node.attributes.points != null) {
          node.attributes.points = roundValues(node.attributes.points);
        }

        if (node.attributes["enable-background"] != null) {
          node.attributes["enable-background"] = roundValues(
            node.attributes["enable-background"],
          );
        }

        if (node.attributes.viewBox != null) {
          node.attributes.viewBox = roundValues(node.attributes.viewBox);
        }

        if (node.attributes["stroke-dasharray"] != null) {
          node.attributes["stroke-dasharray"] = roundValues(
            node.attributes["stroke-dasharray"],
          );
        }

        if (node.attributes.dx != null) {
          node.attributes.dx = roundValues(node.attributes.dx);
        }

        if (node.attributes.dy != null) {
          node.attributes.dy = roundValues(node.attributes.dy);
        }

        if (node.attributes.x != null) {
          node.attributes.x = roundValues(node.attributes.x);
        }

        if (node.attributes.y != null) {
          node.attributes.y = roundValues(node.attributes.y);
        }
      },
    },
  };
};

var convertOneStopGradients = {};

/**
 * @typedef {import('../lib/types').XastElement} XastElement
 * @typedef {import('../lib/types').XastParent} XastParent
 */

const { attrsGroupsDefaults, colorsProps } = _collections;
const {
  detachNodeFromParent: detachNodeFromParent$6,
  querySelectorAll: querySelectorAll$2,
  querySelector,
} = xast;
const { computeStyle, collectStylesheet: collectStylesheet$1 } = style;

convertOneStopGradients.name = "convertOneStopGradients";
convertOneStopGradients.description =
  "converts one-stop (single color) gradients to a plain color";

/**
 * Converts one-stop (single color) gradients to a plain color.
 *
 * @author Seth Falco <seth@falco.fun>
 * @type {import('./plugins-types').Plugin<'convertOneStopGradients'>}
 * @see https://developer.mozilla.org/docs/Web/SVG/Element/linearGradient
 * @see https://developer.mozilla.org/docs/Web/SVG/Element/radialGradient
 */
convertOneStopGradients.fn = (root) => {
  const stylesheet = collectStylesheet$1(root);

  /**
   * Parent defs that had gradients elements removed from them.
   *
   * @type {Set<XastElement>}
   */
  const effectedDefs = new Set();

  /**
   * @type {Map<XastElement, XastParent>}
   */
  const allDefs = new Map();

  /**
   * @type {Map<XastElement, XastParent>}
   */
  const gradientsToDetach = new Map();

  /** Number of references to the xlink:href attribute. */
  let xlinkHrefCount = 0;

  return {
    element: {
      enter: (node, parentNode) => {
        if (node.attributes["xlink:href"] != null) {
          xlinkHrefCount++;
        }

        if (node.name === "defs") {
          allDefs.set(node, parentNode);
          return;
        }

        if (node.name !== "linearGradient" && node.name !== "radialGradient") {
          return;
        }

        const stops = node.children.filter((child) => {
          return child.type === "element" && child.name === "stop";
        });

        const href = node.attributes["xlink:href"] || node.attributes["href"];
        let effectiveNode =
          stops.length === 0 && href != null && href.startsWith("#")
            ? querySelector(root, href)
            : node;

        if (effectiveNode == null || effectiveNode.type !== "element") {
          gradientsToDetach.set(node, parentNode);
          return;
        }

        const effectiveStops = effectiveNode.children.filter((child) => {
          return child.type === "element" && child.name === "stop";
        });

        if (
          effectiveStops.length !== 1 ||
          effectiveStops[0].type !== "element"
        ) {
          return;
        }

        if (parentNode.type === "element" && parentNode.name === "defs") {
          effectedDefs.add(parentNode);
        }

        gradientsToDetach.set(node, parentNode);

        let color;
        const style = computeStyle(stylesheet, effectiveStops[0])["stop-color"];
        if (style != null && style.type === "static") {
          color = style.value;
        }

        const selectorVal = `url(#${node.attributes.id})`;

        const selector = [...colorsProps]
          .map((attr) => `[${attr}="${selectorVal}"]`)
          .join(",");
        const elements = querySelectorAll$2(root, selector);
        for (const element of elements) {
          if (element.type !== "element") {
            continue;
          }

          for (const attr of colorsProps) {
            if (element.attributes[attr] !== selectorVal) {
              continue;
            }

            if (color != null) {
              element.attributes[attr] = color;
            } else {
              delete element.attributes[attr];
            }
          }
        }

        const styledElements = querySelectorAll$2(
          root,
          `[style*=${selectorVal}]`,
        );
        for (const element of styledElements) {
          if (element.type !== "element") {
            continue;
          }

          element.attributes.style = element.attributes.style.replace(
            selectorVal,
            color || attrsGroupsDefaults.presentation["stop-color"],
          );
        }
      },

      exit: (node) => {
        if (node.name === "svg") {
          for (const [gradient, parent] of gradientsToDetach.entries()) {
            if (gradient.attributes["xlink:href"] != null) {
              xlinkHrefCount--;
            }

            detachNodeFromParent$6(gradient, parent);
          }

          if (xlinkHrefCount === 0) {
            delete node.attributes["xmlns:xlink"];
          }

          for (const [defs, parent] of allDefs.entries()) {
            if (effectedDefs.has(defs) && defs.children.length === 0) {
              detachNodeFromParent$6(defs, parent);
            }
          }
        }
      },
    },
  };
};

var convertStyleToAttrs = {};

const { attrsGroups: attrsGroups$1 } = _collections;

convertStyleToAttrs.name = "convertStyleToAttrs";
convertStyleToAttrs.description = "converts style to attributes";

/**
 * @type {(...args: string[]) => string}
 */
const g = (...args) => {
  return "(?:" + args.join("|") + ")";
};

const stylingProps = attrsGroups$1.presentation;
const rEscape = "\\\\(?:[0-9a-f]{1,6}\\s?|\\r\\n|.)"; // Like \" or \2051. Code points consume one space.
const rAttr = "\\s*(" + g("[^:;\\\\]", rEscape) + "*?)\\s*"; // attribute name like fill
const rSingleQuotes = "'(?:[^'\\n\\r\\\\]|" + rEscape + ")*?(?:'|$)"; // string in single quotes: 'smth'
const rQuotes = '"(?:[^"\\n\\r\\\\]|' + rEscape + ')*?(?:"|$)'; // string in double quotes: "smth"
const rQuotedString = new RegExp("^" + g(rSingleQuotes, rQuotes) + "$");
// Parentheses, E.g.: url(data:image/png;base64,iVBO...).
// ':' and ';' inside of it should be treated as is. (Just like in strings.)
const rParenthesis =
  "\\(" + g("[^'\"()\\\\]+", rEscape, rSingleQuotes, rQuotes) + "*?" + "\\)";
// The value. It can have strings and parentheses (see above). Fallbacks to anything in case of unexpected input.
const rValue =
  "\\s*(" +
  g(
    "[^!'\"();\\\\]+?",
    rEscape,
    rSingleQuotes,
    rQuotes,
    rParenthesis,
    "[^;]*?",
  ) +
  "*?" +
  ")";
// End of declaration. Spaces outside of capturing groups help to do natural trimming.
const rDeclEnd = "\\s*(?:;\\s*|$)";
// Important rule
const rImportant = "(\\s*!important(?![-(\\w]))?";
// Final RegExp to parse CSS declarations.
const regDeclarationBlock = new RegExp(
  rAttr + ":" + rValue + rImportant + rDeclEnd,
  "ig",
);
// Comments expression. Honors escape sequences and strings.
const regStripComments = new RegExp(
  g(rEscape, rSingleQuotes, rQuotes, "/\\*[^]*?\\*/"),
  "ig",
);

/**
 * Convert style in attributes. Cleanups comments and illegal declarations (without colon) as a side effect.
 *
 * @example
 * <g style="fill:#000; color: #fff;">
 *             
 * <g fill="#000" color="#fff">
 *
 * @example
 * <g style="fill:#000; color: #fff; -webkit-blah: blah">
 *             
 * <g fill="#000" color="#fff" style="-webkit-blah: blah">
 *
 * @author Kir Belevich
 *
 * @type {import('./plugins-types').Plugin<'convertStyleToAttrs'>}
 */
convertStyleToAttrs.fn = (_root, params) => {
  const { keepImportant = false } = params;
  return {
    element: {
      enter: (node) => {
        if (node.attributes.style != null) {
          // ['opacity: 1', 'color: #000']
          let styles = [];
          /**
           * @type {Record<string, string>}
           */
          const newAttributes = {};

          // Strip CSS comments preserving escape sequences and strings.
          const styleValue = node.attributes.style.replace(
            regStripComments,
            (match) => {
              return match[0] == "/"
                ? ""
                : match[0] == "\\" && /[-g-z]/i.test(match[1])
                  ? match[1]
                  : match;
            },
          );

          regDeclarationBlock.lastIndex = 0;
          for (var rule; (rule = regDeclarationBlock.exec(styleValue)); ) {
            if (!keepImportant || !rule[3]) {
              styles.push([rule[1], rule[2]]);
            }
          }

          if (styles.length) {
            styles = styles.filter(function (style) {
              if (style[0]) {
                var prop = style[0].toLowerCase(),
                  val = style[1];

                if (rQuotedString.test(val)) {
                  val = val.slice(1, -1);
                }

                if (stylingProps.has(prop)) {
                  newAttributes[prop] = val;

                  return false;
                }
              }

              return true;
            });

            Object.assign(node.attributes, newAttributes);

            if (styles.length) {
              node.attributes.style = styles
                .map((declaration) => declaration.join(":"))
                .join(";");
            } else {
              delete node.attributes.style;
            }
          }
        }
      },
    },
  };
};

var prefixIds = {};

/**
 * @typedef {import('../lib/types.js').PluginInfo} PluginInfo
 * @typedef {import('../lib/types').XastElement} XastElement
 */

const csstree = cjs$2;
const { referencesProps } = _collections;

prefixIds.name = "prefixIds";
prefixIds.description = "prefix IDs";

/**
 * extract basename from path
 * @type {(path: string) => string}
 */
const getBasename = (path) => {
  // extract everything after latest slash or backslash
  const matched = /[/\\]?([^/\\]+)$/.exec(path);
  if (matched) {
    return matched[1];
  }
  return "";
};

/**
 * escapes a string for being used as ID
 * @type {(string: string) => string}
 */
const escapeIdentifierName = (str) => {
  return str.replace(/[. ]/g, "_");
};

/**
 * @type {(string: string) => string}
 */
const unquote = (string) => {
  if (
    (string.startsWith('"') && string.endsWith('"')) ||
    (string.startsWith("'") && string.endsWith("'"))
  ) {
    return string.slice(1, -1);
  }
  return string;
};

/**
 * Prefix the given string, unless it already starts with the generated prefix.
 *
 * @param {(id: string) => string} prefixGenerator Function to generate a prefix.
 * @param {string} body An arbitrary string.
 * @returns {string} The given string with a prefix prepended to it.
 */
const prefixId = (prefixGenerator, body) => {
  const prefix = prefixGenerator(body);
  if (body.startsWith(prefix)) {
    return body;
  }
  return prefix + body;
};

/**
 * Insert the prefix in a reference string. A reference string is already
 * prefixed with #, so the prefix is inserted after the first character.
 *
 * @param {(id: string) => string} prefixGenerator Function to generate a prefix.
 * @param {string} reference An arbitrary string, should start with "#".
 * @returns {?string} The given string with a prefix inserted, or null if the string did not start with "#".
 */
const prefixReference = (prefixGenerator, reference) => {
  if (reference.startsWith("#")) {
    return "#" + prefixId(prefixGenerator, reference.slice(1));
  }
  return null;
};

/**
 * Generates a prefix for the given string.
 *
 * @param {string} body An arbitrary string.
 * @param {XastElement} node XML node that the identifier belongs to.
 * @param {PluginInfo} info
 * @param {((node: XastElement, info: PluginInfo) => string)|string|boolean|undefined} prefixGenerator Some way of obtaining a prefix.
 * @param {string} delim Content to insert between the prefix and original value.
 * @param {Map<string, string>} history Map of previously generated prefixes to IDs.
 * @returns {string} A generated prefix.
 */
const generatePrefix = (body, node, info, prefixGenerator, delim, history) => {
  if (typeof prefixGenerator === "function") {
    let prefix = history.get(body);

    if (prefix != null) {
      return prefix;
    }

    prefix = prefixGenerator(node, info) + delim;
    history.set(body, prefix);
    return prefix;
  }

  if (typeof prefixGenerator === "string") {
    return prefixGenerator + delim;
  }

  if (prefixGenerator === false) {
    return "";
  }

  if (info.path != null && info.path.length > 0) {
    return escapeIdentifierName(getBasename(info.path)) + delim;
  }

  return "prefix" + delim;
};

/**
 * Prefixes identifiers
 *
 * @author strarsis <strarsis@gmail.com>
 * @type {import('./plugins-types').Plugin<'prefixIds'>}
 */
prefixIds.fn = (_root, params, info) => {
  const {
    delim = "__",
    prefix,
    prefixIds = true,
    prefixClassNames = true,
  } = params;

  /** @type {Map<string, string>} */
  const prefixMap = new Map();

  return {
    element: {
      enter: (node) => {
        /**
         * @param {string} id A node identifier or class.
         * @returns {string} Given string with a prefix inserted, or null if the string did not start with "#".
         */
        const prefixGenerator = (id) =>
          generatePrefix(id, node, info, prefix, delim, prefixMap);

        // prefix id/class selectors and url() references in styles
        if (node.name === "style") {
          // skip empty <style/> elements
          if (node.children.length === 0) {
            return;
          }

          for (const child of node.children) {
            if (child.type !== "text" && child.type !== "cdata") {
              continue;
            }

            const cssText = child.value;
            /** @type {?csstree.CssNode} */
            let cssAst = null;
            try {
              cssAst = csstree.parse(cssText, {
                parseValue: true,
                parseCustomProperty: false,
              });
            } catch {
              return;
            }

            csstree.walk(cssAst, (node) => {
              if (
                (prefixIds && node.type === "IdSelector") ||
                (prefixClassNames && node.type === "ClassSelector")
              ) {
                node.name = prefixId(prefixGenerator, node.name);
                return;
              }
              if (node.type === "Url" && node.value.length > 0) {
                const prefixed = prefixReference(
                  prefixGenerator,
                  unquote(node.value),
                );
                if (prefixed != null) {
                  node.value = prefixed;
                }
              }
            });

            child.value = csstree.generate(cssAst);
            return;
          }
        }

        // prefix an ID attribute value
        if (
          prefixIds &&
          node.attributes.id != null &&
          node.attributes.id.length !== 0
        ) {
          node.attributes.id = prefixId(prefixGenerator, node.attributes.id);
        }

        // prefix a class attribute value
        if (
          prefixClassNames &&
          node.attributes.class != null &&
          node.attributes.class.length !== 0
        ) {
          node.attributes.class = node.attributes.class
            .split(/\s+/)
            .map((name) => prefixId(prefixGenerator, name))
            .join(" ");
        }

        // prefix a href attribute value
        // xlink:href is deprecated, must be still supported
        for (const name of ["href", "xlink:href"]) {
          if (
            node.attributes[name] != null &&
            node.attributes[name].length !== 0
          ) {
            const prefixed = prefixReference(
              prefixGenerator,
              node.attributes[name],
            );
            if (prefixed != null) {
              node.attributes[name] = prefixed;
            }
          }
        }

        // prefix a URL attribute value
        for (const name of referencesProps) {
          if (
            node.attributes[name] != null &&
            node.attributes[name].length !== 0
          ) {
            node.attributes[name] = node.attributes[name].replace(
              /\burl\((["'])?(#.+?)\1\)/gi,
              (match, _, url) => {
                const prefixed = prefixReference(prefixGenerator, url);
                if (prefixed == null) {
                  return match;
                }
                return `url(${prefixed})`;
              },
            );
          }
        }

        // prefix begin/end attribute value
        for (const name of ["begin", "end"]) {
          if (
            node.attributes[name] != null &&
            node.attributes[name].length !== 0
          ) {
            const parts = node.attributes[name].split(/\s*;\s+/).map((val) => {
              if (val.endsWith(".end") || val.endsWith(".start")) {
                const [id, postfix] = val.split(".");
                return `${prefixId(prefixGenerator, id)}.${postfix}`;
              }
              return val;
            });
            node.attributes[name] = parts.join("; ");
          }
        }
      },
    },
  };
};

var removeAttributesBySelector = {};

const { querySelectorAll: querySelectorAll$1 } = xast;

removeAttributesBySelector.name = "removeAttributesBySelector";
removeAttributesBySelector.description =
  "removes attributes of elements that match a css selector";

/**
 * Removes attributes of elements that match a css selector.
 *
 * @example
 * <caption>A selector removing a single attribute</caption>
 * plugins: [
 *   {
 *     name: "removeAttributesBySelector",
 *     params: {
 *       selector: "[fill='#00ff00']"
 *       attributes: "fill"
 *     }
 *   }
 * ]
 *
 * <rect x="0" y="0" width="100" height="100" fill="#00ff00" stroke="#00ff00"/>
 *   
 * <rect x="0" y="0" width="100" height="100" stroke="#00ff00"/>
 *
 * <caption>A selector removing multiple attributes</caption>
 * plugins: [
 *   {
 *     name: "removeAttributesBySelector",
 *     params: {
 *       selector: "[fill='#00ff00']",
 *       attributes: [
 *         "fill",
 *         "stroke"
 *       ]
 *     }
 *   }
 * ]
 *
 * <rect x="0" y="0" width="100" height="100" fill="#00ff00" stroke="#00ff00"/>
 *   
 * <rect x="0" y="0" width="100" height="100"/>
 *
 * <caption>Multiple selectors removing attributes</caption>
 * plugins: [
 *   {
 *     name: "removeAttributesBySelector",
 *     params: {
 *       selectors: [
 *         {
 *           selector: "[fill='#00ff00']",
 *           attributes: "fill"
 *         },
 *         {
 *           selector: "#remove",
 *           attributes: [
 *             "stroke",
 *             "id"
 *           ]
 *         }
 *       ]
 *     }
 *   }
 * ]
 *
 * <rect x="0" y="0" width="100" height="100" fill="#00ff00" stroke="#00ff00"/>
 *   
 * <rect x="0" y="0" width="100" height="100"/>
 *
 * @link https://developer.mozilla.org/docs/Web/CSS/CSS_Selectors|MDN CSS Selectors
 *
 * @author Bradley Mease
 *
 * @type {import('./plugins-types').Plugin<'removeAttributesBySelector'>}
 */
removeAttributesBySelector.fn = (root, params) => {
  const selectors = Array.isArray(params.selectors)
    ? params.selectors
    : [params];
  for (const { selector, attributes } of selectors) {
    const nodes = querySelectorAll$1(root, selector);
    for (const node of nodes) {
      if (node.type === "element") {
        if (Array.isArray(attributes)) {
          for (const name of attributes) {
            delete node.attributes[name];
          }
        } else {
          delete node.attributes[attributes];
        }
      }
    }
  }
  return {};
};

var removeAttrs = {};

removeAttrs.name = "removeAttrs";
removeAttrs.description = "removes specified attributes";

const DEFAULT_SEPARATOR = ":";
const ENOATTRS = `Warning: The plugin "removeAttrs" requires the "attrs" parameter.
It should have a pattern to remove, otherwise the plugin is a noop.
Config example:

plugins: [
  {
    name: "removeAttrs",
    params: {
      attrs: "(fill|stroke)"
    }
  }
]
`;

/**
 * Remove attributes
 *
 * @example elemSeparator
 *   format: string
 *
 * @example preserveCurrentColor
 *   format: boolean
 *
 * @example attrs:
 *
 *   format: [ element* : attribute* : value* ]
 *
 *   element   : regexp (wrapped into ^...$), single * or omitted > all elements (must be present when value is used)
 *   attribute : regexp (wrapped into ^...$)
 *   value     : regexp (wrapped into ^...$), single * or omitted > all values
 *
 *   examples:
 *
 *     > basic: remove fill attribute
 *     ---
 *     removeAttrs:
 *       attrs: 'fill'
 *
 *     > remove fill attribute on path element
 *     ---
 *       attrs: 'path:fill'
 *
 *     > remove fill attribute on path element where value is none
 *     ---
 *       attrs: 'path:fill:none'
 *
 *
 *     > remove all fill and stroke attribute
 *     ---
 *       attrs:
 *         - 'fill'
 *         - 'stroke'
 *
 *     [is same as]
 *
 *       attrs: '(fill|stroke)'
 *
 *     [is same as]
 *
 *       attrs: '*:(fill|stroke)'
 *
 *     [is same as]
 *
 *       attrs: '.*:(fill|stroke)'
 *
 *     [is same as]
 *
 *       attrs: '.*:(fill|stroke):.*'
 *
 *
 *     > remove all stroke related attributes
 *     ----
 *     attrs: 'stroke.*'
 *
 *
 * @author Benny Schudel
 *
 * @type {import('./plugins-types').Plugin<'removeAttrs'>}
 */
removeAttrs.fn = (root, params) => {
  if (typeof params.attrs == "undefined") {
    console.warn(ENOATTRS);
    return null;
  }

  const elemSeparator =
    typeof params.elemSeparator == "string"
      ? params.elemSeparator
      : DEFAULT_SEPARATOR;
  const preserveCurrentColor =
    typeof params.preserveCurrentColor == "boolean"
      ? params.preserveCurrentColor
      : false;
  const attrs = Array.isArray(params.attrs) ? params.attrs : [params.attrs];

  return {
    element: {
      enter: (node) => {
        for (let pattern of attrs) {
          // if no element separators (:), assume it's attribute name, and apply to all elements *regardless of value*
          if (!pattern.includes(elemSeparator)) {
            pattern = [".*", pattern, ".*"].join(elemSeparator);
            // if only 1 separator, assume it's element and attribute name, and apply regardless of attribute value
          } else if (pattern.split(elemSeparator).length < 3) {
            pattern = [pattern, ".*"].join(elemSeparator);
          }

          // create regexps for element, attribute name, and attribute value
          const list = pattern.split(elemSeparator).map((value) => {
            // adjust single * to match anything
            if (value === "*") {
              value = ".*";
            }
            return new RegExp(["^", value, "$"].join(""), "i");
          });

          // matches element
          if (list[0].test(node.name)) {
            // loop attributes
            for (const [name, value] of Object.entries(node.attributes)) {
              const isFillCurrentColor =
                preserveCurrentColor &&
                name == "fill" &&
                value == "currentColor";
              const isStrokeCurrentColor =
                preserveCurrentColor &&
                name == "stroke" &&
                value == "currentColor";
              if (
                !isFillCurrentColor &&
                !isStrokeCurrentColor &&
                // matches attribute name
                list[1].test(name) &&
                // matches attribute value
                list[2].test(value)
              ) {
                delete node.attributes[name];
              }
            }
          }
        }
      },
    },
  };
};

var removeDimensions = {};

removeDimensions.name = "removeDimensions";
removeDimensions.description =
  "removes width and height in presence of viewBox (opposite to removeViewBox, disable it first)";

/**
 * Remove width/height attributes and add the viewBox attribute if it's missing
 *
 * @example
 * <svg width="100" height="50" />
 *   
 * <svg viewBox="0 0 100 50" />
 *
 * @author Benny Schudel
 *
 * @type {import('./plugins-types').Plugin<'removeDimensions'>}
 */
removeDimensions.fn = () => {
  return {
    element: {
      enter: (node) => {
        if (node.name === "svg") {
          if (node.attributes.viewBox != null) {
            delete node.attributes.width;
            delete node.attributes.height;
          } else if (
            node.attributes.width != null &&
            node.attributes.height != null &&
            Number.isNaN(Number(node.attributes.width)) === false &&
            Number.isNaN(Number(node.attributes.height)) === false
          ) {
            const width = Number(node.attributes.width);
            const height = Number(node.attributes.height);
            node.attributes.viewBox = `0 0 ${width} ${height}`;
            delete node.attributes.width;
            delete node.attributes.height;
          }
        }
      },
    },
  };
};

var removeElementsByAttr = {};

const { detachNodeFromParent: detachNodeFromParent$5 } = xast;

removeElementsByAttr.name = "removeElementsByAttr";
removeElementsByAttr.description =
  "removes arbitrary elements by ID or className (disabled by default)";

/**
 * Remove arbitrary SVG elements by ID or className.
 *
 * @example id
 *     > single: remove element with ID of `elementID`
 *     ---
 *     removeElementsByAttr:
 *       id: 'elementID'
 *
 *     > list: remove multiple elements by ID
 *     ---
 *     removeElementsByAttr:
 *       id:
 *         - 'elementID'
 *         - 'anotherID'
 *
 * @example class
 *     > single: remove all elements with class of `elementClass`
 *     ---
 *     removeElementsByAttr:
 *       class: 'elementClass'
 *
 *     > list: remove all elements with class of `elementClass` or `anotherClass`
 *     ---
 *     removeElementsByAttr:
 *       class:
 *         - 'elementClass'
 *         - 'anotherClass'
 *
 * @author Eli Dupuis (@elidupuis)
 *
 * @type {import('./plugins-types').Plugin<'removeElementsByAttr'>}
 */
removeElementsByAttr.fn = (root, params) => {
  const ids =
    params.id == null ? [] : Array.isArray(params.id) ? params.id : [params.id];
  const classes =
    params.class == null
      ? []
      : Array.isArray(params.class)
        ? params.class
        : [params.class];
  return {
    element: {
      enter: (node, parentNode) => {
        // remove element if it's `id` matches configured `id` params
        if (node.attributes.id != null && ids.length !== 0) {
          if (ids.includes(node.attributes.id)) {
            detachNodeFromParent$5(node, parentNode);
          }
        }
        // remove element if it's `class` contains any of the configured `class` params
        if (node.attributes.class && classes.length !== 0) {
          const classList = node.attributes.class.split(" ");
          for (const item of classes) {
            if (classList.includes(item)) {
              detachNodeFromParent$5(node, parentNode);
              break;
            }
          }
        }
      },
    },
  };
};

var removeOffCanvasPaths = {};

/**
 * @typedef {import('../lib/types').PathDataItem} PathDataItem
 */

const { visitSkip, detachNodeFromParent: detachNodeFromParent$4 } = xast;
const { parsePathData } = path$6;
const { intersects } = _path$1;

removeOffCanvasPaths.name = "removeOffCanvasPaths";
removeOffCanvasPaths.description =
  "removes elements that are drawn outside of the viewbox (disabled by default)";

/**
 * Remove elements that are drawn outside of the viewbox.
 *
 * @author JoshyPHP
 *
 * @type {import('./plugins-types').Plugin<'removeOffCanvasPaths'>}
 */
removeOffCanvasPaths.fn = () => {
  /**
   * @type {?{
   *   top: number,
   *   right: number,
   *   bottom: number,
   *   left: number,
   *   width: number,
   *   height: number
   * }}
   */
  let viewBoxData = null;

  return {
    element: {
      enter: (node, parentNode) => {
        if (node.name === "svg" && parentNode.type === "root") {
          let viewBox = "";
          // find viewbox
          if (node.attributes.viewBox != null) {
            // remove commas and plus signs, normalize and trim whitespace
            viewBox = node.attributes.viewBox;
          } else if (
            node.attributes.height != null &&
            node.attributes.width != null
          ) {
            viewBox = `0 0 ${node.attributes.width} ${node.attributes.height}`;
          }

          // parse viewbox
          // remove commas and plus signs, normalize and trim whitespace
          viewBox = viewBox
            .replace(/[,+]|px/g, " ")
            .replace(/\s+/g, " ")
            .replace(/^\s*|\s*$/g, "");
          // ensure that the dimensions are 4 values separated by space
          const m =
            /^(-?\d*\.?\d+) (-?\d*\.?\d+) (\d*\.?\d+) (\d*\.?\d+)$/.exec(
              viewBox,
            );
          if (m == null) {
            return;
          }
          const left = Number.parseFloat(m[1]);
          const top = Number.parseFloat(m[2]);
          const width = Number.parseFloat(m[3]);
          const height = Number.parseFloat(m[4]);

          // store the viewBox boundaries
          viewBoxData = {
            left,
            top,
            right: left + width,
            bottom: top + height,
            width,
            height,
          };
        }

        // consider that any item with a transform attribute is visible
        if (node.attributes.transform != null) {
          return visitSkip;
        }

        if (
          node.name === "path" &&
          node.attributes.d != null &&
          viewBoxData != null
        ) {
          const pathData = parsePathData(node.attributes.d);

          // consider that a M command within the viewBox is visible
          let visible = false;
          for (const pathDataItem of pathData) {
            if (pathDataItem.command === "M") {
              const [x, y] = pathDataItem.args;
              if (
                x >= viewBoxData.left &&
                x <= viewBoxData.right &&
                y >= viewBoxData.top &&
                y <= viewBoxData.bottom
              ) {
                visible = true;
              }
            }
          }
          if (visible) {
            return;
          }

          if (pathData.length === 2) {
            // close the path too short for intersects()
            pathData.push({ command: "z", args: [] });
          }

          const { left, top, width, height } = viewBoxData;
          /**
           * @type {PathDataItem[]}
           */
          const viewBoxPathData = [
            { command: "M", args: [left, top] },
            { command: "h", args: [width] },
            { command: "v", args: [height] },
            { command: "H", args: [left] },
            { command: "z", args: [] },
          ];

          if (intersects(viewBoxPathData, pathData) === false) {
            detachNodeFromParent$4(node, parentNode);
          }
        }
      },
    },
  };
};

var removeRasterImages = {};

const { detachNodeFromParent: detachNodeFromParent$3 } = xast;

removeRasterImages.name = "removeRasterImages";
removeRasterImages.description = "removes raster images (disabled by default)";

/**
 * Remove raster images references in <image>.
 *
 * @see https://bugs.webkit.org/show_bug.cgi?id=63548
 *
 * @author Kir Belevich
 *
 * @type {import('./plugins-types').Plugin<'removeRasterImages'>}
 */
removeRasterImages.fn = () => {
  return {
    element: {
      enter: (node, parentNode) => {
        if (
          node.name === "image" &&
          node.attributes["xlink:href"] != null &&
          /(\.|image\/)(jpe?g|png|gif)/.test(node.attributes["xlink:href"])
        ) {
          detachNodeFromParent$3(node, parentNode);
        }
      },
    },
  };
};

var removeScriptElement = {};

const { detachNodeFromParent: detachNodeFromParent$2 } = xast;
const { attrsGroups } = _collections;

removeScriptElement.name = "removeScriptElement";
removeScriptElement.description = "removes scripts (disabled by default)";

/** Union of all event attributes. */
const eventAttrs = [
  ...attrsGroups.animationEvent,
  ...attrsGroups.documentEvent,
  ...attrsGroups.documentElementEvent,
  ...attrsGroups.globalEvent,
  ...attrsGroups.graphicalEvent,
];

/**
 * Remove scripts.
 *
 * https://www.w3.org/TR/SVG11/script.html
 *
 * @author Patrick Klingemann
 * @type {import('./plugins-types').Plugin<'removeScriptElement'>}
 */
removeScriptElement.fn = () => {
  return {
    element: {
      enter: (node, parentNode) => {
        if (node.name === "script") {
          detachNodeFromParent$2(node, parentNode);
          return;
        }

        for (const attr of eventAttrs) {
          if (node.attributes[attr] != null) {
            delete node.attributes[attr];
          }
        }
      },
      exit: (node, parentNode) => {
        if (node.name !== "a") {
          return;
        }

        for (const attr of Object.keys(node.attributes)) {
          if (attr === "href" || attr.endsWith(":href")) {
            if (
              node.attributes[attr] == null ||
              !node.attributes[attr].trimStart().startsWith("javascript:")
            ) {
              continue;
            }

            const index = parentNode.children.indexOf(node);
            parentNode.children.splice(index, 1, ...node.children);

            // TODO remove legacy parentNode in v4
            for (const child of node.children) {
              Object.defineProperty(child, "parentNode", {
                writable: true,
                value: parentNode,
              });
            }
          }
        }
      },
    },
  };
};

var removeStyleElement = {};

const { detachNodeFromParent: detachNodeFromParent$1 } = xast;

removeStyleElement.name = "removeStyleElement";
removeStyleElement.description =
  "removes <style> element (disabled by default)";

/**
 * Remove <style>.
 *
 * https://www.w3.org/TR/SVG11/styling.html#StyleElement
 *
 * @author Betsy Dupuis
 *
 * @type {import('./plugins-types').Plugin<'removeStyleElement'>}
 */
removeStyleElement.fn = () => {
  return {
    element: {
      enter: (node, parentNode) => {
        if (node.name === "style") {
          detachNodeFromParent$1(node, parentNode);
        }
      },
    },
  };
};

var removeXlink = {};

const { elems } = _collections;

/**
 * @typedef {import('../lib/types').XastElement} XastElement
 */

removeXlink.name = "removeXlink";
removeXlink.description =
  "remove xlink namespace and replaces attributes with the SVG 2 equivalent where applicable";

/** URI indicating the Xlink namespace. */
const XLINK_NAMESPACE = "http://www.w3.org/1999/xlink";

/**
 * Map of `xlink:show` values to the SVG 2 `target` attribute values.
 *
 * @type {Record<string, string>}
 * @see https://developer.mozilla.org/docs/Web/SVG/Attribute/xlink:show#usage_notes
 */
const SHOW_TO_TARGET = {
  new: "_blank",
  replace: "_self",
};

/**
 * Elements that use xlink:href, but were deprecated in SVG 2 and therefore
 * don't support the SVG 2 href attribute.
 *
 * @type {Set<string>}
 * @see https://developer.mozilla.org/docs/Web/SVG/Attribute/xlink:href
 * @see https://developer.mozilla.org/docs/Web/SVG/Attribute/href
 */
const LEGACY_ELEMENTS = new Set([
  "cursor",
  "filter",
  "font-face-uri",
  "glyphRef",
  "tref",
]);

/**
 * @param {XastElement} node
 * @param {string[]} prefixes
 * @param {string} attr
 * @returns {string[]}
 */
const findPrefixedAttrs = (node, prefixes, attr) => {
  return prefixes
    .map((prefix) => `${prefix}:${attr}`)
    .filter((attr) => node.attributes[attr] != null);
};

/**
 * Removes XLink namespace prefixes and converts references to XLink attributes
 * to the native SVG equivalent.
 *
 * The XLink namespace is deprecated in SVG 2.
 *
 * @type {import('./plugins-types').Plugin<'removeXlink'>}
 * @see https://developer.mozilla.org/docs/Web/SVG/Attribute/xlink:href
 */
removeXlink.fn = (_, params) => {
  const { includeLegacy } = params;

  /**
   * XLink namespace prefixes that are currently in the stack.
   *
   * @type {string[]}
   */
  const xlinkPrefixes = [];

  /**
   * Namespace prefixes that exist in {@link xlinkPrefixes} but were overridden
   * in a child element to point to another namespace, and so is not treated as
   * an XLink attribute.
   *
   * @type {string[]}
   */
  const overriddenPrefixes = [];

  /**
   * Namespace prefixes that were used in one of the {@link LEGACY_ELEMENTS}.
   *
   * @type {string[]}
   */
  const usedInLegacyElement = [];

  return {
    element: {
      enter: (node) => {
        for (const [key, value] of Object.entries(node.attributes)) {
          if (key.startsWith("xmlns:")) {
            const prefix = key.split(":", 2)[1];

            if (value === XLINK_NAMESPACE) {
              xlinkPrefixes.push(prefix);
              continue;
            }

            if (xlinkPrefixes.includes(prefix)) {
              overriddenPrefixes.push(prefix);
            }
          }
        }

        if (
          overriddenPrefixes.some((prefix) => xlinkPrefixes.includes(prefix))
        ) {
          return;
        }

        const showAttrs = findPrefixedAttrs(node, xlinkPrefixes, "show");
        let showHandled = node.attributes.target != null;
        for (let i = showAttrs.length - 1; i >= 0; i--) {
          const attr = showAttrs[i];
          const value = node.attributes[attr];
          const mapping = SHOW_TO_TARGET[value];

          if (showHandled || mapping == null) {
            delete node.attributes[attr];
            continue;
          }

          if (mapping !== elems[node.name]?.defaults?.target) {
            node.attributes.target = mapping;
          }

          delete node.attributes[attr];
          showHandled = true;
        }

        const titleAttrs = findPrefixedAttrs(node, xlinkPrefixes, "title");
        for (let i = titleAttrs.length - 1; i >= 0; i--) {
          const attr = titleAttrs[i];
          const value = node.attributes[attr];
          const hasTitle = node.children.filter(
            (child) => child.type === "element" && child.name === "title",
          );

          if (hasTitle.length > 0) {
            delete node.attributes[attr];
            continue;
          }

          /** @type {XastElement} */
          const titleTag = {
            type: "element",
            name: "title",
            attributes: {},
            children: [
              {
                type: "text",
                value,
              },
            ],
          };

          Object.defineProperty(titleTag, "parentNode", {
            writable: true,
            value: node,
          });

          node.children.unshift(titleTag);
          delete node.attributes[attr];
        }

        const hrefAttrs = findPrefixedAttrs(node, xlinkPrefixes, "href");

        if (
          hrefAttrs.length > 0 &&
          LEGACY_ELEMENTS.has(node.name) &&
          !includeLegacy
        ) {
          hrefAttrs
            .map((attr) => attr.split(":", 1)[0])
            .forEach((prefix) => usedInLegacyElement.push(prefix));
          return;
        }

        for (let i = hrefAttrs.length - 1; i >= 0; i--) {
          const attr = hrefAttrs[i];
          const value = node.attributes[attr];

          if (node.attributes.href != null) {
            delete node.attributes[attr];
            continue;
          }

          node.attributes.href = value;
          delete node.attributes[attr];
        }
      },
      exit: (node) => {
        for (const [key, value] of Object.entries(node.attributes)) {
          const [prefix, attr] = key.split(":", 2);

          if (
            xlinkPrefixes.includes(prefix) &&
            !overriddenPrefixes.includes(prefix) &&
            !usedInLegacyElement.includes(prefix) &&
            !includeLegacy
          ) {
            delete node.attributes[key];
            continue;
          }

          if (key.startsWith("xmlns:") && !usedInLegacyElement.includes(attr)) {
            if (value === XLINK_NAMESPACE) {
              const index = xlinkPrefixes.indexOf(attr);
              xlinkPrefixes.splice(index, 1);
              delete node.attributes[key];
              continue;
            }

            if (overriddenPrefixes.includes(prefix)) {
              const index = overriddenPrefixes.indexOf(attr);
              overriddenPrefixes.splice(index, 1);
            }
          }
        }
      },
    },
  };
};

var removeXMLNS = {};

removeXMLNS.name = "removeXMLNS";
removeXMLNS.description =
  "removes xmlns attribute (for inline svg, disabled by default)";

/**
 * Remove the xmlns attribute when present.
 *
 * @example
 * <svg viewBox="0 0 100 50" xmlns="http://www.w3.org/2000/svg">
 *   
 * <svg viewBox="0 0 100 50">
 *
 * @author Ricardo Tomasi
 *
 * @type {import('./plugins-types').Plugin<'removeXMLNS'>}
 */
removeXMLNS.fn = () => {
  return {
    element: {
      enter: (node) => {
        if (node.name === "svg") {
          delete node.attributes.xmlns;
        }
      },
    },
  };
};

var reusePaths = {};

const { collectStylesheet } = style;
const { detachNodeFromParent, querySelectorAll } = xast;

/**
 * @typedef {import('../lib/types').XastElement} XastElement
 * @typedef {import('../lib/types').XastParent} XastParent
 * @typedef {import('../lib/types').XastNode} XastNode
 */

reusePaths.name = "reusePaths";
reusePaths.description =
  "Finds <path> elements with the same d, fill, and " +
  "stroke, and converts them to <use> elements " +
  "referencing a single <path> def.";

/**
 * Finds <path> elements with the same d, fill, and stroke, and converts them to
 * <use> elements referencing a single <path> def.
 *
 * @author Jacob Howcroft
 *
 * @type {import('./plugins-types').Plugin<'reusePaths'>}
 */
reusePaths.fn = (root) => {
  const stylesheet = collectStylesheet(root);

  /**
   * @type {Map<string, XastElement[]>}
   */
  const paths = new Map();

  /**
   * Reference to the first defs element that is a direct child of the svg
   * element if one exists.
   *
   * @type {XastElement}
   * @see https://developer.mozilla.org/docs/Web/SVG/Element/defs
   */
  let svgDefs;

  /**
   * Set of hrefs that reference the id of another node.
   *
   * @type {Set<string>}
   */
  const hrefs = new Set();

  return {
    element: {
      enter: (node, parentNode) => {
        if (node.name === "path" && node.attributes.d != null) {
          const d = node.attributes.d;
          const fill = node.attributes.fill || "";
          const stroke = node.attributes.stroke || "";
          const key = d + ";s:" + stroke + ";f:" + fill;
          let list = paths.get(key);
          if (list == null) {
            list = [];
            paths.set(key, list);
          }
          list.push(node);
        }

        if (
          svgDefs == null &&
          node.name === "defs" &&
          parentNode.type === "element" &&
          parentNode.name === "svg"
        ) {
          svgDefs = node;
        }

        if (node.name === "use") {
          for (const name of ["href", "xlink:href"]) {
            const href = node.attributes[name];

            if (href != null && href.startsWith("#") && href.length > 1) {
              hrefs.add(href.slice(1));
            }
          }
        }
      },

      exit: (node, parentNode) => {
        if (node.name === "svg" && parentNode.type === "root") {
          let defsTag = svgDefs;

          if (defsTag == null) {
            defsTag = {
              type: "element",
              name: "defs",
              attributes: {},
              children: [],
            };
            // TODO remove legacy parentNode in v4
            Object.defineProperty(defsTag, "parentNode", {
              writable: true,
              value: node,
            });
          }

          let index = 0;
          for (const list of paths.values()) {
            if (list.length > 1) {
              /** @type {XastElement} */
              const reusablePath = {
                type: "element",
                name: "path",
                attributes: {},
                children: [],
              };

              for (const attr of ["fill", "stroke", "d"]) {
                if (list[0].attributes[attr] != null) {
                  reusablePath.attributes[attr] = list[0].attributes[attr];
                }
              }

              const originalId = list[0].attributes.id;
              if (
                originalId == null ||
                hrefs.has(originalId) ||
                stylesheet.rules.some(
                  (rule) => rule.selector === `#${originalId}`,
                )
              ) {
                reusablePath.attributes.id = "reuse-" + index++;
              } else {
                reusablePath.attributes.id = originalId;
                delete list[0].attributes.id;
              }
              // TODO remove legacy parentNode in v4
              Object.defineProperty(reusablePath, "parentNode", {
                writable: true,
                value: defsTag,
              });
              defsTag.children.push(reusablePath);
              // convert paths to <use>
              for (const pathNode of list) {
                delete pathNode.attributes.d;
                delete pathNode.attributes.stroke;
                delete pathNode.attributes.fill;

                if (
                  defsTag.children.includes(pathNode) &&
                  pathNode.children.length === 0
                ) {
                  if (Object.keys(pathNode.attributes).length === 0) {
                    detachNodeFromParent(pathNode, defsTag);
                    continue;
                  }

                  if (
                    Object.keys(pathNode.attributes).length === 1 &&
                    pathNode.attributes.id != null
                  ) {
                    detachNodeFromParent(pathNode, defsTag);
                    const selector = `[xlink\\:href=#${pathNode.attributes.id}], [href=#${pathNode.attributes.id}]`;
                    for (const child of querySelectorAll(node, selector)) {
                      if (child.type !== "element") {
                        continue;
                      }
                      for (const name of ["href", "xlink:href"]) {
                        if (child.attributes[name] != null) {
                          child.attributes[name] =
                            "#" + reusablePath.attributes.id;
                        }
                      }
                    }
                    continue;
                  }
                }

                pathNode.name = "use";
                pathNode.attributes["xlink:href"] =
                  "#" + reusablePath.attributes.id;
              }
            }
          }
          if (defsTag.children.length !== 0) {
            if (node.attributes["xmlns:xlink"] == null) {
              node.attributes["xmlns:xlink"] = "http://www.w3.org/1999/xlink";
            }

            if (svgDefs == null) {
              node.children.unshift(defsTag);
            }
          }
        }
      },
    },
  };
};

builtin$1.builtin = [
  presetDefault_1,
  addAttributesToSVGElement,
  addClassesToSVGElement,
  cleanupAttrs$1,
  cleanupEnableBackground$1,
  cleanupIds$1,
  cleanupListOfValues,
  cleanupNumericValues$1,
  collapseGroups$1,
  convertColors$1,
  convertEllipseToCircle$1,
  convertOneStopGradients,
  convertPathData$1,
  convertShapeToPath$1,
  convertStyleToAttrs,
  convertTransform$2,
  mergeStyles$1,
  inlineStyles$1,
  mergePaths$1,
  minifyStyles$1,
  moveElemsAttrsToGroup$1,
  moveGroupAttrsToElems$1,
  prefixIds,
  removeAttributesBySelector,
  removeAttrs,
  removeComments$1,
  removeDesc$1,
  removeDimensions,
  removeDoctype$1,
  removeEditorsNSData$1,
  removeElementsByAttr,
  removeEmptyAttrs$1,
  removeEmptyContainers$1,
  removeEmptyText$1,
  removeHiddenElems$1,
  removeMetadata$1,
  removeNonInheritableGroupAttrs$1,
  removeOffCanvasPaths,
  removeRasterImages,
  removeScriptElement,
  removeStyleElement,
  removeTitle$1,
  removeUnknownsAndDefaults$1,
  removeUnusedNS$1,
  removeUselessDefs$1,
  removeUselessStrokeAndFill$1,
  removeViewBox$1,
  removeXlink,
  removeXMLNS,
  removeXMLProcInst$1,
  reusePaths,
  sortAttrs$1,
  sortDefsChildren$1,
];

const { parseSvg } = parser$4;
const { stringifySvg } = stringifier;
const { builtin } = builtin$1;
const { invokePlugins } = plugins;
const { encodeSVGDatauri } = tools;

const pluginsMap = {};
for (const plugin of builtin) {
  pluginsMap[plugin.name] = plugin;
}

const resolvePluginConfig = (plugin) => {
  if (typeof plugin === "string") {
    // resolve builtin plugin specified as string
    const builtinPlugin = pluginsMap[plugin];
    if (builtinPlugin == null) {
      throw Error(`Unknown builtin plugin "${plugin}" specified.`);
    }
    return {
      name: plugin,
      params: {},
      fn: builtinPlugin.fn,
    };
  }
  if (typeof plugin === "object" && plugin != null) {
    if (plugin.name == null) {
      throw Error(`Plugin name should be specified`);
    }
    // use custom plugin implementation
    let fn = plugin.fn;
    if (fn == null) {
      // resolve builtin plugin implementation
      const builtinPlugin = pluginsMap[plugin.name];
      if (builtinPlugin == null) {
        throw Error(`Unknown builtin plugin "${plugin.name}" specified.`);
      }
      fn = builtinPlugin.fn;
    }
    return {
      name: plugin.name,
      params: plugin.params,
      fn,
    };
  }
  return null;
};

const optimize$1 = (input, config) => {
  if (config == null) {
    config = {};
  }
  if (typeof config !== "object") {
    throw Error("Config should be an object");
  }
  const maxPassCount = config.multipass ? 10 : 1;
  let prevResultSize = Number.POSITIVE_INFINITY;
  let output = "";
  const info = {};
  if (config.path != null) {
    info.path = config.path;
  }
  for (let i = 0; i < maxPassCount; i += 1) {
    info.multipassCount = i;
    const ast = parseSvg(input, config.path);
    const plugins = config.plugins || ["preset-default"];
    if (!Array.isArray(plugins)) {
      throw Error(
        "malformed config, `plugins` property must be an array.\nSee more info here: https://github.com/svg/svgo#configuration",
      );
    }
    const resolvedPlugins = plugins
      .filter((plugin) => plugin != null)
      .map(resolvePluginConfig);

    if (resolvedPlugins.length < plugins.length) {
      console.warn(
        "Warning: plugins list includes null or undefined elements, these will be ignored.",
      );
    }
    const globalOverrides = {};
    if (config.floatPrecision != null) {
      globalOverrides.floatPrecision = config.floatPrecision;
    }
    invokePlugins(ast, info, resolvedPlugins, null, globalOverrides);
    output = stringifySvg(ast, config.js2svg);
    if (output.length < prevResultSize) {
      input = output;
      prevResultSize = output.length;
    } else {
      break;
    }
  }
  if (config.datauri) {
    output = encodeSVGDatauri(output, config.datauri);
  }
  return {
    data: output,
  };
};
svgo.optimize = optimize$1;

const os = require$$1$4;
const { optimize: optimizeAgnostic } = svgo;

const optimize = (input, config) => {
  if (config == null) {
    config = {};
  }
  if (typeof config !== "object") {
    throw Error("Config should be an object");
  }
  return optimizeAgnostic(input, {
    ...config,
    js2svg: {
      // platform specific default for end of line
      eol: os.EOL === "\r\n" ? "crlf" : "lf",
      ...config.js2svg,
    },
  });
};
var optimize_1 = optimize;

const defaultCommonProps = Object.freeze({
  ...defaultIconProps,
  hidden: false,
});
function filterProps(data, reference, compareDefaultValues) {
  const result = commonObjectProps(data, reference);
  return compareDefaultValues ? unmergeObjects(result, reference) : result;
}

var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) =>
  key in obj
    ? __defProp(obj, key, {
        enumerable: true,
        configurable: true,
        writable: true,
        value,
      })
    : (obj[key] = value);
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
const themeKeys = ["prefixes", "suffixes"];
function sortThemeKeys(keys) {
  return keys.sort((a, b) =>
    a.length === b.length ? a.localeCompare(b) : b.length - a.length,
  );
}
class IconSet {
  /**
   * Load icon set
   */
  constructor(data) {
    /**
     * Properties. You can write directly to almost any property, but avoid writing to
     * 'entries' and 'categories' properties, there are functions for that.
     */
    // Icon set prefix
    __publicField(this, "prefix");
    // Last modification time
    __publicField(this, "lastModified");
    // All icons
    __publicField(this, "entries");
    // Information block
    __publicField(this, "info");
    // Categories, using custom type. Use functions to update data
    __publicField(this, "categories");
    __publicField(this, "prefixes");
    __publicField(this, "suffixes");
    this.load(data);
  }
  /**
   * Load icon set
   */
  load(data) {
    this.prefix = data.prefix;
    const defaultProps = filterProps(data, defaultIconDimensions, true);
    this.entries = /* @__PURE__ */ Object.create(null);
    const entries = this.entries;
    for (const name in data.icons) {
      const item = data.icons[name];
      const entry = {
        type: "icon",
        body: item.body,
        props: filterProps(
          {
            ...defaultProps,
            ...item,
          },
          defaultCommonProps,
          true,
        ),
        chars: /* @__PURE__ */ new Set(),
        categories: /* @__PURE__ */ new Set(),
      };
      entries[name] = entry;
    }
    if (data.aliases) {
      for (const name in data.aliases) {
        if (entries[name]) {
          continue;
        }
        const item = data.aliases[name];
        const parent = item.parent;
        const props = filterProps(item, defaultCommonProps, false);
        const chars = /* @__PURE__ */ new Set();
        if (Object.keys(props).length) {
          const entry = {
            type: "variation",
            parent,
            props,
            chars,
          };
          entries[name] = entry;
        } else {
          const entry = {
            type: "alias",
            parent,
            chars,
          };
          entries[name] = entry;
        }
      }
    }
    const info = data.info && convertIconSetInfo(data.info);
    this.info = info || void 0;
    if (data.chars) {
      for (const char in data.chars) {
        const name = data.chars[char];
        const icon = entries[name];
        if (icon) {
          icon.chars.add(char);
        }
      }
    }
    this.categories = /* @__PURE__ */ new Set();
    if (data.categories) {
      for (const category in data.categories) {
        const item = {
          title: category,
          count: 0,
        };
        data.categories[category].forEach((iconName) => {
          const icon = entries[iconName];
          switch (icon?.type) {
            case "icon":
              icon.categories.add(item);
          }
        });
        this.categories.add(item);
        this.listCategory(item);
      }
    }
    const prefixes = (this.prefixes = /* @__PURE__ */ Object.create(null));
    const suffixes = (this.suffixes = /* @__PURE__ */ Object.create(null));
    if (data.themes) {
      for (const key in data.themes) {
        const item = data.themes[key];
        if (typeof item.prefix === "string") {
          const prefix = item.prefix;
          if (prefix.slice(-1) === "-") {
            prefixes[prefix.slice(0, -1)] = item.title;
          }
        }
        if (typeof item.suffix === "string") {
          const suffix = item.suffix;
          if (suffix.slice(0, 1) === "-") {
            suffixes[suffix.slice(1)] = item.title;
          }
        }
      }
    }
    themeKeys.forEach((prop) => {
      const items = data[prop];
      if (items) {
        this[prop] = /* @__PURE__ */ Object.create(null);
        for (const key in items) {
          this[prop][key] = items[key];
        }
      }
    });
    this.lastModified = data.lastModified || 0;
  }
  /**
   * Update last modification time
   */
  updateLastModified(value) {
    this.lastModified = value || Math.floor(Date.now() / 1e3);
  }
  /**
   * List icons
   */
  list(types = ["icon", "variation"]) {
    return Object.keys(this.entries).filter((name) =>
      types.includes(this.entries[name].type),
    );
  }
  /**
   * forEach function to loop through all entries.
   * Supports asynchronous callbacks.
   *
   * Callback should return false to stop loop.
   */
  async forEach(callback, types = ["icon", "variation", "alias"]) {
    const names = this.list(types);
    for (let i = 0; i < names.length; i++) {
      const name = names[i];
      const item = this.entries[name];
      if (item) {
        let result = callback(name, item.type);
        if (result instanceof Promise) {
          result = await result;
        }
        if (result === false) {
          return;
        }
      }
    }
  }
  /**
   * Synchronous version of forEach function to loop through all entries.
   *
   * Callback should return false to stop loop.
   */
  forEachSync(callback, types = ["icon", "variation", "alias"]) {
    const names = this.list(types);
    for (let i = 0; i < names.length; i++) {
      const name = names[i];
      const item = this.entries[name];
      if (item) {
        const result = callback(name, item.type);
        if (result === false) {
          return;
        }
      }
    }
  }
  /**
   * Get parent icons tree
   *
   * Returns parent icons list for each icon, null if failed to resolve.
   * In parent icons list, first element is a direct parent, last is icon. Does not include item.
   *
   * Examples:
   *   'alias3': ['alias2', 'alias1', 'icon']
   * 	 'icon': []
   * 	 'bad-icon': null
   */
  getTree(names) {
    const entries = this.entries;
    const resolved = /* @__PURE__ */ Object.create(null);
    function resolve(name) {
      const item = entries[name];
      if (!item) {
        return (resolved[name] = null);
      }
      if (item.type === "icon") {
        return (resolved[name] = []);
      }
      if (resolved[name] === void 0) {
        resolved[name] = null;
        const parent = item.parent;
        const value = parent && resolve(parent);
        if (value) {
          resolved[name] = [parent].concat(value);
        }
      }
      return resolved[name];
    }
    (names || Object.keys(entries)).forEach(resolve);
    return resolved;
  }
  resolve(name, full = false) {
    const entries = this.entries;
    const item = entries[name];
    const tree =
      item && (item.type === "icon" ? [] : this.getTree([name])[name]);
    if (!tree) {
      return null;
    }
    let result = {};
    function parse(name2) {
      const item2 = entries[name2];
      if (item2.type === "alias") {
        return;
      }
      result = mergeIconData(item2.props, result);
      if (item2.type === "icon") {
        result.body = item2.body;
      }
    }
    parse(name);
    tree.forEach(parse);
    return result && full ? { ...defaultIconProps, ...result } : result;
  }
  /**
   * Generate HTML
   */
  toString(
    name,
    customisations = {
      width: "auto",
      height: "auto",
    },
  ) {
    const item = this.resolve(name);
    if (!item) {
      return null;
    }
    const result = iconToSVG(item, customisations);
    const attributes = Object.keys(result.attributes)
      .map((key) => ` ${key}="${result.attributes[key]}"`)
      .join("");
    return `<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"${attributes}>${result.body}</svg>`;
  }
  /**
   * Get SVG instance for icon
   */
  toSVG(name) {
    const html = this.toString(name);
    return html ? new SVG(html) : null;
  }
  /**
   * Export icon set
   */
  export(validate = true) {
    const icons = /* @__PURE__ */ Object.create(null);
    const aliases = /* @__PURE__ */ Object.create(null);
    const tree = validate
      ? this.getTree()
      : /* @__PURE__ */ Object.create(null);
    const names = Object.keys(this.entries);
    names.sort((a, b) => a.localeCompare(b));
    names.forEach((name) => {
      const item = this.entries[name];
      switch (item.type) {
        case "icon": {
          const icon = {
            body: item.body,
            ...item.props,
          };
          icons[name] = icon;
          break;
        }
        case "alias":
        case "variation": {
          if (validate && !tree[name]) {
            break;
          }
          const props = item.type === "variation" ? item.props : {};
          const alias = {
            parent: item.parent,
            ...props,
          };
          aliases[name] = alias;
          break;
        }
      }
    });
    let info;
    if (this.info) {
      this.info.total = this.count();
      info = JSON.parse(JSON.stringify(this.info));
    }
    const result = {
      prefix: this.prefix,
    };
    if (info) {
      result.info = info;
    }
    if (this.lastModified) {
      result.lastModified = this.lastModified;
    }
    result.icons = icons;
    if (Object.keys(aliases).length) {
      result.aliases = aliases;
    }
    const chars = this.chars(Object.keys(icons).concat(Object.keys(aliases)));
    if (Object.keys(chars).length) {
      result.chars = chars;
    }
    const categories = /* @__PURE__ */ Object.create(null);
    Array.from(this.categories)
      .sort((a, b) => a.title.localeCompare(b.title))
      .forEach((item) => {
        const names2 = this.listCategory(item);
        if (names2) {
          names2.sort((a, b) => a.localeCompare(b));
          categories[item.title] = names2;
        }
      });
    if (Object.keys(categories).length) {
      result.categories = categories;
    }
    themeKeys.forEach((prop) => {
      const items = this[prop];
      const keys = Object.keys(items);
      if (keys.length) {
        const sortedTheme = /* @__PURE__ */ Object.create(null);
        const tested = this.checkTheme(prop === "prefixes");
        keys.forEach((key) => {
          if (tested.valid[key].length) {
            sortedTheme[key] = items[key];
          }
        });
        if (Object.keys(sortedTheme).length) {
          result[prop] = sortedTheme;
        }
      }
    });
    minifyIconSet(result);
    return result;
  }
  /**
   * Get characters map
   */
  chars(names) {
    const chars = /* @__PURE__ */ Object.create(null);
    if (!names) {
      names = Object.keys(this.entries);
    }
    for (let i = 0; i < names.length; i++) {
      const name = names[i];
      const item = this.entries[name];
      item.chars.forEach((char) => {
        chars[char] = name;
      });
    }
    return chars;
  }
  /**
   * Filter icons
   */
  _filter(callback) {
    const names = [];
    for (const key in this.entries) {
      const item = this.entries[key];
      switch (item.type) {
        case "icon": {
          if (callback(key, item)) {
            names.push(key);
          }
          break;
        }
        case "variation":
        case "alias": {
          const icon = this.resolve(key);
          if (icon && callback(key, item, icon)) {
            names.push(key);
          }
          break;
        }
      }
    }
    return names;
  }
  /**
   * Count icons
   */
  count() {
    return this._filter((_key, item, icon) => {
      if (item.type === "alias" || item.props.hidden || icon?.hidden) {
        return false;
      }
      return true;
    }).length;
  }
  /**
   * Find category by title
   */
  findCategory(title, add) {
    const categoryItem = Array.from(this.categories).find(
      (item) => item.title === title,
    );
    if (categoryItem) {
      return categoryItem;
    }
    if (add) {
      const newItem = {
        title,
        count: 0,
      };
      this.categories.add(newItem);
      return newItem;
    }
    return null;
  }
  /**
   * Count icons in category, remove category if empty
   *
   * Hidden icons and aliases do not count
   */
  listCategory(category) {
    const categoryItem =
      typeof category === "string"
        ? this.findCategory(category, false)
        : category;
    if (!categoryItem) {
      return null;
    }
    const icons = this._filter((_key, item) => {
      if (item.type !== "icon" || item.props.hidden) {
        return false;
      }
      return item.categories.has(categoryItem);
    });
    const count = icons.length;
    categoryItem.count = count;
    if (!count) {
      this.categories.delete(categoryItem);
      return null;
    }
    return icons;
  }
  /**
   * Check if icon exists
   */
  exists(name) {
    return !!this.entries[name];
  }
  /**
   * Remove icons. Returns number of removed icons
   *
   * If removeDependencies is a string, it represents new parent for all aliases of removed icon. New parent cannot be alias or variation.
   */
  remove(name, removeDependencies = true) {
    const entries = this.entries;
    if (typeof removeDependencies === "string") {
      const item2 = entries[removeDependencies];
      if (name === removeDependencies || item2?.type !== "icon") {
        return 0;
      }
    }
    const item = entries[name];
    if (!item) {
      return 0;
    }
    this.updateLastModified();
    if (typeof removeDependencies === "string") {
      for (const key in entries) {
        const item2 = entries[key];
        if (item2.type !== "icon" && item2.parent === name) {
          item2.parent = removeDependencies;
        }
      }
      return 0;
    }
    delete entries[name];
    let count = 1;
    function remove(parent) {
      const list = Object.keys(entries).filter((name2) => {
        const item2 = entries[name2];
        return item2.type !== "icon" && item2.parent === parent;
      });
      list.forEach((name2) => {
        if (entries[name2]) {
          delete entries[name2];
          count++;
          remove(name2);
        }
      });
    }
    if (removeDependencies === true) {
      remove(name);
    }
    return count;
  }
  /**
   * Rename icon
   */
  rename(oldName, newName) {
    const entries = this.entries;
    if (entries[newName]) {
      if (!this.remove(newName)) {
        return false;
      }
    }
    if (!entries[oldName]) {
      return false;
    }
    entries[newName] = entries[oldName];
    delete entries[oldName];
    for (const key in entries) {
      const item = entries[key];
      switch (item.type) {
        case "icon":
          break;
        case "alias":
        case "variation":
          if (item.parent === oldName) {
            item.parent = newName;
          }
          break;
      }
    }
    this.updateLastModified();
    return true;
  }
  /**
   * Add/update item
   */
  setItem(name, item) {
    switch (item.type) {
      case "alias":
      case "variation": {
        if (!this.entries[item.parent]) {
          return false;
        }
      }
    }
    this.entries[name] = item;
    this.updateLastModified();
    return true;
  }
  /**
   * Add/update icon
   */
  setIcon(name, icon) {
    return this.setItem(name, {
      type: "icon",
      body: icon.body,
      props: filterProps(icon, defaultCommonProps, true),
      chars: /* @__PURE__ */ new Set(),
      categories: /* @__PURE__ */ new Set(),
    });
  }
  /**
   * Add/update alias without props
   */
  setAlias(name, parent) {
    return this.setItem(name, {
      type: "alias",
      parent,
      chars: /* @__PURE__ */ new Set(),
    });
  }
  /**
   * Add/update alias with props
   */
  setVariation(name, parent, props) {
    return this.setItem(name, {
      type: "variation",
      parent,
      props,
      chars: /* @__PURE__ */ new Set(),
    });
  }
  /**
   * Icon from SVG. Updates old icon if it exists
   */
  fromSVG(name, svg) {
    const props = { ...svg.viewBox };
    const body = svg.getBody();
    const item = this.entries[name];
    switch (item?.type) {
      case "icon":
      case "variation": {
        return this.setItem(name, {
          type: "icon",
          body,
          props,
          chars: item.chars,
          categories:
            item.type === "icon" ? item.categories : /* @__PURE__ */ new Set(),
        });
      }
    }
    return this.setIcon(name, {
      body,
      ...props,
    });
  }
  /**
   * Add or remove character for icon
   */
  toggleCharacter(iconName, char, add) {
    const item = this.entries[iconName];
    if (!item) {
      return false;
    }
    if (item.chars.has(char) !== add) {
      item.chars[add ? "add" : "delete"](char);
      return true;
    }
    return false;
  }
  /**
   * Add or remove category for icon
   */
  toggleCategory(iconName, category, add) {
    const item = this.entries[iconName];
    const categoryItem = this.findCategory(category, add);
    if (!item || !categoryItem) {
      return false;
    }
    switch (item.type) {
      case "icon":
        if (item.categories.has(categoryItem) !== add) {
          categoryItem.count += add ? 1 : -1;
          item.categories[add ? "add" : "delete"](categoryItem);
          return true;
        }
    }
    return false;
  }
  /**
   * Find icons that belong to theme
   */
  checkTheme(prefix) {
    const themes = prefix ? this.prefixes : this.suffixes;
    const keys = sortThemeKeys(Object.keys(themes));
    const results = {
      valid: /* @__PURE__ */ Object.create(null),
      invalid: [],
    };
    keys.forEach((key) => {
      results.valid[key] = [];
    });
    results.invalid = this._filter((name, item, icon) => {
      if (item.type === "alias" || item.props.hidden || icon?.hidden) {
        return false;
      }
      for (let i = 0; i < keys.length; i++) {
        const search = keys[i];
        if (search === "") {
          results.valid[search].push(name);
          return false;
        }
        const match = prefix ? search + "-" : "-" + search;
        const length = match.length;
        const test = prefix ? name.slice(0, length) : name.slice(0 - length);
        if (test === match) {
          results.valid[search].push(name);
          return false;
        }
      }
      return true;
    });
    return results;
  }
}

var getStream$1 = { exports: {} };

var once$3 = { exports: {} };

// Returns a wrapper function that returns a wrapped callback
// The wrapper function should do some stuff, and return a
// presumably different callback function.
// This makes sure that own properties are retained, so that
// decorations and such are not lost along the way.
var wrappy_1 = wrappy$1;
function wrappy$1(fn, cb) {
  if (fn && cb) return wrappy$1(fn)(cb);

  if (typeof fn !== "function") throw new TypeError("need wrapper function");

  Object.keys(fn).forEach(function (k) {
    wrapper[k] = fn[k];
  });

  return wrapper;

  function wrapper() {
    var args = new Array(arguments.length);
    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i];
    }
    var ret = fn.apply(this, args);
    var cb = args[args.length - 1];
    if (typeof ret === "function" && ret !== cb) {
      Object.keys(cb).forEach(function (k) {
        ret[k] = cb[k];
      });
    }
    return ret;
  }
}

var wrappy = wrappy_1;
once$3.exports = wrappy(once$2);
once$3.exports.strict = wrappy(onceStrict);

once$2.proto = once$2(function () {
  Object.defineProperty(Function.prototype, "once", {
    value: function () {
      return once$2(this);
    },
    configurable: true,
  });

  Object.defineProperty(Function.prototype, "onceStrict", {
    value: function () {
      return onceStrict(this);
    },
    configurable: true,
  });
});

function once$2(fn) {
  var f = function () {
    if (f.called) return f.value;
    f.called = true;
    return (f.value = fn.apply(this, arguments));
  };
  f.called = false;
  return f;
}

function onceStrict(fn) {
  var f = function () {
    if (f.called) throw new Error(f.onceError);
    f.called = true;
    return (f.value = fn.apply(this, arguments));
  };
  var name = fn.name || "Function wrapped with `once`";
  f.onceError = name + " shouldn't be called more than once";
  f.called = false;
  return f;
}

var onceExports = once$3.exports;

var once$1 = onceExports;

var noop$2 = function () {};

var isRequest$1 = function (stream) {
  return stream.setHeader && typeof stream.abort === "function";
};

var isChildProcess = function (stream) {
  return (
    stream.stdio && Array.isArray(stream.stdio) && stream.stdio.length === 3
  );
};

var eos$1 = function (stream, opts, callback) {
  if (typeof opts === "function") return eos$1(stream, null, opts);
  if (!opts) opts = {};

  callback = once$1(callback || noop$2);

  var ws = stream._writableState;
  var rs = stream._readableState;
  var readable = opts.readable || (opts.readable !== false && stream.readable);
  var writable = opts.writable || (opts.writable !== false && stream.writable);
  var cancelled = false;

  var onlegacyfinish = function () {
    if (!stream.writable) onfinish();
  };

  var onfinish = function () {
    writable = false;
    if (!readable) callback.call(stream);
  };

  var onend = function () {
    readable = false;
    if (!writable) callback.call(stream);
  };

  var onexit = function (exitCode) {
    callback.call(
      stream,
      exitCode ? new Error("exited with error code: " + exitCode) : null,
    );
  };

  var onerror = function (err) {
    callback.call(stream, err);
  };

  var onclose = function () {
    process.nextTick(onclosenexttick);
  };

  var onclosenexttick = function () {
    if (cancelled) return;
    if (readable && !(rs && rs.ended && !rs.destroyed))
      return callback.call(stream, new Error("premature close"));
    if (writable && !(ws && ws.ended && !ws.destroyed))
      return callback.call(stream, new Error("premature close"));
  };

  var onrequest = function () {
    stream.req.on("finish", onfinish);
  };

  if (isRequest$1(stream)) {
    stream.on("complete", onfinish);
    stream.on("abort", onclose);
    if (stream.req) onrequest();
    else stream.on("request", onrequest);
  } else if (writable && !ws) {
    // legacy streams
    stream.on("end", onlegacyfinish);
    stream.on("close", onlegacyfinish);
  }

  if (isChildProcess(stream)) stream.on("exit", onexit);

  stream.on("end", onend);
  stream.on("finish", onfinish);
  if (opts.error !== false) stream.on("error", onerror);
  stream.on("close", onclose);

  return function () {
    cancelled = true;
    stream.removeListener("complete", onfinish);
    stream.removeListener("abort", onclose);
    stream.removeListener("request", onrequest);
    if (stream.req) stream.req.removeListener("finish", onfinish);
    stream.removeListener("end", onlegacyfinish);
    stream.removeListener("close", onlegacyfinish);
    stream.removeListener("finish", onfinish);
    stream.removeListener("exit", onexit);
    stream.removeListener("end", onend);
    stream.removeListener("error", onerror);
    stream.removeListener("close", onclose);
  };
};

var endOfStream = eos$1;

var once = onceExports;
var eos = endOfStream;
var fs$b = require$$0$6; // we only need fs to get the ReadStream and WriteStream prototypes

var noop$1 = function () {};
var ancient = /^v?\.0/.test(process.version);

var isFn = function (fn) {
  return typeof fn === "function";
};

var isFS = function (stream) {
  if (!ancient) return false; // newer node version do not need to care about fs is a special way
  if (!fs$b) return false; // browser
  return (
    (stream instanceof (fs$b.ReadStream || noop$1) ||
      stream instanceof (fs$b.WriteStream || noop$1)) &&
    isFn(stream.close)
  );
};

var isRequest = function (stream) {
  return stream.setHeader && isFn(stream.abort);
};

var destroyer = function (stream, reading, writing, callback) {
  callback = once(callback);

  var closed = false;
  stream.on("close", function () {
    closed = true;
  });

  eos(stream, { readable: reading, writable: writing }, function (err) {
    if (err) return callback(err);
    closed = true;
    callback();
  });

  var destroyed = false;
  return function (err) {
    if (closed) return;
    if (destroyed) return;
    destroyed = true;

    if (isFS(stream)) return stream.close(noop$1); // use close for fs streams to avoid fd leaks
    if (isRequest(stream)) return stream.abort(); // request.destroy just do .end - .abort is what we want

    if (isFn(stream.destroy)) return stream.destroy();

    callback(err || new Error("stream was destroyed"));
  };
};

var call = function (fn) {
  fn();
};

var pipe = function (from, to) {
  return from.pipe(to);
};

var pump$1 = function () {
  var streams = Array.prototype.slice.call(arguments);
  var callback =
    (isFn(streams[streams.length - 1] || noop$1) && streams.pop()) || noop$1;

  if (Array.isArray(streams[0])) streams = streams[0];
  if (streams.length < 2)
    throw new Error("pump requires two streams per minimum");

  var error;
  var destroys = streams.map(function (stream, i) {
    var reading = i < streams.length - 1;
    var writing = i > 0;
    return destroyer(stream, reading, writing, function (err) {
      if (!error) error = err;
      if (err) destroys.forEach(call);
      if (reading) return;
      destroys.forEach(call);
      callback(error);
    });
  });

  return streams.reduce(pipe);
};

var pump_1 = pump$1;

const { PassThrough: PassThroughStream } = stream$2;

var bufferStream$1 = (options) => {
  options = { ...options };

  const { array } = options;
  let { encoding } = options;
  const isBuffer = encoding === "buffer";
  let objectMode = false;

  if (array) {
    objectMode = !(encoding || isBuffer);
  } else {
    encoding = encoding || "utf8";
  }

  if (isBuffer) {
    encoding = null;
  }

  const stream = new PassThroughStream({ objectMode });

  if (encoding) {
    stream.setEncoding(encoding);
  }

  let length = 0;
  const chunks = [];

  stream.on("data", (chunk) => {
    chunks.push(chunk);

    if (objectMode) {
      length = chunks.length;
    } else {
      length += chunk.length;
    }
  });

  stream.getBufferedValue = () => {
    if (array) {
      return chunks;
    }

    return isBuffer ? Buffer.concat(chunks, length) : chunks.join("");
  };

  stream.getBufferedLength = () => length;

  return stream;
};

const { constants: BufferConstants } = require$$0$7;
const pump = pump_1;
const bufferStream = bufferStream$1;

class MaxBufferError extends Error {
  constructor() {
    super("maxBuffer exceeded");
    this.name = "MaxBufferError";
  }
}

async function getStream(inputStream, options) {
  if (!inputStream) {
    return Promise.reject(new Error("Expected a stream"));
  }

  options = {
    maxBuffer: Infinity,
    ...options,
  };

  const { maxBuffer } = options;

  let stream;
  await new Promise((resolve, reject) => {
    const rejectPromise = (error) => {
      // Don't retrieve an oversized buffer.
      if (error && stream.getBufferedLength() <= BufferConstants.MAX_LENGTH) {
        error.bufferedData = stream.getBufferedValue();
      }

      reject(error);
    };

    stream = pump(inputStream, bufferStream(options), (error) => {
      if (error) {
        rejectPromise(error);
        return;
      }

      resolve();
    });

    stream.on("data", () => {
      if (stream.getBufferedLength() > maxBuffer) {
        rejectPromise(new MaxBufferError());
      }
    });
  });

  return stream.getBufferedValue();
}

getStream$1.exports = getStream;
// TODO: Remove this for the next major release
getStream$1.exports.default = getStream;
getStream$1.exports.buffer = (stream, options) =>
  getStream(stream, { ...options, encoding: "buffer" });
getStream$1.exports.array = (stream, options) =>
  getStream(stream, { ...options, array: true });
getStream$1.exports.MaxBufferError = MaxBufferError;

var yauzl$1 = {};

var fdSlicer = {};

var pend = Pend$1;

function Pend$1() {
  this.pending = 0;
  this.max = Infinity;
  this.listeners = [];
  this.waiting = [];
  this.error = null;
}

Pend$1.prototype.go = function (fn) {
  if (this.pending < this.max) {
    pendGo(this, fn);
  } else {
    this.waiting.push(fn);
  }
};

Pend$1.prototype.wait = function (cb) {
  if (this.pending === 0) {
    cb(this.error);
  } else {
    this.listeners.push(cb);
  }
};

Pend$1.prototype.hold = function () {
  return pendHold(this);
};

function pendHold(self) {
  self.pending += 1;
  var called = false;
  return onCb;
  function onCb(err) {
    if (called) throw new Error("callback called twice");
    called = true;
    self.error = self.error || err;
    self.pending -= 1;
    if (self.waiting.length > 0 && self.pending < self.max) {
      pendGo(self, self.waiting.shift());
    } else if (self.pending === 0) {
      var listeners = self.listeners;
      self.listeners = [];
      listeners.forEach(cbListener);
    }
  }
  function cbListener(listener) {
    listener(self.error);
  }
}

function pendGo(self, fn) {
  fn(pendHold(self));
}

var fs$a = require$$0$6;
var util$1 = require$$1$5;
var stream$1 = stream$2;
var Readable = stream$1.Readable;
var Writable$1 = stream$1.Writable;
var PassThrough$1 = stream$1.PassThrough;
var Pend = pend;
var EventEmitter$1 = require$$0$8.EventEmitter;

fdSlicer.createFromBuffer = createFromBuffer;
fdSlicer.createFromFd = createFromFd;
fdSlicer.BufferSlicer = BufferSlicer;
fdSlicer.FdSlicer = FdSlicer;

util$1.inherits(FdSlicer, EventEmitter$1);
function FdSlicer(fd, options) {
  options = options || {};
  EventEmitter$1.call(this);

  this.fd = fd;
  this.pend = new Pend();
  this.pend.max = 1;
  this.refCount = 0;
  this.autoClose = !!options.autoClose;
}

FdSlicer.prototype.read = function (
  buffer,
  offset,
  length,
  position,
  callback,
) {
  var self = this;
  self.pend.go(function (cb) {
    fs$a.read(
      self.fd,
      buffer,
      offset,
      length,
      position,
      function (err, bytesRead, buffer) {
        cb();
        callback(err, bytesRead, buffer);
      },
    );
  });
};

FdSlicer.prototype.write = function (
  buffer,
  offset,
  length,
  position,
  callback,
) {
  var self = this;
  self.pend.go(function (cb) {
    fs$a.write(
      self.fd,
      buffer,
      offset,
      length,
      position,
      function (err, written, buffer) {
        cb();
        callback(err, written, buffer);
      },
    );
  });
};

FdSlicer.prototype.createReadStream = function (options) {
  return new ReadStream$1(this, options);
};

FdSlicer.prototype.createWriteStream = function (options) {
  return new WriteStream$1(this, options);
};

FdSlicer.prototype.ref = function () {
  this.refCount += 1;
};

FdSlicer.prototype.unref = function () {
  var self = this;
  self.refCount -= 1;

  if (self.refCount > 0) return;
  if (self.refCount < 0) throw new Error("invalid unref");

  if (self.autoClose) {
    fs$a.close(self.fd, onCloseDone);
  }

  function onCloseDone(err) {
    if (err) {
      self.emit("error", err);
    } else {
      self.emit("close");
    }
  }
};

util$1.inherits(ReadStream$1, Readable);
function ReadStream$1(context, options) {
  options = options || {};
  Readable.call(this, options);

  this.context = context;
  this.context.ref();

  this.start = options.start || 0;
  this.endOffset = options.end;
  this.pos = this.start;
  this.destroyed = false;
}

ReadStream$1.prototype._read = function (n) {
  var self = this;
  if (self.destroyed) return;

  var toRead = Math.min(self._readableState.highWaterMark, n);
  if (self.endOffset != null) {
    toRead = Math.min(toRead, self.endOffset - self.pos);
  }
  if (toRead <= 0) {
    self.destroyed = true;
    self.push(null);
    self.context.unref();
    return;
  }
  self.context.pend.go(function (cb) {
    if (self.destroyed) return cb();
    var buffer = new Buffer(toRead);
    fs$a.read(
      self.context.fd,
      buffer,
      0,
      toRead,
      self.pos,
      function (err, bytesRead) {
        if (err) {
          self.destroy(err);
        } else if (bytesRead === 0) {
          self.destroyed = true;
          self.push(null);
          self.context.unref();
        } else {
          self.pos += bytesRead;
          self.push(buffer.slice(0, bytesRead));
        }
        cb();
      },
    );
  });
};

ReadStream$1.prototype.destroy = function (err) {
  if (this.destroyed) return;
  err = err || new Error("stream destroyed");
  this.destroyed = true;
  this.emit("error", err);
  this.context.unref();
};

util$1.inherits(WriteStream$1, Writable$1);
function WriteStream$1(context, options) {
  options = options || {};
  Writable$1.call(this, options);

  this.context = context;
  this.context.ref();

  this.start = options.start || 0;
  this.endOffset = options.end == null ? Infinity : +options.end;
  this.bytesWritten = 0;
  this.pos = this.start;
  this.destroyed = false;

  this.on("finish", this.destroy.bind(this));
}

WriteStream$1.prototype._write = function (buffer, encoding, callback) {
  var self = this;
  if (self.destroyed) return;

  if (self.pos + buffer.length > self.endOffset) {
    var err = new Error("maximum file length exceeded");
    err.code = "ETOOBIG";
    self.destroy();
    callback(err);
    return;
  }
  self.context.pend.go(function (cb) {
    if (self.destroyed) return cb();
    fs$a.write(
      self.context.fd,
      buffer,
      0,
      buffer.length,
      self.pos,
      function (err, bytes) {
        if (err) {
          self.destroy();
          cb();
          callback(err);
        } else {
          self.bytesWritten += bytes;
          self.pos += bytes;
          self.emit("progress");
          cb();
          callback();
        }
      },
    );
  });
};

WriteStream$1.prototype.destroy = function () {
  if (this.destroyed) return;
  this.destroyed = true;
  this.context.unref();
};

util$1.inherits(BufferSlicer, EventEmitter$1);
function BufferSlicer(buffer, options) {
  EventEmitter$1.call(this);

  options = options || {};
  this.refCount = 0;
  this.buffer = buffer;
  this.maxChunkSize = options.maxChunkSize || Number.MAX_SAFE_INTEGER;
}

BufferSlicer.prototype.read = function (
  buffer,
  offset,
  length,
  position,
  callback,
) {
  var end = position + length;
  var delta = end - this.buffer.length;
  var written = delta > 0 ? delta : length;
  this.buffer.copy(buffer, offset, position, end);
  setImmediate(function () {
    callback(null, written);
  });
};

BufferSlicer.prototype.write = function (
  buffer,
  offset,
  length,
  position,
  callback,
) {
  buffer.copy(this.buffer, position, offset, offset + length);
  setImmediate(function () {
    callback(null, length, buffer);
  });
};

BufferSlicer.prototype.createReadStream = function (options) {
  options = options || {};
  var readStream = new PassThrough$1(options);
  readStream.destroyed = false;
  readStream.start = options.start || 0;
  readStream.endOffset = options.end;
  // by the time this function returns, we'll be done.
  readStream.pos = readStream.endOffset || this.buffer.length;

  // respect the maxChunkSize option to slice up the chunk into smaller pieces.
  var entireSlice = this.buffer.slice(readStream.start, readStream.pos);
  var offset = 0;
  while (true) {
    var nextOffset = offset + this.maxChunkSize;
    if (nextOffset >= entireSlice.length) {
      // last chunk
      if (offset < entireSlice.length) {
        readStream.write(entireSlice.slice(offset, entireSlice.length));
      }
      break;
    }
    readStream.write(entireSlice.slice(offset, nextOffset));
    offset = nextOffset;
  }

  readStream.end();
  readStream.destroy = function () {
    readStream.destroyed = true;
  };
  return readStream;
};

BufferSlicer.prototype.createWriteStream = function (options) {
  var bufferSlicer = this;
  options = options || {};
  var writeStream = new Writable$1(options);
  writeStream.start = options.start || 0;
  writeStream.endOffset =
    options.end == null ? this.buffer.length : +options.end;
  writeStream.bytesWritten = 0;
  writeStream.pos = writeStream.start;
  writeStream.destroyed = false;
  writeStream._write = function (buffer, encoding, callback) {
    if (writeStream.destroyed) return;

    var end = writeStream.pos + buffer.length;
    if (end > writeStream.endOffset) {
      var err = new Error("maximum file length exceeded");
      err.code = "ETOOBIG";
      writeStream.destroyed = true;
      callback(err);
      return;
    }
    buffer.copy(bufferSlicer.buffer, writeStream.pos, 0, buffer.length);

    writeStream.bytesWritten += buffer.length;
    writeStream.pos = end;
    writeStream.emit("progress");
    callback();
  };
  writeStream.destroy = function () {
    writeStream.destroyed = true;
  };
  return writeStream;
};

BufferSlicer.prototype.ref = function () {
  this.refCount += 1;
};

BufferSlicer.prototype.unref = function () {
  this.refCount -= 1;

  if (this.refCount < 0) {
    throw new Error("invalid unref");
  }
};

function createFromBuffer(buffer, options) {
  return new BufferSlicer(buffer, options);
}

function createFromFd(fd, options) {
  return new FdSlicer(fd, options);
}

var Buffer$2 = require$$0$7.Buffer;

var CRC_TABLE = [
  0x00000000, 0x77073096, 0xee0e612c, 0x990951ba, 0x076dc419, 0x706af48f,
  0xe963a535, 0x9e6495a3, 0x0edb8832, 0x79dcb8a4, 0xe0d5e91e, 0x97d2d988,
  0x09b64c2b, 0x7eb17cbd, 0xe7b82d07, 0x90bf1d91, 0x1db71064, 0x6ab020f2,
  0xf3b97148, 0x84be41de, 0x1adad47d, 0x6ddde4eb, 0xf4d4b551, 0x83d385c7,
  0x136c9856, 0x646ba8c0, 0xfd62f97a, 0x8a65c9ec, 0x14015c4f, 0x63066cd9,
  0xfa0f3d63, 0x8d080df5, 0x3b6e20c8, 0x4c69105e, 0xd56041e4, 0xa2677172,
  0x3c03e4d1, 0x4b04d447, 0xd20d85fd, 0xa50ab56b, 0x35b5a8fa, 0x42b2986c,
  0xdbbbc9d6, 0xacbcf940, 0x32d86ce3, 0x45df5c75, 0xdcd60dcf, 0xabd13d59,
  0x26d930ac, 0x51de003a, 0xc8d75180, 0xbfd06116, 0x21b4f4b5, 0x56b3c423,
  0xcfba9599, 0xb8bda50f, 0x2802b89e, 0x5f058808, 0xc60cd9b2, 0xb10be924,
  0x2f6f7c87, 0x58684c11, 0xc1611dab, 0xb6662d3d, 0x76dc4190, 0x01db7106,
  0x98d220bc, 0xefd5102a, 0x71b18589, 0x06b6b51f, 0x9fbfe4a5, 0xe8b8d433,
  0x7807c9a2, 0x0f00f934, 0x9609a88e, 0xe10e9818, 0x7f6a0dbb, 0x086d3d2d,
  0x91646c97, 0xe6635c01, 0x6b6b51f4, 0x1c6c6162, 0x856530d8, 0xf262004e,
  0x6c0695ed, 0x1b01a57b, 0x8208f4c1, 0xf50fc457, 0x65b0d9c6, 0x12b7e950,
  0x8bbeb8ea, 0xfcb9887c, 0x62dd1ddf, 0x15da2d49, 0x8cd37cf3, 0xfbd44c65,
  0x4db26158, 0x3ab551ce, 0xa3bc0074, 0xd4bb30e2, 0x4adfa541, 0x3dd895d7,
  0xa4d1c46d, 0xd3d6f4fb, 0x4369e96a, 0x346ed9fc, 0xad678846, 0xda60b8d0,
  0x44042d73, 0x33031de5, 0xaa0a4c5f, 0xdd0d7cc9, 0x5005713c, 0x270241aa,
  0xbe0b1010, 0xc90c2086, 0x5768b525, 0x206f85b3, 0xb966d409, 0xce61e49f,
  0x5edef90e, 0x29d9c998, 0xb0d09822, 0xc7d7a8b4, 0x59b33d17, 0x2eb40d81,
  0xb7bd5c3b, 0xc0ba6cad, 0xedb88320, 0x9abfb3b6, 0x03b6e20c, 0x74b1d29a,
  0xead54739, 0x9dd277af, 0x04db2615, 0x73dc1683, 0xe3630b12, 0x94643b84,
  0x0d6d6a3e, 0x7a6a5aa8, 0xe40ecf0b, 0x9309ff9d, 0x0a00ae27, 0x7d079eb1,
  0xf00f9344, 0x8708a3d2, 0x1e01f268, 0x6906c2fe, 0xf762575d, 0x806567cb,
  0x196c3671, 0x6e6b06e7, 0xfed41b76, 0x89d32be0, 0x10da7a5a, 0x67dd4acc,
  0xf9b9df6f, 0x8ebeeff9, 0x17b7be43, 0x60b08ed5, 0xd6d6a3e8, 0xa1d1937e,
  0x38d8c2c4, 0x4fdff252, 0xd1bb67f1, 0xa6bc5767, 0x3fb506dd, 0x48b2364b,
  0xd80d2bda, 0xaf0a1b4c, 0x36034af6, 0x41047a60, 0xdf60efc3, 0xa867df55,
  0x316e8eef, 0x4669be79, 0xcb61b38c, 0xbc66831a, 0x256fd2a0, 0x5268e236,
  0xcc0c7795, 0xbb0b4703, 0x220216b9, 0x5505262f, 0xc5ba3bbe, 0xb2bd0b28,
  0x2bb45a92, 0x5cb36a04, 0xc2d7ffa7, 0xb5d0cf31, 0x2cd99e8b, 0x5bdeae1d,
  0x9b64c2b0, 0xec63f226, 0x756aa39c, 0x026d930a, 0x9c0906a9, 0xeb0e363f,
  0x72076785, 0x05005713, 0x95bf4a82, 0xe2b87a14, 0x7bb12bae, 0x0cb61b38,
  0x92d28e9b, 0xe5d5be0d, 0x7cdcefb7, 0x0bdbdf21, 0x86d3d2d4, 0xf1d4e242,
  0x68ddb3f8, 0x1fda836e, 0x81be16cd, 0xf6b9265b, 0x6fb077e1, 0x18b74777,
  0x88085ae6, 0xff0f6a70, 0x66063bca, 0x11010b5c, 0x8f659eff, 0xf862ae69,
  0x616bffd3, 0x166ccf45, 0xa00ae278, 0xd70dd2ee, 0x4e048354, 0x3903b3c2,
  0xa7672661, 0xd06016f7, 0x4969474d, 0x3e6e77db, 0xaed16a4a, 0xd9d65adc,
  0x40df0b66, 0x37d83bf0, 0xa9bcae53, 0xdebb9ec5, 0x47b2cf7f, 0x30b5ffe9,
  0xbdbdf21c, 0xcabac28a, 0x53b39330, 0x24b4a3a6, 0xbad03605, 0xcdd70693,
  0x54de5729, 0x23d967bf, 0xb3667a2e, 0xc4614ab8, 0x5d681b02, 0x2a6f2b94,
  0xb40bbe37, 0xc30c8ea1, 0x5a05df1b, 0x2d02ef8d,
];

if (typeof Int32Array !== "undefined") {
  CRC_TABLE = new Int32Array(CRC_TABLE);
}

function ensureBuffer(input) {
  if (Buffer$2.isBuffer(input)) {
    return input;
  }

  var hasNewBufferAPI =
    typeof Buffer$2.alloc === "function" && typeof Buffer$2.from === "function";

  if (typeof input === "number") {
    return hasNewBufferAPI ? Buffer$2.alloc(input) : new Buffer$2(input);
  } else if (typeof input === "string") {
    return hasNewBufferAPI ? Buffer$2.from(input) : new Buffer$2(input);
  } else {
    throw new Error(
      "input must be buffer, number, or string, received " + typeof input,
    );
  }
}

function bufferizeInt(num) {
  var tmp = ensureBuffer(4);
  tmp.writeInt32BE(num, 0);
  return tmp;
}

function _crc32(buf, previous) {
  buf = ensureBuffer(buf);
  if (Buffer$2.isBuffer(previous)) {
    previous = previous.readUInt32BE(0);
  }
  var crc = ~~previous ^ -1;
  for (var n = 0; n < buf.length; n++) {
    crc = CRC_TABLE[(crc ^ buf[n]) & 0xff] ^ (crc >>> 8);
  }
  return crc ^ -1;
}

function crc32$1() {
  return bufferizeInt(_crc32.apply(null, arguments));
}
crc32$1.signed = function () {
  return _crc32.apply(null, arguments);
};
crc32$1.unsigned = function () {
  return _crc32.apply(null, arguments) >>> 0;
};

var bufferCrc32 = crc32$1;

var fs$9 = require$$0$6;
var zlib$2 = zlib$3;
var fd_slicer = fdSlicer;
var crc32 = bufferCrc32;
var util = require$$1$5;
var EventEmitter = require$$0$8.EventEmitter;
var Transform = stream$2.Transform;
var PassThrough = stream$2.PassThrough;
var Writable = stream$2.Writable;

yauzl$1.open = open;
yauzl$1.fromFd = fromFd;
yauzl$1.fromBuffer = fromBuffer;
yauzl$1.fromRandomAccessReader = fromRandomAccessReader;
yauzl$1.dosDateTimeToDate = dosDateTimeToDate;
yauzl$1.validateFileName = validateFileName;
yauzl$1.ZipFile = ZipFile;
yauzl$1.Entry = Entry$1;
yauzl$1.RandomAccessReader = RandomAccessReader;

function open(path, options, callback) {
  if (typeof options === "function") {
    callback = options;
    options = null;
  }
  if (options == null) options = {};
  if (options.autoClose == null) options.autoClose = true;
  if (options.lazyEntries == null) options.lazyEntries = false;
  if (options.decodeStrings == null) options.decodeStrings = true;
  if (options.validateEntrySizes == null) options.validateEntrySizes = true;
  if (options.strictFileNames == null) options.strictFileNames = false;
  if (callback == null) callback = defaultCallback;
  fs$9.open(path, "r", function (err, fd) {
    if (err) return callback(err);
    fromFd(fd, options, function (err, zipfile) {
      if (err) fs$9.close(fd, defaultCallback);
      callback(err, zipfile);
    });
  });
}

function fromFd(fd, options, callback) {
  if (typeof options === "function") {
    callback = options;
    options = null;
  }
  if (options == null) options = {};
  if (options.autoClose == null) options.autoClose = false;
  if (options.lazyEntries == null) options.lazyEntries = false;
  if (options.decodeStrings == null) options.decodeStrings = true;
  if (options.validateEntrySizes == null) options.validateEntrySizes = true;
  if (options.strictFileNames == null) options.strictFileNames = false;
  if (callback == null) callback = defaultCallback;
  fs$9.fstat(fd, function (err, stats) {
    if (err) return callback(err);
    var reader = fd_slicer.createFromFd(fd, { autoClose: true });
    fromRandomAccessReader(reader, stats.size, options, callback);
  });
}

function fromBuffer(buffer, options, callback) {
  if (typeof options === "function") {
    callback = options;
    options = null;
  }
  if (options == null) options = {};
  options.autoClose = false;
  if (options.lazyEntries == null) options.lazyEntries = false;
  if (options.decodeStrings == null) options.decodeStrings = true;
  if (options.validateEntrySizes == null) options.validateEntrySizes = true;
  if (options.strictFileNames == null) options.strictFileNames = false;
  // limit the max chunk size. see https://github.com/thejoshwolfe/yauzl/issues/87
  var reader = fd_slicer.createFromBuffer(buffer, { maxChunkSize: 0x10000 });
  fromRandomAccessReader(reader, buffer.length, options, callback);
}

function fromRandomAccessReader(reader, totalSize, options, callback) {
  if (typeof options === "function") {
    callback = options;
    options = null;
  }
  if (options == null) options = {};
  if (options.autoClose == null) options.autoClose = true;
  if (options.lazyEntries == null) options.lazyEntries = false;
  if (options.decodeStrings == null) options.decodeStrings = true;
  var decodeStrings = !!options.decodeStrings;
  if (options.validateEntrySizes == null) options.validateEntrySizes = true;
  if (options.strictFileNames == null) options.strictFileNames = false;
  if (callback == null) callback = defaultCallback;
  if (typeof totalSize !== "number")
    throw new Error("expected totalSize parameter to be a number");
  if (totalSize > Number.MAX_SAFE_INTEGER) {
    throw new Error(
      "zip file too large. only file sizes up to 2^52 are supported due to JavaScript's Number type being an IEEE 754 double.",
    );
  }

  // the matching unref() call is in zipfile.close()
  reader.ref();

  // eocdr means End of Central Directory Record.
  // search backwards for the eocdr signature.
  // the last field of the eocdr is a variable-length comment.
  // the comment size is encoded in a 2-byte field in the eocdr, which we can't find without trudging backwards through the comment to find it.
  // as a consequence of this design decision, it's possible to have ambiguous zip file metadata if a coherent eocdr was in the comment.
  // we search backwards for a eocdr signature, and hope that whoever made the zip file was smart enough to forbid the eocdr signature in the comment.
  var eocdrWithoutCommentSize = 22;
  var maxCommentSize = 0xffff; // 2-byte size
  var bufferSize = Math.min(
    eocdrWithoutCommentSize + maxCommentSize,
    totalSize,
  );
  var buffer = newBuffer(bufferSize);
  var bufferReadStart = totalSize - buffer.length;
  readAndAssertNoEof(
    reader,
    buffer,
    0,
    bufferSize,
    bufferReadStart,
    function (err) {
      if (err) return callback(err);
      for (var i = bufferSize - eocdrWithoutCommentSize; i >= 0; i -= 1) {
        if (buffer.readUInt32LE(i) !== 0x06054b50) continue;
        // found eocdr
        var eocdrBuffer = buffer.slice(i);

        // 0 - End of central directory signature = 0x06054b50
        // 4 - Number of this disk
        var diskNumber = eocdrBuffer.readUInt16LE(4);
        if (diskNumber !== 0) {
          return callback(
            new Error(
              "multi-disk zip files are not supported: found disk number: " +
                diskNumber,
            ),
          );
        }
        // 6 - Disk where central directory starts
        // 8 - Number of central directory records on this disk
        // 10 - Total number of central directory records
        var entryCount = eocdrBuffer.readUInt16LE(10);
        // 12 - Size of central directory (bytes)
        // 16 - Offset of start of central directory, relative to start of archive
        var centralDirectoryOffset = eocdrBuffer.readUInt32LE(16);
        // 20 - Comment length
        var commentLength = eocdrBuffer.readUInt16LE(20);
        var expectedCommentLength =
          eocdrBuffer.length - eocdrWithoutCommentSize;
        if (commentLength !== expectedCommentLength) {
          return callback(
            new Error(
              "invalid comment length. expected: " +
                expectedCommentLength +
                ". found: " +
                commentLength,
            ),
          );
        }
        // 22 - Comment
        // the encoding is always cp437.
        var comment = decodeStrings
          ? decodeBuffer(eocdrBuffer, 22, eocdrBuffer.length, false)
          : eocdrBuffer.slice(22);

        if (!(entryCount === 0xffff || centralDirectoryOffset === 0xffffffff)) {
          return callback(
            null,
            new ZipFile(
              reader,
              centralDirectoryOffset,
              totalSize,
              entryCount,
              comment,
              options.autoClose,
              options.lazyEntries,
              decodeStrings,
              options.validateEntrySizes,
              options.strictFileNames,
            ),
          );
        }

        // ZIP64 format

        // ZIP64 Zip64 end of central directory locator
        var zip64EocdlBuffer = newBuffer(20);
        var zip64EocdlOffset = bufferReadStart + i - zip64EocdlBuffer.length;
        readAndAssertNoEof(
          reader,
          zip64EocdlBuffer,
          0,
          zip64EocdlBuffer.length,
          zip64EocdlOffset,
          function (err) {
            if (err) return callback(err);

            // 0 - zip64 end of central dir locator signature = 0x07064b50
            if (zip64EocdlBuffer.readUInt32LE(0) !== 0x07064b50) {
              return callback(
                new Error(
                  "invalid zip64 end of central directory locator signature",
                ),
              );
            }
            // 4 - number of the disk with the start of the zip64 end of central directory
            // 8 - relative offset of the zip64 end of central directory record
            var zip64EocdrOffset = readUInt64LE(zip64EocdlBuffer, 8);
            // 16 - total number of disks

            // ZIP64 end of central directory record
            var zip64EocdrBuffer = newBuffer(56);
            readAndAssertNoEof(
              reader,
              zip64EocdrBuffer,
              0,
              zip64EocdrBuffer.length,
              zip64EocdrOffset,
              function (err) {
                if (err) return callback(err);

                // 0 - zip64 end of central dir signature                           4 bytes  (0x06064b50)
                if (zip64EocdrBuffer.readUInt32LE(0) !== 0x06064b50) {
                  return callback(
                    new Error(
                      "invalid zip64 end of central directory record signature",
                    ),
                  );
                }
                // 4 - size of zip64 end of central directory record                8 bytes
                // 12 - version made by                                             2 bytes
                // 14 - version needed to extract                                   2 bytes
                // 16 - number of this disk                                         4 bytes
                // 20 - number of the disk with the start of the central directory  4 bytes
                // 24 - total number of entries in the central directory on this disk         8 bytes
                // 32 - total number of entries in the central directory            8 bytes
                entryCount = readUInt64LE(zip64EocdrBuffer, 32);
                // 40 - size of the central directory                               8 bytes
                // 48 - offset of start of central directory with respect to the starting disk number     8 bytes
                centralDirectoryOffset = readUInt64LE(zip64EocdrBuffer, 48);
                // 56 - zip64 extensible data sector                                (variable size)
                return callback(
                  null,
                  new ZipFile(
                    reader,
                    centralDirectoryOffset,
                    totalSize,
                    entryCount,
                    comment,
                    options.autoClose,
                    options.lazyEntries,
                    decodeStrings,
                    options.validateEntrySizes,
                    options.strictFileNames,
                  ),
                );
              },
            );
          },
        );
        return;
      }
      callback(
        new Error("end of central directory record signature not found"),
      );
    },
  );
}

util.inherits(ZipFile, EventEmitter);
function ZipFile(
  reader,
  centralDirectoryOffset,
  fileSize,
  entryCount,
  comment,
  autoClose,
  lazyEntries,
  decodeStrings,
  validateEntrySizes,
  strictFileNames,
) {
  var self = this;
  EventEmitter.call(self);
  self.reader = reader;
  // forward close events
  self.reader.on("error", function (err) {
    // error closing the fd
    emitError(self, err);
  });
  self.reader.once("close", function () {
    self.emit("close");
  });
  self.readEntryCursor = centralDirectoryOffset;
  self.fileSize = fileSize;
  self.entryCount = entryCount;
  self.comment = comment;
  self.entriesRead = 0;
  self.autoClose = !!autoClose;
  self.lazyEntries = !!lazyEntries;
  self.decodeStrings = !!decodeStrings;
  self.validateEntrySizes = !!validateEntrySizes;
  self.strictFileNames = !!strictFileNames;
  self.isOpen = true;
  self.emittedError = false;

  if (!self.lazyEntries) self._readEntry();
}
ZipFile.prototype.close = function () {
  if (!this.isOpen) return;
  this.isOpen = false;
  this.reader.unref();
};

function emitErrorAndAutoClose(self, err) {
  if (self.autoClose) self.close();
  emitError(self, err);
}
function emitError(self, err) {
  if (self.emittedError) return;
  self.emittedError = true;
  self.emit("error", err);
}

ZipFile.prototype.readEntry = function () {
  if (!this.lazyEntries)
    throw new Error("readEntry() called without lazyEntries:true");
  this._readEntry();
};
ZipFile.prototype._readEntry = function () {
  var self = this;
  if (self.entryCount === self.entriesRead) {
    // done with metadata
    setImmediate(function () {
      if (self.autoClose) self.close();
      if (self.emittedError) return;
      self.emit("end");
    });
    return;
  }
  if (self.emittedError) return;
  var buffer = newBuffer(46);
  readAndAssertNoEof(
    self.reader,
    buffer,
    0,
    buffer.length,
    self.readEntryCursor,
    function (err) {
      if (err) return emitErrorAndAutoClose(self, err);
      if (self.emittedError) return;
      var entry = new Entry$1();
      // 0 - Central directory file header signature
      var signature = buffer.readUInt32LE(0);
      if (signature !== 0x02014b50)
        return emitErrorAndAutoClose(
          self,
          new Error(
            "invalid central directory file header signature: 0x" +
              signature.toString(16),
          ),
        );
      // 4 - Version made by
      entry.versionMadeBy = buffer.readUInt16LE(4);
      // 6 - Version needed to extract (minimum)
      entry.versionNeededToExtract = buffer.readUInt16LE(6);
      // 8 - General purpose bit flag
      entry.generalPurposeBitFlag = buffer.readUInt16LE(8);
      // 10 - Compression method
      entry.compressionMethod = buffer.readUInt16LE(10);
      // 12 - File last modification time
      entry.lastModFileTime = buffer.readUInt16LE(12);
      // 14 - File last modification date
      entry.lastModFileDate = buffer.readUInt16LE(14);
      // 16 - CRC-32
      entry.crc32 = buffer.readUInt32LE(16);
      // 20 - Compressed size
      entry.compressedSize = buffer.readUInt32LE(20);
      // 24 - Uncompressed size
      entry.uncompressedSize = buffer.readUInt32LE(24);
      // 28 - File name length (n)
      entry.fileNameLength = buffer.readUInt16LE(28);
      // 30 - Extra field length (m)
      entry.extraFieldLength = buffer.readUInt16LE(30);
      // 32 - File comment length (k)
      entry.fileCommentLength = buffer.readUInt16LE(32);
      // 34 - Disk number where file starts
      // 36 - Internal file attributes
      entry.internalFileAttributes = buffer.readUInt16LE(36);
      // 38 - External file attributes
      entry.externalFileAttributes = buffer.readUInt32LE(38);
      // 42 - Relative offset of local file header
      entry.relativeOffsetOfLocalHeader = buffer.readUInt32LE(42);

      if (entry.generalPurposeBitFlag & 0x40)
        return emitErrorAndAutoClose(
          self,
          new Error("strong encryption is not supported"),
        );

      self.readEntryCursor += 46;

      buffer = newBuffer(
        entry.fileNameLength + entry.extraFieldLength + entry.fileCommentLength,
      );
      readAndAssertNoEof(
        self.reader,
        buffer,
        0,
        buffer.length,
        self.readEntryCursor,
        function (err) {
          if (err) return emitErrorAndAutoClose(self, err);
          if (self.emittedError) return;
          // 46 - File name
          var isUtf8 = (entry.generalPurposeBitFlag & 0x800) !== 0;
          entry.fileName = self.decodeStrings
            ? decodeBuffer(buffer, 0, entry.fileNameLength, isUtf8)
            : buffer.slice(0, entry.fileNameLength);

          // 46+n - Extra field
          var fileCommentStart = entry.fileNameLength + entry.extraFieldLength;
          var extraFieldBuffer = buffer.slice(
            entry.fileNameLength,
            fileCommentStart,
          );
          entry.extraFields = [];
          var i = 0;
          while (i < extraFieldBuffer.length - 3) {
            var headerId = extraFieldBuffer.readUInt16LE(i + 0);
            var dataSize = extraFieldBuffer.readUInt16LE(i + 2);
            var dataStart = i + 4;
            var dataEnd = dataStart + dataSize;
            if (dataEnd > extraFieldBuffer.length)
              return emitErrorAndAutoClose(
                self,
                new Error("extra field length exceeds extra field buffer size"),
              );
            var dataBuffer = newBuffer(dataSize);
            extraFieldBuffer.copy(dataBuffer, 0, dataStart, dataEnd);
            entry.extraFields.push({
              id: headerId,
              data: dataBuffer,
            });
            i = dataEnd;
          }

          // 46+n+m - File comment
          entry.fileComment = self.decodeStrings
            ? decodeBuffer(
                buffer,
                fileCommentStart,
                fileCommentStart + entry.fileCommentLength,
                isUtf8,
              )
            : buffer.slice(
                fileCommentStart,
                fileCommentStart + entry.fileCommentLength,
              );
          // compatibility hack for https://github.com/thejoshwolfe/yauzl/issues/47
          entry.comment = entry.fileComment;

          self.readEntryCursor += buffer.length;
          self.entriesRead += 1;

          if (
            entry.uncompressedSize === 0xffffffff ||
            entry.compressedSize === 0xffffffff ||
            entry.relativeOffsetOfLocalHeader === 0xffffffff
          ) {
            // ZIP64 format
            // find the Zip64 Extended Information Extra Field
            var zip64EiefBuffer = null;
            for (var i = 0; i < entry.extraFields.length; i++) {
              var extraField = entry.extraFields[i];
              if (extraField.id === 0x0001) {
                zip64EiefBuffer = extraField.data;
                break;
              }
            }
            if (zip64EiefBuffer == null) {
              return emitErrorAndAutoClose(
                self,
                new Error("expected zip64 extended information extra field"),
              );
            }
            var index = 0;
            // 0 - Original Size          8 bytes
            if (entry.uncompressedSize === 0xffffffff) {
              if (index + 8 > zip64EiefBuffer.length) {
                return emitErrorAndAutoClose(
                  self,
                  new Error(
                    "zip64 extended information extra field does not include uncompressed size",
                  ),
                );
              }
              entry.uncompressedSize = readUInt64LE(zip64EiefBuffer, index);
              index += 8;
            }
            // 8 - Compressed Size        8 bytes
            if (entry.compressedSize === 0xffffffff) {
              if (index + 8 > zip64EiefBuffer.length) {
                return emitErrorAndAutoClose(
                  self,
                  new Error(
                    "zip64 extended information extra field does not include compressed size",
                  ),
                );
              }
              entry.compressedSize = readUInt64LE(zip64EiefBuffer, index);
              index += 8;
            }
            // 16 - Relative Header Offset 8 bytes
            if (entry.relativeOffsetOfLocalHeader === 0xffffffff) {
              if (index + 8 > zip64EiefBuffer.length) {
                return emitErrorAndAutoClose(
                  self,
                  new Error(
                    "zip64 extended information extra field does not include relative header offset",
                  ),
                );
              }
              entry.relativeOffsetOfLocalHeader = readUInt64LE(
                zip64EiefBuffer,
                index,
              );
              index += 8;
            }
            // 24 - Disk Start Number      4 bytes
          }

          // check for Info-ZIP Unicode Path Extra Field (0x7075)
          // see https://github.com/thejoshwolfe/yauzl/issues/33
          if (self.decodeStrings) {
            for (var i = 0; i < entry.extraFields.length; i++) {
              var extraField = entry.extraFields[i];
              if (extraField.id === 0x7075) {
                if (extraField.data.length < 6) {
                  // too short to be meaningful
                  continue;
                }
                // Version       1 byte      version of this extra field, currently 1
                if (extraField.data.readUInt8(0) !== 1) {
                  // > Changes may not be backward compatible so this extra
                  // > field should not be used if the version is not recognized.
                  continue;
                }
                // NameCRC32     4 bytes     File Name Field CRC32 Checksum
                var oldNameCrc32 = extraField.data.readUInt32LE(1);
                if (
                  crc32.unsigned(buffer.slice(0, entry.fileNameLength)) !==
                  oldNameCrc32
                ) {
                  // > If the CRC check fails, this UTF-8 Path Extra Field should be
                  // > ignored and the File Name field in the header should be used instead.
                  continue;
                }
                // UnicodeName   Variable    UTF-8 version of the entry File Name
                entry.fileName = decodeBuffer(
                  extraField.data,
                  5,
                  extraField.data.length,
                  true,
                );
                break;
              }
            }
          }

          // validate file size
          if (self.validateEntrySizes && entry.compressionMethod === 0) {
            var expectedCompressedSize = entry.uncompressedSize;
            if (entry.isEncrypted()) {
              // traditional encryption prefixes the file data with a header
              expectedCompressedSize += 12;
            }
            if (entry.compressedSize !== expectedCompressedSize) {
              var msg =
                "compressed/uncompressed size mismatch for stored file: " +
                entry.compressedSize +
                " != " +
                entry.uncompressedSize;
              return emitErrorAndAutoClose(self, new Error(msg));
            }
          }

          if (self.decodeStrings) {
            if (!self.strictFileNames) {
              // allow backslash
              entry.fileName = entry.fileName.replace(/\\/g, "/");
            }
            var errorMessage = validateFileName(
              entry.fileName,
              self.validateFileNameOptions,
            );
            if (errorMessage != null)
              return emitErrorAndAutoClose(self, new Error(errorMessage));
          }
          self.emit("entry", entry);

          if (!self.lazyEntries) self._readEntry();
        },
      );
    },
  );
};

ZipFile.prototype.openReadStream = function (entry, options, callback) {
  var self = this;
  // parameter validation
  var relativeStart = 0;
  var relativeEnd = entry.compressedSize;
  if (callback == null) {
    callback = options;
    options = {};
  } else {
    // validate options that the caller has no excuse to get wrong
    if (options.decrypt != null) {
      if (!entry.isEncrypted()) {
        throw new Error(
          "options.decrypt can only be specified for encrypted entries",
        );
      }
      if (options.decrypt !== false)
        throw new Error("invalid options.decrypt value: " + options.decrypt);
      if (entry.isCompressed()) {
        if (options.decompress !== false)
          throw new Error(
            "entry is encrypted and compressed, and options.decompress !== false",
          );
      }
    }
    if (options.decompress != null) {
      if (!entry.isCompressed()) {
        throw new Error(
          "options.decompress can only be specified for compressed entries",
        );
      }
      if (!(options.decompress === false || options.decompress === true)) {
        throw new Error(
          "invalid options.decompress value: " + options.decompress,
        );
      }
    }
    if (options.start != null || options.end != null) {
      if (entry.isCompressed() && options.decompress !== false) {
        throw new Error(
          "start/end range not allowed for compressed entry without options.decompress === false",
        );
      }
      if (entry.isEncrypted() && options.decrypt !== false) {
        throw new Error(
          "start/end range not allowed for encrypted entry without options.decrypt === false",
        );
      }
    }
    if (options.start != null) {
      relativeStart = options.start;
      if (relativeStart < 0) throw new Error("options.start < 0");
      if (relativeStart > entry.compressedSize)
        throw new Error("options.start > entry.compressedSize");
    }
    if (options.end != null) {
      relativeEnd = options.end;
      if (relativeEnd < 0) throw new Error("options.end < 0");
      if (relativeEnd > entry.compressedSize)
        throw new Error("options.end > entry.compressedSize");
      if (relativeEnd < relativeStart)
        throw new Error("options.end < options.start");
    }
  }
  // any further errors can either be caused by the zipfile,
  // or were introduced in a minor version of yauzl,
  // so should be passed to the client rather than thrown.
  if (!self.isOpen) return callback(new Error("closed"));
  if (entry.isEncrypted()) {
    if (options.decrypt !== false)
      return callback(
        new Error("entry is encrypted, and options.decrypt !== false"),
      );
  }
  // make sure we don't lose the fd before we open the actual read stream
  self.reader.ref();
  var buffer = newBuffer(30);
  readAndAssertNoEof(
    self.reader,
    buffer,
    0,
    buffer.length,
    entry.relativeOffsetOfLocalHeader,
    function (err) {
      try {
        if (err) return callback(err);
        // 0 - Local file header signature = 0x04034b50
        var signature = buffer.readUInt32LE(0);
        if (signature !== 0x04034b50) {
          return callback(
            new Error(
              "invalid local file header signature: 0x" +
                signature.toString(16),
            ),
          );
        }
        // all this should be redundant
        // 4 - Version needed to extract (minimum)
        // 6 - General purpose bit flag
        // 8 - Compression method
        // 10 - File last modification time
        // 12 - File last modification date
        // 14 - CRC-32
        // 18 - Compressed size
        // 22 - Uncompressed size
        // 26 - File name length (n)
        var fileNameLength = buffer.readUInt16LE(26);
        // 28 - Extra field length (m)
        var extraFieldLength = buffer.readUInt16LE(28);
        // 30 - File name
        // 30+n - Extra field
        var localFileHeaderEnd =
          entry.relativeOffsetOfLocalHeader +
          buffer.length +
          fileNameLength +
          extraFieldLength;
        var decompress;
        if (entry.compressionMethod === 0) {
          // 0 - The file is stored (no compression)
          decompress = false;
        } else if (entry.compressionMethod === 8) {
          // 8 - The file is Deflated
          decompress = options.decompress != null ? options.decompress : true;
        } else {
          return callback(
            new Error(
              "unsupported compression method: " + entry.compressionMethod,
            ),
          );
        }
        var fileDataStart = localFileHeaderEnd;
        var fileDataEnd = fileDataStart + entry.compressedSize;
        if (entry.compressedSize !== 0) {
          // bounds check now, because the read streams will probably not complain loud enough.
          // since we're dealing with an unsigned offset plus an unsigned size,
          // we only have 1 thing to check for.
          if (fileDataEnd > self.fileSize) {
            return callback(
              new Error(
                "file data overflows file bounds: " +
                  fileDataStart +
                  " + " +
                  entry.compressedSize +
                  " > " +
                  self.fileSize,
              ),
            );
          }
        }
        var readStream = self.reader.createReadStream({
          start: fileDataStart + relativeStart,
          end: fileDataStart + relativeEnd,
        });
        var endpointStream = readStream;
        if (decompress) {
          var destroyed = false;
          var inflateFilter = zlib$2.createInflateRaw();
          readStream.on("error", function (err) {
            // setImmediate here because errors can be emitted during the first call to pipe()
            setImmediate(function () {
              if (!destroyed) inflateFilter.emit("error", err);
            });
          });
          readStream.pipe(inflateFilter);

          if (self.validateEntrySizes) {
            endpointStream = new AssertByteCountStream(entry.uncompressedSize);
            inflateFilter.on("error", function (err) {
              // forward zlib errors to the client-visible stream
              setImmediate(function () {
                if (!destroyed) endpointStream.emit("error", err);
              });
            });
            inflateFilter.pipe(endpointStream);
          } else {
            // the zlib filter is the client-visible stream
            endpointStream = inflateFilter;
          }
          // this is part of yauzl's API, so implement this function on the client-visible stream
          endpointStream.destroy = function () {
            destroyed = true;
            if (inflateFilter !== endpointStream)
              inflateFilter.unpipe(endpointStream);
            readStream.unpipe(inflateFilter);
            // TODO: the inflateFilter may cause a memory leak. see Issue #27.
            readStream.destroy();
          };
        }
        callback(null, endpointStream);
      } finally {
        self.reader.unref();
      }
    },
  );
};

function Entry$1() {}
Entry$1.prototype.getLastModDate = function () {
  return dosDateTimeToDate(this.lastModFileDate, this.lastModFileTime);
};
Entry$1.prototype.isEncrypted = function () {
  return (this.generalPurposeBitFlag & 0x1) !== 0;
};
Entry$1.prototype.isCompressed = function () {
  return this.compressionMethod === 8;
};

function dosDateTimeToDate(date, time) {
  var day = date & 0x1f; // 1-31
  var month = ((date >> 5) & 0xf) - 1; // 1-12, 0-11
  var year = ((date >> 9) & 0x7f) + 1980; // 0-128, 1980-2108

  var millisecond = 0;
  var second = (time & 0x1f) * 2; // 0-29, 0-58 (even numbers)
  var minute = (time >> 5) & 0x3f; // 0-59
  var hour = (time >> 11) & 0x1f; // 0-23

  return new Date(year, month, day, hour, minute, second, millisecond);
}

function validateFileName(fileName) {
  if (fileName.indexOf("\\") !== -1) {
    return "invalid characters in fileName: " + fileName;
  }
  if (/^[a-zA-Z]:/.test(fileName) || /^\//.test(fileName)) {
    return "absolute path: " + fileName;
  }
  if (fileName.split("/").indexOf("..") !== -1) {
    return "invalid relative path: " + fileName;
  }
  // all good
  return null;
}

function readAndAssertNoEof(
  reader,
  buffer,
  offset,
  length,
  position,
  callback,
) {
  if (length === 0) {
    // fs.read will throw an out-of-bounds error if you try to read 0 bytes from a 0 byte file
    return setImmediate(function () {
      callback(null, newBuffer(0));
    });
  }
  reader.read(buffer, offset, length, position, function (err, bytesRead) {
    if (err) return callback(err);
    if (bytesRead < length) {
      return callback(new Error("unexpected EOF"));
    }
    callback();
  });
}

util.inherits(AssertByteCountStream, Transform);
function AssertByteCountStream(byteCount) {
  Transform.call(this);
  this.actualByteCount = 0;
  this.expectedByteCount = byteCount;
}
AssertByteCountStream.prototype._transform = function (chunk, encoding, cb) {
  this.actualByteCount += chunk.length;
  if (this.actualByteCount > this.expectedByteCount) {
    var msg =
      "too many bytes in the stream. expected " +
      this.expectedByteCount +
      ". got at least " +
      this.actualByteCount;
    return cb(new Error(msg));
  }
  cb(null, chunk);
};
AssertByteCountStream.prototype._flush = function (cb) {
  if (this.actualByteCount < this.expectedByteCount) {
    var msg =
      "not enough bytes in the stream. expected " +
      this.expectedByteCount +
      ". got only " +
      this.actualByteCount;
    return cb(new Error(msg));
  }
  cb();
};

util.inherits(RandomAccessReader, EventEmitter);
function RandomAccessReader() {
  EventEmitter.call(this);
  this.refCount = 0;
}
RandomAccessReader.prototype.ref = function () {
  this.refCount += 1;
};
RandomAccessReader.prototype.unref = function () {
  var self = this;
  self.refCount -= 1;

  if (self.refCount > 0) return;
  if (self.refCount < 0) throw new Error("invalid unref");

  self.close(onCloseDone);

  function onCloseDone(err) {
    if (err) return self.emit("error", err);
    self.emit("close");
  }
};
RandomAccessReader.prototype.createReadStream = function (options) {
  var start = options.start;
  var end = options.end;
  if (start === end) {
    var emptyStream = new PassThrough();
    setImmediate(function () {
      emptyStream.end();
    });
    return emptyStream;
  }
  var stream = this._readStreamForRange(start, end);

  var destroyed = false;
  var refUnrefFilter = new RefUnrefFilter(this);
  stream.on("error", function (err) {
    setImmediate(function () {
      if (!destroyed) refUnrefFilter.emit("error", err);
    });
  });
  refUnrefFilter.destroy = function () {
    stream.unpipe(refUnrefFilter);
    refUnrefFilter.unref();
    stream.destroy();
  };

  var byteCounter = new AssertByteCountStream(end - start);
  refUnrefFilter.on("error", function (err) {
    setImmediate(function () {
      if (!destroyed) byteCounter.emit("error", err);
    });
  });
  byteCounter.destroy = function () {
    destroyed = true;
    refUnrefFilter.unpipe(byteCounter);
    refUnrefFilter.destroy();
  };

  return stream.pipe(refUnrefFilter).pipe(byteCounter);
};
RandomAccessReader.prototype._readStreamForRange = function (start, end) {
  throw new Error("not implemented");
};
RandomAccessReader.prototype.read = function (
  buffer,
  offset,
  length,
  position,
  callback,
) {
  var readStream = this.createReadStream({
    start: position,
    end: position + length,
  });
  var writeStream = new Writable();
  var written = 0;
  writeStream._write = function (chunk, encoding, cb) {
    chunk.copy(buffer, offset + written, 0, chunk.length);
    written += chunk.length;
    cb();
  };
  writeStream.on("finish", callback);
  readStream.on("error", function (error) {
    callback(error);
  });
  readStream.pipe(writeStream);
};
RandomAccessReader.prototype.close = function (callback) {
  setImmediate(callback);
};

util.inherits(RefUnrefFilter, PassThrough);
function RefUnrefFilter(context) {
  PassThrough.call(this);
  this.context = context;
  this.context.ref();
  this.unreffedYet = false;
}
RefUnrefFilter.prototype._flush = function (cb) {
  this.unref();
  cb();
};
RefUnrefFilter.prototype.unref = function (cb) {
  if (this.unreffedYet) return;
  this.unreffedYet = true;
  this.context.unref();
};

var cp437 =
  "\u0000 !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~";
function decodeBuffer(buffer, start, end, isUtf8) {
  if (isUtf8) {
    return buffer.toString("utf8", start, end);
  } else {
    var result = "";
    for (var i = start; i < end; i++) {
      result += cp437[buffer[i]];
    }
    return result;
  }
}

function readUInt64LE(buffer, offset) {
  // there is no native function for this, because we can't actually store 64-bit integers precisely.
  // after 53 bits, JavaScript's Number type (IEEE 754 double) can't store individual integers anymore.
  // but since 53 bits is a whole lot more than 32 bits, we do our best anyway.
  var lower32 = buffer.readUInt32LE(offset);
  var upper32 = buffer.readUInt32LE(offset + 4);
  // we can't use bitshifting here, because JavaScript bitshifting only works on 32-bit integers.
  return upper32 * 0x100000000 + lower32;
  // as long as we're bounds checking the result of this function against the total file size,
  // we'll catch any overflow errors, because we already made sure the total file size was within reason.
}

// Node 10 deprecated new Buffer().
var newBuffer;
if (typeof Buffer.allocUnsafe === "function") {
  newBuffer = function (len) {
    return Buffer.allocUnsafe(len);
  };
} else {
  newBuffer = function (len) {
    return new Buffer(len);
  };
}

function defaultCallback(err) {
  if (err) throw err;
}

srcExports("extract-zip");
const { promisify: promisify$1 } = require$$1$5;
const stream = stream$2;
const yauzl = yauzl$1;

promisify$1(yauzl.open);
promisify$1(stream.pipeline);

var minipass$1 = {};

const proc$1 =
  typeof process === "object" && process
    ? process
    : {
        stdout: null,
        stderr: null,
      };
const EE$3 = require$$0$8;
const Stream$1 = stream$2;
const stringdecoder = require$$2$2;
const SD$1 = stringdecoder.StringDecoder;

const EOF$2 = Symbol("EOF");
const MAYBE_EMIT_END$1 = Symbol("maybeEmitEnd");
const EMITTED_END$1 = Symbol("emittedEnd");
const EMITTING_END$1 = Symbol("emittingEnd");
const EMITTED_ERROR$1 = Symbol("emittedError");
const CLOSED$1 = Symbol("closed");
const READ$2 = Symbol("read");
const FLUSH$1 = Symbol("flush");
const FLUSHCHUNK$1 = Symbol("flushChunk");
const ENCODING$1 = Symbol("encoding");
const DECODER$1 = Symbol("decoder");
const FLOWING$1 = Symbol("flowing");
const PAUSED$1 = Symbol("paused");
const RESUME$1 = Symbol("resume");
const BUFFER$1 = Symbol("buffer");
const PIPES = Symbol("pipes");
const BUFFERLENGTH$1 = Symbol("bufferLength");
const BUFFERPUSH$1 = Symbol("bufferPush");
const BUFFERSHIFT$1 = Symbol("bufferShift");
const OBJECTMODE$1 = Symbol("objectMode");
// internal event when stream is destroyed
const DESTROYED$1 = Symbol("destroyed");
// internal event when stream has an error
const ERROR = Symbol("error");
const EMITDATA$1 = Symbol("emitData");
const EMITEND$1 = Symbol("emitEnd");
const EMITEND2$1 = Symbol("emitEnd2");
const ASYNC$1 = Symbol("async");
const ABORT = Symbol("abort");
const ABORTED$1 = Symbol("aborted");
const SIGNAL = Symbol("signal");

const defer$1 = (fn) => Promise.resolve().then(fn);

// TODO remove when Node v8 support drops
const doIter$1 = commonjsGlobal._MP_NO_ITERATOR_SYMBOLS_ !== "1";
const ASYNCITERATOR$1 =
  (doIter$1 && Symbol.asyncIterator) || Symbol("asyncIterator not implemented");
const ITERATOR$1 =
  (doIter$1 && Symbol.iterator) || Symbol("iterator not implemented");

// events that mean 'the stream is over'
// these are treated specially, and re-emitted
// if they are listened for after emitting.
const isEndish$1 = (ev) =>
  ev === "end" || ev === "finish" || ev === "prefinish";

const isArrayBuffer$1 = (b) =>
  b instanceof ArrayBuffer ||
  (typeof b === "object" &&
    b.constructor &&
    b.constructor.name === "ArrayBuffer" &&
    b.byteLength >= 0);

const isArrayBufferView$1 = (b) => !Buffer.isBuffer(b) && ArrayBuffer.isView(b);

let Pipe$1 = class Pipe {
  constructor(src, dest, opts) {
    this.src = src;
    this.dest = dest;
    this.opts = opts;
    this.ondrain = () => src[RESUME$1]();
    dest.on("drain", this.ondrain);
  }
  unpipe() {
    this.dest.removeListener("drain", this.ondrain);
  }
  // istanbul ignore next - only here for the prototype
  proxyErrors() {}
  end() {
    this.unpipe();
    if (this.opts.end) this.dest.end();
  }
};

let PipeProxyErrors$1 = class PipeProxyErrors extends Pipe$1 {
  unpipe() {
    this.src.removeListener("error", this.proxyErrors);
    super.unpipe();
  }
  constructor(src, dest, opts) {
    super(src, dest, opts);
    this.proxyErrors = (er) => dest.emit("error", er);
    src.on("error", this.proxyErrors);
  }
};

let Minipass$4 = class Minipass extends Stream$1 {
  constructor(options) {
    super();
    this[FLOWING$1] = false;
    // whether we're explicitly paused
    this[PAUSED$1] = false;
    this[PIPES] = [];
    this[BUFFER$1] = [];
    this[OBJECTMODE$1] = (options && options.objectMode) || false;
    if (this[OBJECTMODE$1]) this[ENCODING$1] = null;
    else this[ENCODING$1] = (options && options.encoding) || null;
    if (this[ENCODING$1] === "buffer") this[ENCODING$1] = null;
    this[ASYNC$1] = (options && !!options.async) || false;
    this[DECODER$1] = this[ENCODING$1] ? new SD$1(this[ENCODING$1]) : null;
    this[EOF$2] = false;
    this[EMITTED_END$1] = false;
    this[EMITTING_END$1] = false;
    this[CLOSED$1] = false;
    this[EMITTED_ERROR$1] = null;
    this.writable = true;
    this.readable = true;
    this[BUFFERLENGTH$1] = 0;
    this[DESTROYED$1] = false;
    if (options && options.debugExposeBuffer === true) {
      Object.defineProperty(this, "buffer", { get: () => this[BUFFER$1] });
    }
    if (options && options.debugExposePipes === true) {
      Object.defineProperty(this, "pipes", { get: () => this[PIPES] });
    }
    this[SIGNAL] = options && options.signal;
    this[ABORTED$1] = false;
    if (this[SIGNAL]) {
      this[SIGNAL].addEventListener("abort", () => this[ABORT]());
      if (this[SIGNAL].aborted) {
        this[ABORT]();
      }
    }
  }

  get bufferLength() {
    return this[BUFFERLENGTH$1];
  }

  get encoding() {
    return this[ENCODING$1];
  }
  set encoding(enc) {
    if (this[OBJECTMODE$1])
      throw new Error("cannot set encoding in objectMode");

    if (
      this[ENCODING$1] &&
      enc !== this[ENCODING$1] &&
      ((this[DECODER$1] && this[DECODER$1].lastNeed) || this[BUFFERLENGTH$1])
    )
      throw new Error("cannot change encoding");

    if (this[ENCODING$1] !== enc) {
      this[DECODER$1] = enc ? new SD$1(enc) : null;
      if (this[BUFFER$1].length)
        this[BUFFER$1] = this[BUFFER$1].map((chunk) =>
          this[DECODER$1].write(chunk),
        );
    }

    this[ENCODING$1] = enc;
  }

  setEncoding(enc) {
    this.encoding = enc;
  }

  get objectMode() {
    return this[OBJECTMODE$1];
  }
  set objectMode(om) {
    this[OBJECTMODE$1] = this[OBJECTMODE$1] || !!om;
  }

  get ["async"]() {
    return this[ASYNC$1];
  }
  set ["async"](a) {
    this[ASYNC$1] = this[ASYNC$1] || !!a;
  }

  // drop everything and get out of the flow completely
  [ABORT]() {
    this[ABORTED$1] = true;
    this.emit("abort", this[SIGNAL].reason);
    this.destroy(this[SIGNAL].reason);
  }

  get aborted() {
    return this[ABORTED$1];
  }
  set aborted(_) {}

  write(chunk, encoding, cb) {
    if (this[ABORTED$1]) return false;
    if (this[EOF$2]) throw new Error("write after end");

    if (this[DESTROYED$1]) {
      this.emit(
        "error",
        Object.assign(
          new Error("Cannot call write after a stream was destroyed"),
          { code: "ERR_STREAM_DESTROYED" },
        ),
      );
      return true;
    }

    if (typeof encoding === "function") (cb = encoding), (encoding = "utf8");

    if (!encoding) encoding = "utf8";

    const fn = this[ASYNC$1] ? defer$1 : (f) => f();

    // convert array buffers and typed array views into buffers
    // at some point in the future, we may want to do the opposite!
    // leave strings and buffers as-is
    // anything else switches us into object mode
    if (!this[OBJECTMODE$1] && !Buffer.isBuffer(chunk)) {
      if (isArrayBufferView$1(chunk))
        chunk = Buffer.from(chunk.buffer, chunk.byteOffset, chunk.byteLength);
      else if (isArrayBuffer$1(chunk)) chunk = Buffer.from(chunk);
      else if (typeof chunk !== "string")
        // use the setter so we throw if we have encoding set
        this.objectMode = true;
    }

    // handle object mode up front, since it's simpler
    // this yields better performance, fewer checks later.
    if (this[OBJECTMODE$1]) {
      /* istanbul ignore if - maybe impossible? */
      if (this.flowing && this[BUFFERLENGTH$1] !== 0) this[FLUSH$1](true);

      if (this.flowing) this.emit("data", chunk);
      else this[BUFFERPUSH$1](chunk);

      if (this[BUFFERLENGTH$1] !== 0) this.emit("readable");

      if (cb) fn(cb);

      return this.flowing;
    }

    // at this point the chunk is a buffer or string
    // don't buffer it up or send it to the decoder
    if (!chunk.length) {
      if (this[BUFFERLENGTH$1] !== 0) this.emit("readable");
      if (cb) fn(cb);
      return this.flowing;
    }

    // fast-path writing strings of same encoding to a stream with
    // an empty buffer, skipping the buffer/decoder dance
    if (
      typeof chunk === "string" &&
      // unless it is a string already ready for us to use
      !(encoding === this[ENCODING$1] && !this[DECODER$1].lastNeed)
    ) {
      chunk = Buffer.from(chunk, encoding);
    }

    if (Buffer.isBuffer(chunk) && this[ENCODING$1])
      chunk = this[DECODER$1].write(chunk);

    // Note: flushing CAN potentially switch us into not-flowing mode
    if (this.flowing && this[BUFFERLENGTH$1] !== 0) this[FLUSH$1](true);

    if (this.flowing) this.emit("data", chunk);
    else this[BUFFERPUSH$1](chunk);

    if (this[BUFFERLENGTH$1] !== 0) this.emit("readable");

    if (cb) fn(cb);

    return this.flowing;
  }

  read(n) {
    if (this[DESTROYED$1]) return null;

    if (this[BUFFERLENGTH$1] === 0 || n === 0 || n > this[BUFFERLENGTH$1]) {
      this[MAYBE_EMIT_END$1]();
      return null;
    }

    if (this[OBJECTMODE$1]) n = null;

    if (this[BUFFER$1].length > 1 && !this[OBJECTMODE$1]) {
      if (this.encoding) this[BUFFER$1] = [this[BUFFER$1].join("")];
      else
        this[BUFFER$1] = [Buffer.concat(this[BUFFER$1], this[BUFFERLENGTH$1])];
    }

    const ret = this[READ$2](n || null, this[BUFFER$1][0]);
    this[MAYBE_EMIT_END$1]();
    return ret;
  }

  [READ$2](n, chunk) {
    if (n === chunk.length || n === null) this[BUFFERSHIFT$1]();
    else {
      this[BUFFER$1][0] = chunk.slice(n);
      chunk = chunk.slice(0, n);
      this[BUFFERLENGTH$1] -= n;
    }

    this.emit("data", chunk);

    if (!this[BUFFER$1].length && !this[EOF$2]) this.emit("drain");

    return chunk;
  }

  end(chunk, encoding, cb) {
    if (typeof chunk === "function") (cb = chunk), (chunk = null);
    if (typeof encoding === "function") (cb = encoding), (encoding = "utf8");
    if (chunk) this.write(chunk, encoding);
    if (cb) this.once("end", cb);
    this[EOF$2] = true;
    this.writable = false;

    // if we haven't written anything, then go ahead and emit,
    // even if we're not reading.
    // we'll re-emit if a new 'end' listener is added anyway.
    // This makes MP more suitable to write-only use cases.
    if (this.flowing || !this[PAUSED$1]) this[MAYBE_EMIT_END$1]();
    return this;
  }

  // don't let the internal resume be overwritten
  [RESUME$1]() {
    if (this[DESTROYED$1]) return;

    this[PAUSED$1] = false;
    this[FLOWING$1] = true;
    this.emit("resume");
    if (this[BUFFER$1].length) this[FLUSH$1]();
    else if (this[EOF$2]) this[MAYBE_EMIT_END$1]();
    else this.emit("drain");
  }

  resume() {
    return this[RESUME$1]();
  }

  pause() {
    this[FLOWING$1] = false;
    this[PAUSED$1] = true;
  }

  get destroyed() {
    return this[DESTROYED$1];
  }

  get flowing() {
    return this[FLOWING$1];
  }

  get paused() {
    return this[PAUSED$1];
  }

  [BUFFERPUSH$1](chunk) {
    if (this[OBJECTMODE$1]) this[BUFFERLENGTH$1] += 1;
    else this[BUFFERLENGTH$1] += chunk.length;
    this[BUFFER$1].push(chunk);
  }

  [BUFFERSHIFT$1]() {
    if (this[OBJECTMODE$1]) this[BUFFERLENGTH$1] -= 1;
    else this[BUFFERLENGTH$1] -= this[BUFFER$1][0].length;
    return this[BUFFER$1].shift();
  }

  [FLUSH$1](noDrain) {
    do {} while (
      this[FLUSHCHUNK$1](this[BUFFERSHIFT$1]()) &&
      this[BUFFER$1].length
    );

    if (!noDrain && !this[BUFFER$1].length && !this[EOF$2]) this.emit("drain");
  }

  [FLUSHCHUNK$1](chunk) {
    this.emit("data", chunk);
    return this.flowing;
  }

  pipe(dest, opts) {
    if (this[DESTROYED$1]) return;

    const ended = this[EMITTED_END$1];
    opts = opts || {};
    if (dest === proc$1.stdout || dest === proc$1.stderr) opts.end = false;
    else opts.end = opts.end !== false;
    opts.proxyErrors = !!opts.proxyErrors;

    // piping an ended stream ends immediately
    if (ended) {
      if (opts.end) dest.end();
    } else {
      this[PIPES].push(
        !opts.proxyErrors
          ? new Pipe$1(this, dest, opts)
          : new PipeProxyErrors$1(this, dest, opts),
      );
      if (this[ASYNC$1]) defer$1(() => this[RESUME$1]());
      else this[RESUME$1]();
    }

    return dest;
  }

  unpipe(dest) {
    const p = this[PIPES].find((p) => p.dest === dest);
    if (p) {
      this[PIPES].splice(this[PIPES].indexOf(p), 1);
      p.unpipe();
    }
  }

  addListener(ev, fn) {
    return this.on(ev, fn);
  }

  on(ev, fn) {
    const ret = super.on(ev, fn);
    if (ev === "data" && !this[PIPES].length && !this.flowing) this[RESUME$1]();
    else if (ev === "readable" && this[BUFFERLENGTH$1] !== 0)
      super.emit("readable");
    else if (isEndish$1(ev) && this[EMITTED_END$1]) {
      super.emit(ev);
      this.removeAllListeners(ev);
    } else if (ev === "error" && this[EMITTED_ERROR$1]) {
      if (this[ASYNC$1]) defer$1(() => fn.call(this, this[EMITTED_ERROR$1]));
      else fn.call(this, this[EMITTED_ERROR$1]);
    }
    return ret;
  }

  get emittedEnd() {
    return this[EMITTED_END$1];
  }

  [MAYBE_EMIT_END$1]() {
    if (
      !this[EMITTING_END$1] &&
      !this[EMITTED_END$1] &&
      !this[DESTROYED$1] &&
      this[BUFFER$1].length === 0 &&
      this[EOF$2]
    ) {
      this[EMITTING_END$1] = true;
      this.emit("end");
      this.emit("prefinish");
      this.emit("finish");
      if (this[CLOSED$1]) this.emit("close");
      this[EMITTING_END$1] = false;
    }
  }

  emit(ev, data, ...extra) {
    // error and close are only events allowed after calling destroy()
    if (
      ev !== "error" &&
      ev !== "close" &&
      ev !== DESTROYED$1 &&
      this[DESTROYED$1]
    )
      return;
    else if (ev === "data") {
      return !this[OBJECTMODE$1] && !data
        ? false
        : this[ASYNC$1]
          ? defer$1(() => this[EMITDATA$1](data))
          : this[EMITDATA$1](data);
    } else if (ev === "end") {
      return this[EMITEND$1]();
    } else if (ev === "close") {
      this[CLOSED$1] = true;
      // don't emit close before 'end' and 'finish'
      if (!this[EMITTED_END$1] && !this[DESTROYED$1]) return;
      const ret = super.emit("close");
      this.removeAllListeners("close");
      return ret;
    } else if (ev === "error") {
      this[EMITTED_ERROR$1] = data;
      super.emit(ERROR, data);
      const ret =
        !this[SIGNAL] || this.listeners("error").length
          ? super.emit("error", data)
          : false;
      this[MAYBE_EMIT_END$1]();
      return ret;
    } else if (ev === "resume") {
      const ret = super.emit("resume");
      this[MAYBE_EMIT_END$1]();
      return ret;
    } else if (ev === "finish" || ev === "prefinish") {
      const ret = super.emit(ev);
      this.removeAllListeners(ev);
      return ret;
    }

    // Some other unknown event
    const ret = super.emit(ev, data, ...extra);
    this[MAYBE_EMIT_END$1]();
    return ret;
  }

  [EMITDATA$1](data) {
    for (const p of this[PIPES]) {
      if (p.dest.write(data) === false) this.pause();
    }
    const ret = super.emit("data", data);
    this[MAYBE_EMIT_END$1]();
    return ret;
  }

  [EMITEND$1]() {
    if (this[EMITTED_END$1]) return;

    this[EMITTED_END$1] = true;
    this.readable = false;
    if (this[ASYNC$1]) defer$1(() => this[EMITEND2$1]());
    else this[EMITEND2$1]();
  }

  [EMITEND2$1]() {
    if (this[DECODER$1]) {
      const data = this[DECODER$1].end();
      if (data) {
        for (const p of this[PIPES]) {
          p.dest.write(data);
        }
        super.emit("data", data);
      }
    }

    for (const p of this[PIPES]) {
      p.end();
    }
    const ret = super.emit("end");
    this.removeAllListeners("end");
    return ret;
  }

  // const all = await stream.collect()
  collect() {
    const buf = [];
    if (!this[OBJECTMODE$1]) buf.dataLength = 0;
    // set the promise first, in case an error is raised
    // by triggering the flow here.
    const p = this.promise();
    this.on("data", (c) => {
      buf.push(c);
      if (!this[OBJECTMODE$1]) buf.dataLength += c.length;
    });
    return p.then(() => buf);
  }

  // const data = await stream.concat()
  concat() {
    return this[OBJECTMODE$1]
      ? Promise.reject(new Error("cannot concat in objectMode"))
      : this.collect().then((buf) =>
          this[OBJECTMODE$1]
            ? Promise.reject(new Error("cannot concat in objectMode"))
            : this[ENCODING$1]
              ? buf.join("")
              : Buffer.concat(buf, buf.dataLength),
        );
  }

  // stream.promise().then(() => done, er => emitted error)
  promise() {
    return new Promise((resolve, reject) => {
      this.on(DESTROYED$1, () => reject(new Error("stream destroyed")));
      this.on("error", (er) => reject(er));
      this.on("end", () => resolve());
    });
  }

  // for await (let chunk of stream)
  [ASYNCITERATOR$1]() {
    let stopped = false;
    const stop = () => {
      this.pause();
      stopped = true;
      return Promise.resolve({ done: true });
    };
    const next = () => {
      if (stopped) return stop();
      const res = this.read();
      if (res !== null) return Promise.resolve({ done: false, value: res });

      if (this[EOF$2]) return stop();

      let resolve = null;
      let reject = null;
      const onerr = (er) => {
        this.removeListener("data", ondata);
        this.removeListener("end", onend);
        this.removeListener(DESTROYED$1, ondestroy);
        stop();
        reject(er);
      };
      const ondata = (value) => {
        this.removeListener("error", onerr);
        this.removeListener("end", onend);
        this.removeListener(DESTROYED$1, ondestroy);
        this.pause();
        resolve({ value: value, done: !!this[EOF$2] });
      };
      const onend = () => {
        this.removeListener("error", onerr);
        this.removeListener("data", ondata);
        this.removeListener(DESTROYED$1, ondestroy);
        stop();
        resolve({ done: true });
      };
      const ondestroy = () => onerr(new Error("stream destroyed"));
      return new Promise((res, rej) => {
        reject = rej;
        resolve = res;
        this.once(DESTROYED$1, ondestroy);
        this.once("error", onerr);
        this.once("end", onend);
        this.once("data", ondata);
      });
    };

    return {
      next,
      throw: stop,
      return: stop,
      [ASYNCITERATOR$1]() {
        return this;
      },
    };
  }

  // for (let chunk of stream)
  [ITERATOR$1]() {
    let stopped = false;
    const stop = () => {
      this.pause();
      this.removeListener(ERROR, stop);
      this.removeListener(DESTROYED$1, stop);
      this.removeListener("end", stop);
      stopped = true;
      return { done: true };
    };

    const next = () => {
      if (stopped) return stop();
      const value = this.read();
      return value === null ? stop() : { value };
    };
    this.once("end", stop);
    this.once(ERROR, stop);
    this.once(DESTROYED$1, stop);

    return {
      next,
      throw: stop,
      return: stop,
      [ITERATOR$1]() {
        return this;
      },
    };
  }

  destroy(er) {
    if (this[DESTROYED$1]) {
      if (er) this.emit("error", er);
      else this.emit(DESTROYED$1);
      return this;
    }

    this[DESTROYED$1] = true;

    // throw away all buffered data, it's never coming out
    this[BUFFER$1].length = 0;
    this[BUFFERLENGTH$1] = 0;

    if (typeof this.close === "function" && !this[CLOSED$1]) this.close();

    if (er) this.emit("error", er);
    // if no error to emit, still reject pending promises
    else this.emit(DESTROYED$1);

    return this;
  }

  static isStream(s) {
    return (
      !!s &&
      (s instanceof Minipass ||
        s instanceof Stream$1 ||
        (s instanceof EE$3 &&
          // readable
          (typeof s.pipe === "function" ||
            // writable
            (typeof s.write === "function" && typeof s.end === "function"))))
    );
  }
};

minipass$1.Minipass = Minipass$4;

var minizlib = {};

// Update with any zlib constants that are added or changed in the future.
// Node v6 didn't export this, so we just hard code the version and rely
// on all the other hard-coded values from zlib v4736.  When node v6
// support drops, we can just export the realZlibConstants object.
const realZlibConstants = zlib$3.constants || /* istanbul ignore next */ {
  ZLIB_VERNUM: 4736,
};

var constants$1 = Object.freeze(
  Object.assign(
    Object.create(null),
    {
      Z_NO_FLUSH: 0,
      Z_PARTIAL_FLUSH: 1,
      Z_SYNC_FLUSH: 2,
      Z_FULL_FLUSH: 3,
      Z_FINISH: 4,
      Z_BLOCK: 5,
      Z_OK: 0,
      Z_STREAM_END: 1,
      Z_NEED_DICT: 2,
      Z_ERRNO: -1,
      Z_STREAM_ERROR: -2,
      Z_DATA_ERROR: -3,
      Z_MEM_ERROR: -4,
      Z_BUF_ERROR: -5,
      Z_VERSION_ERROR: -6,
      Z_NO_COMPRESSION: 0,
      Z_BEST_SPEED: 1,
      Z_BEST_COMPRESSION: 9,
      Z_DEFAULT_COMPRESSION: -1,
      Z_FILTERED: 1,
      Z_HUFFMAN_ONLY: 2,
      Z_RLE: 3,
      Z_FIXED: 4,
      Z_DEFAULT_STRATEGY: 0,
      DEFLATE: 1,
      INFLATE: 2,
      GZIP: 3,
      GUNZIP: 4,
      DEFLATERAW: 5,
      INFLATERAW: 6,
      UNZIP: 7,
      BROTLI_DECODE: 8,
      BROTLI_ENCODE: 9,
      Z_MIN_WINDOWBITS: 8,
      Z_MAX_WINDOWBITS: 15,
      Z_DEFAULT_WINDOWBITS: 15,
      Z_MIN_CHUNK: 64,
      Z_MAX_CHUNK: Infinity,
      Z_DEFAULT_CHUNK: 16384,
      Z_MIN_MEMLEVEL: 1,
      Z_MAX_MEMLEVEL: 9,
      Z_DEFAULT_MEMLEVEL: 8,
      Z_MIN_LEVEL: -1,
      Z_MAX_LEVEL: 9,
      Z_DEFAULT_LEVEL: -1,
      BROTLI_OPERATION_PROCESS: 0,
      BROTLI_OPERATION_FLUSH: 1,
      BROTLI_OPERATION_FINISH: 2,
      BROTLI_OPERATION_EMIT_METADATA: 3,
      BROTLI_MODE_GENERIC: 0,
      BROTLI_MODE_TEXT: 1,
      BROTLI_MODE_FONT: 2,
      BROTLI_DEFAULT_MODE: 0,
      BROTLI_MIN_QUALITY: 0,
      BROTLI_MAX_QUALITY: 11,
      BROTLI_DEFAULT_QUALITY: 11,
      BROTLI_MIN_WINDOW_BITS: 10,
      BROTLI_MAX_WINDOW_BITS: 24,
      BROTLI_LARGE_MAX_WINDOW_BITS: 30,
      BROTLI_DEFAULT_WINDOW: 22,
      BROTLI_MIN_INPUT_BLOCK_BITS: 16,
      BROTLI_MAX_INPUT_BLOCK_BITS: 24,
      BROTLI_PARAM_MODE: 0,
      BROTLI_PARAM_QUALITY: 1,
      BROTLI_PARAM_LGWIN: 2,
      BROTLI_PARAM_LGBLOCK: 3,
      BROTLI_PARAM_DISABLE_LITERAL_CONTEXT_MODELING: 4,
      BROTLI_PARAM_SIZE_HINT: 5,
      BROTLI_PARAM_LARGE_WINDOW: 6,
      BROTLI_PARAM_NPOSTFIX: 7,
      BROTLI_PARAM_NDIRECT: 8,
      BROTLI_DECODER_RESULT_ERROR: 0,
      BROTLI_DECODER_RESULT_SUCCESS: 1,
      BROTLI_DECODER_RESULT_NEEDS_MORE_INPUT: 2,
      BROTLI_DECODER_RESULT_NEEDS_MORE_OUTPUT: 3,
      BROTLI_DECODER_PARAM_DISABLE_RING_BUFFER_REALLOCATION: 0,
      BROTLI_DECODER_PARAM_LARGE_WINDOW: 1,
      BROTLI_DECODER_NO_ERROR: 0,
      BROTLI_DECODER_SUCCESS: 1,
      BROTLI_DECODER_NEEDS_MORE_INPUT: 2,
      BROTLI_DECODER_NEEDS_MORE_OUTPUT: 3,
      BROTLI_DECODER_ERROR_FORMAT_EXUBERANT_NIBBLE: -1,
      BROTLI_DECODER_ERROR_FORMAT_RESERVED: -2,
      BROTLI_DECODER_ERROR_FORMAT_EXUBERANT_META_NIBBLE: -3,
      BROTLI_DECODER_ERROR_FORMAT_SIMPLE_HUFFMAN_ALPHABET: -4,
      BROTLI_DECODER_ERROR_FORMAT_SIMPLE_HUFFMAN_SAME: -5,
      BROTLI_DECODER_ERROR_FORMAT_CL_SPACE: -6,
      BROTLI_DECODER_ERROR_FORMAT_HUFFMAN_SPACE: -7,
      BROTLI_DECODER_ERROR_FORMAT_CONTEXT_MAP_REPEAT: -8,
      BROTLI_DECODER_ERROR_FORMAT_BLOCK_LENGTH_1: -9,
      BROTLI_DECODER_ERROR_FORMAT_BLOCK_LENGTH_2: -10,
      BROTLI_DECODER_ERROR_FORMAT_TRANSFORM: -11,
      BROTLI_DECODER_ERROR_FORMAT_DICTIONARY: -12,
      BROTLI_DECODER_ERROR_FORMAT_WINDOW_BITS: -13,
      BROTLI_DECODER_ERROR_FORMAT_PADDING_1: -14,
      BROTLI_DECODER_ERROR_FORMAT_PADDING_2: -15,
      BROTLI_DECODER_ERROR_FORMAT_DISTANCE: -16,
      BROTLI_DECODER_ERROR_DICTIONARY_NOT_SET: -19,
      BROTLI_DECODER_ERROR_INVALID_ARGUMENTS: -20,
      BROTLI_DECODER_ERROR_ALLOC_CONTEXT_MODES: -21,
      BROTLI_DECODER_ERROR_ALLOC_TREE_GROUPS: -22,
      BROTLI_DECODER_ERROR_ALLOC_CONTEXT_MAP: -25,
      BROTLI_DECODER_ERROR_ALLOC_RING_BUFFER_1: -26,
      BROTLI_DECODER_ERROR_ALLOC_RING_BUFFER_2: -27,
      BROTLI_DECODER_ERROR_ALLOC_BLOCK_TYPE_TREES: -30,
      BROTLI_DECODER_ERROR_UNREACHABLE: -31,
    },
    realZlibConstants,
  ),
);

const proc =
  typeof process === "object" && process
    ? process
    : {
        stdout: null,
        stderr: null,
      };
const EE$2 = require$$0$8;
const Stream = stream$2;
const SD = require$$2$2.StringDecoder;

const EOF$1 = Symbol("EOF");
const MAYBE_EMIT_END = Symbol("maybeEmitEnd");
const EMITTED_END = Symbol("emittedEnd");
const EMITTING_END = Symbol("emittingEnd");
const EMITTED_ERROR = Symbol("emittedError");
const CLOSED = Symbol("closed");
const READ$1 = Symbol("read");
const FLUSH = Symbol("flush");
const FLUSHCHUNK = Symbol("flushChunk");
const ENCODING = Symbol("encoding");
const DECODER = Symbol("decoder");
const FLOWING = Symbol("flowing");
const PAUSED = Symbol("paused");
const RESUME = Symbol("resume");
const BUFFERLENGTH = Symbol("bufferLength");
const BUFFERPUSH = Symbol("bufferPush");
const BUFFERSHIFT = Symbol("bufferShift");
const OBJECTMODE = Symbol("objectMode");
const DESTROYED = Symbol("destroyed");
const EMITDATA = Symbol("emitData");
const EMITEND = Symbol("emitEnd");
const EMITEND2 = Symbol("emitEnd2");
const ASYNC = Symbol("async");

const defer = (fn) => Promise.resolve().then(fn);

// TODO remove when Node v8 support drops
const doIter = commonjsGlobal._MP_NO_ITERATOR_SYMBOLS_ !== "1";
const ASYNCITERATOR =
  (doIter && Symbol.asyncIterator) || Symbol("asyncIterator not implemented");
const ITERATOR =
  (doIter && Symbol.iterator) || Symbol("iterator not implemented");

// events that mean 'the stream is over'
// these are treated specially, and re-emitted
// if they are listened for after emitting.
const isEndish = (ev) => ev === "end" || ev === "finish" || ev === "prefinish";

const isArrayBuffer = (b) =>
  b instanceof ArrayBuffer ||
  (typeof b === "object" &&
    b.constructor &&
    b.constructor.name === "ArrayBuffer" &&
    b.byteLength >= 0);

const isArrayBufferView = (b) => !Buffer.isBuffer(b) && ArrayBuffer.isView(b);

class Pipe {
  constructor(src, dest, opts) {
    this.src = src;
    this.dest = dest;
    this.opts = opts;
    this.ondrain = () => src[RESUME]();
    dest.on("drain", this.ondrain);
  }
  unpipe() {
    this.dest.removeListener("drain", this.ondrain);
  }
  // istanbul ignore next - only here for the prototype
  proxyErrors() {}
  end() {
    this.unpipe();
    if (this.opts.end) this.dest.end();
  }
}

class PipeProxyErrors extends Pipe {
  unpipe() {
    this.src.removeListener("error", this.proxyErrors);
    super.unpipe();
  }
  constructor(src, dest, opts) {
    super(src, dest, opts);
    this.proxyErrors = (er) => dest.emit("error", er);
    src.on("error", this.proxyErrors);
  }
}

var minipass = class Minipass extends Stream {
  constructor(options) {
    super();
    this[FLOWING] = false;
    // whether we're explicitly paused
    this[PAUSED] = false;
    this.pipes = [];
    this.buffer = [];
    this[OBJECTMODE] = (options && options.objectMode) || false;
    if (this[OBJECTMODE]) this[ENCODING] = null;
    else this[ENCODING] = (options && options.encoding) || null;
    if (this[ENCODING] === "buffer") this[ENCODING] = null;
    this[ASYNC] = (options && !!options.async) || false;
    this[DECODER] = this[ENCODING] ? new SD(this[ENCODING]) : null;
    this[EOF$1] = false;
    this[EMITTED_END] = false;
    this[EMITTING_END] = false;
    this[CLOSED] = false;
    this[EMITTED_ERROR] = null;
    this.writable = true;
    this.readable = true;
    this[BUFFERLENGTH] = 0;
    this[DESTROYED] = false;
  }

  get bufferLength() {
    return this[BUFFERLENGTH];
  }

  get encoding() {
    return this[ENCODING];
  }
  set encoding(enc) {
    if (this[OBJECTMODE]) throw new Error("cannot set encoding in objectMode");

    if (
      this[ENCODING] &&
      enc !== this[ENCODING] &&
      ((this[DECODER] && this[DECODER].lastNeed) || this[BUFFERLENGTH])
    )
      throw new Error("cannot change encoding");

    if (this[ENCODING] !== enc) {
      this[DECODER] = enc ? new SD(enc) : null;
      if (this.buffer.length)
        this.buffer = this.buffer.map((chunk) => this[DECODER].write(chunk));
    }

    this[ENCODING] = enc;
  }

  setEncoding(enc) {
    this.encoding = enc;
  }

  get objectMode() {
    return this[OBJECTMODE];
  }
  set objectMode(om) {
    this[OBJECTMODE] = this[OBJECTMODE] || !!om;
  }

  get ["async"]() {
    return this[ASYNC];
  }
  set ["async"](a) {
    this[ASYNC] = this[ASYNC] || !!a;
  }

  write(chunk, encoding, cb) {
    if (this[EOF$1]) throw new Error("write after end");

    if (this[DESTROYED]) {
      this.emit(
        "error",
        Object.assign(
          new Error("Cannot call write after a stream was destroyed"),
          { code: "ERR_STREAM_DESTROYED" },
        ),
      );
      return true;
    }

    if (typeof encoding === "function") (cb = encoding), (encoding = "utf8");

    if (!encoding) encoding = "utf8";

    const fn = this[ASYNC] ? defer : (f) => f();

    // convert array buffers and typed array views into buffers
    // at some point in the future, we may want to do the opposite!
    // leave strings and buffers as-is
    // anything else switches us into object mode
    if (!this[OBJECTMODE] && !Buffer.isBuffer(chunk)) {
      if (isArrayBufferView(chunk))
        chunk = Buffer.from(chunk.buffer, chunk.byteOffset, chunk.byteLength);
      else if (isArrayBuffer(chunk)) chunk = Buffer.from(chunk);
      else if (typeof chunk !== "string")
        // use the setter so we throw if we have encoding set
        this.objectMode = true;
    }

    // handle object mode up front, since it's simpler
    // this yields better performance, fewer checks later.
    if (this[OBJECTMODE]) {
      /* istanbul ignore if - maybe impossible? */
      if (this.flowing && this[BUFFERLENGTH] !== 0) this[FLUSH](true);

      if (this.flowing) this.emit("data", chunk);
      else this[BUFFERPUSH](chunk);

      if (this[BUFFERLENGTH] !== 0) this.emit("readable");

      if (cb) fn(cb);

      return this.flowing;
    }

    // at this point the chunk is a buffer or string
    // don't buffer it up or send it to the decoder
    if (!chunk.length) {
      if (this[BUFFERLENGTH] !== 0) this.emit("readable");
      if (cb) fn(cb);
      return this.flowing;
    }

    // fast-path writing strings of same encoding to a stream with
    // an empty buffer, skipping the buffer/decoder dance
    if (
      typeof chunk === "string" &&
      // unless it is a string already ready for us to use
      !(encoding === this[ENCODING] && !this[DECODER].lastNeed)
    ) {
      chunk = Buffer.from(chunk, encoding);
    }

    if (Buffer.isBuffer(chunk) && this[ENCODING])
      chunk = this[DECODER].write(chunk);

    // Note: flushing CAN potentially switch us into not-flowing mode
    if (this.flowing && this[BUFFERLENGTH] !== 0) this[FLUSH](true);

    if (this.flowing) this.emit("data", chunk);
    else this[BUFFERPUSH](chunk);

    if (this[BUFFERLENGTH] !== 0) this.emit("readable");

    if (cb) fn(cb);

    return this.flowing;
  }

  read(n) {
    if (this[DESTROYED]) return null;

    if (this[BUFFERLENGTH] === 0 || n === 0 || n > this[BUFFERLENGTH]) {
      this[MAYBE_EMIT_END]();
      return null;
    }

    if (this[OBJECTMODE]) n = null;

    if (this.buffer.length > 1 && !this[OBJECTMODE]) {
      if (this.encoding) this.buffer = [this.buffer.join("")];
      else this.buffer = [Buffer.concat(this.buffer, this[BUFFERLENGTH])];
    }

    const ret = this[READ$1](n || null, this.buffer[0]);
    this[MAYBE_EMIT_END]();
    return ret;
  }

  [READ$1](n, chunk) {
    if (n === chunk.length || n === null) this[BUFFERSHIFT]();
    else {
      this.buffer[0] = chunk.slice(n);
      chunk = chunk.slice(0, n);
      this[BUFFERLENGTH] -= n;
    }

    this.emit("data", chunk);

    if (!this.buffer.length && !this[EOF$1]) this.emit("drain");

    return chunk;
  }

  end(chunk, encoding, cb) {
    if (typeof chunk === "function") (cb = chunk), (chunk = null);
    if (typeof encoding === "function") (cb = encoding), (encoding = "utf8");
    if (chunk) this.write(chunk, encoding);
    if (cb) this.once("end", cb);
    this[EOF$1] = true;
    this.writable = false;

    // if we haven't written anything, then go ahead and emit,
    // even if we're not reading.
    // we'll re-emit if a new 'end' listener is added anyway.
    // This makes MP more suitable to write-only use cases.
    if (this.flowing || !this[PAUSED]) this[MAYBE_EMIT_END]();
    return this;
  }

  // don't let the internal resume be overwritten
  [RESUME]() {
    if (this[DESTROYED]) return;

    this[PAUSED] = false;
    this[FLOWING] = true;
    this.emit("resume");
    if (this.buffer.length) this[FLUSH]();
    else if (this[EOF$1]) this[MAYBE_EMIT_END]();
    else this.emit("drain");
  }

  resume() {
    return this[RESUME]();
  }

  pause() {
    this[FLOWING] = false;
    this[PAUSED] = true;
  }

  get destroyed() {
    return this[DESTROYED];
  }

  get flowing() {
    return this[FLOWING];
  }

  get paused() {
    return this[PAUSED];
  }

  [BUFFERPUSH](chunk) {
    if (this[OBJECTMODE]) this[BUFFERLENGTH] += 1;
    else this[BUFFERLENGTH] += chunk.length;
    this.buffer.push(chunk);
  }

  [BUFFERSHIFT]() {
    if (this.buffer.length) {
      if (this[OBJECTMODE]) this[BUFFERLENGTH] -= 1;
      else this[BUFFERLENGTH] -= this.buffer[0].length;
    }
    return this.buffer.shift();
  }

  [FLUSH](noDrain) {
    do {} while (this[FLUSHCHUNK](this[BUFFERSHIFT]()));

    if (!noDrain && !this.buffer.length && !this[EOF$1]) this.emit("drain");
  }

  [FLUSHCHUNK](chunk) {
    return chunk ? (this.emit("data", chunk), this.flowing) : false;
  }

  pipe(dest, opts) {
    if (this[DESTROYED]) return;

    const ended = this[EMITTED_END];
    opts = opts || {};
    if (dest === proc.stdout || dest === proc.stderr) opts.end = false;
    else opts.end = opts.end !== false;
    opts.proxyErrors = !!opts.proxyErrors;

    // piping an ended stream ends immediately
    if (ended) {
      if (opts.end) dest.end();
    } else {
      this.pipes.push(
        !opts.proxyErrors
          ? new Pipe(this, dest, opts)
          : new PipeProxyErrors(this, dest, opts),
      );
      if (this[ASYNC]) defer(() => this[RESUME]());
      else this[RESUME]();
    }

    return dest;
  }

  unpipe(dest) {
    const p = this.pipes.find((p) => p.dest === dest);
    if (p) {
      this.pipes.splice(this.pipes.indexOf(p), 1);
      p.unpipe();
    }
  }

  addListener(ev, fn) {
    return this.on(ev, fn);
  }

  on(ev, fn) {
    const ret = super.on(ev, fn);
    if (ev === "data" && !this.pipes.length && !this.flowing) this[RESUME]();
    else if (ev === "readable" && this[BUFFERLENGTH] !== 0)
      super.emit("readable");
    else if (isEndish(ev) && this[EMITTED_END]) {
      super.emit(ev);
      this.removeAllListeners(ev);
    } else if (ev === "error" && this[EMITTED_ERROR]) {
      if (this[ASYNC]) defer(() => fn.call(this, this[EMITTED_ERROR]));
      else fn.call(this, this[EMITTED_ERROR]);
    }
    return ret;
  }

  get emittedEnd() {
    return this[EMITTED_END];
  }

  [MAYBE_EMIT_END]() {
    if (
      !this[EMITTING_END] &&
      !this[EMITTED_END] &&
      !this[DESTROYED] &&
      this.buffer.length === 0 &&
      this[EOF$1]
    ) {
      this[EMITTING_END] = true;
      this.emit("end");
      this.emit("prefinish");
      this.emit("finish");
      if (this[CLOSED]) this.emit("close");
      this[EMITTING_END] = false;
    }
  }

  emit(ev, data, ...extra) {
    // error and close are only events allowed after calling destroy()
    if (ev !== "error" && ev !== "close" && ev !== DESTROYED && this[DESTROYED])
      return;
    else if (ev === "data") {
      return !data
        ? false
        : this[ASYNC]
          ? defer(() => this[EMITDATA](data))
          : this[EMITDATA](data);
    } else if (ev === "end") {
      return this[EMITEND]();
    } else if (ev === "close") {
      this[CLOSED] = true;
      // don't emit close before 'end' and 'finish'
      if (!this[EMITTED_END] && !this[DESTROYED]) return;
      const ret = super.emit("close");
      this.removeAllListeners("close");
      return ret;
    } else if (ev === "error") {
      this[EMITTED_ERROR] = data;
      const ret = super.emit("error", data);
      this[MAYBE_EMIT_END]();
      return ret;
    } else if (ev === "resume") {
      const ret = super.emit("resume");
      this[MAYBE_EMIT_END]();
      return ret;
    } else if (ev === "finish" || ev === "prefinish") {
      const ret = super.emit(ev);
      this.removeAllListeners(ev);
      return ret;
    }

    // Some other unknown event
    const ret = super.emit(ev, data, ...extra);
    this[MAYBE_EMIT_END]();
    return ret;
  }

  [EMITDATA](data) {
    for (const p of this.pipes) {
      if (p.dest.write(data) === false) this.pause();
    }
    const ret = super.emit("data", data);
    this[MAYBE_EMIT_END]();
    return ret;
  }

  [EMITEND]() {
    if (this[EMITTED_END]) return;

    this[EMITTED_END] = true;
    this.readable = false;
    if (this[ASYNC]) defer(() => this[EMITEND2]());
    else this[EMITEND2]();
  }

  [EMITEND2]() {
    if (this[DECODER]) {
      const data = this[DECODER].end();
      if (data) {
        for (const p of this.pipes) {
          p.dest.write(data);
        }
        super.emit("data", data);
      }
    }

    for (const p of this.pipes) {
      p.end();
    }
    const ret = super.emit("end");
    this.removeAllListeners("end");
    return ret;
  }

  // const all = await stream.collect()
  collect() {
    const buf = [];
    if (!this[OBJECTMODE]) buf.dataLength = 0;
    // set the promise first, in case an error is raised
    // by triggering the flow here.
    const p = this.promise();
    this.on("data", (c) => {
      buf.push(c);
      if (!this[OBJECTMODE]) buf.dataLength += c.length;
    });
    return p.then(() => buf);
  }

  // const data = await stream.concat()
  concat() {
    return this[OBJECTMODE]
      ? Promise.reject(new Error("cannot concat in objectMode"))
      : this.collect().then((buf) =>
          this[OBJECTMODE]
            ? Promise.reject(new Error("cannot concat in objectMode"))
            : this[ENCODING]
              ? buf.join("")
              : Buffer.concat(buf, buf.dataLength),
        );
  }

  // stream.promise().then(() => done, er => emitted error)
  promise() {
    return new Promise((resolve, reject) => {
      this.on(DESTROYED, () => reject(new Error("stream destroyed")));
      this.on("error", (er) => reject(er));
      this.on("end", () => resolve());
    });
  }

  // for await (let chunk of stream)
  [ASYNCITERATOR]() {
    const next = () => {
      const res = this.read();
      if (res !== null) return Promise.resolve({ done: false, value: res });

      if (this[EOF$1]) return Promise.resolve({ done: true });

      let resolve = null;
      let reject = null;
      const onerr = (er) => {
        this.removeListener("data", ondata);
        this.removeListener("end", onend);
        reject(er);
      };
      const ondata = (value) => {
        this.removeListener("error", onerr);
        this.removeListener("end", onend);
        this.pause();
        resolve({ value: value, done: !!this[EOF$1] });
      };
      const onend = () => {
        this.removeListener("error", onerr);
        this.removeListener("data", ondata);
        resolve({ done: true });
      };
      const ondestroy = () => onerr(new Error("stream destroyed"));
      return new Promise((res, rej) => {
        reject = rej;
        resolve = res;
        this.once(DESTROYED, ondestroy);
        this.once("error", onerr);
        this.once("end", onend);
        this.once("data", ondata);
      });
    };

    return { next };
  }

  // for (let chunk of stream)
  [ITERATOR]() {
    const next = () => {
      const value = this.read();
      const done = value === null;
      return { value, done };
    };
    return { next };
  }

  destroy(er) {
    if (this[DESTROYED]) {
      if (er) this.emit("error", er);
      else this.emit(DESTROYED);
      return this;
    }

    this[DESTROYED] = true;

    // throw away all buffered data, it's never coming out
    this.buffer.length = 0;
    this[BUFFERLENGTH] = 0;

    if (typeof this.close === "function" && !this[CLOSED]) this.close();

    if (er) this.emit("error", er);
    // if no error to emit, still reject pending promises
    else this.emit(DESTROYED);

    return this;
  }

  static isStream(s) {
    return (
      !!s &&
      (s instanceof Minipass ||
        s instanceof Stream ||
        (s instanceof EE$2 &&
          (typeof s.pipe === "function" || // readable
            (typeof s.write === "function" && typeof s.end === "function")))) // writable
    );
  }
};

const assert$2 = require$$0$9;
const Buffer$1 = require$$0$7.Buffer;
const realZlib = zlib$3;

const constants = (minizlib.constants = constants$1);
const Minipass$3 = minipass;

const OriginalBufferConcat = Buffer$1.concat;

const _superWrite = Symbol("_superWrite");
class ZlibError extends Error {
  constructor(err) {
    super("zlib: " + err.message);
    this.code = err.code;
    this.errno = err.errno;
    /* istanbul ignore if */
    if (!this.code) this.code = "ZLIB_ERROR";

    this.message = "zlib: " + err.message;
    Error.captureStackTrace(this, this.constructor);
  }

  get name() {
    return "ZlibError";
  }
}

// the Zlib class they all inherit from
// This thing manages the queue of requests, and returns
// true or false if there is anything in the queue when
// you call the .write() method.
const _opts = Symbol("opts");
const _flushFlag = Symbol("flushFlag");
const _finishFlushFlag = Symbol("finishFlushFlag");
const _fullFlushFlag = Symbol("fullFlushFlag");
const _handle = Symbol("handle");
const _onError = Symbol("onError");
const _sawError = Symbol("sawError");
const _level = Symbol("level");
const _strategy = Symbol("strategy");
const _ended$1 = Symbol("ended");

class ZlibBase extends Minipass$3 {
  constructor(opts, mode) {
    if (!opts || typeof opts !== "object")
      throw new TypeError("invalid options for ZlibBase constructor");

    super(opts);
    this[_sawError] = false;
    this[_ended$1] = false;
    this[_opts] = opts;

    this[_flushFlag] = opts.flush;
    this[_finishFlushFlag] = opts.finishFlush;
    // this will throw if any options are invalid for the class selected
    try {
      this[_handle] = new realZlib[mode](opts);
    } catch (er) {
      // make sure that all errors get decorated properly
      throw new ZlibError(er);
    }

    this[_onError] = (err) => {
      // no sense raising multiple errors, since we abort on the first one.
      if (this[_sawError]) return;

      this[_sawError] = true;

      // there is no way to cleanly recover.
      // continuing only obscures problems.
      this.close();
      this.emit("error", err);
    };

    this[_handle].on("error", (er) => this[_onError](new ZlibError(er)));
    this.once("end", () => this.close);
  }

  close() {
    if (this[_handle]) {
      this[_handle].close();
      this[_handle] = null;
      this.emit("close");
    }
  }

  reset() {
    if (!this[_sawError]) {
      assert$2(this[_handle], "zlib binding closed");
      return this[_handle].reset();
    }
  }

  flush(flushFlag) {
    if (this.ended) return;

    if (typeof flushFlag !== "number") flushFlag = this[_fullFlushFlag];
    this.write(Object.assign(Buffer$1.alloc(0), { [_flushFlag]: flushFlag }));
  }

  end(chunk, encoding, cb) {
    if (chunk) this.write(chunk, encoding);
    this.flush(this[_finishFlushFlag]);
    this[_ended$1] = true;
    return super.end(null, null, cb);
  }

  get ended() {
    return this[_ended$1];
  }

  write(chunk, encoding, cb) {
    // process the chunk using the sync process
    // then super.write() all the outputted chunks
    if (typeof encoding === "function") (cb = encoding), (encoding = "utf8");

    if (typeof chunk === "string") chunk = Buffer$1.from(chunk, encoding);

    if (this[_sawError]) return;
    assert$2(this[_handle], "zlib binding closed");

    // _processChunk tries to .close() the native handle after it's done, so we
    // intercept that by temporarily making it a no-op.
    const nativeHandle = this[_handle]._handle;
    const originalNativeClose = nativeHandle.close;
    nativeHandle.close = () => {};
    const originalClose = this[_handle].close;
    this[_handle].close = () => {};
    // It also calls `Buffer.concat()` at the end, which may be convenient
    // for some, but which we are not interested in as it slows us down.
    Buffer$1.concat = (args) => args;
    let result;
    try {
      const flushFlag =
        typeof chunk[_flushFlag] === "number"
          ? chunk[_flushFlag]
          : this[_flushFlag];
      result = this[_handle]._processChunk(chunk, flushFlag);
      // if we don't throw, reset it back how it was
      Buffer$1.concat = OriginalBufferConcat;
    } catch (err) {
      // or if we do, put Buffer.concat() back before we emit error
      // Error events call into user code, which may call Buffer.concat()
      Buffer$1.concat = OriginalBufferConcat;
      this[_onError](new ZlibError(err));
    } finally {
      if (this[_handle]) {
        // Core zlib resets `_handle` to null after attempting to close the
        // native handle. Our no-op handler prevented actual closure, but we
        // need to restore the `._handle` property.
        this[_handle]._handle = nativeHandle;
        nativeHandle.close = originalNativeClose;
        this[_handle].close = originalClose;
        // `_processChunk()` adds an 'error' listener. If we don't remove it
        // after each call, these handlers start piling up.
        this[_handle].removeAllListeners("error");
        // make sure OUR error listener is still attached tho
      }
    }

    if (this[_handle])
      this[_handle].on("error", (er) => this[_onError](new ZlibError(er)));

    let writeReturn;
    if (result) {
      if (Array.isArray(result) && result.length > 0) {
        // The first buffer is always `handle._outBuffer`, which would be
        // re-used for later invocations; so, we always have to copy that one.
        writeReturn = this[_superWrite](Buffer$1.from(result[0]));
        for (let i = 1; i < result.length; i++) {
          writeReturn = this[_superWrite](result[i]);
        }
      } else {
        writeReturn = this[_superWrite](Buffer$1.from(result));
      }
    }

    if (cb) cb();
    return writeReturn;
  }

  [_superWrite](data) {
    return super.write(data);
  }
}

class Zlib extends ZlibBase {
  constructor(opts, mode) {
    opts = opts || {};

    opts.flush = opts.flush || constants.Z_NO_FLUSH;
    opts.finishFlush = opts.finishFlush || constants.Z_FINISH;
    super(opts, mode);

    this[_fullFlushFlag] = constants.Z_FULL_FLUSH;
    this[_level] = opts.level;
    this[_strategy] = opts.strategy;
  }

  params(level, strategy) {
    if (this[_sawError]) return;

    if (!this[_handle])
      throw new Error("cannot switch params when binding is closed");

    // no way to test this without also not supporting params at all
    /* istanbul ignore if */
    if (!this[_handle].params)
      throw new Error("not supported in this implementation");

    if (this[_level] !== level || this[_strategy] !== strategy) {
      this.flush(constants.Z_SYNC_FLUSH);
      assert$2(this[_handle], "zlib binding closed");
      // .params() calls .flush(), but the latter is always async in the
      // core zlib. We override .flush() temporarily to intercept that and
      // flush synchronously.
      const origFlush = this[_handle].flush;
      this[_handle].flush = (flushFlag, cb) => {
        this.flush(flushFlag);
        cb();
      };
      try {
        this[_handle].params(level, strategy);
      } finally {
        this[_handle].flush = origFlush;
      }
      /* istanbul ignore else */
      if (this[_handle]) {
        this[_level] = level;
        this[_strategy] = strategy;
      }
    }
  }
}

// minimal 2-byte header
class Deflate extends Zlib {
  constructor(opts) {
    super(opts, "Deflate");
  }
}

class Inflate extends Zlib {
  constructor(opts) {
    super(opts, "Inflate");
  }
}

// gzip - bigger header, same deflate compression
const _portable = Symbol("_portable");
class Gzip extends Zlib {
  constructor(opts) {
    super(opts, "Gzip");
    this[_portable] = opts && !!opts.portable;
  }

  [_superWrite](data) {
    if (!this[_portable]) return super[_superWrite](data);

    // we'll always get the header emitted in one first chunk
    // overwrite the OS indicator byte with 0xFF
    this[_portable] = false;
    data[9] = 255;
    return super[_superWrite](data);
  }
}

class Gunzip extends Zlib {
  constructor(opts) {
    super(opts, "Gunzip");
  }
}

// raw - no header
class DeflateRaw extends Zlib {
  constructor(opts) {
    super(opts, "DeflateRaw");
  }
}

class InflateRaw extends Zlib {
  constructor(opts) {
    super(opts, "InflateRaw");
  }
}

// auto-detect header.
class Unzip extends Zlib {
  constructor(opts) {
    super(opts, "Unzip");
  }
}

class Brotli extends ZlibBase {
  constructor(opts, mode) {
    opts = opts || {};

    opts.flush = opts.flush || constants.BROTLI_OPERATION_PROCESS;
    opts.finishFlush = opts.finishFlush || constants.BROTLI_OPERATION_FINISH;

    super(opts, mode);

    this[_fullFlushFlag] = constants.BROTLI_OPERATION_FLUSH;
  }
}

class BrotliCompress extends Brotli {
  constructor(opts) {
    super(opts, "BrotliCompress");
  }
}

class BrotliDecompress extends Brotli {
  constructor(opts) {
    super(opts, "BrotliDecompress");
  }
}

minizlib.Deflate = Deflate;
minizlib.Inflate = Inflate;
minizlib.Gzip = Gzip;
minizlib.Gunzip = Gunzip;
minizlib.DeflateRaw = DeflateRaw;
minizlib.InflateRaw = InflateRaw;
minizlib.Unzip = Unzip;
/* istanbul ignore else */
if (typeof realZlib.BrotliCompress === "function") {
  minizlib.BrotliCompress = BrotliCompress;
  minizlib.BrotliDecompress = BrotliDecompress;
} else {
  minizlib.BrotliCompress = minizlib.BrotliDecompress = class {
    constructor() {
      throw new Error("Brotli is not supported in this version of Node.js");
    }
  };
}

// on windows, either \ or / are valid directory separators.
// on unix, \ is a valid character in filenames.
// so, on windows, and only on windows, we replace all \ chars with /,
// so that we can use / as our one and only directory separator char.

const platform$4 = process.env.TESTING_TAR_FAKE_PLATFORM || process.platform;
var normalizeWindowsPath =
  platform$4 !== "win32" ? (p) => p : (p) => p && p.replace(/\\/g, "/");

const { Minipass: Minipass$2 } = minipass$1;
const normPath$4 = normalizeWindowsPath;

const SLURP$1 = Symbol("slurp");
var readEntry = class ReadEntry extends Minipass$2 {
  constructor(header, ex, gex) {
    super();
    // read entries always start life paused.  this is to avoid the
    // situation where Minipass's auto-ending empty streams results
    // in an entry ending before we're ready for it.
    this.pause();
    this.extended = ex;
    this.globalExtended = gex;
    this.header = header;
    this.startBlockSize = 512 * Math.ceil(header.size / 512);
    this.blockRemain = this.startBlockSize;
    this.remain = header.size;
    this.type = header.type;
    this.meta = false;
    this.ignore = false;
    switch (this.type) {
      case "File":
      case "OldFile":
      case "Link":
      case "SymbolicLink":
      case "CharacterDevice":
      case "BlockDevice":
      case "Directory":
      case "FIFO":
      case "ContiguousFile":
      case "GNUDumpDir":
        break;

      case "NextFileHasLongLinkpath":
      case "NextFileHasLongPath":
      case "OldGnuLongPath":
      case "GlobalExtendedHeader":
      case "ExtendedHeader":
      case "OldExtendedHeader":
        this.meta = true;
        break;

      // NOTE: gnutar and bsdtar treat unrecognized types as 'File'
      // it may be worth doing the same, but with a warning.
      default:
        this.ignore = true;
    }

    this.path = normPath$4(header.path);
    this.mode = header.mode;
    if (this.mode) {
      this.mode = this.mode & 0o7777;
    }
    this.uid = header.uid;
    this.gid = header.gid;
    this.uname = header.uname;
    this.gname = header.gname;
    this.size = header.size;
    this.mtime = header.mtime;
    this.atime = header.atime;
    this.ctime = header.ctime;
    this.linkpath = normPath$4(header.linkpath);
    this.uname = header.uname;
    this.gname = header.gname;

    if (ex) {
      this[SLURP$1](ex);
    }
    if (gex) {
      this[SLURP$1](gex, true);
    }
  }

  write(data) {
    const writeLen = data.length;
    if (writeLen > this.blockRemain) {
      throw new Error("writing more to entry than is appropriate");
    }

    const r = this.remain;
    const br = this.blockRemain;
    this.remain = Math.max(0, r - writeLen);
    this.blockRemain = Math.max(0, br - writeLen);
    if (this.ignore) {
      return true;
    }

    if (r >= writeLen) {
      return super.write(data);
    }

    // r < writeLen
    return super.write(data.slice(0, r));
  }

  [SLURP$1](ex, global) {
    for (const k in ex) {
      // we slurp in everything except for the path attribute in
      // a global extended header, because that's weird.
      if (ex[k] !== null && ex[k] !== undefined && !(global && k === "path")) {
        this[k] = k === "path" || k === "linkpath" ? normPath$4(ex[k]) : ex[k];
      }
    }
  }
};

var types$1 = {};

(function (exports) {
  // map types from key to human-friendly name
  exports.name = new Map([
    ["0", "File"],
    // same as File
    ["", "OldFile"],
    ["1", "Link"],
    ["2", "SymbolicLink"],
    // Devices and FIFOs aren't fully supported
    // they are parsed, but skipped when unpacking
    ["3", "CharacterDevice"],
    ["4", "BlockDevice"],
    ["5", "Directory"],
    ["6", "FIFO"],
    // same as File
    ["7", "ContiguousFile"],
    // pax headers
    ["g", "GlobalExtendedHeader"],
    ["x", "ExtendedHeader"],
    // vendor-specific stuff
    // skip
    ["A", "SolarisACL"],
    // like 5, but with data, which should be skipped
    ["D", "GNUDumpDir"],
    // metadata only, skip
    ["I", "Inode"],
    // data = link path of next file
    ["K", "NextFileHasLongLinkpath"],
    // data = path of next file
    ["L", "NextFileHasLongPath"],
    // skip
    ["M", "ContinuationFile"],
    // like L
    ["N", "OldGnuLongPath"],
    // skip
    ["S", "SparseFile"],
    // skip
    ["V", "TapeVolumeHeader"],
    // like x
    ["X", "OldExtendedHeader"],
  ]);

  // map the other direction
  exports.code = new Map(Array.from(exports.name).map((kv) => [kv[1], kv[0]]));
})(types$1);

// Tar can encode large and negative numbers using a leading byte of
// 0xff for negative, and 0x80 for positive.

const encode = (num, buf) => {
  if (!Number.isSafeInteger(num)) {
    // The number is so large that javascript cannot represent it with integer
    // precision.
    throw Error(
      "cannot encode number outside of javascript safe integer range",
    );
  } else if (num < 0) {
    encodeNegative(num, buf);
  } else {
    encodePositive(num, buf);
  }
  return buf;
};

const encodePositive = (num, buf) => {
  buf[0] = 0x80;

  for (var i = buf.length; i > 1; i--) {
    buf[i - 1] = num & 0xff;
    num = Math.floor(num / 0x100);
  }
};

const encodeNegative = (num, buf) => {
  buf[0] = 0xff;
  var flipped = false;
  num = num * -1;
  for (var i = buf.length; i > 1; i--) {
    var byte = num & 0xff;
    num = Math.floor(num / 0x100);
    if (flipped) {
      buf[i - 1] = onesComp(byte);
    } else if (byte === 0) {
      buf[i - 1] = 0;
    } else {
      flipped = true;
      buf[i - 1] = twosComp(byte);
    }
  }
};

const parse$3 = (buf) => {
  const pre = buf[0];
  const value =
    pre === 0x80
      ? pos(buf.slice(1, buf.length))
      : pre === 0xff
        ? twos(buf)
        : null;
  if (value === null) {
    throw Error("invalid base256 encoding");
  }

  if (!Number.isSafeInteger(value)) {
    // The number is so large that javascript cannot represent it with integer
    // precision.
    throw Error("parsed number outside of javascript safe integer range");
  }

  return value;
};

const twos = (buf) => {
  var len = buf.length;
  var sum = 0;
  var flipped = false;
  for (var i = len - 1; i > -1; i--) {
    var byte = buf[i];
    var f;
    if (flipped) {
      f = onesComp(byte);
    } else if (byte === 0) {
      f = byte;
    } else {
      flipped = true;
      f = twosComp(byte);
    }
    if (f !== 0) {
      sum -= f * Math.pow(256, len - i - 1);
    }
  }
  return sum;
};

const pos = (buf) => {
  var len = buf.length;
  var sum = 0;
  for (var i = len - 1; i > -1; i--) {
    var byte = buf[i];
    if (byte !== 0) {
      sum += byte * Math.pow(256, len - i - 1);
    }
  }
  return sum;
};

const onesComp = (byte) => (0xff ^ byte) & 0xff;

const twosComp = (byte) => ((0xff ^ byte) + 1) & 0xff;

var largeNumbers = {
  encode,
  parse: parse$3,
};

// parse a 512-byte header block to a data object, or vice-versa
// encode returns `true` if a pax extended header is needed, because
// the data could not be faithfully encoded in a simple header.
// (Also, check header.needPax to see if it needs a pax header.)

const types = types$1;
const pathModule = require$$0$a.posix;
const large = largeNumbers;

const SLURP = Symbol("slurp");
const TYPE = Symbol("type");

let Header$3 = class Header {
  constructor(data, off, ex, gex) {
    this.cksumValid = false;
    this.needPax = false;
    this.nullBlock = false;

    this.block = null;
    this.path = null;
    this.mode = null;
    this.uid = null;
    this.gid = null;
    this.size = null;
    this.mtime = null;
    this.cksum = null;
    this[TYPE] = "0";
    this.linkpath = null;
    this.uname = null;
    this.gname = null;
    this.devmaj = 0;
    this.devmin = 0;
    this.atime = null;
    this.ctime = null;

    if (Buffer.isBuffer(data)) {
      this.decode(data, off || 0, ex, gex);
    } else if (data) {
      this.set(data);
    }
  }

  decode(buf, off, ex, gex) {
    if (!off) {
      off = 0;
    }

    if (!buf || !(buf.length >= off + 512)) {
      throw new Error("need 512 bytes for header");
    }

    this.path = decString(buf, off, 100);
    this.mode = decNumber(buf, off + 100, 8);
    this.uid = decNumber(buf, off + 108, 8);
    this.gid = decNumber(buf, off + 116, 8);
    this.size = decNumber(buf, off + 124, 12);
    this.mtime = decDate(buf, off + 136, 12);
    this.cksum = decNumber(buf, off + 148, 12);

    // if we have extended or global extended headers, apply them now
    // See https://github.com/npm/node-tar/pull/187
    this[SLURP](ex);
    this[SLURP](gex, true);

    // old tar versions marked dirs as a file with a trailing /
    this[TYPE] = decString(buf, off + 156, 1);
    if (this[TYPE] === "") {
      this[TYPE] = "0";
    }
    if (this[TYPE] === "0" && this.path.slice(-1) === "/") {
      this[TYPE] = "5";
    }

    // tar implementations sometimes incorrectly put the stat(dir).size
    // as the size in the tarball, even though Directory entries are
    // not able to have any body at all.  In the very rare chance that
    // it actually DOES have a body, we weren't going to do anything with
    // it anyway, and it'll just be a warning about an invalid header.
    if (this[TYPE] === "5") {
      this.size = 0;
    }

    this.linkpath = decString(buf, off + 157, 100);
    if (buf.slice(off + 257, off + 265).toString() === "ustar\u000000") {
      this.uname = decString(buf, off + 265, 32);
      this.gname = decString(buf, off + 297, 32);
      this.devmaj = decNumber(buf, off + 329, 8);
      this.devmin = decNumber(buf, off + 337, 8);
      if (buf[off + 475] !== 0) {
        // definitely a prefix, definitely >130 chars.
        const prefix = decString(buf, off + 345, 155);
        this.path = prefix + "/" + this.path;
      } else {
        const prefix = decString(buf, off + 345, 130);
        if (prefix) {
          this.path = prefix + "/" + this.path;
        }
        this.atime = decDate(buf, off + 476, 12);
        this.ctime = decDate(buf, off + 488, 12);
      }
    }

    let sum = 8 * 0x20;
    for (let i = off; i < off + 148; i++) {
      sum += buf[i];
    }

    for (let i = off + 156; i < off + 512; i++) {
      sum += buf[i];
    }

    this.cksumValid = sum === this.cksum;
    if (this.cksum === null && sum === 8 * 0x20) {
      this.nullBlock = true;
    }
  }

  [SLURP](ex, global) {
    for (const k in ex) {
      // we slurp in everything except for the path attribute in
      // a global extended header, because that's weird.
      if (ex[k] !== null && ex[k] !== undefined && !(global && k === "path")) {
        this[k] = ex[k];
      }
    }
  }

  encode(buf, off) {
    if (!buf) {
      buf = this.block = Buffer.alloc(512);
      off = 0;
    }

    if (!off) {
      off = 0;
    }

    if (!(buf.length >= off + 512)) {
      throw new Error("need 512 bytes for header");
    }

    const prefixSize = this.ctime || this.atime ? 130 : 155;
    const split = splitPrefix(this.path || "", prefixSize);
    const path = split[0];
    const prefix = split[1];
    this.needPax = split[2];

    this.needPax = encString(buf, off, 100, path) || this.needPax;
    this.needPax = encNumber(buf, off + 100, 8, this.mode) || this.needPax;
    this.needPax = encNumber(buf, off + 108, 8, this.uid) || this.needPax;
    this.needPax = encNumber(buf, off + 116, 8, this.gid) || this.needPax;
    this.needPax = encNumber(buf, off + 124, 12, this.size) || this.needPax;
    this.needPax = encDate(buf, off + 136, 12, this.mtime) || this.needPax;
    buf[off + 156] = this[TYPE].charCodeAt(0);
    this.needPax =
      encString(buf, off + 157, 100, this.linkpath) || this.needPax;
    buf.write("ustar\u000000", off + 257, 8);
    this.needPax = encString(buf, off + 265, 32, this.uname) || this.needPax;
    this.needPax = encString(buf, off + 297, 32, this.gname) || this.needPax;
    this.needPax = encNumber(buf, off + 329, 8, this.devmaj) || this.needPax;
    this.needPax = encNumber(buf, off + 337, 8, this.devmin) || this.needPax;
    this.needPax =
      encString(buf, off + 345, prefixSize, prefix) || this.needPax;
    if (buf[off + 475] !== 0) {
      this.needPax = encString(buf, off + 345, 155, prefix) || this.needPax;
    } else {
      this.needPax = encString(buf, off + 345, 130, prefix) || this.needPax;
      this.needPax = encDate(buf, off + 476, 12, this.atime) || this.needPax;
      this.needPax = encDate(buf, off + 488, 12, this.ctime) || this.needPax;
    }

    let sum = 8 * 0x20;
    for (let i = off; i < off + 148; i++) {
      sum += buf[i];
    }

    for (let i = off + 156; i < off + 512; i++) {
      sum += buf[i];
    }

    this.cksum = sum;
    encNumber(buf, off + 148, 8, this.cksum);
    this.cksumValid = true;

    return this.needPax;
  }

  set(data) {
    for (const i in data) {
      if (data[i] !== null && data[i] !== undefined) {
        this[i] = data[i];
      }
    }
  }

  get type() {
    return types.name.get(this[TYPE]) || this[TYPE];
  }

  get typeKey() {
    return this[TYPE];
  }

  set type(type) {
    if (types.code.has(type)) {
      this[TYPE] = types.code.get(type);
    } else {
      this[TYPE] = type;
    }
  }
};

const splitPrefix = (p, prefixSize) => {
  const pathSize = 100;
  let pp = p;
  let prefix = "";
  let ret;
  const root = pathModule.parse(p).root || ".";

  if (Buffer.byteLength(pp) < pathSize) {
    ret = [pp, prefix, false];
  } else {
    // first set prefix to the dir, and path to the base
    prefix = pathModule.dirname(pp);
    pp = pathModule.basename(pp);

    do {
      if (
        Buffer.byteLength(pp) <= pathSize &&
        Buffer.byteLength(prefix) <= prefixSize
      ) {
        // both fit!
        ret = [pp, prefix, false];
      } else if (
        Buffer.byteLength(pp) > pathSize &&
        Buffer.byteLength(prefix) <= prefixSize
      ) {
        // prefix fits in prefix, but path doesn't fit in path
        ret = [pp.slice(0, pathSize - 1), prefix, true];
      } else {
        // make path take a bit from prefix
        pp = pathModule.join(pathModule.basename(prefix), pp);
        prefix = pathModule.dirname(prefix);
      }
    } while (prefix !== root && !ret);

    // at this point, found no resolution, just truncate
    if (!ret) {
      ret = [p.slice(0, pathSize - 1), "", true];
    }
  }
  return ret;
};

const decString = (buf, off, size) =>
  buf
    .slice(off, off + size)
    .toString("utf8")
    .replace(/\0.*/, "");

const decDate = (buf, off, size) => numToDate(decNumber(buf, off, size));

const numToDate = (num) => (num === null ? null : new Date(num * 1000));

const decNumber = (buf, off, size) =>
  buf[off] & 0x80
    ? large.parse(buf.slice(off, off + size))
    : decSmallNumber(buf, off, size);

const nanNull = (value) => (isNaN(value) ? null : value);

const decSmallNumber = (buf, off, size) =>
  nanNull(
    parseInt(
      buf
        .slice(off, off + size)
        .toString("utf8")
        .replace(/\0.*$/, "")
        .trim(),
      8,
    ),
  );

// the maximum encodable as a null-terminated octal, by field size
const MAXNUM = {
  12: 0o77777777777,
  8: 0o7777777,
};

const encNumber = (buf, off, size, number) =>
  number === null
    ? false
    : number > MAXNUM[size] || number < 0
      ? (large.encode(number, buf.slice(off, off + size)), true)
      : (encSmallNumber(buf, off, size, number), false);

const encSmallNumber = (buf, off, size, number) =>
  buf.write(octalString(number, size), off, size, "ascii");

const octalString = (number, size) =>
  padOctal(Math.floor(number).toString(8), size);

const padOctal = (string, size) =>
  (string.length === size - 1
    ? string
    : new Array(size - string.length - 1).join("0") + string + " ") + "\0";

const encDate = (buf, off, size, date) =>
  date === null ? false : encNumber(buf, off, size, date.getTime() / 1000);

// enough to fill the longest string we've got
const NULLS = new Array(156).join("\0");
// pad with nulls, return true if it's longer or non-ascii
const encString = (buf, off, size, string) =>
  string === null
    ? false
    : (buf.write(string + NULLS, off, size, "utf8"),
      string.length !== Buffer.byteLength(string) || string.length > size);

var header = Header$3;

const Header$2 = header;
const path$5 = require$$0$a;

let Pax$2 = class Pax {
  constructor(obj, global) {
    this.atime = obj.atime || null;
    this.charset = obj.charset || null;
    this.comment = obj.comment || null;
    this.ctime = obj.ctime || null;
    this.gid = obj.gid || null;
    this.gname = obj.gname || null;
    this.linkpath = obj.linkpath || null;
    this.mtime = obj.mtime || null;
    this.path = obj.path || null;
    this.size = obj.size || null;
    this.uid = obj.uid || null;
    this.uname = obj.uname || null;
    this.dev = obj.dev || null;
    this.ino = obj.ino || null;
    this.nlink = obj.nlink || null;
    this.global = global || false;
  }

  encode() {
    const body = this.encodeBody();
    if (body === "") {
      return null;
    }

    const bodyLen = Buffer.byteLength(body);
    // round up to 512 bytes
    // add 512 for header
    const bufLen = 512 * Math.ceil(1 + bodyLen / 512);
    const buf = Buffer.allocUnsafe(bufLen);

    // 0-fill the header section, it might not hit every field
    for (let i = 0; i < 512; i++) {
      buf[i] = 0;
    }

    new Header$2({
      // XXX split the path
      // then the path should be PaxHeader + basename, but less than 99,
      // prepend with the dirname
      path: ("PaxHeader/" + path$5.basename(this.path)).slice(0, 99),
      mode: this.mode || 0o644,
      uid: this.uid || null,
      gid: this.gid || null,
      size: bodyLen,
      mtime: this.mtime || null,
      type: this.global ? "GlobalExtendedHeader" : "ExtendedHeader",
      linkpath: "",
      uname: this.uname || "",
      gname: this.gname || "",
      devmaj: 0,
      devmin: 0,
      atime: this.atime || null,
      ctime: this.ctime || null,
    }).encode(buf);

    buf.write(body, 512, bodyLen, "utf8");

    // null pad after the body
    for (let i = bodyLen + 512; i < buf.length; i++) {
      buf[i] = 0;
    }

    return buf;
  }

  encodeBody() {
    return (
      this.encodeField("path") +
      this.encodeField("ctime") +
      this.encodeField("atime") +
      this.encodeField("dev") +
      this.encodeField("ino") +
      this.encodeField("nlink") +
      this.encodeField("charset") +
      this.encodeField("comment") +
      this.encodeField("gid") +
      this.encodeField("gname") +
      this.encodeField("linkpath") +
      this.encodeField("mtime") +
      this.encodeField("size") +
      this.encodeField("uid") +
      this.encodeField("uname")
    );
  }

  encodeField(field) {
    if (this[field] === null || this[field] === undefined) {
      return "";
    }
    const v =
      this[field] instanceof Date ? this[field].getTime() / 1000 : this[field];
    const s =
      " " +
      (field === "dev" || field === "ino" || field === "nlink"
        ? "SCHILY."
        : "") +
      field +
      "=" +
      v +
      "\n";
    const byteLen = Buffer.byteLength(s);
    // the digits includes the length of the digits in ascii base-10
    // so if it's 9 characters, then adding 1 for the 9 makes it 10
    // which makes it 11 chars.
    let digits = Math.floor(Math.log(byteLen) / Math.log(10)) + 1;
    if (byteLen + digits >= Math.pow(10, digits)) {
      digits += 1;
    }
    const len = digits + byteLen;
    return len + s;
  }
};

Pax$2.parse = (string, ex, g) => new Pax$2(merge(parseKV(string), ex), g);

const merge = (a, b) =>
  b ? Object.keys(a).reduce((s, k) => ((s[k] = a[k]), s), b) : a;

const parseKV = (string) =>
  string
    .replace(/\n$/, "")
    .split("\n")
    .reduce(parseKVLine, Object.create(null));

const parseKVLine = (set, line) => {
  const n = parseInt(line, 10);

  // XXX Values with \n in them will fail this.
  // Refactor to not be a naive line-by-line parse.
  if (n !== Buffer.byteLength(line) + 1) {
    return set;
  }

  line = line.slice((n + " ").length);
  const kv = line.split("=");
  const k = kv.shift().replace(/^SCHILY\.(dev|ino|nlink)/, "$1");
  if (!k) {
    return set;
  }

  const v = kv.join("=");
  set[k] = /^([A-Z]+\.)?([mac]|birth|creation)time$/.test(k)
    ? new Date(v * 1000)
    : /^[0-9]+$/.test(v)
      ? +v
      : v;
  return set;
};

var pax = Pax$2;

// warning: extremely hot code path.
// This has been meticulously optimized for use
// within npm install on large package trees.
// Do not edit without careful benchmarking.
var stripTrailingSlashes = (str) => {
  let i = str.length - 1;
  let slashesStart = -1;
  while (i > -1 && str.charAt(i) === "/") {
    slashesStart = i;
    i--;
  }
  return slashesStart === -1 ? str : str.slice(0, slashesStart);
};

var warnMixin = (Base) =>
  class extends Base {
    warn(code, message, data = {}) {
      if (this.file) {
        data.file = this.file;
      }
      if (this.cwd) {
        data.cwd = this.cwd;
      }
      data.code = (message instanceof Error && message.code) || code;
      data.tarCode = code;
      if (!this.strict && data.recoverable !== false) {
        if (message instanceof Error) {
          data = Object.assign(message, data);
          message = message.message;
        }
        this.emit("warn", data.tarCode, message, data);
      } else if (message instanceof Error) {
        this.emit("error", Object.assign(message, data));
      } else {
        this.emit(
          "error",
          Object.assign(new Error(`${code}: ${message}`), data),
        );
      }
    }
  };

// When writing files on Windows, translate the characters to their
// 0xf000 higher-encoded versions.

const raw = ["|", "<", ">", "?", ":"];

const win = raw.map((char) => String.fromCharCode(0xf000 + char.charCodeAt(0)));

const toWin = new Map(raw.map((char, i) => [char, win[i]]));
const toRaw = new Map(win.map((char, i) => [char, raw[i]]));

var winchars$1 = {
  encode: (s) => raw.reduce((s, c) => s.split(c).join(toWin.get(c)), s),
  decode: (s) => win.reduce((s, c) => s.split(c).join(toRaw.get(c)), s),
};

// unix absolute paths are also absolute on win32, so we use this for both
const { isAbsolute, parse: parse$2 } = require$$0$a.win32;

// returns [root, stripped]
// Note that windows will think that //x/y/z/a has a "root" of //x/y, and in
// those cases, we want to sanitize it to x/y/z/a, not z/a, so we strip /
// explicitly if it's the first character.
// drive-specific relative paths on Windows get their root stripped off even
// though they are not absolute, so `c:../foo` becomes ['c:', '../foo']
var stripAbsolutePath$2 = (path) => {
  let r = "";

  let parsed = parse$2(path);
  while (isAbsolute(path) || parsed.root) {
    // windows will think that //x/y/z has a "root" of //x/y/
    // but strip the //?/C:/ off of //?/C:/path
    const root =
      path.charAt(0) === "/" && path.slice(0, 4) !== "//?/" ? "/" : parsed.root;
    path = path.slice(root.length);
    r += root;
    parsed = parse$2(path);
  }
  return [r, path];
};

var modeFix$1;
var hasRequiredModeFix;

function requireModeFix() {
  if (hasRequiredModeFix) return modeFix$1;
  hasRequiredModeFix = 1;
  modeFix$1 = (mode, isDir, portable) => {
    mode &= 0o7777;

    // in portable mode, use the minimum reasonable umask
    // if this system creates files with 0o664 by default
    // (as some linux distros do), then we'll write the
    // archive with 0o644 instead.  Also, don't ever create
    // a file that is not readable/writable by the owner.
    if (portable) {
      mode = (mode | 0o600) & ~0o22;
    }

    // if dirs are readable, then they should be listable
    if (isDir) {
      if (mode & 0o400) {
        mode |= 0o100;
      }
      if (mode & 0o40) {
        mode |= 0o10;
      }
      if (mode & 0o4) {
        mode |= 0o1;
      }
    }
    return mode;
  };
  return modeFix$1;
}

const { Minipass: Minipass$1 } = minipass$1;
const Pax$1 = pax;
const Header$1 = header;
const fs$8 = require$$0$6;
const path$4 = require$$0$a;
const normPath$3 = normalizeWindowsPath;
const stripSlash$1 = stripTrailingSlashes;

const prefixPath = (path, prefix) => {
  if (!prefix) {
    return normPath$3(path);
  }
  path = normPath$3(path).replace(/^\.(\/|$)/, "");
  return stripSlash$1(prefix) + "/" + path;
};

const maxReadSize = 16 * 1024 * 1024;
const PROCESS$1 = Symbol("process");
const FILE$1 = Symbol("file");
const DIRECTORY$1 = Symbol("directory");
const SYMLINK$1 = Symbol("symlink");
const HARDLINK$1 = Symbol("hardlink");
const HEADER = Symbol("header");
const READ = Symbol("read");
const LSTAT = Symbol("lstat");
const ONLSTAT = Symbol("onlstat");
const ONREAD = Symbol("onread");
const ONREADLINK = Symbol("onreadlink");
const OPENFILE = Symbol("openfile");
const ONOPENFILE = Symbol("onopenfile");
const CLOSE = Symbol("close");
const MODE = Symbol("mode");
const AWAITDRAIN = Symbol("awaitDrain");
const ONDRAIN$1 = Symbol("ondrain");
const PREFIX = Symbol("prefix");
const HAD_ERROR = Symbol("hadError");
const warner$2 = warnMixin;
const winchars = winchars$1;
const stripAbsolutePath$1 = stripAbsolutePath$2;

const modeFix = requireModeFix();

const WriteEntry$1 = warner$2(
  class WriteEntry extends Minipass$1 {
    constructor(p, opt) {
      opt = opt || {};
      super(opt);
      if (typeof p !== "string") {
        throw new TypeError("path is required");
      }
      this.path = normPath$3(p);
      // suppress atime, ctime, uid, gid, uname, gname
      this.portable = !!opt.portable;
      // until node has builtin pwnam functions, this'll have to do
      this.myuid = (process.getuid && process.getuid()) || 0;
      this.myuser = process.env.USER || "";
      this.maxReadSize = opt.maxReadSize || maxReadSize;
      this.linkCache = opt.linkCache || new Map();
      this.statCache = opt.statCache || new Map();
      this.preservePaths = !!opt.preservePaths;
      this.cwd = normPath$3(opt.cwd || process.cwd());
      this.strict = !!opt.strict;
      this.noPax = !!opt.noPax;
      this.noMtime = !!opt.noMtime;
      this.mtime = opt.mtime || null;
      this.prefix = opt.prefix ? normPath$3(opt.prefix) : null;

      this.fd = null;
      this.blockLen = null;
      this.blockRemain = null;
      this.buf = null;
      this.offset = null;
      this.length = null;
      this.pos = null;
      this.remain = null;

      if (typeof opt.onwarn === "function") {
        this.on("warn", opt.onwarn);
      }

      let pathWarn = false;
      if (!this.preservePaths) {
        const [root, stripped] = stripAbsolutePath$1(this.path);
        if (root) {
          this.path = stripped;
          pathWarn = root;
        }
      }

      this.win32 = !!opt.win32 || process.platform === "win32";
      if (this.win32) {
        // force the \ to / normalization, since we might not *actually*
        // be on windows, but want \ to be considered a path separator.
        this.path = winchars.decode(this.path.replace(/\\/g, "/"));
        p = p.replace(/\\/g, "/");
      }

      this.absolute = normPath$3(opt.absolute || path$4.resolve(this.cwd, p));

      if (this.path === "") {
        this.path = "./";
      }

      if (pathWarn) {
        this.warn(
          "TAR_ENTRY_INFO",
          `stripping ${pathWarn} from absolute path`,
          {
            entry: this,
            path: pathWarn + this.path,
          },
        );
      }

      if (this.statCache.has(this.absolute)) {
        this[ONLSTAT](this.statCache.get(this.absolute));
      } else {
        this[LSTAT]();
      }
    }

    emit(ev, ...data) {
      if (ev === "error") {
        this[HAD_ERROR] = true;
      }
      return super.emit(ev, ...data);
    }

    [LSTAT]() {
      fs$8.lstat(this.absolute, (er, stat) => {
        if (er) {
          return this.emit("error", er);
        }
        this[ONLSTAT](stat);
      });
    }

    [ONLSTAT](stat) {
      this.statCache.set(this.absolute, stat);
      this.stat = stat;
      if (!stat.isFile()) {
        stat.size = 0;
      }
      this.type = getType(stat);
      this.emit("stat", stat);
      this[PROCESS$1]();
    }

    [PROCESS$1]() {
      switch (this.type) {
        case "File":
          return this[FILE$1]();
        case "Directory":
          return this[DIRECTORY$1]();
        case "SymbolicLink":
          return this[SYMLINK$1]();
        // unsupported types are ignored.
        default:
          return this.end();
      }
    }

    [MODE](mode) {
      return modeFix(mode, this.type === "Directory", this.portable);
    }

    [PREFIX](path) {
      return prefixPath(path, this.prefix);
    }

    [HEADER]() {
      if (this.type === "Directory" && this.portable) {
        this.noMtime = true;
      }

      this.header = new Header$1({
        path: this[PREFIX](this.path),
        // only apply the prefix to hard links.
        linkpath:
          this.type === "Link" ? this[PREFIX](this.linkpath) : this.linkpath,
        // only the permissions and setuid/setgid/sticky bitflags
        // not the higher-order bits that specify file type
        mode: this[MODE](this.stat.mode),
        uid: this.portable ? null : this.stat.uid,
        gid: this.portable ? null : this.stat.gid,
        size: this.stat.size,
        mtime: this.noMtime ? null : this.mtime || this.stat.mtime,
        type: this.type,
        uname: this.portable
          ? null
          : this.stat.uid === this.myuid
            ? this.myuser
            : "",
        atime: this.portable ? null : this.stat.atime,
        ctime: this.portable ? null : this.stat.ctime,
      });

      if (this.header.encode() && !this.noPax) {
        super.write(
          new Pax$1({
            atime: this.portable ? null : this.header.atime,
            ctime: this.portable ? null : this.header.ctime,
            gid: this.portable ? null : this.header.gid,
            mtime: this.noMtime ? null : this.mtime || this.header.mtime,
            path: this[PREFIX](this.path),
            linkpath:
              this.type === "Link"
                ? this[PREFIX](this.linkpath)
                : this.linkpath,
            size: this.header.size,
            uid: this.portable ? null : this.header.uid,
            uname: this.portable ? null : this.header.uname,
            dev: this.portable ? null : this.stat.dev,
            ino: this.portable ? null : this.stat.ino,
            nlink: this.portable ? null : this.stat.nlink,
          }).encode(),
        );
      }
      super.write(this.header.block);
    }

    [DIRECTORY$1]() {
      if (this.path.slice(-1) !== "/") {
        this.path += "/";
      }
      this.stat.size = 0;
      this[HEADER]();
      this.end();
    }

    [SYMLINK$1]() {
      fs$8.readlink(this.absolute, (er, linkpath) => {
        if (er) {
          return this.emit("error", er);
        }
        this[ONREADLINK](linkpath);
      });
    }

    [ONREADLINK](linkpath) {
      this.linkpath = normPath$3(linkpath);
      this[HEADER]();
      this.end();
    }

    [HARDLINK$1](linkpath) {
      this.type = "Link";
      this.linkpath = normPath$3(path$4.relative(this.cwd, linkpath));
      this.stat.size = 0;
      this[HEADER]();
      this.end();
    }

    [FILE$1]() {
      if (this.stat.nlink > 1) {
        const linkKey = this.stat.dev + ":" + this.stat.ino;
        if (this.linkCache.has(linkKey)) {
          const linkpath = this.linkCache.get(linkKey);
          if (linkpath.indexOf(this.cwd) === 0) {
            return this[HARDLINK$1](linkpath);
          }
        }
        this.linkCache.set(linkKey, this.absolute);
      }

      this[HEADER]();
      if (this.stat.size === 0) {
        return this.end();
      }

      this[OPENFILE]();
    }

    [OPENFILE]() {
      fs$8.open(this.absolute, "r", (er, fd) => {
        if (er) {
          return this.emit("error", er);
        }
        this[ONOPENFILE](fd);
      });
    }

    [ONOPENFILE](fd) {
      this.fd = fd;
      if (this[HAD_ERROR]) {
        return this[CLOSE]();
      }

      this.blockLen = 512 * Math.ceil(this.stat.size / 512);
      this.blockRemain = this.blockLen;
      const bufLen = Math.min(this.blockLen, this.maxReadSize);
      this.buf = Buffer.allocUnsafe(bufLen);
      this.offset = 0;
      this.pos = 0;
      this.remain = this.stat.size;
      this.length = this.buf.length;
      this[READ]();
    }

    [READ]() {
      const { fd, buf, offset, length, pos } = this;
      fs$8.read(fd, buf, offset, length, pos, (er, bytesRead) => {
        if (er) {
          // ignoring the error from close(2) is a bad practice, but at
          // this point we already have an error, don't need another one
          return this[CLOSE](() => this.emit("error", er));
        }
        this[ONREAD](bytesRead);
      });
    }

    [CLOSE](cb) {
      fs$8.close(this.fd, cb);
    }

    [ONREAD](bytesRead) {
      if (bytesRead <= 0 && this.remain > 0) {
        const er = new Error("encountered unexpected EOF");
        er.path = this.absolute;
        er.syscall = "read";
        er.code = "EOF";
        return this[CLOSE](() => this.emit("error", er));
      }

      if (bytesRead > this.remain) {
        const er = new Error("did not encounter expected EOF");
        er.path = this.absolute;
        er.syscall = "read";
        er.code = "EOF";
        return this[CLOSE](() => this.emit("error", er));
      }

      // null out the rest of the buffer, if we could fit the block padding
      // at the end of this loop, we've incremented bytesRead and this.remain
      // to be incremented up to the blockRemain level, as if we had expected
      // to get a null-padded file, and read it until the end.  then we will
      // decrement both remain and blockRemain by bytesRead, and know that we
      // reached the expected EOF, without any null buffer to append.
      if (bytesRead === this.remain) {
        for (
          let i = bytesRead;
          i < this.length && bytesRead < this.blockRemain;
          i++
        ) {
          this.buf[i + this.offset] = 0;
          bytesRead++;
          this.remain++;
        }
      }

      const writeBuf =
        this.offset === 0 && bytesRead === this.buf.length
          ? this.buf
          : this.buf.slice(this.offset, this.offset + bytesRead);

      const flushed = this.write(writeBuf);
      if (!flushed) {
        this[AWAITDRAIN](() => this[ONDRAIN$1]());
      } else {
        this[ONDRAIN$1]();
      }
    }

    [AWAITDRAIN](cb) {
      this.once("drain", cb);
    }

    write(writeBuf) {
      if (this.blockRemain < writeBuf.length) {
        const er = new Error("writing more data than expected");
        er.path = this.absolute;
        return this.emit("error", er);
      }
      this.remain -= writeBuf.length;
      this.blockRemain -= writeBuf.length;
      this.pos += writeBuf.length;
      this.offset += writeBuf.length;
      return super.write(writeBuf);
    }

    [ONDRAIN$1]() {
      if (!this.remain) {
        if (this.blockRemain) {
          super.write(Buffer.alloc(this.blockRemain));
        }
        return this[CLOSE]((er) => (er ? this.emit("error", er) : this.end()));
      }

      if (this.offset >= this.length) {
        // if we only have a smaller bit left to read, alloc a smaller buffer
        // otherwise, keep it the same length it was before.
        this.buf = Buffer.allocUnsafe(
          Math.min(this.blockRemain, this.buf.length),
        );
        this.offset = 0;
      }
      this.length = this.buf.length - this.offset;
      this[READ]();
    }
  },
);

let WriteEntrySync$1 = class WriteEntrySync extends WriteEntry$1 {
  [LSTAT]() {
    this[ONLSTAT](fs$8.lstatSync(this.absolute));
  }

  [SYMLINK$1]() {
    this[ONREADLINK](fs$8.readlinkSync(this.absolute));
  }

  [OPENFILE]() {
    this[ONOPENFILE](fs$8.openSync(this.absolute, "r"));
  }

  [READ]() {
    let threw = true;
    try {
      const { fd, buf, offset, length, pos } = this;
      const bytesRead = fs$8.readSync(fd, buf, offset, length, pos);
      this[ONREAD](bytesRead);
      threw = false;
    } finally {
      // ignoring the error from close(2) is a bad practice, but at
      // this point we already have an error, don't need another one
      if (threw) {
        try {
          this[CLOSE](() => {});
        } catch (er) {}
      }
    }
  }

  [AWAITDRAIN](cb) {
    cb();
  }

  [CLOSE](cb) {
    fs$8.closeSync(this.fd);
    cb();
  }
};

const WriteEntryTar$1 = warner$2(
  class WriteEntryTar extends Minipass$1 {
    constructor(readEntry, opt) {
      opt = opt || {};
      super(opt);
      this.preservePaths = !!opt.preservePaths;
      this.portable = !!opt.portable;
      this.strict = !!opt.strict;
      this.noPax = !!opt.noPax;
      this.noMtime = !!opt.noMtime;

      this.readEntry = readEntry;
      this.type = readEntry.type;
      if (this.type === "Directory" && this.portable) {
        this.noMtime = true;
      }

      this.prefix = opt.prefix || null;

      this.path = normPath$3(readEntry.path);
      this.mode = this[MODE](readEntry.mode);
      this.uid = this.portable ? null : readEntry.uid;
      this.gid = this.portable ? null : readEntry.gid;
      this.uname = this.portable ? null : readEntry.uname;
      this.gname = this.portable ? null : readEntry.gname;
      this.size = readEntry.size;
      this.mtime = this.noMtime ? null : opt.mtime || readEntry.mtime;
      this.atime = this.portable ? null : readEntry.atime;
      this.ctime = this.portable ? null : readEntry.ctime;
      this.linkpath = normPath$3(readEntry.linkpath);

      if (typeof opt.onwarn === "function") {
        this.on("warn", opt.onwarn);
      }

      let pathWarn = false;
      if (!this.preservePaths) {
        const [root, stripped] = stripAbsolutePath$1(this.path);
        if (root) {
          this.path = stripped;
          pathWarn = root;
        }
      }

      this.remain = readEntry.size;
      this.blockRemain = readEntry.startBlockSize;

      this.header = new Header$1({
        path: this[PREFIX](this.path),
        linkpath:
          this.type === "Link" ? this[PREFIX](this.linkpath) : this.linkpath,
        // only the permissions and setuid/setgid/sticky bitflags
        // not the higher-order bits that specify file type
        mode: this.mode,
        uid: this.portable ? null : this.uid,
        gid: this.portable ? null : this.gid,
        size: this.size,
        mtime: this.noMtime ? null : this.mtime,
        type: this.type,
        uname: this.portable ? null : this.uname,
        atime: this.portable ? null : this.atime,
        ctime: this.portable ? null : this.ctime,
      });

      if (pathWarn) {
        this.warn(
          "TAR_ENTRY_INFO",
          `stripping ${pathWarn} from absolute path`,
          {
            entry: this,
            path: pathWarn + this.path,
          },
        );
      }

      if (this.header.encode() && !this.noPax) {
        super.write(
          new Pax$1({
            atime: this.portable ? null : this.atime,
            ctime: this.portable ? null : this.ctime,
            gid: this.portable ? null : this.gid,
            mtime: this.noMtime ? null : this.mtime,
            path: this[PREFIX](this.path),
            linkpath:
              this.type === "Link"
                ? this[PREFIX](this.linkpath)
                : this.linkpath,
            size: this.size,
            uid: this.portable ? null : this.uid,
            uname: this.portable ? null : this.uname,
            dev: this.portable ? null : this.readEntry.dev,
            ino: this.portable ? null : this.readEntry.ino,
            nlink: this.portable ? null : this.readEntry.nlink,
          }).encode(),
        );
      }

      super.write(this.header.block);
      readEntry.pipe(this);
    }

    [PREFIX](path) {
      return prefixPath(path, this.prefix);
    }

    [MODE](mode) {
      return modeFix(mode, this.type === "Directory", this.portable);
    }

    write(data) {
      const writeLen = data.length;
      if (writeLen > this.blockRemain) {
        throw new Error("writing more to entry than is appropriate");
      }
      this.blockRemain -= writeLen;
      return super.write(data);
    }

    end() {
      if (this.blockRemain) {
        super.write(Buffer.alloc(this.blockRemain));
      }
      return super.end();
    }
  },
);

WriteEntry$1.Sync = WriteEntrySync$1;
WriteEntry$1.Tar = WriteEntryTar$1;

const getType = (stat) =>
  stat.isFile()
    ? "File"
    : stat.isDirectory()
      ? "Directory"
      : stat.isSymbolicLink()
        ? "SymbolicLink"
        : "Unsupported";

var writeEntry = WriteEntry$1;

var iterator;
var hasRequiredIterator;

function requireIterator() {
  if (hasRequiredIterator) return iterator;
  hasRequiredIterator = 1;
  iterator = function (Yallist) {
    Yallist.prototype[Symbol.iterator] = function* () {
      for (let walker = this.head; walker; walker = walker.next) {
        yield walker.value;
      }
    };
  };
  return iterator;
}

var yallist = Yallist$2;

Yallist$2.Node = Node;
Yallist$2.create = Yallist$2;

function Yallist$2(list) {
  var self = this;
  if (!(self instanceof Yallist$2)) {
    self = new Yallist$2();
  }

  self.tail = null;
  self.head = null;
  self.length = 0;

  if (list && typeof list.forEach === "function") {
    list.forEach(function (item) {
      self.push(item);
    });
  } else if (arguments.length > 0) {
    for (var i = 0, l = arguments.length; i < l; i++) {
      self.push(arguments[i]);
    }
  }

  return self;
}

Yallist$2.prototype.removeNode = function (node) {
  if (node.list !== this) {
    throw new Error("removing node which does not belong to this list");
  }

  var next = node.next;
  var prev = node.prev;

  if (next) {
    next.prev = prev;
  }

  if (prev) {
    prev.next = next;
  }

  if (node === this.head) {
    this.head = next;
  }
  if (node === this.tail) {
    this.tail = prev;
  }

  node.list.length--;
  node.next = null;
  node.prev = null;
  node.list = null;

  return next;
};

Yallist$2.prototype.unshiftNode = function (node) {
  if (node === this.head) {
    return;
  }

  if (node.list) {
    node.list.removeNode(node);
  }

  var head = this.head;
  node.list = this;
  node.next = head;
  if (head) {
    head.prev = node;
  }

  this.head = node;
  if (!this.tail) {
    this.tail = node;
  }
  this.length++;
};

Yallist$2.prototype.pushNode = function (node) {
  if (node === this.tail) {
    return;
  }

  if (node.list) {
    node.list.removeNode(node);
  }

  var tail = this.tail;
  node.list = this;
  node.prev = tail;
  if (tail) {
    tail.next = node;
  }

  this.tail = node;
  if (!this.head) {
    this.head = node;
  }
  this.length++;
};

Yallist$2.prototype.push = function () {
  for (var i = 0, l = arguments.length; i < l; i++) {
    push(this, arguments[i]);
  }
  return this.length;
};

Yallist$2.prototype.unshift = function () {
  for (var i = 0, l = arguments.length; i < l; i++) {
    unshift(this, arguments[i]);
  }
  return this.length;
};

Yallist$2.prototype.pop = function () {
  if (!this.tail) {
    return undefined;
  }

  var res = this.tail.value;
  this.tail = this.tail.prev;
  if (this.tail) {
    this.tail.next = null;
  } else {
    this.head = null;
  }
  this.length--;
  return res;
};

Yallist$2.prototype.shift = function () {
  if (!this.head) {
    return undefined;
  }

  var res = this.head.value;
  this.head = this.head.next;
  if (this.head) {
    this.head.prev = null;
  } else {
    this.tail = null;
  }
  this.length--;
  return res;
};

Yallist$2.prototype.forEach = function (fn, thisp) {
  thisp = thisp || this;
  for (var walker = this.head, i = 0; walker !== null; i++) {
    fn.call(thisp, walker.value, i, this);
    walker = walker.next;
  }
};

Yallist$2.prototype.forEachReverse = function (fn, thisp) {
  thisp = thisp || this;
  for (var walker = this.tail, i = this.length - 1; walker !== null; i--) {
    fn.call(thisp, walker.value, i, this);
    walker = walker.prev;
  }
};

Yallist$2.prototype.get = function (n) {
  for (var i = 0, walker = this.head; walker !== null && i < n; i++) {
    // abort out of the list early if we hit a cycle
    walker = walker.next;
  }
  if (i === n && walker !== null) {
    return walker.value;
  }
};

Yallist$2.prototype.getReverse = function (n) {
  for (var i = 0, walker = this.tail; walker !== null && i < n; i++) {
    // abort out of the list early if we hit a cycle
    walker = walker.prev;
  }
  if (i === n && walker !== null) {
    return walker.value;
  }
};

Yallist$2.prototype.map = function (fn, thisp) {
  thisp = thisp || this;
  var res = new Yallist$2();
  for (var walker = this.head; walker !== null; ) {
    res.push(fn.call(thisp, walker.value, this));
    walker = walker.next;
  }
  return res;
};

Yallist$2.prototype.mapReverse = function (fn, thisp) {
  thisp = thisp || this;
  var res = new Yallist$2();
  for (var walker = this.tail; walker !== null; ) {
    res.push(fn.call(thisp, walker.value, this));
    walker = walker.prev;
  }
  return res;
};

Yallist$2.prototype.reduce = function (fn, initial) {
  var acc;
  var walker = this.head;
  if (arguments.length > 1) {
    acc = initial;
  } else if (this.head) {
    walker = this.head.next;
    acc = this.head.value;
  } else {
    throw new TypeError("Reduce of empty list with no initial value");
  }

  for (var i = 0; walker !== null; i++) {
    acc = fn(acc, walker.value, i);
    walker = walker.next;
  }

  return acc;
};

Yallist$2.prototype.reduceReverse = function (fn, initial) {
  var acc;
  var walker = this.tail;
  if (arguments.length > 1) {
    acc = initial;
  } else if (this.tail) {
    walker = this.tail.prev;
    acc = this.tail.value;
  } else {
    throw new TypeError("Reduce of empty list with no initial value");
  }

  for (var i = this.length - 1; walker !== null; i--) {
    acc = fn(acc, walker.value, i);
    walker = walker.prev;
  }

  return acc;
};

Yallist$2.prototype.toArray = function () {
  var arr = new Array(this.length);
  for (var i = 0, walker = this.head; walker !== null; i++) {
    arr[i] = walker.value;
    walker = walker.next;
  }
  return arr;
};

Yallist$2.prototype.toArrayReverse = function () {
  var arr = new Array(this.length);
  for (var i = 0, walker = this.tail; walker !== null; i++) {
    arr[i] = walker.value;
    walker = walker.prev;
  }
  return arr;
};

Yallist$2.prototype.slice = function (from, to) {
  to = to || this.length;
  if (to < 0) {
    to += this.length;
  }
  from = from || 0;
  if (from < 0) {
    from += this.length;
  }
  var ret = new Yallist$2();
  if (to < from || to < 0) {
    return ret;
  }
  if (from < 0) {
    from = 0;
  }
  if (to > this.length) {
    to = this.length;
  }
  for (var i = 0, walker = this.head; walker !== null && i < from; i++) {
    walker = walker.next;
  }
  for (; walker !== null && i < to; i++, walker = walker.next) {
    ret.push(walker.value);
  }
  return ret;
};

Yallist$2.prototype.sliceReverse = function (from, to) {
  to = to || this.length;
  if (to < 0) {
    to += this.length;
  }
  from = from || 0;
  if (from < 0) {
    from += this.length;
  }
  var ret = new Yallist$2();
  if (to < from || to < 0) {
    return ret;
  }
  if (from < 0) {
    from = 0;
  }
  if (to > this.length) {
    to = this.length;
  }
  for (
    var i = this.length, walker = this.tail;
    walker !== null && i > to;
    i--
  ) {
    walker = walker.prev;
  }
  for (; walker !== null && i > from; i--, walker = walker.prev) {
    ret.push(walker.value);
  }
  return ret;
};

Yallist$2.prototype.splice = function (start, deleteCount, ...nodes) {
  if (start > this.length) {
    start = this.length - 1;
  }
  if (start < 0) {
    start = this.length + start;
  }

  for (var i = 0, walker = this.head; walker !== null && i < start; i++) {
    walker = walker.next;
  }

  var ret = [];
  for (var i = 0; walker && i < deleteCount; i++) {
    ret.push(walker.value);
    walker = this.removeNode(walker);
  }
  if (walker === null) {
    walker = this.tail;
  }

  if (walker !== this.head && walker !== this.tail) {
    walker = walker.prev;
  }

  for (var i = 0; i < nodes.length; i++) {
    walker = insert(this, walker, nodes[i]);
  }
  return ret;
};

Yallist$2.prototype.reverse = function () {
  var head = this.head;
  var tail = this.tail;
  for (var walker = head; walker !== null; walker = walker.prev) {
    var p = walker.prev;
    walker.prev = walker.next;
    walker.next = p;
  }
  this.head = tail;
  this.tail = head;
  return this;
};

function insert(self, node, value) {
  var inserted =
    node === self.head
      ? new Node(value, null, node, self)
      : new Node(value, node, node.next, self);

  if (inserted.next === null) {
    self.tail = inserted;
  }
  if (inserted.prev === null) {
    self.head = inserted;
  }

  self.length++;

  return inserted;
}

function push(self, item) {
  self.tail = new Node(item, self.tail, null, self);
  if (!self.head) {
    self.head = self.tail;
  }
  self.length++;
}

function unshift(self, item) {
  self.head = new Node(item, null, self.head, self);
  if (!self.tail) {
    self.tail = self.head;
  }
  self.length++;
}

function Node(value, prev, next, list) {
  if (!(this instanceof Node)) {
    return new Node(value, prev, next, list);
  }

  this.list = list;
  this.value = value;

  if (prev) {
    prev.next = this;
    this.prev = prev;
  } else {
    this.prev = null;
  }

  if (next) {
    next.prev = this;
    this.next = next;
  } else {
    this.next = null;
  }
}

try {
  // add if support for Symbol.iterator is present
  requireIterator()(Yallist$2);
} catch (er) {}

// A readable tar stream creator
// Technically, this is a transform stream that you write paths into,
// and tar format comes out of.
// The `add()` method is like `write()` but returns this,
// and end() return `this` as well, so you can
// do `new Pack(opt).add('files').add('dir').end().pipe(output)
// You could also do something like:
// streamOfPaths().pipe(new Pack()).pipe(new fs.WriteStream('out.tar'))

class PackJob {
  constructor(path, absolute) {
    this.path = path || "./";
    this.absolute = absolute;
    this.entry = null;
    this.stat = null;
    this.readdir = null;
    this.pending = false;
    this.ignore = false;
    this.piped = false;
  }
}

const { Minipass } = minipass$1;
const zlib$1 = minizlib;
const ReadEntry = readEntry;
const WriteEntry = writeEntry;
const WriteEntrySync = WriteEntry.Sync;
const WriteEntryTar = WriteEntry.Tar;
const Yallist$1 = yallist;
const EOF = Buffer.alloc(1024);
const ONSTAT = Symbol("onStat");
const ENDED$2 = Symbol("ended");
const QUEUE$1 = Symbol("queue");
const CURRENT = Symbol("current");
const PROCESS = Symbol("process");
const PROCESSING = Symbol("processing");
const PROCESSJOB = Symbol("processJob");
const JOBS = Symbol("jobs");
const JOBDONE = Symbol("jobDone");
const ADDFSENTRY = Symbol("addFSEntry");
const ADDTARENTRY = Symbol("addTarEntry");
const STAT = Symbol("stat");
const READDIR = Symbol("readdir");
const ONREADDIR = Symbol("onreaddir");
const PIPE = Symbol("pipe");
const ENTRY = Symbol("entry");
const ENTRYOPT = Symbol("entryOpt");
const WRITEENTRYCLASS = Symbol("writeEntryClass");
const WRITE = Symbol("write");
const ONDRAIN = Symbol("ondrain");

const fs$7 = require$$0$6;
const path$3 = require$$0$a;
const warner$1 = warnMixin;
const normPath$2 = normalizeWindowsPath;

const Pack = warner$1(
  class Pack extends Minipass {
    constructor(opt) {
      super(opt);
      opt = opt || Object.create(null);
      this.opt = opt;
      this.file = opt.file || "";
      this.cwd = opt.cwd || process.cwd();
      this.maxReadSize = opt.maxReadSize;
      this.preservePaths = !!opt.preservePaths;
      this.strict = !!opt.strict;
      this.noPax = !!opt.noPax;
      this.prefix = normPath$2(opt.prefix || "");
      this.linkCache = opt.linkCache || new Map();
      this.statCache = opt.statCache || new Map();
      this.readdirCache = opt.readdirCache || new Map();

      this[WRITEENTRYCLASS] = WriteEntry;
      if (typeof opt.onwarn === "function") {
        this.on("warn", opt.onwarn);
      }

      this.portable = !!opt.portable;
      this.zip = null;

      if (opt.gzip || opt.brotli) {
        if (opt.gzip && opt.brotli) {
          throw new TypeError("gzip and brotli are mutually exclusive");
        }
        if (opt.gzip) {
          if (typeof opt.gzip !== "object") {
            opt.gzip = {};
          }
          if (this.portable) {
            opt.gzip.portable = true;
          }
          this.zip = new zlib$1.Gzip(opt.gzip);
        }
        if (opt.brotli) {
          if (typeof opt.brotli !== "object") {
            opt.brotli = {};
          }
          this.zip = new zlib$1.BrotliCompress(opt.brotli);
        }
        this.zip.on("data", (chunk) => super.write(chunk));
        this.zip.on("end", (_) => super.end());
        this.zip.on("drain", (_) => this[ONDRAIN]());
        this.on("resume", (_) => this.zip.resume());
      } else {
        this.on("drain", this[ONDRAIN]);
      }

      this.noDirRecurse = !!opt.noDirRecurse;
      this.follow = !!opt.follow;
      this.noMtime = !!opt.noMtime;
      this.mtime = opt.mtime || null;

      this.filter = typeof opt.filter === "function" ? opt.filter : (_) => true;

      this[QUEUE$1] = new Yallist$1();
      this[JOBS] = 0;
      this.jobs = +opt.jobs || 4;
      this[PROCESSING] = false;
      this[ENDED$2] = false;
    }

    [WRITE](chunk) {
      return super.write(chunk);
    }

    add(path) {
      this.write(path);
      return this;
    }

    end(path) {
      if (path) {
        this.write(path);
      }
      this[ENDED$2] = true;
      this[PROCESS]();
      return this;
    }

    write(path) {
      if (this[ENDED$2]) {
        throw new Error("write after end");
      }

      if (path instanceof ReadEntry) {
        this[ADDTARENTRY](path);
      } else {
        this[ADDFSENTRY](path);
      }
      return this.flowing;
    }

    [ADDTARENTRY](p) {
      const absolute = normPath$2(path$3.resolve(this.cwd, p.path));
      // in this case, we don't have to wait for the stat
      if (!this.filter(p.path, p)) {
        p.resume();
      } else {
        const job = new PackJob(p.path, absolute, false);
        job.entry = new WriteEntryTar(p, this[ENTRYOPT](job));
        job.entry.on("end", (_) => this[JOBDONE](job));
        this[JOBS] += 1;
        this[QUEUE$1].push(job);
      }

      this[PROCESS]();
    }

    [ADDFSENTRY](p) {
      const absolute = normPath$2(path$3.resolve(this.cwd, p));
      this[QUEUE$1].push(new PackJob(p, absolute));
      this[PROCESS]();
    }

    [STAT](job) {
      job.pending = true;
      this[JOBS] += 1;
      const stat = this.follow ? "stat" : "lstat";
      fs$7[stat](job.absolute, (er, stat) => {
        job.pending = false;
        this[JOBS] -= 1;
        if (er) {
          this.emit("error", er);
        } else {
          this[ONSTAT](job, stat);
        }
      });
    }

    [ONSTAT](job, stat) {
      this.statCache.set(job.absolute, stat);
      job.stat = stat;

      // now we have the stat, we can filter it.
      if (!this.filter(job.path, stat)) {
        job.ignore = true;
      }

      this[PROCESS]();
    }

    [READDIR](job) {
      job.pending = true;
      this[JOBS] += 1;
      fs$7.readdir(job.absolute, (er, entries) => {
        job.pending = false;
        this[JOBS] -= 1;
        if (er) {
          return this.emit("error", er);
        }
        this[ONREADDIR](job, entries);
      });
    }

    [ONREADDIR](job, entries) {
      this.readdirCache.set(job.absolute, entries);
      job.readdir = entries;
      this[PROCESS]();
    }

    [PROCESS]() {
      if (this[PROCESSING]) {
        return;
      }

      this[PROCESSING] = true;
      for (
        let w = this[QUEUE$1].head;
        w !== null && this[JOBS] < this.jobs;
        w = w.next
      ) {
        this[PROCESSJOB](w.value);
        if (w.value.ignore) {
          const p = w.next;
          this[QUEUE$1].removeNode(w);
          w.next = p;
        }
      }

      this[PROCESSING] = false;

      if (this[ENDED$2] && !this[QUEUE$1].length && this[JOBS] === 0) {
        if (this.zip) {
          this.zip.end(EOF);
        } else {
          super.write(EOF);
          super.end();
        }
      }
    }

    get [CURRENT]() {
      return this[QUEUE$1] && this[QUEUE$1].head && this[QUEUE$1].head.value;
    }

    [JOBDONE](job) {
      this[QUEUE$1].shift();
      this[JOBS] -= 1;
      this[PROCESS]();
    }

    [PROCESSJOB](job) {
      if (job.pending) {
        return;
      }

      if (job.entry) {
        if (job === this[CURRENT] && !job.piped) {
          this[PIPE](job);
        }
        return;
      }

      if (!job.stat) {
        if (this.statCache.has(job.absolute)) {
          this[ONSTAT](job, this.statCache.get(job.absolute));
        } else {
          this[STAT](job);
        }
      }
      if (!job.stat) {
        return;
      }

      // filtered out!
      if (job.ignore) {
        return;
      }

      if (!this.noDirRecurse && job.stat.isDirectory() && !job.readdir) {
        if (this.readdirCache.has(job.absolute)) {
          this[ONREADDIR](job, this.readdirCache.get(job.absolute));
        } else {
          this[READDIR](job);
        }
        if (!job.readdir) {
          return;
        }
      }

      // we know it doesn't have an entry, because that got checked above
      job.entry = this[ENTRY](job);
      if (!job.entry) {
        job.ignore = true;
        return;
      }

      if (job === this[CURRENT] && !job.piped) {
        this[PIPE](job);
      }
    }

    [ENTRYOPT](job) {
      return {
        onwarn: (code, msg, data) => this.warn(code, msg, data),
        noPax: this.noPax,
        cwd: this.cwd,
        absolute: job.absolute,
        preservePaths: this.preservePaths,
        maxReadSize: this.maxReadSize,
        strict: this.strict,
        portable: this.portable,
        linkCache: this.linkCache,
        statCache: this.statCache,
        noMtime: this.noMtime,
        mtime: this.mtime,
        prefix: this.prefix,
      };
    }

    [ENTRY](job) {
      this[JOBS] += 1;
      try {
        return new this[WRITEENTRYCLASS](job.path, this[ENTRYOPT](job))
          .on("end", () => this[JOBDONE](job))
          .on("error", (er) => this.emit("error", er));
      } catch (er) {
        this.emit("error", er);
      }
    }

    [ONDRAIN]() {
      if (this[CURRENT] && this[CURRENT].entry) {
        this[CURRENT].entry.resume();
      }
    }

    // like .pipe() but using super, because our write() is special
    [PIPE](job) {
      job.piped = true;

      if (job.readdir) {
        job.readdir.forEach((entry) => {
          const p = job.path;
          const base = p === "./" ? "" : p.replace(/\/*$/, "/");
          this[ADDFSENTRY](base + entry);
        });
      }

      const source = job.entry;
      const zip = this.zip;

      if (zip) {
        source.on("data", (chunk) => {
          if (!zip.write(chunk)) {
            source.pause();
          }
        });
      } else {
        source.on("data", (chunk) => {
          if (!super.write(chunk)) {
            source.pause();
          }
        });
      }
    }

    pause() {
      if (this.zip) {
        this.zip.pause();
      }
      return super.pause();
    }
  },
);

class PackSync extends Pack {
  constructor(opt) {
    super(opt);
    this[WRITEENTRYCLASS] = WriteEntrySync;
  }

  // pause/resume are no-ops in sync streams.
  pause() {}
  resume() {}

  [STAT](job) {
    const stat = this.follow ? "statSync" : "lstatSync";
    this[ONSTAT](job, fs$7[stat](job.absolute));
  }

  [READDIR](job, stat) {
    this[ONREADDIR](job, fs$7.readdirSync(job.absolute));
  }

  // gotta get it all in this tick
  [PIPE](job) {
    const source = job.entry;
    const zip = this.zip;

    if (job.readdir) {
      job.readdir.forEach((entry) => {
        const p = job.path;
        const base = p === "./" ? "" : p.replace(/\/*$/, "/");
        this[ADDFSENTRY](base + entry);
      });
    }

    if (zip) {
      source.on("data", (chunk) => {
        zip.write(chunk);
      });
    } else {
      source.on("data", (chunk) => {
        super[WRITE](chunk);
      });
    }
  }
}

Pack.Sync = PackSync;

var fsMinipass = {};

const MiniPass = minipass;
const EE$1 = require$$0$8.EventEmitter;
const fs$6 = require$$0$6;

let writev = fs$6.writev;
/* istanbul ignore next */
if (!writev) {
  // This entire block can be removed if support for earlier than Node.js
  // 12.9.0 is not needed.
  const binding = process.binding("fs");
  const FSReqWrap = binding.FSReqWrap || binding.FSReqCallback;

  writev = (fd, iovec, pos, cb) => {
    const done = (er, bw) => cb(er, bw, iovec);
    const req = new FSReqWrap();
    req.oncomplete = done;
    binding.writeBuffers(fd, iovec, pos, req);
  };
}

const _autoClose = Symbol("_autoClose");
const _close = Symbol("_close");
const _ended = Symbol("_ended");
const _fd = Symbol("_fd");
const _finished = Symbol("_finished");
const _flags = Symbol("_flags");
const _flush = Symbol("_flush");
const _handleChunk = Symbol("_handleChunk");
const _makeBuf = Symbol("_makeBuf");
const _mode = Symbol("_mode");
const _needDrain = Symbol("_needDrain");
const _onerror = Symbol("_onerror");
const _onopen = Symbol("_onopen");
const _onread = Symbol("_onread");
const _onwrite = Symbol("_onwrite");
const _open = Symbol("_open");
const _path = Symbol("_path");
const _pos = Symbol("_pos");
const _queue = Symbol("_queue");
const _read = Symbol("_read");
const _readSize = Symbol("_readSize");
const _reading = Symbol("_reading");
const _remain = Symbol("_remain");
const _size = Symbol("_size");
const _write = Symbol("_write");
const _writing = Symbol("_writing");
const _defaultFlag = Symbol("_defaultFlag");
const _errored = Symbol("_errored");

class ReadStream extends MiniPass {
  constructor(path, opt) {
    opt = opt || {};
    super(opt);

    this.readable = true;
    this.writable = false;

    if (typeof path !== "string") throw new TypeError("path must be a string");

    this[_errored] = false;
    this[_fd] = typeof opt.fd === "number" ? opt.fd : null;
    this[_path] = path;
    this[_readSize] = opt.readSize || 16 * 1024 * 1024;
    this[_reading] = false;
    this[_size] = typeof opt.size === "number" ? opt.size : Infinity;
    this[_remain] = this[_size];
    this[_autoClose] =
      typeof opt.autoClose === "boolean" ? opt.autoClose : true;

    if (typeof this[_fd] === "number") this[_read]();
    else this[_open]();
  }

  get fd() {
    return this[_fd];
  }
  get path() {
    return this[_path];
  }

  write() {
    throw new TypeError("this is a readable stream");
  }

  end() {
    throw new TypeError("this is a readable stream");
  }

  [_open]() {
    fs$6.open(this[_path], "r", (er, fd) => this[_onopen](er, fd));
  }

  [_onopen](er, fd) {
    if (er) this[_onerror](er);
    else {
      this[_fd] = fd;
      this.emit("open", fd);
      this[_read]();
    }
  }

  [_makeBuf]() {
    return Buffer.allocUnsafe(Math.min(this[_readSize], this[_remain]));
  }

  [_read]() {
    if (!this[_reading]) {
      this[_reading] = true;
      const buf = this[_makeBuf]();
      /* istanbul ignore if */
      if (buf.length === 0)
        return process.nextTick(() => this[_onread](null, 0, buf));
      fs$6.read(this[_fd], buf, 0, buf.length, null, (er, br, buf) =>
        this[_onread](er, br, buf),
      );
    }
  }

  [_onread](er, br, buf) {
    this[_reading] = false;
    if (er) this[_onerror](er);
    else if (this[_handleChunk](br, buf)) this[_read]();
  }

  [_close]() {
    if (this[_autoClose] && typeof this[_fd] === "number") {
      const fd = this[_fd];
      this[_fd] = null;
      fs$6.close(fd, (er) =>
        er ? this.emit("error", er) : this.emit("close"),
      );
    }
  }

  [_onerror](er) {
    this[_reading] = true;
    this[_close]();
    this.emit("error", er);
  }

  [_handleChunk](br, buf) {
    let ret = false;
    // no effect if infinite
    this[_remain] -= br;
    if (br > 0) ret = super.write(br < buf.length ? buf.slice(0, br) : buf);

    if (br === 0 || this[_remain] <= 0) {
      ret = false;
      this[_close]();
      super.end();
    }

    return ret;
  }

  emit(ev, data) {
    switch (ev) {
      case "prefinish":
      case "finish":
        break;

      case "drain":
        if (typeof this[_fd] === "number") this[_read]();
        break;

      case "error":
        if (this[_errored]) return;
        this[_errored] = true;
        return super.emit(ev, data);

      default:
        return super.emit(ev, data);
    }
  }
}

class ReadStreamSync extends ReadStream {
  [_open]() {
    let threw = true;
    try {
      this[_onopen](null, fs$6.openSync(this[_path], "r"));
      threw = false;
    } finally {
      if (threw) this[_close]();
    }
  }

  [_read]() {
    let threw = true;
    try {
      if (!this[_reading]) {
        this[_reading] = true;
        do {
          const buf = this[_makeBuf]();
          /* istanbul ignore next */
          const br =
            buf.length === 0
              ? 0
              : fs$6.readSync(this[_fd], buf, 0, buf.length, null);
          if (!this[_handleChunk](br, buf)) break;
        } while (true);
        this[_reading] = false;
      }
      threw = false;
    } finally {
      if (threw) this[_close]();
    }
  }

  [_close]() {
    if (this[_autoClose] && typeof this[_fd] === "number") {
      const fd = this[_fd];
      this[_fd] = null;
      fs$6.closeSync(fd);
      this.emit("close");
    }
  }
}

class WriteStream extends EE$1 {
  constructor(path, opt) {
    opt = opt || {};
    super(opt);
    this.readable = false;
    this.writable = true;
    this[_errored] = false;
    this[_writing] = false;
    this[_ended] = false;
    this[_needDrain] = false;
    this[_queue] = [];
    this[_path] = path;
    this[_fd] = typeof opt.fd === "number" ? opt.fd : null;
    this[_mode] = opt.mode === undefined ? 0o666 : opt.mode;
    this[_pos] = typeof opt.start === "number" ? opt.start : null;
    this[_autoClose] =
      typeof opt.autoClose === "boolean" ? opt.autoClose : true;

    // truncating makes no sense when writing into the middle
    const defaultFlag = this[_pos] !== null ? "r+" : "w";
    this[_defaultFlag] = opt.flags === undefined;
    this[_flags] = this[_defaultFlag] ? defaultFlag : opt.flags;

    if (this[_fd] === null) this[_open]();
  }

  emit(ev, data) {
    if (ev === "error") {
      if (this[_errored]) return;
      this[_errored] = true;
    }
    return super.emit(ev, data);
  }

  get fd() {
    return this[_fd];
  }
  get path() {
    return this[_path];
  }

  [_onerror](er) {
    this[_close]();
    this[_writing] = true;
    this.emit("error", er);
  }

  [_open]() {
    fs$6.open(this[_path], this[_flags], this[_mode], (er, fd) =>
      this[_onopen](er, fd),
    );
  }

  [_onopen](er, fd) {
    if (
      this[_defaultFlag] &&
      this[_flags] === "r+" &&
      er &&
      er.code === "ENOENT"
    ) {
      this[_flags] = "w";
      this[_open]();
    } else if (er) this[_onerror](er);
    else {
      this[_fd] = fd;
      this.emit("open", fd);
      this[_flush]();
    }
  }

  end(buf, enc) {
    if (buf) this.write(buf, enc);

    this[_ended] = true;

    // synthetic after-write logic, where drain/finish live
    if (
      !this[_writing] &&
      !this[_queue].length &&
      typeof this[_fd] === "number"
    )
      this[_onwrite](null, 0);
    return this;
  }

  write(buf, enc) {
    if (typeof buf === "string") buf = Buffer.from(buf, enc);

    if (this[_ended]) {
      this.emit("error", new Error("write() after end()"));
      return false;
    }

    if (this[_fd] === null || this[_writing] || this[_queue].length) {
      this[_queue].push(buf);
      this[_needDrain] = true;
      return false;
    }

    this[_writing] = true;
    this[_write](buf);
    return true;
  }

  [_write](buf) {
    fs$6.write(this[_fd], buf, 0, buf.length, this[_pos], (er, bw) =>
      this[_onwrite](er, bw),
    );
  }

  [_onwrite](er, bw) {
    if (er) this[_onerror](er);
    else {
      if (this[_pos] !== null) this[_pos] += bw;
      if (this[_queue].length) this[_flush]();
      else {
        this[_writing] = false;

        if (this[_ended] && !this[_finished]) {
          this[_finished] = true;
          this[_close]();
          this.emit("finish");
        } else if (this[_needDrain]) {
          this[_needDrain] = false;
          this.emit("drain");
        }
      }
    }
  }

  [_flush]() {
    if (this[_queue].length === 0) {
      if (this[_ended]) this[_onwrite](null, 0);
    } else if (this[_queue].length === 1) this[_write](this[_queue].pop());
    else {
      const iovec = this[_queue];
      this[_queue] = [];
      writev(this[_fd], iovec, this[_pos], (er, bw) => this[_onwrite](er, bw));
    }
  }

  [_close]() {
    if (this[_autoClose] && typeof this[_fd] === "number") {
      const fd = this[_fd];
      this[_fd] = null;
      fs$6.close(fd, (er) =>
        er ? this.emit("error", er) : this.emit("close"),
      );
    }
  }
}

class WriteStreamSync extends WriteStream {
  [_open]() {
    let fd;
    // only wrap in a try{} block if we know we'll retry, to avoid
    // the rethrow obscuring the error's source frame in most cases.
    if (this[_defaultFlag] && this[_flags] === "r+") {
      try {
        fd = fs$6.openSync(this[_path], this[_flags], this[_mode]);
      } catch (er) {
        if (er.code === "ENOENT") {
          this[_flags] = "w";
          return this[_open]();
        } else throw er;
      }
    } else fd = fs$6.openSync(this[_path], this[_flags], this[_mode]);

    this[_onopen](null, fd);
  }

  [_close]() {
    if (this[_autoClose] && typeof this[_fd] === "number") {
      const fd = this[_fd];
      this[_fd] = null;
      fs$6.closeSync(fd);
      this.emit("close");
    }
  }

  [_write](buf) {
    // throw the original, but try to close if it fails
    let threw = true;
    try {
      this[_onwrite](
        null,
        fs$6.writeSync(this[_fd], buf, 0, buf.length, this[_pos]),
      );
      threw = false;
    } finally {
      if (threw)
        try {
          this[_close]();
        } catch (_) {}
    }
  }
}

fsMinipass.ReadStream = ReadStream;
fsMinipass.ReadStreamSync = ReadStreamSync;

fsMinipass.WriteStream = WriteStream;
fsMinipass.WriteStreamSync = WriteStreamSync;

// this[BUFFER] is the remainder of a chunk if we're waiting for
// the full 512 bytes of a header to come in.  We will Buffer.concat()
// it to the next write(), which is a mem copy, but a small one.
//
// this[QUEUE] is a Yallist of entries that haven't been emitted
// yet this can only get filled up if the user keeps write()ing after
// a write() returns false, or does a write() with more than one entry
//
// We don't buffer chunks, we always parse them and either create an
// entry, or push it into the active entry.  The ReadEntry class knows
// to throw data away if .ignore=true
//
// Shift entry off the buffer when it emits 'end', and emit 'entry' for
// the next one in the list.
//
// At any time, we're pushing body chunks into the entry at WRITEENTRY,
// and waiting for 'end' on the entry at READENTRY
//
// ignored entries get .resume() called on them straight away

const warner = warnMixin;
const Header = header;
const EE = require$$0$8;
const Yallist = yallist;
const maxMetaEntrySize = 1024 * 1024;
const Entry = readEntry;
const Pax = pax;
const zlib = minizlib;
const { nextTick } = require$$7;

const gzipHeader = Buffer.from([0x1f, 0x8b]);
const STATE = Symbol("state");
const WRITEENTRY = Symbol("writeEntry");
const READENTRY = Symbol("readEntry");
const NEXTENTRY = Symbol("nextEntry");
const PROCESSENTRY = Symbol("processEntry");
const EX = Symbol("extendedHeader");
const GEX = Symbol("globalExtendedHeader");
const META = Symbol("meta");
const EMITMETA = Symbol("emitMeta");
const BUFFER = Symbol("buffer");
const QUEUE = Symbol("queue");
const ENDED$1 = Symbol("ended");
const EMITTEDEND = Symbol("emittedEnd");
const EMIT = Symbol("emit");
const UNZIP = Symbol("unzip");
const CONSUMECHUNK = Symbol("consumeChunk");
const CONSUMECHUNKSUB = Symbol("consumeChunkSub");
const CONSUMEBODY = Symbol("consumeBody");
const CONSUMEMETA = Symbol("consumeMeta");
const CONSUMEHEADER = Symbol("consumeHeader");
const CONSUMING = Symbol("consuming");
const BUFFERCONCAT = Symbol("bufferConcat");
const MAYBEEND = Symbol("maybeEnd");
const WRITING = Symbol("writing");
const ABORTED = Symbol("aborted");
const DONE = Symbol("onDone");
const SAW_VALID_ENTRY = Symbol("sawValidEntry");
const SAW_NULL_BLOCK = Symbol("sawNullBlock");
const SAW_EOF = Symbol("sawEOF");
const CLOSESTREAM = Symbol("closeStream");

const noop = (_) => true;

var parse$1 = warner(
  class Parser extends EE {
    constructor(opt) {
      opt = opt || {};
      super(opt);

      this.file = opt.file || "";

      // set to boolean false when an entry starts.  1024 bytes of \0
      // is technically a valid tarball, albeit a boring one.
      this[SAW_VALID_ENTRY] = null;

      // these BADARCHIVE errors can't be detected early. listen on DONE.
      this.on(DONE, (_) => {
        if (this[STATE] === "begin" || this[SAW_VALID_ENTRY] === false) {
          // either less than 1 block of data, or all entries were invalid.
          // Either way, probably not even a tarball.
          this.warn("TAR_BAD_ARCHIVE", "Unrecognized archive format");
        }
      });

      if (opt.ondone) {
        this.on(DONE, opt.ondone);
      } else {
        this.on(DONE, (_) => {
          this.emit("prefinish");
          this.emit("finish");
          this.emit("end");
        });
      }

      this.strict = !!opt.strict;
      this.maxMetaEntrySize = opt.maxMetaEntrySize || maxMetaEntrySize;
      this.filter = typeof opt.filter === "function" ? opt.filter : noop;
      // Unlike gzip, brotli doesn't have any magic bytes to identify it
      // Users need to explicitly tell us they're extracting a brotli file
      // Or we infer from the file extension
      const isTBR =
        opt.file && (opt.file.endsWith(".tar.br") || opt.file.endsWith(".tbr"));
      // if it's a tbr file it MIGHT be brotli, but we don't know until
      // we look at it and verify it's not a valid tar file.
      this.brotli =
        !opt.gzip && opt.brotli !== undefined
          ? opt.brotli
          : isTBR
            ? undefined
            : false;

      // have to set this so that streams are ok piping into it
      this.writable = true;
      this.readable = false;

      this[QUEUE] = new Yallist();
      this[BUFFER] = null;
      this[READENTRY] = null;
      this[WRITEENTRY] = null;
      this[STATE] = "begin";
      this[META] = "";
      this[EX] = null;
      this[GEX] = null;
      this[ENDED$1] = false;
      this[UNZIP] = null;
      this[ABORTED] = false;
      this[SAW_NULL_BLOCK] = false;
      this[SAW_EOF] = false;

      this.on("end", () => this[CLOSESTREAM]());

      if (typeof opt.onwarn === "function") {
        this.on("warn", opt.onwarn);
      }
      if (typeof opt.onentry === "function") {
        this.on("entry", opt.onentry);
      }
    }

    [CONSUMEHEADER](chunk, position) {
      if (this[SAW_VALID_ENTRY] === null) {
        this[SAW_VALID_ENTRY] = false;
      }
      let header;
      try {
        header = new Header(chunk, position, this[EX], this[GEX]);
      } catch (er) {
        return this.warn("TAR_ENTRY_INVALID", er);
      }

      if (header.nullBlock) {
        if (this[SAW_NULL_BLOCK]) {
          this[SAW_EOF] = true;
          // ending an archive with no entries.  pointless, but legal.
          if (this[STATE] === "begin") {
            this[STATE] = "header";
          }
          this[EMIT]("eof");
        } else {
          this[SAW_NULL_BLOCK] = true;
          this[EMIT]("nullBlock");
        }
      } else {
        this[SAW_NULL_BLOCK] = false;
        if (!header.cksumValid) {
          this.warn("TAR_ENTRY_INVALID", "checksum failure", { header });
        } else if (!header.path) {
          this.warn("TAR_ENTRY_INVALID", "path is required", { header });
        } else {
          const type = header.type;
          if (/^(Symbolic)?Link$/.test(type) && !header.linkpath) {
            this.warn("TAR_ENTRY_INVALID", "linkpath required", { header });
          } else if (!/^(Symbolic)?Link$/.test(type) && header.linkpath) {
            this.warn("TAR_ENTRY_INVALID", "linkpath forbidden", { header });
          } else {
            const entry = (this[WRITEENTRY] = new Entry(
              header,
              this[EX],
              this[GEX],
            ));

            // we do this for meta & ignored entries as well, because they
            // are still valid tar, or else we wouldn't know to ignore them
            if (!this[SAW_VALID_ENTRY]) {
              if (entry.remain) {
                // this might be the one!
                const onend = () => {
                  if (!entry.invalid) {
                    this[SAW_VALID_ENTRY] = true;
                  }
                };
                entry.on("end", onend);
              } else {
                this[SAW_VALID_ENTRY] = true;
              }
            }

            if (entry.meta) {
              if (entry.size > this.maxMetaEntrySize) {
                entry.ignore = true;
                this[EMIT]("ignoredEntry", entry);
                this[STATE] = "ignore";
                entry.resume();
              } else if (entry.size > 0) {
                this[META] = "";
                entry.on("data", (c) => (this[META] += c));
                this[STATE] = "meta";
              }
            } else {
              this[EX] = null;
              entry.ignore = entry.ignore || !this.filter(entry.path, entry);

              if (entry.ignore) {
                // probably valid, just not something we care about
                this[EMIT]("ignoredEntry", entry);
                this[STATE] = entry.remain ? "ignore" : "header";
                entry.resume();
              } else {
                if (entry.remain) {
                  this[STATE] = "body";
                } else {
                  this[STATE] = "header";
                  entry.end();
                }

                if (!this[READENTRY]) {
                  this[QUEUE].push(entry);
                  this[NEXTENTRY]();
                } else {
                  this[QUEUE].push(entry);
                }
              }
            }
          }
        }
      }
    }

    [CLOSESTREAM]() {
      nextTick(() => this.emit("close"));
    }

    [PROCESSENTRY](entry) {
      let go = true;

      if (!entry) {
        this[READENTRY] = null;
        go = false;
      } else if (Array.isArray(entry)) {
        this.emit.apply(this, entry);
      } else {
        this[READENTRY] = entry;
        this.emit("entry", entry);
        if (!entry.emittedEnd) {
          entry.on("end", (_) => this[NEXTENTRY]());
          go = false;
        }
      }

      return go;
    }

    [NEXTENTRY]() {
      do {} while (this[PROCESSENTRY](this[QUEUE].shift()));

      if (!this[QUEUE].length) {
        // At this point, there's nothing in the queue, but we may have an
        // entry which is being consumed (readEntry).
        // If we don't, then we definitely can handle more data.
        // If we do, and either it's flowing, or it has never had any data
        // written to it, then it needs more.
        // The only other possibility is that it has returned false from a
        // write() call, so we wait for the next drain to continue.
        const re = this[READENTRY];
        const drainNow = !re || re.flowing || re.size === re.remain;
        if (drainNow) {
          if (!this[WRITING]) {
            this.emit("drain");
          }
        } else {
          re.once("drain", (_) => this.emit("drain"));
        }
      }
    }

    [CONSUMEBODY](chunk, position) {
      // write up to but no  more than writeEntry.blockRemain
      const entry = this[WRITEENTRY];
      const br = entry.blockRemain;
      const c =
        br >= chunk.length && position === 0
          ? chunk
          : chunk.slice(position, position + br);

      entry.write(c);

      if (!entry.blockRemain) {
        this[STATE] = "header";
        this[WRITEENTRY] = null;
        entry.end();
      }

      return c.length;
    }

    [CONSUMEMETA](chunk, position) {
      const entry = this[WRITEENTRY];
      const ret = this[CONSUMEBODY](chunk, position);

      // if we finished, then the entry is reset
      if (!this[WRITEENTRY]) {
        this[EMITMETA](entry);
      }

      return ret;
    }

    [EMIT](ev, data, extra) {
      if (!this[QUEUE].length && !this[READENTRY]) {
        this.emit(ev, data, extra);
      } else {
        this[QUEUE].push([ev, data, extra]);
      }
    }

    [EMITMETA](entry) {
      this[EMIT]("meta", this[META]);
      switch (entry.type) {
        case "ExtendedHeader":
        case "OldExtendedHeader":
          this[EX] = Pax.parse(this[META], this[EX], false);
          break;

        case "GlobalExtendedHeader":
          this[GEX] = Pax.parse(this[META], this[GEX], true);
          break;

        case "NextFileHasLongPath":
        case "OldGnuLongPath":
          this[EX] = this[EX] || Object.create(null);
          this[EX].path = this[META].replace(/\0.*/, "");
          break;

        case "NextFileHasLongLinkpath":
          this[EX] = this[EX] || Object.create(null);
          this[EX].linkpath = this[META].replace(/\0.*/, "");
          break;

        /* istanbul ignore next */
        default:
          throw new Error("unknown meta: " + entry.type);
      }
    }

    abort(error) {
      this[ABORTED] = true;
      this.emit("abort", error);
      // always throws, even in non-strict mode
      this.warn("TAR_ABORT", error, { recoverable: false });
    }

    write(chunk) {
      if (this[ABORTED]) {
        return;
      }

      // first write, might be gzipped
      const needSniff =
        this[UNZIP] === null ||
        (this.brotli === undefined && this[UNZIP] === false);
      if (needSniff && chunk) {
        if (this[BUFFER]) {
          chunk = Buffer.concat([this[BUFFER], chunk]);
          this[BUFFER] = null;
        }
        if (chunk.length < gzipHeader.length) {
          this[BUFFER] = chunk;
          return true;
        }

        // look for gzip header
        for (let i = 0; this[UNZIP] === null && i < gzipHeader.length; i++) {
          if (chunk[i] !== gzipHeader[i]) {
            this[UNZIP] = false;
          }
        }

        const maybeBrotli = this.brotli === undefined;
        if (this[UNZIP] === false && maybeBrotli) {
          // read the first header to see if it's a valid tar file. If so,
          // we can safely assume that it's not actually brotli, despite the
          // .tbr or .tar.br file extension.
          // if we ended before getting a full chunk, yes, def brotli
          if (chunk.length < 512) {
            if (this[ENDED$1]) {
              this.brotli = true;
            } else {
              this[BUFFER] = chunk;
              return true;
            }
          } else {
            // if it's tar, it's pretty reliably not brotli, chances of
            // that happening are astronomical.
            try {
              new Header(chunk.slice(0, 512));
              this.brotli = false;
            } catch (_) {
              this.brotli = true;
            }
          }
        }

        if (this[UNZIP] === null || (this[UNZIP] === false && this.brotli)) {
          const ended = this[ENDED$1];
          this[ENDED$1] = false;
          this[UNZIP] =
            this[UNZIP] === null
              ? new zlib.Unzip()
              : new zlib.BrotliDecompress();
          this[UNZIP].on("data", (chunk) => this[CONSUMECHUNK](chunk));
          this[UNZIP].on("error", (er) => this.abort(er));
          this[UNZIP].on("end", (_) => {
            this[ENDED$1] = true;
            this[CONSUMECHUNK]();
          });
          this[WRITING] = true;
          const ret = this[UNZIP][ended ? "end" : "write"](chunk);
          this[WRITING] = false;
          return ret;
        }
      }

      this[WRITING] = true;
      if (this[UNZIP]) {
        this[UNZIP].write(chunk);
      } else {
        this[CONSUMECHUNK](chunk);
      }
      this[WRITING] = false;

      // return false if there's a queue, or if the current entry isn't flowing
      const ret = this[QUEUE].length
        ? false
        : this[READENTRY]
          ? this[READENTRY].flowing
          : true;

      // if we have no queue, then that means a clogged READENTRY
      if (!ret && !this[QUEUE].length) {
        this[READENTRY].once("drain", (_) => this.emit("drain"));
      }

      return ret;
    }

    [BUFFERCONCAT](c) {
      if (c && !this[ABORTED]) {
        this[BUFFER] = this[BUFFER] ? Buffer.concat([this[BUFFER], c]) : c;
      }
    }

    [MAYBEEND]() {
      if (
        this[ENDED$1] &&
        !this[EMITTEDEND] &&
        !this[ABORTED] &&
        !this[CONSUMING]
      ) {
        this[EMITTEDEND] = true;
        const entry = this[WRITEENTRY];
        if (entry && entry.blockRemain) {
          // truncated, likely a damaged file
          const have = this[BUFFER] ? this[BUFFER].length : 0;
          this.warn(
            "TAR_BAD_ARCHIVE",
            `Truncated input (needed ${entry.blockRemain} more bytes, only ${have} available)`,
            { entry },
          );
          if (this[BUFFER]) {
            entry.write(this[BUFFER]);
          }
          entry.end();
        }
        this[EMIT](DONE);
      }
    }

    [CONSUMECHUNK](chunk) {
      if (this[CONSUMING]) {
        this[BUFFERCONCAT](chunk);
      } else if (!chunk && !this[BUFFER]) {
        this[MAYBEEND]();
      } else {
        this[CONSUMING] = true;
        if (this[BUFFER]) {
          this[BUFFERCONCAT](chunk);
          const c = this[BUFFER];
          this[BUFFER] = null;
          this[CONSUMECHUNKSUB](c);
        } else {
          this[CONSUMECHUNKSUB](chunk);
        }

        while (
          this[BUFFER] &&
          this[BUFFER].length >= 512 &&
          !this[ABORTED] &&
          !this[SAW_EOF]
        ) {
          const c = this[BUFFER];
          this[BUFFER] = null;
          this[CONSUMECHUNKSUB](c);
        }
        this[CONSUMING] = false;
      }

      if (!this[BUFFER] || this[ENDED$1]) {
        this[MAYBEEND]();
      }
    }

    [CONSUMECHUNKSUB](chunk) {
      // we know that we are in CONSUMING mode, so anything written goes into
      // the buffer.  Advance the position and put any remainder in the buffer.
      let position = 0;
      const length = chunk.length;
      while (position + 512 <= length && !this[ABORTED] && !this[SAW_EOF]) {
        switch (this[STATE]) {
          case "begin":
          case "header":
            this[CONSUMEHEADER](chunk, position);
            position += 512;
            break;

          case "ignore":
          case "body":
            position += this[CONSUMEBODY](chunk, position);
            break;

          case "meta":
            position += this[CONSUMEMETA](chunk, position);
            break;

          /* istanbul ignore next */
          default:
            throw new Error("invalid state: " + this[STATE]);
        }
      }

      if (position < length) {
        if (this[BUFFER]) {
          this[BUFFER] = Buffer.concat([chunk.slice(position), this[BUFFER]]);
        } else {
          this[BUFFER] = chunk.slice(position);
        }
      }
    }

    end(chunk) {
      if (!this[ABORTED]) {
        if (this[UNZIP]) {
          this[UNZIP].end(chunk);
        } else {
          this[ENDED$1] = true;
          if (this.brotli === undefined) chunk = chunk || Buffer.alloc(0);
          this.write(chunk);
        }
      }
    }
  },
);

var mkdir$1 = { exports: {} };

const { promisify } = require$$1$5;
const fs$5 = require$$0$6;
const optsArg$1 = (opts) => {
  if (!opts) opts = { mode: 0o777, fs: fs$5 };
  else if (typeof opts === "object") opts = { mode: 0o777, fs: fs$5, ...opts };
  else if (typeof opts === "number") opts = { mode: opts, fs: fs$5 };
  else if (typeof opts === "string")
    opts = { mode: parseInt(opts, 8), fs: fs$5 };
  else throw new TypeError("invalid options argument");

  opts.mkdir = opts.mkdir || opts.fs.mkdir || fs$5.mkdir;
  opts.mkdirAsync = promisify(opts.mkdir);
  opts.stat = opts.stat || opts.fs.stat || fs$5.stat;
  opts.statAsync = promisify(opts.stat);
  opts.statSync = opts.statSync || opts.fs.statSync || fs$5.statSync;
  opts.mkdirSync = opts.mkdirSync || opts.fs.mkdirSync || fs$5.mkdirSync;
  return opts;
};
var optsArg_1 = optsArg$1;

const platform$3 = process.env.__TESTING_MKDIRP_PLATFORM__ || process.platform;
const { resolve, parse } = require$$0$a;
const pathArg$1 = (path) => {
  if (/\0/.test(path)) {
    // simulate same failure that node raises
    throw Object.assign(
      new TypeError("path must be a string without null bytes"),
      {
        path,
        code: "ERR_INVALID_ARG_VALUE",
      },
    );
  }

  path = resolve(path);
  if (platform$3 === "win32") {
    const badWinChars = /[*|"<>?:]/;
    const { root } = parse(path);
    if (badWinChars.test(path.substr(root.length))) {
      throw Object.assign(new Error("Illegal characters in path."), {
        path,
        code: "EINVAL",
      });
    }
  }

  return path;
};
var pathArg_1 = pathArg$1;

const { dirname: dirname$2 } = require$$0$a;

const findMade$1 = (opts, parent, path = undefined) => {
  // we never want the 'made' return value to be a root directory
  if (path === parent) return Promise.resolve();

  return opts.statAsync(parent).then(
    (st) => (st.isDirectory() ? path : undefined), // will fail later
    (er) =>
      er.code === "ENOENT"
        ? findMade$1(opts, dirname$2(parent), parent)
        : undefined,
  );
};

const findMadeSync$1 = (opts, parent, path = undefined) => {
  if (path === parent) return undefined;

  try {
    return opts.statSync(parent).isDirectory() ? path : undefined;
  } catch (er) {
    return er.code === "ENOENT"
      ? findMadeSync$1(opts, dirname$2(parent), parent)
      : undefined;
  }
};

var findMade_1 = { findMade: findMade$1, findMadeSync: findMadeSync$1 };

const { dirname: dirname$1 } = require$$0$a;

const mkdirpManual$2 = (path, opts, made) => {
  opts.recursive = false;
  const parent = dirname$1(path);
  if (parent === path) {
    return opts.mkdirAsync(path, opts).catch((er) => {
      // swallowed by recursive implementation on posix systems
      // any other error is a failure
      if (er.code !== "EISDIR") throw er;
    });
  }

  return opts.mkdirAsync(path, opts).then(
    () => made || path,
    (er) => {
      if (er.code === "ENOENT")
        return mkdirpManual$2(parent, opts).then((made) =>
          mkdirpManual$2(path, opts, made),
        );
      if (er.code !== "EEXIST" && er.code !== "EROFS") throw er;
      return opts.statAsync(path).then(
        (st) => {
          if (st.isDirectory()) return made;
          else throw er;
        },
        () => {
          throw er;
        },
      );
    },
  );
};

const mkdirpManualSync$2 = (path, opts, made) => {
  const parent = dirname$1(path);
  opts.recursive = false;

  if (parent === path) {
    try {
      return opts.mkdirSync(path, opts);
    } catch (er) {
      // swallowed by recursive implementation on posix systems
      // any other error is a failure
      if (er.code !== "EISDIR") throw er;
      else return;
    }
  }

  try {
    opts.mkdirSync(path, opts);
    return made || path;
  } catch (er) {
    if (er.code === "ENOENT")
      return mkdirpManualSync$2(
        path,
        opts,
        mkdirpManualSync$2(parent, opts, made),
      );
    if (er.code !== "EEXIST" && er.code !== "EROFS") throw er;
    try {
      if (!opts.statSync(path).isDirectory()) throw er;
    } catch (_) {
      throw er;
    }
  }
};

var mkdirpManual_1 = {
  mkdirpManual: mkdirpManual$2,
  mkdirpManualSync: mkdirpManualSync$2,
};

const { dirname } = require$$0$a;
const { findMade, findMadeSync } = findMade_1;
const { mkdirpManual: mkdirpManual$1, mkdirpManualSync: mkdirpManualSync$1 } =
  mkdirpManual_1;

const mkdirpNative$1 = (path, opts) => {
  opts.recursive = true;
  const parent = dirname(path);
  if (parent === path) return opts.mkdirAsync(path, opts);

  return findMade(opts, path).then((made) =>
    opts
      .mkdirAsync(path, opts)
      .then(() => made)
      .catch((er) => {
        if (er.code === "ENOENT") return mkdirpManual$1(path, opts);
        else throw er;
      }),
  );
};

const mkdirpNativeSync$1 = (path, opts) => {
  opts.recursive = true;
  const parent = dirname(path);
  if (parent === path) return opts.mkdirSync(path, opts);

  const made = findMadeSync(opts, path);
  try {
    opts.mkdirSync(path, opts);
    return made;
  } catch (er) {
    if (er.code === "ENOENT") return mkdirpManualSync$1(path, opts);
    else throw er;
  }
};

var mkdirpNative_1 = {
  mkdirpNative: mkdirpNative$1,
  mkdirpNativeSync: mkdirpNativeSync$1,
};

const fs$4 = require$$0$6;

const version = process.env.__TESTING_MKDIRP_NODE_VERSION__ || process.version;
const versArr = version.replace(/^v/, "").split(".");
const hasNative = +versArr[0] > 10 || (+versArr[0] === 10 && +versArr[1] >= 12);

const useNative$1 = !hasNative
  ? () => false
  : (opts) => opts.mkdir === fs$4.mkdir;
const useNativeSync$1 = !hasNative
  ? () => false
  : (opts) => opts.mkdirSync === fs$4.mkdirSync;

var useNative_1 = { useNative: useNative$1, useNativeSync: useNativeSync$1 };

const optsArg = optsArg_1;
const pathArg = pathArg_1;

const { mkdirpNative, mkdirpNativeSync } = mkdirpNative_1;
const { mkdirpManual, mkdirpManualSync } = mkdirpManual_1;
const { useNative, useNativeSync } = useNative_1;

const mkdirp$1 = (path, opts) => {
  path = pathArg(path);
  opts = optsArg(opts);
  return useNative(opts) ? mkdirpNative(path, opts) : mkdirpManual(path, opts);
};

const mkdirpSync = (path, opts) => {
  path = pathArg(path);
  opts = optsArg(opts);
  return useNativeSync(opts)
    ? mkdirpNativeSync(path, opts)
    : mkdirpManualSync(path, opts);
};

mkdirp$1.sync = mkdirpSync;
mkdirp$1.native = (path, opts) => mkdirpNative(pathArg(path), optsArg(opts));
mkdirp$1.manual = (path, opts) => mkdirpManual(pathArg(path), optsArg(opts));
mkdirp$1.nativeSync = (path, opts) =>
  mkdirpNativeSync(pathArg(path), optsArg(opts));
mkdirp$1.manualSync = (path, opts) =>
  mkdirpManualSync(pathArg(path), optsArg(opts));

var mkdirp_1 = mkdirp$1;

const fs$3 = require$$0$6;
const path$2 = require$$0$a;

/* istanbul ignore next */
const LCHOWN = fs$3.lchown ? "lchown" : "chown";
/* istanbul ignore next */
const LCHOWNSYNC = fs$3.lchownSync ? "lchownSync" : "chownSync";

/* istanbul ignore next */
const needEISDIRHandled =
  fs$3.lchown &&
  !process.version.match(/v1[1-9]+\./) &&
  !process.version.match(/v10\.[6-9]/);

const lchownSync = (path, uid, gid) => {
  try {
    return fs$3[LCHOWNSYNC](path, uid, gid);
  } catch (er) {
    if (er.code !== "ENOENT") throw er;
  }
};

/* istanbul ignore next */
const chownSync = (path, uid, gid) => {
  try {
    return fs$3.chownSync(path, uid, gid);
  } catch (er) {
    if (er.code !== "ENOENT") throw er;
  }
};

/* istanbul ignore next */
const handleEISDIR = needEISDIRHandled
  ? (path, uid, gid, cb) => (er) => {
      // Node prior to v10 had a very questionable implementation of
      // fs.lchown, which would always try to call fs.open on a directory
      // Fall back to fs.chown in those cases.
      if (!er || er.code !== "EISDIR") cb(er);
      else fs$3.chown(path, uid, gid, cb);
    }
  : (_, __, ___, cb) => cb;

/* istanbul ignore next */
const handleEISDirSync = needEISDIRHandled
  ? (path, uid, gid) => {
      try {
        return lchownSync(path, uid, gid);
      } catch (er) {
        if (er.code !== "EISDIR") throw er;
        chownSync(path, uid, gid);
      }
    }
  : (path, uid, gid) => lchownSync(path, uid, gid);

// fs.readdir could only accept an options object as of node v6
const nodeVersion = process.version;
let readdir = (path, options, cb) => fs$3.readdir(path, options, cb);
let readdirSync = (path, options) => fs$3.readdirSync(path, options);
/* istanbul ignore next */
if (/^v4\./.test(nodeVersion))
  readdir = (path, options, cb) => fs$3.readdir(path, cb);

const chown = (cpath, uid, gid, cb) => {
  fs$3[LCHOWN](
    cpath,
    uid,
    gid,
    handleEISDIR(cpath, uid, gid, (er) => {
      // Skip ENOENT error
      cb(er && er.code !== "ENOENT" ? er : null);
    }),
  );
};

const chownrKid = (p, child, uid, gid, cb) => {
  if (typeof child === "string")
    return fs$3.lstat(path$2.resolve(p, child), (er, stats) => {
      // Skip ENOENT error
      if (er) return cb(er.code !== "ENOENT" ? er : null);
      stats.name = child;
      chownrKid(p, stats, uid, gid, cb);
    });

  if (child.isDirectory()) {
    chownr$1(path$2.resolve(p, child.name), uid, gid, (er) => {
      if (er) return cb(er);
      const cpath = path$2.resolve(p, child.name);
      chown(cpath, uid, gid, cb);
    });
  } else {
    const cpath = path$2.resolve(p, child.name);
    chown(cpath, uid, gid, cb);
  }
};

const chownr$1 = (p, uid, gid, cb) => {
  readdir(p, { withFileTypes: true }, (er, children) => {
    // any error other than ENOTDIR or ENOTSUP means it's not readable,
    // or doesn't exist.  give up.
    if (er) {
      if (er.code === "ENOENT") return cb();
      else if (er.code !== "ENOTDIR" && er.code !== "ENOTSUP") return cb(er);
    }
    if (er || !children.length) return chown(p, uid, gid, cb);

    let len = children.length;
    let errState = null;
    const then = (er) => {
      if (errState) return;
      if (er) return cb((errState = er));
      if (--len === 0) return chown(p, uid, gid, cb);
    };

    children.forEach((child) => chownrKid(p, child, uid, gid, then));
  });
};

const chownrKidSync = (p, child, uid, gid) => {
  if (typeof child === "string") {
    try {
      const stats = fs$3.lstatSync(path$2.resolve(p, child));
      stats.name = child;
      child = stats;
    } catch (er) {
      if (er.code === "ENOENT") return;
      else throw er;
    }
  }

  if (child.isDirectory()) chownrSync(path$2.resolve(p, child.name), uid, gid);

  handleEISDirSync(path$2.resolve(p, child.name), uid, gid);
};

const chownrSync = (p, uid, gid) => {
  let children;
  try {
    children = readdirSync(p, { withFileTypes: true });
  } catch (er) {
    if (er.code === "ENOENT") return;
    else if (er.code === "ENOTDIR" || er.code === "ENOTSUP")
      return handleEISDirSync(p, uid, gid);
    else throw er;
  }

  if (children && children.length)
    children.forEach((child) => chownrKidSync(p, child, uid, gid));

  return handleEISDirSync(p, uid, gid);
};

var chownr_1 = chownr$1;
chownr$1.sync = chownrSync;

// wrapper around mkdirp for tar's needs.

// TODO: This should probably be a class, not functionally
// passing around state in a gazillion args.

const mkdirp = mkdirp_1;
const fs$2 = require$$0$6;
const path$1 = require$$0$a;
const chownr = chownr_1;
const normPath$1 = normalizeWindowsPath;

class SymlinkError extends Error {
  constructor(symlink, path) {
    super("Cannot extract through symbolic link");
    this.path = path;
    this.symlink = symlink;
  }

  get name() {
    return "SylinkError";
  }
}

class CwdError extends Error {
  constructor(path, code) {
    super(code + ": Cannot cd into '" + path + "'");
    this.path = path;
    this.code = code;
  }

  get name() {
    return "CwdError";
  }
}

const cGet = (cache, key) => cache.get(normPath$1(key));
const cSet = (cache, key, val) => cache.set(normPath$1(key), val);

const checkCwd = (dir, cb) => {
  fs$2.stat(dir, (er, st) => {
    if (er || !st.isDirectory()) {
      er = new CwdError(dir, (er && er.code) || "ENOTDIR");
    }
    cb(er);
  });
};

mkdir$1.exports = (dir, opt, cb) => {
  dir = normPath$1(dir);

  // if there's any overlap between mask and mode,
  // then we'll need an explicit chmod
  const umask = opt.umask;
  const mode = opt.mode | 0o0700;
  const needChmod = (mode & umask) !== 0;

  const uid = opt.uid;
  const gid = opt.gid;
  const doChown =
    typeof uid === "number" &&
    typeof gid === "number" &&
    (uid !== opt.processUid || gid !== opt.processGid);

  const preserve = opt.preserve;
  const unlink = opt.unlink;
  const cache = opt.cache;
  const cwd = normPath$1(opt.cwd);

  const done = (er, created) => {
    if (er) {
      cb(er);
    } else {
      cSet(cache, dir, true);
      if (created && doChown) {
        chownr(created, uid, gid, (er) => done(er));
      } else if (needChmod) {
        fs$2.chmod(dir, mode, cb);
      } else {
        cb();
      }
    }
  };

  if (cache && cGet(cache, dir) === true) {
    return done();
  }

  if (dir === cwd) {
    return checkCwd(dir, done);
  }

  if (preserve) {
    return mkdirp(dir, { mode }).then((made) => done(null, made), done);
  }

  const sub = normPath$1(path$1.relative(cwd, dir));
  const parts = sub.split("/");
  mkdir_(cwd, parts, mode, cache, unlink, cwd, null, done);
};

const mkdir_ = (base, parts, mode, cache, unlink, cwd, created, cb) => {
  if (!parts.length) {
    return cb(null, created);
  }
  const p = parts.shift();
  const part = normPath$1(path$1.resolve(base + "/" + p));
  if (cGet(cache, part)) {
    return mkdir_(part, parts, mode, cache, unlink, cwd, created, cb);
  }
  fs$2.mkdir(
    part,
    mode,
    onmkdir(part, parts, mode, cache, unlink, cwd, created, cb),
  );
};

const onmkdir =
  (part, parts, mode, cache, unlink, cwd, created, cb) => (er) => {
    if (er) {
      fs$2.lstat(part, (statEr, st) => {
        if (statEr) {
          statEr.path = statEr.path && normPath$1(statEr.path);
          cb(statEr);
        } else if (st.isDirectory()) {
          mkdir_(part, parts, mode, cache, unlink, cwd, created, cb);
        } else if (unlink) {
          fs$2.unlink(part, (er) => {
            if (er) {
              return cb(er);
            }
            fs$2.mkdir(
              part,
              mode,
              onmkdir(part, parts, mode, cache, unlink, cwd, created, cb),
            );
          });
        } else if (st.isSymbolicLink()) {
          return cb(new SymlinkError(part, part + "/" + parts.join("/")));
        } else {
          cb(er);
        }
      });
    } else {
      created = created || part;
      mkdir_(part, parts, mode, cache, unlink, cwd, created, cb);
    }
  };

const checkCwdSync = (dir) => {
  let ok = false;
  let code = "ENOTDIR";
  try {
    ok = fs$2.statSync(dir).isDirectory();
  } catch (er) {
    code = er.code;
  } finally {
    if (!ok) {
      throw new CwdError(dir, code);
    }
  }
};

mkdir$1.exports.sync = (dir, opt) => {
  dir = normPath$1(dir);
  // if there's any overlap between mask and mode,
  // then we'll need an explicit chmod
  const umask = opt.umask;
  const mode = opt.mode | 0o0700;
  const needChmod = (mode & umask) !== 0;

  const uid = opt.uid;
  const gid = opt.gid;
  const doChown =
    typeof uid === "number" &&
    typeof gid === "number" &&
    (uid !== opt.processUid || gid !== opt.processGid);

  const preserve = opt.preserve;
  const unlink = opt.unlink;
  const cache = opt.cache;
  const cwd = normPath$1(opt.cwd);

  const done = (created) => {
    cSet(cache, dir, true);
    if (created && doChown) {
      chownr.sync(created, uid, gid);
    }
    if (needChmod) {
      fs$2.chmodSync(dir, mode);
    }
  };

  if (cache && cGet(cache, dir) === true) {
    return done();
  }

  if (dir === cwd) {
    checkCwdSync(cwd);
    return done();
  }

  if (preserve) {
    return done(mkdirp.sync(dir, mode));
  }

  const sub = normPath$1(path$1.relative(cwd, dir));
  const parts = sub.split("/");
  let created = null;
  for (
    let p = parts.shift(), part = cwd;
    p && (part += "/" + p);
    p = parts.shift()
  ) {
    part = normPath$1(path$1.resolve(part));
    if (cGet(cache, part)) {
      continue;
    }

    try {
      fs$2.mkdirSync(part, mode);
      created = created || part;
      cSet(cache, part, true);
    } catch (er) {
      const st = fs$2.lstatSync(part);
      if (st.isDirectory()) {
        cSet(cache, part, true);
        continue;
      } else if (unlink) {
        fs$2.unlinkSync(part);
        fs$2.mkdirSync(part, mode);
        created = created || part;
        cSet(cache, part, true);
        continue;
      } else if (st.isSymbolicLink()) {
        return new SymlinkError(part, part + "/" + parts.join("/"));
      }
    }
  }

  return done(created);
};

var mkdirExports = mkdir$1.exports;

// warning: extremely hot code path.
// This has been meticulously optimized for use
// within npm install on large package trees.
// Do not edit without careful benchmarking.
const normalizeCache = Object.create(null);
const { hasOwnProperty: hasOwnProperty$1 } = Object.prototype;
var normalizeUnicode = (s) => {
  if (!hasOwnProperty$1.call(normalizeCache, s)) {
    normalizeCache[s] = s.normalize("NFD");
  }
  return normalizeCache[s];
};

// A path exclusive reservation system
// reserve([list, of, paths], fn)
// When the fn is first in line for all its paths, it
// is called with a cb that clears the reservation.
//
// Used by async unpack to avoid clobbering paths in use,
// while still allowing maximal safe parallelization.

const assert$1 = require$$0$9;
const normalize$1 = normalizeUnicode;
const stripSlashes = stripTrailingSlashes;
const { join } = require$$0$a;

const platform$2 = process.env.TESTING_TAR_FAKE_PLATFORM || process.platform;
const isWindows$2 = platform$2 === "win32";

var pathReservations$1 = () => {
  // path => [function or Set]
  // A Set object means a directory reservation
  // A fn is a direct reservation on that path
  const queues = new Map();

  // fn => {paths:[path,...], dirs:[path, ...]}
  const reservations = new Map();

  // return a set of parent dirs for a given path
  // '/a/b/c/d' -> ['/', '/a', '/a/b', '/a/b/c', '/a/b/c/d']
  const getDirs = (path) => {
    const dirs = path
      .split("/")
      .slice(0, -1)
      .reduce((set, path) => {
        if (set.length) {
          path = join(set[set.length - 1], path);
        }
        set.push(path || "/");
        return set;
      }, []);
    return dirs;
  };

  // functions currently running
  const running = new Set();

  // return the queues for each path the function cares about
  // fn => {paths, dirs}
  const getQueues = (fn) => {
    const res = reservations.get(fn);
    /* istanbul ignore if - unpossible */
    if (!res) {
      throw new Error("function does not have any path reservations");
    }
    return {
      paths: res.paths.map((path) => queues.get(path)),
      dirs: [...res.dirs].map((path) => queues.get(path)),
    };
  };

  // check if fn is first in line for all its paths, and is
  // included in the first set for all its dir queues
  const check = (fn) => {
    const { paths, dirs } = getQueues(fn);
    return (
      paths.every((q) => q[0] === fn) &&
      dirs.every((q) => q[0] instanceof Set && q[0].has(fn))
    );
  };

  // run the function if it's first in line and not already running
  const run = (fn) => {
    if (running.has(fn) || !check(fn)) {
      return false;
    }
    running.add(fn);
    fn(() => clear(fn));
    return true;
  };

  const clear = (fn) => {
    if (!running.has(fn)) {
      return false;
    }

    const { paths, dirs } = reservations.get(fn);
    const next = new Set();

    paths.forEach((path) => {
      const q = queues.get(path);
      assert$1.equal(q[0], fn);
      if (q.length === 1) {
        queues.delete(path);
      } else {
        q.shift();
        if (typeof q[0] === "function") {
          next.add(q[0]);
        } else {
          q[0].forEach((fn) => next.add(fn));
        }
      }
    });

    dirs.forEach((dir) => {
      const q = queues.get(dir);
      assert$1(q[0] instanceof Set);
      if (q[0].size === 1 && q.length === 1) {
        queues.delete(dir);
      } else if (q[0].size === 1) {
        q.shift();

        // must be a function or else the Set would've been reused
        next.add(q[0]);
      } else {
        q[0].delete(fn);
      }
    });
    running.delete(fn);

    next.forEach((fn) => run(fn));
    return true;
  };

  const reserve = (paths, fn) => {
    // collide on matches across case and unicode normalization
    // On windows, thanks to the magic of 8.3 shortnames, it is fundamentally
    // impossible to determine whether two paths refer to the same thing on
    // disk, without asking the kernel for a shortname.
    // So, we just pretend that every path matches every other path here,
    // effectively removing all parallelization on windows.
    paths = isWindows$2
      ? ["win32 parallelization disabled"]
      : paths.map((p) => {
          // don't need normPath, because we skip this entirely for windows
          return stripSlashes(join(normalize$1(p))).toLowerCase();
        });

    const dirs = new Set(
      paths.map((path) => getDirs(path)).reduce((a, b) => a.concat(b)),
    );
    reservations.set(fn, { dirs, paths });
    paths.forEach((path) => {
      const q = queues.get(path);
      if (!q) {
        queues.set(path, [fn]);
      } else {
        q.push(fn);
      }
    });
    dirs.forEach((dir) => {
      const q = queues.get(dir);
      if (!q) {
        queues.set(dir, [new Set([fn])]);
      } else if (q[q.length - 1] instanceof Set) {
        q[q.length - 1].add(fn);
      } else {
        q.push(new Set([fn]));
      }
    });

    return run(fn);
  };

  return { check, reserve };
};

// Get the appropriate flag to use for creating files
// We use fmap on Windows platforms for files less than
// 512kb.  This is a fairly low limit, but avoids making
// things slower in some cases.  Since most of what this
// library is used for is extracting tarballs of many
// relatively small files in npm packages and the like,
// it can be a big boost on Windows platforms.
// Only supported in Node v12.9.0 and above.
const platform$1 = process.env.__FAKE_PLATFORM__ || process.platform;
const isWindows$1 = platform$1 === "win32";
const fs$1 = commonjsGlobal.__FAKE_TESTING_FS__ || require$$0$6;

/* istanbul ignore next */
const { O_CREAT, O_TRUNC, O_WRONLY, UV_FS_O_FILEMAP = 0 } = fs$1.constants;

const fMapEnabled = isWindows$1 && !!UV_FS_O_FILEMAP;
const fMapLimit = 512 * 1024;
const fMapFlag = UV_FS_O_FILEMAP | O_TRUNC | O_CREAT | O_WRONLY;
var getWriteFlag = !fMapEnabled
  ? () => "w"
  : (size) => (size < fMapLimit ? fMapFlag : "w");

// the PEND/UNPEND stuff tracks whether we're ready to emit end/close yet.
// but the path reservations are required to avoid race conditions where
// parallelized unpack ops may mess with one another, due to dependencies
// (like a Link depending on its target) or destructive operations (like
// clobbering an fs object to create one of a different type.)

const assert = require$$0$9;
const Parser = parse$1;
const fs = require$$0$6;
const fsm = fsMinipass;
const path = require$$0$a;
const mkdir = mkdirExports;
const wc = winchars$1;
const pathReservations = pathReservations$1;
const stripAbsolutePath = stripAbsolutePath$2;
const normPath = normalizeWindowsPath;
const stripSlash = stripTrailingSlashes;
const normalize = normalizeUnicode;

const ONENTRY = Symbol("onEntry");
const CHECKFS = Symbol("checkFs");
const CHECKFS2 = Symbol("checkFs2");
const PRUNECACHE = Symbol("pruneCache");
const ISREUSABLE = Symbol("isReusable");
const MAKEFS = Symbol("makeFs");
const FILE = Symbol("file");
const DIRECTORY = Symbol("directory");
const LINK = Symbol("link");
const SYMLINK = Symbol("symlink");
const HARDLINK = Symbol("hardlink");
const UNSUPPORTED = Symbol("unsupported");
const CHECKPATH = Symbol("checkPath");
const MKDIR = Symbol("mkdir");
const ONERROR = Symbol("onError");
const PENDING = Symbol("pending");
const PEND = Symbol("pend");
const UNPEND = Symbol("unpend");
const ENDED = Symbol("ended");
const MAYBECLOSE = Symbol("maybeClose");
const SKIP = Symbol("skip");
const DOCHOWN = Symbol("doChown");
const UID = Symbol("uid");
const GID = Symbol("gid");
const CHECKED_CWD = Symbol("checkedCwd");
const crypto = require$$5;
const getFlag = getWriteFlag;
const platform = process.env.TESTING_TAR_FAKE_PLATFORM || process.platform;
const isWindows = platform === "win32";

// Unlinks on Windows are not atomic.
//
// This means that if you have a file entry, followed by another
// file entry with an identical name, and you cannot re-use the file
// (because it's a hardlink, or because unlink:true is set, or it's
// Windows, which does not have useful nlink values), then the unlink
// will be committed to the disk AFTER the new file has been written
// over the old one, deleting the new file.
//
// To work around this, on Windows systems, we rename the file and then
// delete the renamed file.  It's a sloppy kludge, but frankly, I do not
// know of a better way to do this, given windows' non-atomic unlink
// semantics.
//
// See: https://github.com/npm/node-tar/issues/183
/* istanbul ignore next */
const unlinkFile = (path, cb) => {
  if (!isWindows) {
    return fs.unlink(path, cb);
  }

  const name = path + ".DELETE." + crypto.randomBytes(16).toString("hex");
  fs.rename(path, name, (er) => {
    if (er) {
      return cb(er);
    }
    fs.unlink(name, cb);
  });
};

/* istanbul ignore next */
const unlinkFileSync = (path) => {
  if (!isWindows) {
    return fs.unlinkSync(path);
  }

  const name = path + ".DELETE." + crypto.randomBytes(16).toString("hex");
  fs.renameSync(path, name);
  fs.unlinkSync(name);
};

// this.gid, entry.gid, this.processUid
const uint32 = (a, b, c) => (a === a >>> 0 ? a : b === b >>> 0 ? b : c);

// clear the cache if it's a case-insensitive unicode-squashing match.
// we can't know if the current file system is case-sensitive or supports
// unicode fully, so we check for similarity on the maximally compatible
// representation.  Err on the side of pruning, since all it's doing is
// preventing lstats, and it's not the end of the world if we get a false
// positive.
// Note that on windows, we always drop the entire cache whenever a
// symbolic link is encountered, because 8.3 filenames are impossible
// to reason about, and collisions are hazards rather than just failures.
const cacheKeyNormalize = (path) =>
  stripSlash(normPath(normalize(path))).toLowerCase();

const pruneCache = (cache, abs) => {
  abs = cacheKeyNormalize(abs);
  for (const path of cache.keys()) {
    const pnorm = cacheKeyNormalize(path);
    if (pnorm === abs || pnorm.indexOf(abs + "/") === 0) {
      cache.delete(path);
    }
  }
};

const dropCache = (cache) => {
  for (const key of cache.keys()) {
    cache.delete(key);
  }
};

class Unpack extends Parser {
  constructor(opt) {
    if (!opt) {
      opt = {};
    }

    opt.ondone = (_) => {
      this[ENDED] = true;
      this[MAYBECLOSE]();
    };

    super(opt);

    this[CHECKED_CWD] = false;

    this.reservations = pathReservations();

    this.transform = typeof opt.transform === "function" ? opt.transform : null;

    this.writable = true;
    this.readable = false;

    this[PENDING] = 0;
    this[ENDED] = false;

    this.dirCache = opt.dirCache || new Map();

    if (typeof opt.uid === "number" || typeof opt.gid === "number") {
      // need both or neither
      if (typeof opt.uid !== "number" || typeof opt.gid !== "number") {
        throw new TypeError("cannot set owner without number uid and gid");
      }
      if (opt.preserveOwner) {
        throw new TypeError(
          "cannot preserve owner in archive and also set owner explicitly",
        );
      }
      this.uid = opt.uid;
      this.gid = opt.gid;
      this.setOwner = true;
    } else {
      this.uid = null;
      this.gid = null;
      this.setOwner = false;
    }

    // default true for root
    if (opt.preserveOwner === undefined && typeof opt.uid !== "number") {
      this.preserveOwner = process.getuid && process.getuid() === 0;
    } else {
      this.preserveOwner = !!opt.preserveOwner;
    }

    this.processUid =
      (this.preserveOwner || this.setOwner) && process.getuid
        ? process.getuid()
        : null;
    this.processGid =
      (this.preserveOwner || this.setOwner) && process.getgid
        ? process.getgid()
        : null;

    // mostly just for testing, but useful in some cases.
    // Forcibly trigger a chown on every entry, no matter what
    this.forceChown = opt.forceChown === true;

    // turn ><?| in filenames into 0xf000-higher encoded forms
    this.win32 = !!opt.win32 || isWindows;

    // do not unpack over files that are newer than what's in the archive
    this.newer = !!opt.newer;

    // do not unpack over ANY files
    this.keep = !!opt.keep;

    // do not set mtime/atime of extracted entries
    this.noMtime = !!opt.noMtime;

    // allow .., absolute path entries, and unpacking through symlinks
    // without this, warn and skip .., relativize absolutes, and error
    // on symlinks in extraction path
    this.preservePaths = !!opt.preservePaths;

    // unlink files and links before writing. This breaks existing hard
    // links, and removes symlink directories rather than erroring
    this.unlink = !!opt.unlink;

    this.cwd = normPath(path.resolve(opt.cwd || process.cwd()));
    this.strip = +opt.strip || 0;
    // if we're not chmodding, then we don't need the process umask
    this.processUmask = opt.noChmod ? 0 : process.umask();
    this.umask = typeof opt.umask === "number" ? opt.umask : this.processUmask;

    // default mode for dirs created as parents
    this.dmode = opt.dmode || 0o0777 & ~this.umask;
    this.fmode = opt.fmode || 0o0666 & ~this.umask;

    this.on("entry", (entry) => this[ONENTRY](entry));
  }

  // a bad or damaged archive is a warning for Parser, but an error
  // when extracting.  Mark those errors as unrecoverable, because
  // the Unpack contract cannot be met.
  warn(code, msg, data = {}) {
    if (code === "TAR_BAD_ARCHIVE" || code === "TAR_ABORT") {
      data.recoverable = false;
    }
    return super.warn(code, msg, data);
  }

  [MAYBECLOSE]() {
    if (this[ENDED] && this[PENDING] === 0) {
      this.emit("prefinish");
      this.emit("finish");
      this.emit("end");
    }
  }

  [CHECKPATH](entry) {
    if (this.strip) {
      const parts = normPath(entry.path).split("/");
      if (parts.length < this.strip) {
        return false;
      }
      entry.path = parts.slice(this.strip).join("/");

      if (entry.type === "Link") {
        const linkparts = normPath(entry.linkpath).split("/");
        if (linkparts.length >= this.strip) {
          entry.linkpath = linkparts.slice(this.strip).join("/");
        } else {
          return false;
        }
      }
    }

    if (!this.preservePaths) {
      const p = normPath(entry.path);
      const parts = p.split("/");
      if (
        parts.includes("..") ||
        (isWindows && /^[a-z]:\.\.$/i.test(parts[0]))
      ) {
        this.warn("TAR_ENTRY_ERROR", `path contains '..'`, {
          entry,
          path: p,
        });
        return false;
      }

      // strip off the root
      const [root, stripped] = stripAbsolutePath(p);
      if (root) {
        entry.path = stripped;
        this.warn("TAR_ENTRY_INFO", `stripping ${root} from absolute path`, {
          entry,
          path: p,
        });
      }
    }

    if (path.isAbsolute(entry.path)) {
      entry.absolute = normPath(path.resolve(entry.path));
    } else {
      entry.absolute = normPath(path.resolve(this.cwd, entry.path));
    }

    // if we somehow ended up with a path that escapes the cwd, and we are
    // not in preservePaths mode, then something is fishy!  This should have
    // been prevented above, so ignore this for coverage.
    /* istanbul ignore if - defense in depth */
    if (
      !this.preservePaths &&
      entry.absolute.indexOf(this.cwd + "/") !== 0 &&
      entry.absolute !== this.cwd
    ) {
      this.warn("TAR_ENTRY_ERROR", "path escaped extraction target", {
        entry,
        path: normPath(entry.path),
        resolvedPath: entry.absolute,
        cwd: this.cwd,
      });
      return false;
    }

    // an archive can set properties on the extraction directory, but it
    // may not replace the cwd with a different kind of thing entirely.
    if (
      entry.absolute === this.cwd &&
      entry.type !== "Directory" &&
      entry.type !== "GNUDumpDir"
    ) {
      return false;
    }

    // only encode : chars that aren't drive letter indicators
    if (this.win32) {
      const { root: aRoot } = path.win32.parse(entry.absolute);
      entry.absolute = aRoot + wc.encode(entry.absolute.slice(aRoot.length));
      const { root: pRoot } = path.win32.parse(entry.path);
      entry.path = pRoot + wc.encode(entry.path.slice(pRoot.length));
    }

    return true;
  }

  [ONENTRY](entry) {
    if (!this[CHECKPATH](entry)) {
      return entry.resume();
    }

    assert.equal(typeof entry.absolute, "string");

    switch (entry.type) {
      case "Directory":
      case "GNUDumpDir":
        if (entry.mode) {
          entry.mode = entry.mode | 0o700;
        }

      // eslint-disable-next-line no-fallthrough
      case "File":
      case "OldFile":
      case "ContiguousFile":
      case "Link":
      case "SymbolicLink":
        return this[CHECKFS](entry);

      case "CharacterDevice":
      case "BlockDevice":
      case "FIFO":
      default:
        return this[UNSUPPORTED](entry);
    }
  }

  [ONERROR](er, entry) {
    // Cwd has to exist, or else nothing works. That's serious.
    // Other errors are warnings, which raise the error in strict
    // mode, but otherwise continue on.
    if (er.name === "CwdError") {
      this.emit("error", er);
    } else {
      this.warn("TAR_ENTRY_ERROR", er, { entry });
      this[UNPEND]();
      entry.resume();
    }
  }

  [MKDIR](dir, mode, cb) {
    mkdir(
      normPath(dir),
      {
        uid: this.uid,
        gid: this.gid,
        processUid: this.processUid,
        processGid: this.processGid,
        umask: this.processUmask,
        preserve: this.preservePaths,
        unlink: this.unlink,
        cache: this.dirCache,
        cwd: this.cwd,
        mode: mode,
        noChmod: this.noChmod,
      },
      cb,
    );
  }

  [DOCHOWN](entry) {
    // in preserve owner mode, chown if the entry doesn't match process
    // in set owner mode, chown if setting doesn't match process
    return (
      this.forceChown ||
      (this.preserveOwner &&
        ((typeof entry.uid === "number" && entry.uid !== this.processUid) ||
          (typeof entry.gid === "number" && entry.gid !== this.processGid))) ||
      (typeof this.uid === "number" && this.uid !== this.processUid) ||
      (typeof this.gid === "number" && this.gid !== this.processGid)
    );
  }

  [UID](entry) {
    return uint32(this.uid, entry.uid, this.processUid);
  }

  [GID](entry) {
    return uint32(this.gid, entry.gid, this.processGid);
  }

  [FILE](entry, fullyDone) {
    const mode = entry.mode & 0o7777 || this.fmode;
    const stream = new fsm.WriteStream(entry.absolute, {
      flags: getFlag(entry.size),
      mode: mode,
      autoClose: false,
    });
    stream.on("error", (er) => {
      if (stream.fd) {
        fs.close(stream.fd, () => {});
      }

      // flush all the data out so that we aren't left hanging
      // if the error wasn't actually fatal.  otherwise the parse
      // is blocked, and we never proceed.
      stream.write = () => true;
      this[ONERROR](er, entry);
      fullyDone();
    });

    let actions = 1;
    const done = (er) => {
      if (er) {
        /* istanbul ignore else - we should always have a fd by now */
        if (stream.fd) {
          fs.close(stream.fd, () => {});
        }

        this[ONERROR](er, entry);
        fullyDone();
        return;
      }

      if (--actions === 0) {
        fs.close(stream.fd, (er) => {
          if (er) {
            this[ONERROR](er, entry);
          } else {
            this[UNPEND]();
          }
          fullyDone();
        });
      }
    };

    stream.on("finish", (_) => {
      // if futimes fails, try utimes
      // if utimes fails, fail with the original error
      // same for fchown/chown
      const abs = entry.absolute;
      const fd = stream.fd;

      if (entry.mtime && !this.noMtime) {
        actions++;
        const atime = entry.atime || new Date();
        const mtime = entry.mtime;
        fs.futimes(fd, atime, mtime, (er) =>
          er ? fs.utimes(abs, atime, mtime, (er2) => done(er2 && er)) : done(),
        );
      }

      if (this[DOCHOWN](entry)) {
        actions++;
        const uid = this[UID](entry);
        const gid = this[GID](entry);
        fs.fchown(fd, uid, gid, (er) =>
          er ? fs.chown(abs, uid, gid, (er2) => done(er2 && er)) : done(),
        );
      }

      done();
    });

    const tx = this.transform ? this.transform(entry) || entry : entry;
    if (tx !== entry) {
      tx.on("error", (er) => {
        this[ONERROR](er, entry);
        fullyDone();
      });
      entry.pipe(tx);
    }
    tx.pipe(stream);
  }

  [DIRECTORY](entry, fullyDone) {
    const mode = entry.mode & 0o7777 || this.dmode;
    this[MKDIR](entry.absolute, mode, (er) => {
      if (er) {
        this[ONERROR](er, entry);
        fullyDone();
        return;
      }

      let actions = 1;
      const done = (_) => {
        if (--actions === 0) {
          fullyDone();
          this[UNPEND]();
          entry.resume();
        }
      };

      if (entry.mtime && !this.noMtime) {
        actions++;
        fs.utimes(entry.absolute, entry.atime || new Date(), entry.mtime, done);
      }

      if (this[DOCHOWN](entry)) {
        actions++;
        fs.chown(entry.absolute, this[UID](entry), this[GID](entry), done);
      }

      done();
    });
  }

  [UNSUPPORTED](entry) {
    entry.unsupported = true;
    this.warn(
      "TAR_ENTRY_UNSUPPORTED",
      `unsupported entry type: ${entry.type}`,
      { entry },
    );
    entry.resume();
  }

  [SYMLINK](entry, done) {
    this[LINK](entry, entry.linkpath, "symlink", done);
  }

  [HARDLINK](entry, done) {
    const linkpath = normPath(path.resolve(this.cwd, entry.linkpath));
    this[LINK](entry, linkpath, "link", done);
  }

  [PEND]() {
    this[PENDING]++;
  }

  [UNPEND]() {
    this[PENDING]--;
    this[MAYBECLOSE]();
  }

  [SKIP](entry) {
    this[UNPEND]();
    entry.resume();
  }

  // Check if we can reuse an existing filesystem entry safely and
  // overwrite it, rather than unlinking and recreating
  // Windows doesn't report a useful nlink, so we just never reuse entries
  [ISREUSABLE](entry, st) {
    return (
      entry.type === "File" &&
      !this.unlink &&
      st.isFile() &&
      st.nlink <= 1 &&
      !isWindows
    );
  }

  // check if a thing is there, and if so, try to clobber it
  [CHECKFS](entry) {
    this[PEND]();
    const paths = [entry.path];
    if (entry.linkpath) {
      paths.push(entry.linkpath);
    }
    this.reservations.reserve(paths, (done) => this[CHECKFS2](entry, done));
  }

  [PRUNECACHE](entry) {
    // if we are not creating a directory, and the path is in the dirCache,
    // then that means we are about to delete the directory we created
    // previously, and it is no longer going to be a directory, and neither
    // is any of its children.
    // If a symbolic link is encountered, all bets are off.  There is no
    // reasonable way to sanitize the cache in such a way we will be able to
    // avoid having filesystem collisions.  If this happens with a non-symlink
    // entry, it'll just fail to unpack, but a symlink to a directory, using an
    // 8.3 shortname or certain unicode attacks, can evade detection and lead
    // to arbitrary writes to anywhere on the system.
    if (entry.type === "SymbolicLink") {
      dropCache(this.dirCache);
    } else if (entry.type !== "Directory") {
      pruneCache(this.dirCache, entry.absolute);
    }
  }

  [CHECKFS2](entry, fullyDone) {
    this[PRUNECACHE](entry);

    const done = (er) => {
      this[PRUNECACHE](entry);
      fullyDone(er);
    };

    const checkCwd = () => {
      this[MKDIR](this.cwd, this.dmode, (er) => {
        if (er) {
          this[ONERROR](er, entry);
          done();
          return;
        }
        this[CHECKED_CWD] = true;
        start();
      });
    };

    const start = () => {
      if (entry.absolute !== this.cwd) {
        const parent = normPath(path.dirname(entry.absolute));
        if (parent !== this.cwd) {
          return this[MKDIR](parent, this.dmode, (er) => {
            if (er) {
              this[ONERROR](er, entry);
              done();
              return;
            }
            afterMakeParent();
          });
        }
      }
      afterMakeParent();
    };

    const afterMakeParent = () => {
      fs.lstat(entry.absolute, (lstatEr, st) => {
        if (st && (this.keep || (this.newer && st.mtime > entry.mtime))) {
          this[SKIP](entry);
          done();
          return;
        }
        if (lstatEr || this[ISREUSABLE](entry, st)) {
          return this[MAKEFS](null, entry, done);
        }

        if (st.isDirectory()) {
          if (entry.type === "Directory") {
            const needChmod =
              !this.noChmod && entry.mode && (st.mode & 0o7777) !== entry.mode;
            const afterChmod = (er) => this[MAKEFS](er, entry, done);
            if (!needChmod) {
              return afterChmod();
            }
            return fs.chmod(entry.absolute, entry.mode, afterChmod);
          }
          // Not a dir entry, have to remove it.
          // NB: the only way to end up with an entry that is the cwd
          // itself, in such a way that == does not detect, is a
          // tricky windows absolute path with UNC or 8.3 parts (and
          // preservePaths:true, or else it will have been stripped).
          // In that case, the user has opted out of path protections
          // explicitly, so if they blow away the cwd, c'est la vie.
          if (entry.absolute !== this.cwd) {
            return fs.rmdir(entry.absolute, (er) =>
              this[MAKEFS](er, entry, done),
            );
          }
        }

        // not a dir, and not reusable
        // don't remove if the cwd, we want that error
        if (entry.absolute === this.cwd) {
          return this[MAKEFS](null, entry, done);
        }

        unlinkFile(entry.absolute, (er) => this[MAKEFS](er, entry, done));
      });
    };

    if (this[CHECKED_CWD]) {
      start();
    } else {
      checkCwd();
    }
  }

  [MAKEFS](er, entry, done) {
    if (er) {
      this[ONERROR](er, entry);
      done();
      return;
    }

    switch (entry.type) {
      case "File":
      case "OldFile":
      case "ContiguousFile":
        return this[FILE](entry, done);

      case "Link":
        return this[HARDLINK](entry, done);

      case "SymbolicLink":
        return this[SYMLINK](entry, done);

      case "Directory":
      case "GNUDumpDir":
        return this[DIRECTORY](entry, done);
    }
  }

  [LINK](entry, linkpath, link, done) {
    // XXX: get the type ('symlink' or 'junction') for windows
    fs[link](linkpath, entry.absolute, (er) => {
      if (er) {
        this[ONERROR](er, entry);
      } else {
        this[UNPEND]();
        entry.resume();
      }
      done();
    });
  }
}

const callSync = (fn) => {
  try {
    return [null, fn()];
  } catch (er) {
    return [er, null];
  }
};
class UnpackSync extends Unpack {
  [MAKEFS](er, entry) {
    return super[MAKEFS](er, entry, () => {});
  }

  [CHECKFS](entry) {
    this[PRUNECACHE](entry);

    if (!this[CHECKED_CWD]) {
      const er = this[MKDIR](this.cwd, this.dmode);
      if (er) {
        return this[ONERROR](er, entry);
      }
      this[CHECKED_CWD] = true;
    }

    // don't bother to make the parent if the current entry is the cwd,
    // we've already checked it.
    if (entry.absolute !== this.cwd) {
      const parent = normPath(path.dirname(entry.absolute));
      if (parent !== this.cwd) {
        const mkParent = this[MKDIR](parent, this.dmode);
        if (mkParent) {
          return this[ONERROR](mkParent, entry);
        }
      }
    }

    const [lstatEr, st] = callSync(() => fs.lstatSync(entry.absolute));
    if (st && (this.keep || (this.newer && st.mtime > entry.mtime))) {
      return this[SKIP](entry);
    }

    if (lstatEr || this[ISREUSABLE](entry, st)) {
      return this[MAKEFS](null, entry);
    }

    if (st.isDirectory()) {
      if (entry.type === "Directory") {
        const needChmod =
          !this.noChmod && entry.mode && (st.mode & 0o7777) !== entry.mode;
        const [er] = needChmod
          ? callSync(() => {
              fs.chmodSync(entry.absolute, entry.mode);
            })
          : [];
        return this[MAKEFS](er, entry);
      }
      // not a dir entry, have to remove it
      const [er] = callSync(() => fs.rmdirSync(entry.absolute));
      this[MAKEFS](er, entry);
    }

    // not a dir, and not reusable.
    // don't remove if it's the cwd, since we want that error.
    const [er] =
      entry.absolute === this.cwd
        ? []
        : callSync(() => unlinkFileSync(entry.absolute));
    this[MAKEFS](er, entry);
  }

  [FILE](entry, done) {
    const mode = entry.mode & 0o7777 || this.fmode;

    const oner = (er) => {
      let closeError;
      try {
        fs.closeSync(fd);
      } catch (e) {
        closeError = e;
      }
      if (er || closeError) {
        this[ONERROR](er || closeError, entry);
      }
      done();
    };

    let fd;
    try {
      fd = fs.openSync(entry.absolute, getFlag(entry.size), mode);
    } catch (er) {
      return oner(er);
    }
    const tx = this.transform ? this.transform(entry) || entry : entry;
    if (tx !== entry) {
      tx.on("error", (er) => this[ONERROR](er, entry));
      entry.pipe(tx);
    }

    tx.on("data", (chunk) => {
      try {
        fs.writeSync(fd, chunk, 0, chunk.length);
      } catch (er) {
        oner(er);
      }
    });

    tx.on("end", (_) => {
      let er = null;
      // try both, falling futimes back to utimes
      // if either fails, handle the first error
      if (entry.mtime && !this.noMtime) {
        const atime = entry.atime || new Date();
        const mtime = entry.mtime;
        try {
          fs.futimesSync(fd, atime, mtime);
        } catch (futimeser) {
          try {
            fs.utimesSync(entry.absolute, atime, mtime);
          } catch (utimeser) {
            er = futimeser;
          }
        }
      }

      if (this[DOCHOWN](entry)) {
        const uid = this[UID](entry);
        const gid = this[GID](entry);

        try {
          fs.fchownSync(fd, uid, gid);
        } catch (fchowner) {
          try {
            fs.chownSync(entry.absolute, uid, gid);
          } catch (chowner) {
            er = er || fchowner;
          }
        }
      }

      oner(er);
    });
  }

  [DIRECTORY](entry, done) {
    const mode = entry.mode & 0o7777 || this.dmode;
    const er = this[MKDIR](entry.absolute, mode);
    if (er) {
      this[ONERROR](er, entry);
      done();
      return;
    }
    if (entry.mtime && !this.noMtime) {
      try {
        fs.utimesSync(entry.absolute, entry.atime || new Date(), entry.mtime);
      } catch (er) {}
    }
    if (this[DOCHOWN](entry)) {
      try {
        fs.chownSync(entry.absolute, this[UID](entry), this[GID](entry));
      } catch (er) {}
    }
    done();
    entry.resume();
  }

  [MKDIR](dir, mode) {
    try {
      return mkdir.sync(normPath(dir), {
        uid: this.uid,
        gid: this.gid,
        processUid: this.processUid,
        processGid: this.processGid,
        umask: this.processUmask,
        preserve: this.preservePaths,
        unlink: this.unlink,
        cache: this.dirCache,
        cwd: this.cwd,
        mode: mode,
      });
    } catch (er) {
      return er;
    }
  }

  [LINK](entry, linkpath, link, done) {
    try {
      fs[link + "Sync"](linkpath, entry.absolute);
      done();
      entry.resume();
    } catch (er) {
      return this[ONERROR](er, entry);
    }
  }
}

Unpack.Sync = UnpackSync;

const baseURL =
  {
    BASE_URL: "/",
    MODE: "production",
    DEV: false,
    PROD: true,
    SSR: true,
    SITE: undefined,
    ASSETS_PREFIX: undefined,
  }.ASTRO_ICON_API ?? "https://api.iconify.design/";
const requests = /* @__PURE__ */ new Map();
const fetchCache = /* @__PURE__ */ new Map();
async function get(pack, name) {
  const url = new URL(`./${pack}.json?icons=${name}`, baseURL).toString();
  if (requests.has(url)) {
    return await requests.get(url);
  }
  if (fetchCache.has(url)) {
    return fetchCache.get(url);
  }
  let request = async () => {
    const res = await fetch(url);
    if (!res.ok) {
      throw new Error(await res.text());
    }
    const svg = new IconSet(await res.json()).toString(name);
    fetchCache.set(url, svg);
    requests.delete(url);
    return svg;
  };
  let promise = request();
  requests.set(url, promise);
  return await promise;
}

const splitAttrsTokenizer = /([a-z0-9_\:\-]*)\s*?=\s*?(['"]?)(.*?)\2\s+/gim;
const domParserTokenizer =
  /(?:<(\/?)([a-zA-Z][a-zA-Z0-9\:]*)(?:\s([^>]*?))?((?:\s*\/)?)>|(<\!\-\-)([\s\S]*?)(\-\->)|(<\!\[CDATA\[)([\s\S]*?)(\]\]>))/gm;
const splitAttrs = (str) => {
  let res = {};
  let token;
  if (str) {
    splitAttrsTokenizer.lastIndex = 0;
    str = " " + (str || "") + " ";
    while ((token = splitAttrsTokenizer.exec(str))) {
      res[token[1]] = token[3];
    }
  }
  return res;
};
function optimizeSvg(contents, name, options) {
  return optimize_1(contents, {
    plugins: [
      "removeDoctype",
      "removeXMLProcInst",
      "removeComments",
      "removeMetadata",
      "removeXMLNS",
      "removeEditorsNSData",
      "cleanupAttrs",
      "minifyStyles",
      "convertStyleToAttrs",
      "cleanupIds",
      {
        name: "prefixIds",
        params: { prefix: `${SPRITESHEET_NAMESPACE}:${name}` },
      },
      "removeRasterImages",
      "removeUselessDefs",
      "cleanupNumericValues",
      "cleanupListOfValues",
      "convertColors",
      "removeUnknownsAndDefaults",
      "removeNonInheritableGroupAttrs",
      "removeUselessStrokeAndFill",
      "removeViewBox",
      "cleanupEnableBackground",
      "removeHiddenElems",
      "removeEmptyText",
      "convertShapeToPath",
      "moveElemsAttrsToGroup",
      "moveGroupAttrsToElems",
      "collapseGroups",
      "convertPathData",
      "convertTransform",
      "removeEmptyAttrs",
      "removeEmptyContainers",
      "mergePaths",
      "removeUnusedNS",
      "sortAttrs",
      "removeTitle",
      "removeDesc",
      "removeDimensions",
      "removeStyleElement",
      "removeScriptElement",
    ],
  }).data;
}
const preprocessCache = /* @__PURE__ */ new Map();
function preprocess(contents, name, { optimize }) {
  if (preprocessCache.has(contents)) {
    return preprocessCache.get(contents);
  }
  if (optimize) {
    contents = optimizeSvg(contents, name);
  }
  domParserTokenizer.lastIndex = 0;
  let result = contents;
  let token;
  if (contents) {
    while ((token = domParserTokenizer.exec(contents))) {
      const tag = token[2];
      if (tag === "svg") {
        const attrs = splitAttrs(token[3]);
        result = contents
          .slice(domParserTokenizer.lastIndex)
          .replace(/<\/svg>/gim, "")
          .trim();
        const value = { innerHTML: result, defaultProps: attrs };
        preprocessCache.set(contents, value);
        return value;
      }
    }
  }
}
function normalizeProps(inputProps) {
  const size = inputProps.size;
  delete inputProps.size;
  const w = inputProps.width ?? size;
  const h = inputProps.height ?? size;
  const width = w ? toAttributeSize(w) : void 0;
  const height = h ? toAttributeSize(h) : void 0;
  return { ...inputProps, width, height };
}
const toAttributeSize = (size) => String(size).replace(/(?<=[0-9])x$/, "em");
async function load(name, inputProps, optimize) {
  const key = name;
  if (!name) {
    throw new Error("<Icon> requires a name!");
  }
  let svg = "";
  let filepath = "";
  if (name.includes(":")) {
    const [pack, ..._name] = name.split(":");
    name = _name.join(":");
    filepath = `/src/icons/${pack}`;
    let get$1;
    try {
      const files = import.meta.globEager(
        "/src/icons/**/*.{js,ts,cjs,mjc,cts,mts}",
      );
      const keys = Object.fromEntries(
        Object.keys(files).map((key2) => [
          key2.replace(/\.[cm]?[jt]s$/, ""),
          key2,
        ]),
      );
      if (!(filepath in keys)) {
        throw new Error(`Could not find the file "${filepath}"`);
      }
      const mod = files[keys[filepath]];
      if (typeof mod.default !== "function") {
        throw new Error(
          `[astro-icon] "${filepath}" did not export a default function!`,
        );
      }
      get$1 = mod.default;
    } catch (e) {}
    if (typeof get$1 === "undefined") {
      get$1 = get.bind(null, pack);
    }
    const contents = await get$1(name, inputProps);
    if (!contents) {
      throw new Error(
        `<Icon pack="${pack}" name="${name}" /> did not return an icon!`,
      );
    }
    if (!/<svg/gim.test(contents)) {
      throw new Error(
        `Unable to process "<Icon pack="${pack}" name="${name}" />" because an SVG string was not returned!

Recieved the following content:
${contents}`,
      );
    }
    svg = contents;
  } else {
    filepath = `/src/icons/${name}.svg`;
    try {
      const files = import.meta.globEager("/src/icons/**/*.svg", { as: "raw" });
      if (!(filepath in files)) {
        throw new Error(`Could not find the file "${filepath}"`);
      }
      const contents = files[filepath];
      if (!/<svg/gim.test(contents)) {
        throw new Error(
          `Unable to process "${filepath}" because it is not an SVG!

Recieved the following content:
${contents}`,
        );
      }
      svg = contents;
    } catch (e) {
      throw new Error(
        `[astro-icon] Unable to load "${filepath}". Does the file exist?`,
      );
    }
  }
  const { innerHTML, defaultProps } = preprocess(svg, key, { optimize });
  if (!innerHTML.trim()) {
    throw new Error(`Unable to parse "${filepath}"!`);
  }
  return {
    innerHTML,
    props: { ...defaultProps, ...normalizeProps(inputProps) },
  };
}

const $$Astro$6 = createAstro();
const $$Icon = createComponent(
  async ($$result, $$props, $$slots) => {
    const Astro2 = $$result.createAstro($$Astro$6, $$props, $$slots);
    Astro2.self = $$Icon;
    let {
      name,
      pack,
      title,
      optimize = true,
      class: className,
      ...inputProps
    } = Astro2.props;
    let props = {};
    if (pack) {
      name = `${pack}:${name}`;
    }
    let innerHTML = "";
    try {
      const svg = await load(
        name,
        { ...inputProps, class: className },
        optimize,
      );
      innerHTML = svg.innerHTML;
      props = svg.props;
    } catch (e) {
      {
        throw new Error(`[astro-icon] Unable to load icon "${name}"!
${e}`);
      }
    }
    return renderTemplate`${maybeRenderHead()}<svg${spreadAttributes(
      props,
    )}${addAttribute(name, "astro-icon")}>${unescapeHTML(
      (title ? `<title>${title}</title>` : "") + innerHTML,
    )}</svg>`;
  },
  "C:/Users/ermou/Desktop/PROGRAMACAO/cantinho_do_bloguinho/blog/node_modules/.pnpm/astro-iconify@1.2.0/node_modules/astro-iconify/lib/Icon.astro",
  void 0,
);

const sprites = /* @__PURE__ */ new WeakMap();
function trackSprite(request, name) {
  let currentSet = sprites.get(request);
  if (!currentSet) {
    currentSet = /* @__PURE__ */ new Set([name]);
  } else {
    currentSet.add(name);
  }
  sprites.set(request, currentSet);
}
const warned = /* @__PURE__ */ new Set();
async function getUsedSprites(request) {
  const currentSet = sprites.get(request);
  if (currentSet) {
    return Array.from(currentSet);
  }
  if (!warned.has(request)) {
    const { pathname } = new URL(request.url);
    console.log(`[astro-icon] No sprites found while rendering "${pathname}"`);
    warned.add(request);
  }
  return [];
}

const $$Astro$5 = createAstro();
const $$Spritesheet = createComponent(
  async ($$result, $$props, $$slots) => {
    const Astro2 = $$result.createAstro($$Astro$5, $$props, $$slots);
    Astro2.self = $$Spritesheet;
    const { optimize = true, style, ...props } = Astro2.props;
    const names = await getUsedSprites(Astro2.request);
    const icons = await Promise.all(
      names.map((name) => {
        return load(name, {}, optimize)
          .then((res) => ({ ...res, name }))
          .catch((e) => {
            {
              throw new Error(`[astro-icon] Unable to load icon "${name}"!
${e}`);
            }
          });
      }),
    );
    return renderTemplate`${maybeRenderHead()}<svg${addAttribute(
      `position: absolute; width: 0; height: 0; overflow: hidden; ${
        style ?? ""
      }`.trim(),
      "style",
    )}${spreadAttributes({
      "aria-hidden": true,
      ...props,
    })} astro-icon-spritesheet> ${icons.map(
      (icon) =>
        renderTemplate`<symbol${spreadAttributes(icon.props)}${addAttribute(
          `${SPRITESHEET_NAMESPACE}:${icon.name}`,
          "id",
        )}>${unescapeHTML(icon.innerHTML)}</symbol>`,
    )} </svg>`;
  },
  "C:/Users/ermou/Desktop/PROGRAMACAO/cantinho_do_bloguinho/blog/node_modules/.pnpm/astro-iconify@1.2.0/node_modules/astro-iconify/lib/Spritesheet.astro",
  void 0,
);

const $$Astro$4 = createAstro();
const $$SpriteProvider = createComponent(
  async ($$result, $$props, $$slots) => {
    const Astro2 = $$result.createAstro($$Astro$4, $$props, $$slots);
    Astro2.self = $$SpriteProvider;
    const content = await Astro2.slots.render("default");
    return renderTemplate`${renderComponent(
      $$result,
      "Fragment",
      Fragment,
      {},
      { default: ($$result2) => renderTemplate`${unescapeHTML(content)}` },
    )}${renderComponent($$result, "Spritesheet", $$Spritesheet, {})}`;
  },
  "C:/Users/ermou/Desktop/PROGRAMACAO/cantinho_do_bloguinho/blog/node_modules/.pnpm/astro-iconify@1.2.0/node_modules/astro-iconify/lib/SpriteProvider.astro",
  void 0,
);

const $$Astro$3 = createAstro();
const $$Sprite = createComponent(
  async ($$result, $$props, $$slots) => {
    const Astro2 = $$result.createAstro($$Astro$3, $$props, $$slots);
    Astro2.self = $$Sprite;
    let {
      name,
      pack,
      title,
      class: className,
      x,
      y,
      ...inputProps
    } = Astro2.props;
    const props = normalizeProps(inputProps);
    if (pack) {
      name = `${pack}:${name}`;
    }
    const href = `#${SPRITESHEET_NAMESPACE}:${name}`;
    trackSprite(Astro2.request, name);
    return renderTemplate`${maybeRenderHead()}<svg${spreadAttributes(
      props,
    )}${addAttribute(className, "class")}${addAttribute(name, "astro-icon")}> ${
      title ? renderTemplate`<title>${title}</title>` : ""
    } <use${spreadAttributes({
      "xlink:href": href,
      width: props.width,
      height: props.height,
      x,
      y,
    })}></use> </svg>`;
  },
  "C:/Users/ermou/Desktop/PROGRAMACAO/cantinho_do_bloguinho/blog/node_modules/.pnpm/astro-iconify@1.2.0/node_modules/astro-iconify/lib/Sprite.astro",
  void 0,
);

Object.assign($$Sprite, { Provider: $$SpriteProvider });

const _sfc_main$3 = /* @__PURE__ */ defineComponent({
  __name: "Modal",
  setup(__props, { expose: __expose }) {
    __expose();
    const isModalOpened = ref(false);
    const openModal = () => {
      isModalOpened.value = true;
    };
    const closeModal = () => {
      isModalOpened.value = false;
    };
    const __returned__ = { isModalOpened, openModal, closeModal };
    Object.defineProperty(__returned__, "__isScriptSetup", {
      enumerable: false,
      value: true,
    });
    return __returned__;
  },
});
function _sfc_ssrRender$3(
  _ctx,
  _push,
  _parent,
  _attrs,
  $props,
  $setup,
  $data,
  $options,
) {
  _push(
    `<div${ssrRenderAttrs(
      _attrs,
    )}><div class="flex justify-center"><div class="cursor-pointer">Sobre</div><div style="${ssrRenderStyle(
      $setup.isModalOpened ? null : { display: "none" },
    )}" class="absolute inset-0 flex items-center justify-center bg-gray-700 bg-opacity-50 backdrop-blur-sm"><div class="mx-4 max-w-2xl rounded-lg bg-white p-6 shadow-xl"><div class="flex items-center justify-end"><svg xmlns="http://www.w3.org/2000/svg" class="h-8 w-8 cursor-pointer" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 14l2-2m0 0l2-2m-2 2l-2-2m2 2l2 2m7-2a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg></div><div class="mt-4"><p class="mb-4 px-4 text-justify indent-10 text-base font-semibold leading-loose"> Cantinho do blog foi criado utilizando a tecnologia VueJS 3 e TypeScript, com o intuito especialmente de catalogar e guardar as minhas d\xFAvidas com rela\xE7\xE3o \xE0 desenvolvimento de software, outro ponto importante \xE9 que tamb\xE9m serve para demonstrar e compartilhar de uma forma intuitiva me estimulando a pensar em formas de trazer o conte\xFAdo entend\xEDvel tanto para pessoas leigas como para profissionais sem deixar de lados os termos t\xE9cnicos. </p></div></div></div></div></div>`,
  );
}
const _sfc_setup$3 = _sfc_main$3.setup;
_sfc_main$3.setup = (props, ctx) => {
  const ssrContext = useSSRContext();
  (ssrContext.modules || (ssrContext.modules = /* @__PURE__ */ new Set())).add(
    "src/components/Modal/Modal.vue",
  );
  return _sfc_setup$3 ? _sfc_setup$3(props, ctx) : void 0;
};
const Modal = /* @__PURE__ */ _export_sfc(_sfc_main$3, [
  ["ssrRender", _sfc_ssrRender$3],
]);

const $$Astro$2 = createAstro();
const $$Header = createComponent(
  async ($$result, $$props, $$slots) => {
    const Astro2 = $$result.createAstro($$Astro$2, $$props, $$slots);
    Astro2.self = $$Header;
    return renderTemplate`${maybeRenderHead()}<header class="mb-8 flex h-20 w-full items-center bg-[#a0db44] px-8"> <div class="mx-auto flex max-w-screen-xl sm:gap-32 lg:gap-96"> ${renderComponent(
      $$result,
      "HeaderVue",
      HeaderVue,
      { title: "Cantinho do Bloguinho" },
      {
        default: ($$result2) =>
          renderTemplate` ${renderComponent($$result2, "Icon", $$Icon, {
            name: "flat-color-icons:collaboration",
            size: "50",
          })} `,
      },
    )} <div class="flex items-center gap-7 text-lg font-semibold text-[#0a0094]"> <a href="/" target="_self"><span>Home</span></a> ${renderComponent(
      $$result,
      "Modal",
      Modal,
      {
        "client:load": true,
        "client:component-hydration": "load",
        "client:component-path":
          "C:/Users/ermou/Desktop/PROGRAMACAO/cantinho_do_bloguinho/blog/src/components/Modal/Modal.vue",
        "client:component-export": "default",
      },
    )} </div> </div> </header>`;
  },
  "C:/Users/ermou/Desktop/PROGRAMACAO/cantinho_do_bloguinho/blog/src/components/Header/Header.astro",
  void 0,
);

const $$Astro$1 = createAstro();
const $$Layout = createComponent(
  async ($$result, $$props, $$slots) => {
    const Astro2 = $$result.createAstro($$Astro$1, $$props, $$slots);
    Astro2.self = $$Layout;
    const { title } = Astro2.props;
    return renderTemplate`<html lang="pt-br" data-astro-cid-sckkx6r4> <head><meta charset="UTF-8"><meta name="description" content="Astro description"><meta name="viewport" content="width=device-width"><link rel="icon" type="image/svg+xml" href="/favicon.svg"><meta name="generator"${addAttribute(
      Astro2.generator,
      "content",
    )}><title>${title}</title>${renderHead()}</head> <body class="font-roboto bg-slate-200" data-astro-cid-sckkx6r4> ${renderComponent(
      $$result,
      "Header",
      $$Header,
      { "data-astro-cid-sckkx6r4": true },
    )} ${renderSlot($$result, $$slots["default"])} </body></html>`;
  },
  "C:/Users/ermou/Desktop/PROGRAMACAO/cantinho_do_bloguinho/blog/src/layouts/Layout.astro",
  void 0,
);

const _sfc_main$2 = {};

function _sfc_ssrRender$2(_ctx, _push, _parent, _attrs) {
  _push(
    `<span${ssrRenderAttrs(
      mergeProps({ class: "marcaTexto" }, _attrs),
    )} data-v-6b70153a>`,
  );
  ssrRenderSlot(_ctx.$slots, "default", {}, null, _push, _parent);
  _push(`</span>`);
}
const _sfc_setup$2 = _sfc_main$2.setup;
_sfc_main$2.setup = (props, ctx) => {
  const ssrContext = useSSRContext();
  (ssrContext.modules || (ssrContext.modules = new Set())).add(
    "src/components/Text/MarkText.vue",
  );
  return _sfc_setup$2 ? _sfc_setup$2(props, ctx) : undefined;
};
const MarkText = /*#__PURE__*/ _export_sfc(_sfc_main$2, [
  ["ssrRender", _sfc_ssrRender$2],
  ["__scopeId", "data-v-6b70153a"],
]);

const _sfc_main$1 = {};

function _sfc_ssrRender$1(_ctx, _push, _parent, _attrs) {
  _push(
    `<span${ssrRenderAttrs(
      mergeProps({ class: "exemploTexto" }, _attrs),
    )} data-v-280f9434>`,
  );
  ssrRenderSlot(_ctx.$slots, "default", {}, null, _push, _parent);
  _push(`</span>`);
}
const _sfc_setup$1 = _sfc_main$1.setup;
_sfc_main$1.setup = (props, ctx) => {
  const ssrContext = useSSRContext();
  (ssrContext.modules || (ssrContext.modules = new Set())).add(
    "src/components/Text/ExampleText.vue",
  );
  return _sfc_setup$1 ? _sfc_setup$1(props, ctx) : undefined;
};
const ExampleText = /*#__PURE__*/ _export_sfc(_sfc_main$1, [
  ["ssrRender", _sfc_ssrRender$1],
  ["__scopeId", "data-v-280f9434"],
]);

const _sfc_main = {};

function _sfc_ssrRender(_ctx, _push, _parent, _attrs) {
  _push(
    `<code${ssrRenderAttrs(
      mergeProps({ class: "codigoTexto" }, _attrs),
    )} data-v-971607be>`,
  );
  ssrRenderSlot(_ctx.$slots, "default", {}, null, _push, _parent);
  _push(`</code>`);
}
const _sfc_setup = _sfc_main.setup;
_sfc_main.setup = (props, ctx) => {
  const ssrContext = useSSRContext();
  (ssrContext.modules || (ssrContext.modules = new Set())).add(
    "src/components/Text/CodeText.vue",
  );
  return _sfc_setup ? _sfc_setup(props, ctx) : undefined;
};
const CodeText = /*#__PURE__*/ _export_sfc(_sfc_main, [
  ["ssrRender", _sfc_ssrRender],
  ["__scopeId", "data-v-971607be"],
]);

const $$Astro = createAstro();
function getStaticPaths() {
  return [{ params: { title: formateTitle } }];
}
const $$ = createComponent(
  async ($$result, $$props, $$slots) => {
    const Astro2 = $$result.createAstro($$Astro, $$props, $$slots);
    Astro2.self = $$;
    const { title } = Astro2.params;
    return renderTemplate`${renderComponent(
      $$result,
      "Layout",
      $$Layout,
      { title: title },
      {
        default: (
          $$result2,
        ) => renderTemplate` ${maybeRenderHead()}<div class="container mx-auto max-w-screen-lg rounded-lg bg-white p-8"> <header class="flex flex-col gap-10 pb-10"> <h2 class="text-sm font-medium text-[#4141b1]">
Publicado em ${formateDate()} </h2> <h1 class="font-title text-center text-3xl font-semibold">${titleNews}</h1> </header> <section class="flex flex-col gap-4 hyphens-auto break-words leading-loose"> <p>
Esse  um tutorial que funciona no ${renderComponent(
          $$result2,
          "MarkText",
          MarkText,
          {},
          { default: ($$result3) => renderTemplate`VueJS (v3.3.8)` },
        )} em
        conjunto com o ${renderComponent(
          $$result2,
          "MarkText",
          MarkText,
          {},
          {
            default: ($$result3) => renderTemplate`Vite mais recente (v4.5.0)`,
          },
        )} </p> <p>
 sempre importante lembrar que voc pode configurar corretamente o seu
        projeto para que facilite certos tipos de ao aumentando a sua
        produtividade, e um desses tipos de configurao  como podemos melhorar
        mtodos de ${renderComponent(
          $$result2,
          "MarkText",
          MarkText,
          {},
          {
            default: ($$result3) =>
              renderTemplate`chamar pastas / arquivos / imagens`,
          },
        )} dentro
        de um projeto de forma eficiente e sem se preocupar muito com os subdiretrios,
        tudo isso atravs do ${renderComponent(
          $$result2,
          "MarkText",
          MarkText,
          {},
          { default: ($$result3) => renderTemplate`path alias (@)` },
        )} </p> <p>
Geralmente chamamos as pastas por caminhos atravs de pontinhos e barras
${renderComponent(
  $$result2,
  "MarkText",
  MarkText,
  {},
  { default: ($$result3) => renderTemplate`(navegao por pastas)` },
)}, por exemplo
${renderComponent($$result2, "Code01", Content, {})}
(lembrando o sistema de pesquisa do terminal Linux ou do Windows) mas se
        preferir, poder substituir os pontos pelo prefixo @ "arroba" por
        exemplo
${renderComponent(
  $$result2,
  "Code02",
  Content$1,
  {},
)} </p> <p> ${renderComponent(
          $$result2,
          "ExampleText",
          ExampleText,
          {},
          {
            default: ($$result3) =>
              renderTemplate`Exemplo de cdigo com a navegao por pastas:`,
          },
        )} ${renderComponent(
          $$result2,
          "Code03",
          Content$2,
          {},
        )} </p> <p> ${renderComponent(
          $$result2,
          "ExampleText",
          ExampleText,
          {},
          {
            default: ($$result3) =>
              renderTemplate`Exemplo de cdigo utilizando o path alias @:`,
          },
        )} ${renderComponent($$result2, "Code04", Content$3, {})} </p> <p>
Geralmente aps o processo de instalao de um novo projeto VueJS esse
        tipo de ${renderComponent(
          $$result2,
          "MarkText",
          MarkText,
          {},
          { default: ($$result3) => renderTemplate`atalho` },
        )} j  adicionado e configurado automaticamente
        em seu projeto, mas em caso de dvidas, acesse o arquivo ${renderComponent(
          $$result2,
          "CodeText",
          CodeText,
          {},
          {
            default: ($$result3) => renderTemplate`
vite.config.ts
`,
          },
        )} ou
${renderComponent(
  $$result2,
  "CodeText",
  CodeText,
  {},
  { default: ($$result3) => renderTemplate`vite.config.js` },
)} e verifique se ir aparecer semelhante
        a esse cdigo abaixo:
</p> ${renderComponent($$result2, "Code05", Content$4, {})} <p>
O ${renderComponent(
          $$result2,
          "MarkText",
          MarkText,
          {},
          { default: ($$result3) => renderTemplate`atalho @` },
        )}  configurado para apontar para o diretrio
${renderComponent(
  $$result2,
  "MarkText",
  MarkText,
  {},
  { default: ($$result3) => renderTemplate`src` },
)} do seu projeto. Isso  feito usando a funo ${renderComponent(
          $$result2,
          "CodeText",
          CodeText,
          {},
          {
            default: ($$result3) => renderTemplate`
fileURLToPath
`,
          },
        )} e
${renderComponent(
  $$result2,
  "CodeText",
  CodeText,
  {},
  { default: ($$result3) => renderTemplate`new URL` },
)} do
${renderComponent(
  $$result2,
  "MarkText",
  MarkText,
  {},
  { default: ($$result3) => renderTemplate`Node.js` },
)}
para criar um caminho absoluto para o diretrio ${renderComponent(
          $$result2,
          "MarkText",
          MarkText,
          {},
          {
            default: ($$result3) => renderTemplate`
src
`,
          },
        )}, ou seja, voc poder indicar em qualquer pasta que esteja
        dentro da ${renderComponent(
          $$result2,
          "MarkText",
          MarkText,
          {},
          { default: ($$result3) => renderTemplate`pasta-me src` },
        )} </p> </section> </div> `,
      },
    )}`;
  },
  "C:/Users/ermou/Desktop/PROGRAMACAO/cantinho_do_bloguinho/blog/src/pages/2023/11/07/[...title].astro",
  void 0,
);

const $$file =
  "C:/Users/ermou/Desktop/PROGRAMACAO/cantinho_do_bloguinho/blog/src/pages/2023/11/07/[...title].astro";
const $$url = "/2023/11/07/[...title]";

const ____title_ = /*#__PURE__*/ Object.freeze(
  /*#__PURE__*/ Object.defineProperty(
    {
      __proto__: null,
      default: $$,
      file: $$file,
      getStaticPaths,
      url: $$url,
    },
    Symbol.toStringTag,
    { value: "Module" },
  ),
);

export { $$Icon as $, _export_sfc as _, $$Layout as a, ____title_ as b };
